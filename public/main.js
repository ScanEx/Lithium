(function () {
    'use strict';

    var nsGmx$1 = {};
    window.nsGmx = nsGmx$1;

    /** Загрузчик модулей ГеоМиксера
    Позволяет загружать модули из разных файлов.
    Модуль - единица кода, имеющая уникальное имя и зависящая от других модулей и скриптов.
    @namespace
    */

    var gmxCore$1 = function () {
      var _callbacks = [];
      var _modules = {}; //null - файл модуля уже загружается, но сам модуль пока не доступен

      var _globalNamespace = this;

      var _modulesDefaultHost = "";
      var _modulePathes = {
        /*#buildinclude<modules_path.txt>*/
      };
      var _moduleFiles = {
        /*#buildinclude<module_files.txt>*/
      };

      var getScriptURL = function getScriptURL(scriptName) {
        scriptName = scriptName.toLowerCase();
        var scripts1 = document.getElementsByTagName("script");

        for (var i = 0; i < scripts1.length; i++) {
          var src = scripts1[i].getAttribute("src");
          if (src && src.toLowerCase().indexOf(scriptName) != -1) return src;
        }

        return false;
      }; //производится регистронезависимое сравнение


      var getScriptBase = function getScriptBase(scriptName) {
        scriptName = scriptName.toLowerCase();
        var url = getScriptURL(scriptName);
        return url ? url.toLowerCase().substring(0, url.toLowerCase().indexOf(scriptName)) : "";
      };

      var invokeCallbacks = function invokeCallbacks() {
        for (var k = 0; k < _callbacks.length; k++) {
          var isAllModules = true;
          var curModules = _callbacks[k].modules;
          var modules = [];

          for (var m = 0; m < curModules.length; m++) {
            if (!_modules[curModules[m]]) {
              isAllModules = false;
              break;
            }

            modules.push(_modules[curModules[m]]);
          }

          if (isAllModules) {
            var curCallback = _callbacks[k].callback; //first delete, then callback!

            _callbacks.splice(k, 1);

            k = k - 1;
            curCallback.apply(null, modules);
          }
        }
      };

      var LABjsDeferred = null;

      var lazyLoadLABjs = function lazyLoadLABjs() {
        if (!LABjsDeferred) {
          LABjsDeferred = $.Deferred(); //load LAB.js (snippest from its website)

          (function (g, b, _d) {
            var c = b.head || b.getElementsByTagName("head"),
                D = "readyState",
                E = "onreadystatechange",
                F = "DOMContentLoaded",
                G = "addEventListener",
                H = setTimeout;
            H(function () {
              if ("item" in c) {
                if (!c[0]) {
                  H(arguments.callee, 25);
                  return;
                }

                c = c[0];
              }

              var a = b.createElement("script"),
                  e = false;

              a.onload = a[E] = function () {
                if (a[D] && a[D] !== "complete" && a[D] !== "loaded" || e) {
                  return false;
                }

                a.onload = a[E] = null;
                e = true;
                LABjsDeferred.resolve();
              };

              a.src = (getScriptBase('gmxcore.js') || window.gmxJSHost || "") + 'LAB.min.js';
              c.insertBefore(a, c.firstChild);
            }, 0);

            if (b[D] == null && b[G]) {
              b[D] = "loading";
              b[G](F, _d = function d() {
                b.removeEventListener(F, _d, false);
                b[D] = "complete";
              }, false);
            }
          })(this, document);
        }

        return LABjsDeferred.promise();
      };

      var cssLoader = null;

      var withCachePostfix = function withCachePostfix(filename) {
        var sym = filename.indexOf('?') === -1 ? '?' : '&';

        if (window.gmxDropBrowserCache) {
          filename += sym + Math.random();
        } else if (window.nsGmx && nsGmx$1.buildGUID) {
          filename += sym + nsGmx$1.buildGUID;
        }

        return filename;
      };

      var publicInterface =
      /** @lends gmxCore */
      {
        /** Добавить новый модуль
        * @param {String} moduleName Уникальное имя модуля
        * @param {Object|Function} moduleObj Тело модуля или ф-ция, возвращающая тело. Аргумент ф-ции - путь к модулю. Будет вызвана после загрузки всех зависимостей.
        * @param {Object} [options] Дополнительные параметры модуля
        * @param {String[]} [options.require] Какие модули должны быть загрежены перед данным
        * @param {Function} [options.init] Ф-ция для инициализации модуля. Сигнатура: function (moduleObj, modulePath)->{void|{@link jQuery.Deferred}}. Если ф-ция возвращает {@link jQuery.Deferred}, загрузчик будет ждать его для окончания инициализации.
        * @param {String|String[]} [options.css] CSS файлы для загрузки. Пути к CSS указываются относительно файла текущего модуля.
        */
        addModule: function addModule(moduleName, moduleObj, options) {
          var requiredModules = options && 'require' in options ? options.require : [];
          var initDeferred = null;

          var _this = this;

          for (var r = 0; r < requiredModules.length; r++) {
            this.loadModule(requiredModules[r]);
          }

          this.addModulesCallback(requiredModules, function () {
            if (options && 'init' in options) {
              initDeferred = options.init(moduleObj, _modulePathes[moduleName]);
            }

            if (options && 'css' in options) {
              var cssFiles = typeof options.css === 'string' ? [options.css] : options.css;
              var path = _modulePathes[moduleName] || window.gmxJSHost || "";

              for (var iF = 0; iF < cssFiles.length; iF++) {
                _this.loadCSS(withCachePostfix(path + cssFiles[iF]));
              }
            }

            var doAdd = function doAdd() {
              if (typeof moduleObj === 'function') {
                moduleObj = moduleObj(_modulePathes[moduleName]);
              }

              _modules[moduleName] = moduleObj;
              invokeCallbacks();
            };

            if (initDeferred) {
              initDeferred.done(doAdd);
            } else {
              doAdd();
            }
          });
        },

        /** Загрузить модуль
        * @param { String } moduleName Имя модуля для загрузки
        * @param { String } [moduleSource] Имя файла, откуда загружать модуль. Если не указан, будет сформирован в виде (defaultHost + moduleName + '.js')
        * @param { Function } [callback] Ф-ция, которая будет вызвана после загрузки и инициализации. В ф-цию первым параметром передаётся тело модуля
        * @return { jQuery.Deferred } Promise, который будет resolve при загрузке модуля (параметр - модуль).
        */
        loadModule: function loadModule(moduleName, moduleSource, callback) {
          var def = $.Deferred();

          if (typeof moduleSource === 'function') {
            callback = moduleSource;
            moduleSource = undefined;
          }

          this.addModulesCallback([moduleName], function (module) {
            callback && callback(module);
            def.resolve(module);
          });

          if (!(moduleName in _modules)) {
            _modules[moduleName] = null;
            var headElem = document.getElementsByTagName("head")[0];
            var newScript = document.createElement('script');
            var path;

            if (typeof moduleSource != 'undefined') {
              path = moduleSource.match(/^https?:\/\//i) ? moduleSource : (window.gmxJSHost || "") + moduleSource;
            } else {
              path = moduleName in _moduleFiles ? _moduleFiles[moduleName] : (_modulesDefaultHost || window.gmxJSHost || "") + moduleName + '.js';
            }

            var pathRegexp = /(.*)\/[^\/]+/;
            if (typeof _modulePathes[moduleName] === 'undefined') _modulePathes[moduleName] = pathRegexp.test(path) ? path.match(pathRegexp)[1] + "/" : ""; // var pathPostfix = "";

            newScript.onerror = function () {
              def.reject();
            };

            newScript.type = 'text/javascript';
            newScript.src = withCachePostfix(path);
            newScript.charset = "utf-8";
            headElem.appendChild(newScript);
          }

          return def;
        },

        /** Добавить callback, который будет вызван после загрузки моделей
        *
        * Если модули уже загружены, callback будет вызван сразу же
        *
        * @param {Array} moduleNames Массив имён модулей
        * @param {Function} callback Ф-ция, которую нужно вызвать после загрузки. В качестве аргументов в ф-цию передаются загруженные модули
        */
        addModulesCallback: function addModulesCallback(moduleNames, callback) {
          _callbacks.push({
            modules: moduleNames,
            callback: callback
          });

          invokeCallbacks();
        },

        /** Получить модуль по имени.
        *
        * @param {String} moduleName Имя модуля
        * @return {Object} Тело модуля. Если модуль не загружен, вернётся null.
        */
        getModule: function getModule(moduleName) {
          return _modules[moduleName] || null;
        },

        /** Установить дефольный путь к модулям. Используется если указан локальный файл модуля.
        * @param {String} defaultHost Дефолтный путь у модулям.
        */
        setDefaultModulesHost: function setDefaultModulesHost(defaultHost) {
          _modulesDefaultHost = defaultHost;
        },

        /** Явно задать полный путь к модулю
        * @param {String} moduleName Имя модуля
        * @param {String} defaultHost Путь к файлу модулю. При загрузке модуля будет загружен файл по указанному пути
        */
        setModuleFile: function setModuleFile(moduleName, moduleFile) {
          _moduleFiles[moduleName] = moduleFile;
        },
        pushModule2GlobalNamespace: function pushModule2GlobalNamespace(moduleName) {
          if (!_modules[moduleName]) return;
          var module = _modules[moduleName];

          for (var p in module) {
            _globalNamespace[p] = module[p];
          }
        },

        /** Получить путь к директории, из которой был загружен модуль.
        * @param {String} moduleName Имя модуля
        * @returns {String} Путь к директории, из которой был загружен модуль. Для не загруженных модулей ничего не возвращает
        */
        getModulePath: function getModulePath(moduleName) {
          return _modulePathes[moduleName];
        },

        /** Возвращает ф-цию, которая делает следующее:
        *
        *  - Если модуль moduleName не загружен, загружает его
        *  - Потом просто вызывает ф-цию с именем functionName из этого модуля, передав ей все свои параметры
        *
        *  - Возвращённая ф-ция при вызове возвращает jQuery.Promise, который будет resolve с параметрами, возвращёнными исходной ф-цией из модуля
        * @param {String} moduleName Имя модуля
        * @param {String} functionName Название ф-ции внутри модуля
        * @param {Function} callback Ф-ция, которая будет вызвана после того, как отработает ф-ция модуля. В callback будет передан ответ исходной ф-ции.
        */
        createDeferredFunction: function createDeferredFunction(moduleName, functionName, callback) {
          var _this = this;

          return function () {
            var deferred = $.Deferred();
            var args = arguments;

            _this.loadModule(moduleName).done(function (module) {
              var res = module[functionName].apply(this, args);
              callback && callback(res);
              deferred.resolve(res);
            });

            return deferred.promise();
          };
        },

        /** Загружает скрипт после предвариетельной проверки условий.
        *
        * @param {Array} filesInfo Массив объектов со следующими свойствами:
        *
        *   * check: function() -> Bool. Если возвращает true, ни js ни css не будет загружены
        *   * script: String. Не обязательно. Скрипт для загрузки, если провалится проверка
        *   * css: String | String[]. Не обязательно. CSS файл(ы) для загрузки, если провалится проверка
        *   @returns {jQuery.Deferred} Deferred, который будет разрешён когда все скрипты выполнятся (окончание загрузки css не отслеживается)
        */
        loadScriptWithCheck: function loadScriptWithCheck(filesInfo) {
          var _this = this;

          var localFilesInfo = filesInfo.slice(0);
          var def = $.Deferred();

          var doLoad = function doLoad() {
            if (localFilesInfo.length > 0) {
              var curInfo = localFilesInfo.shift();
              if (curInfo.check()) doLoad();else {
                var css = curInfo.css || [];

                if (typeof css === 'string') {
                  css = [css];
                }

                css.forEach(_this.loadCSS);
                if (curInfo.script) _this.loadScript(curInfo.script).then(doLoad);else doLoad();
              }
            } else def.resolve();
          };

          doLoad();
          return def.promise();
        },

        /**
        * Загружает отдельный скрипт
        * @param {String} fileName Имя файла скрипта
        * @param {function} [callback] Ф-ция, которая будет вызвана после загрузки
        * @param {String} [charset=utf-8] Кодировка загружаемого файла
        * @returns {jQuery.Deferred}
        */
        loadScript: function loadScript(fileName, callback, charset) {
          var def = $.Deferred();
          lazyLoadLABjs().done(function () {
            var descr = {
              src: withCachePostfix(fileName)
            };

            if (charset) {
              descr.charset = charset;
            }

            $LAB.script(descr).wait(function () {
              def.resolve();
              callback && callback();
            });
          });
          return def.promise();
        },

        /** Загрузить отдельный css файл
        * @param {String} cssFilename Имя css файла.
        */
        loadCSS: function loadCSS(cssFilename) {
          var doLoadCss = function doLoadCss() {
            $.getCSS(withCachePostfix(cssFilename));
          };

          if ('getCSS' in $) {
            doLoadCss();
          } else {
            if (!cssLoader) {
              var path = getScriptBase('gmxcore.js') || window.gmxJSHost || "";
              cssLoader = $.getScript(path + "jquery/jquery.getCSS.js");
            }

            cssLoader.done(doLoadCss);
          }
        }
      };
      return publicInterface;
    }();

    window.gmxCore = gmxCore$1;

    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function (obj) {
          return typeof obj;
        };
      } else {
        _typeof = function (obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    /* ======================================================================
        APICore.js
       ====================================================================== */ /** Пространство имён GeoMixer API
    * @name gmxAPI
    * @namespace
    */ /** Описание API JS 
    * @name api
    * @namespace
    */(function(){var memoize=function memoize(func){var called=false;var result;return function(){if(!called){result=func();called=true;}return result;};};var extend=function extend(ph,pt,flag){if(!ph)ph={};for(var key in pt){if(flag&&ph[key])continue;ph[key]=pt[key];}return ph;};window.PI=3.14159265358979;//устарело - обратная совместимость
    if(!window.gmxAPI)window.gmxAPI={};window.gmxAPI.extend=extend;extend(window.gmxAPI,{kosmosnimki_API:'1D30C72D02914C5FB90D1D448159CAB6',_tmpMaps:{},MAX_LATITUDE:85.0840591556,origin:window.document.domain,defaultMinZoom:1// мин.zoom по умолчанию
    ,defaultMaxZoom:24// макс.zoom по умолчанию
    ,mousePressed:false// Флаг мышь нажата
    ,APILoaded:false// Флаг возможности использования gmxAPI сторонними модулями
    ,initParams:null// Параметры заданные при создании карты 
    ,buildGUID:["02d3fb70bb0e11e3a63d1c6f65874c73"][0]// GUID текущей сборки
    ,leafletPlugins:{},_getEdgeIntersection:function _getEdgeIntersection(a,b,code,bounds){var dx=b[0]-a[0],dy=b[1]-a[1],min=bounds.min,max=bounds.max;if(code&8){// top
    return [a[0]+dx*(max.y-a[1])/dy,max.y];}else if(code&4){// bottom
    return [a[0]+dx*(min.y-a[1])/dy,min.y];}else if(code&2){// right
    return [max.x,a[1]+dy*(max.x-a[0])/dx];}else if(code&1){// left
    return [min.x,a[1]+dy*(min.x-a[0])/dx];}},_getBitCode:function _getBitCode(p,bounds){var code=0;if(p[0]<bounds.min.x){// left
    code|=1;}else if(p[0]>bounds.max.x){// right
    code|=2;}if(p[1]<bounds.min.y){// bottom
    code|=4;}else if(p[1]>bounds.max.y){// top
    code|=8;}return code;},clipPolygonByBounds:function clipPolygonByBounds(points,bounds){var clippedPoints,edges=[1,4,2,8],i,j,k,a,b,len,edge,p;for(i=0,len=points.length;i<len;i++){points[i][3]=gmxAPI._getBitCode(points[i],bounds);}// for each edge (left, bottom, right, top)
    for(k=0;k<4;k++){edge=edges[k];clippedPoints=[];for(i=0,len=points.length,j=len-1;i<len;j=i++){a=points[i];b=points[j];// if a is inside the clip window
    if(!(a[3]&edge)){// if b is outside the clip window (a->b goes out of screen)
    if(b[3]&edge){p=gmxAPI._getEdgeIntersection(b,a,edge,bounds);p[3]=gmxAPI._getBitCode(p,bounds);clippedPoints.push(p);}clippedPoints.push(a);// else if b is inside the clip window (a->b enters the screen)
    }else if(!(b[3]&edge)){p=gmxAPI._getEdgeIntersection(b,a,edge,bounds);p[3]=gmxAPI._getBitCode(p,bounds);clippedPoints.push(p);}}points=clippedPoints;}return points;},clipImageByPolygon:function clipImageByPolygon(attr){// Polygon fill
    if(attr.bgImage&&attr.geom.type.indexOf('POLYGON')!==-1){var mInPixel=attr.mInPixel,geom=attr.geom,coords=geom.coordinates,px=attr.tpx,py=attr.tpy,ctx=attr.ctx;ctx.fillStyle=ctx.createPattern(attr.bgImage,"no-repeat");if(geom.type==='POLYGON')coords=[coords];for(var i=0,len=coords.length;i<len;i++){var coords1=coords[i][0];// POLYGON без HELLS
    for(var k=0,len2=coords1.length;k<len2;k++){var x=0.5+coords1[k][0]*mInPixel-px<<0,y=0.5+py-coords1[k][1]*mInPixel<<0;ctx[k===0?'moveTo':'lineTo'](x,y);}}ctx.fill();}return true;},loadJS:function loadJS(item,callback,callbackError){var script=document.createElement("script");script.setAttribute("charset","windows-1251");script.setAttribute("src",item.src);item.readystate='loading';script.onload=function(ev){var count=0;if(item.count)count=item.count--;if(count===0)item.readystate='loaded';if(item.callback)item.callback(item);document.getElementsByTagName("head").item(0).removeChild(script);};script.onerror=function(ev){item.readystate='error';if(item.callbackError)item.callbackError(item);document.getElementsByTagName("head").item(0).removeChild(script);};document.getElementsByTagName("head").item(0).appendChild(script);},loadCSS:function loadCSS(href){var css=document.createElement("link");css.setAttribute("type","text/css");css.setAttribute("rel","stylesheet");css.setAttribute("media","screen");css.setAttribute("href",href);document.getElementsByTagName("head").item(0).appendChild(css);},getURLParams:memoize(function(){var q=window.location.search,kvp=q.length>1?q.substring(1).split("&"):[];for(var i=0;i<kvp.length;i++){kvp[i]=kvp[i].split("=");}var params={},givenMapName=false;for(var j=0;j<kvp.length;j++){if(kvp[j].length==1){if(!givenMapName)givenMapName=kvp[j][0];}else params[kvp[j][0]]=kvp[j][1];}return {params:params,givenMapName:givenMapName};}),getHtmlColor:function getHtmlColor(){// Получить цвет текста по map.backgroundColor
    var color=gmxAPI.map.backgroundColor;return (0xff&color>>16)>80?"black":"white";},getCoordinatesText:function getCoordinatesText(currPos,coordFormat){if(!currPos)currPos=gmxAPI.currPosition||gmxAPI.map.getPosition();var x=currPos.latlng?currPos.latlng.x:gmxAPI.from_merc_x(currPos.x);var y=currPos.latlng?currPos.latlng.y:gmxAPI.from_merc_y(currPos.y);if(x>180)x-=360;if(x<-180)x+=360;if(coordFormat%3==0)return gmxAPI.LatLon_formatCoordinates(x,y);else if(coordFormat%3==1)return gmxAPI.LatLon_formatCoordinates2(x,y);else return ''+Math.round(gmxAPI.merc_x(x))+', '+Math.round(gmxAPI.merc_y(y));},getScaleBarDistance:function getScaleBarDistance(){var currPos=gmxAPI.currPosition||gmxAPI.map.getPosition();var z=Math.round(currPos.z);var x=currPos.latlng?currPos.latlng.x:0;var y=currPos.latlng?currPos.latlng.y:0;if(gmxAPI.map.needMove){z=gmxAPI.map.needMove.z;x=gmxAPI.map.needMove.x;y=gmxAPI.map.needMove.y;}var metersPerPixel=gmxAPI.getScale(z)*gmxAPI.distVincenty(x,y,gmxAPI.from_merc_x(gmxAPI.merc_x(x)+40),gmxAPI.from_merc_y(gmxAPI.merc_y(y)+30))/50;for(var i=0;i<30;i++){var distance=[1,2,5][i%3]*Math.pow(10,Math.floor(i/3));var w=Math.floor(distance/metersPerPixel);if(w>100){return {txt:gmxAPI.prettifyDistance(distance),width:w};}}return null;},'getXmlHttp':function getXmlHttp(){var xmlhttp;if(typeof XMLHttpRequest!='undefined'){xmlhttp=new XMLHttpRequest();}if(!xmlhttp){try{xmlhttp=new ActiveXObject("Msxml2.XMLHTTP");}catch(e){try{xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");}catch(E){xmlhttp=false;}}}return xmlhttp;},'request':function request(ph){// {'type': 'GET|POST', 'url': 'string', 'callback': 'func'}
    try{var xhr=gmxAPI.getXmlHttp();xhr.open(ph['type']?ph['type']:'GET',ph['url'],true);xhr.withCredentials=true;xhr.onreadystatechange=function(){if(xhr.readyState==4){if(xhr.status==200){ph['callback'](xhr.responseText);xhr=null;}}};xhr.send(ph['params']?ph['params']:null);return xhr.status;}catch(e){if(ph['onError'])ph['onError'](xhr.responseText);return e.description;// turn all errors into empty results
    }},'createMap':function createMap(div,ph){var hostName=ph['hostName']||getAPIHost();var mapName=ph['mapName']||'DefaultMap';var callback=ph['callback']||function(){};gmxAPI.initParams=ph;createFlashMap(div,hostName,mapName,callback);return true;},'getSQLFunction':function getSQLFunction(sql){// Получить функцию по SQL выражению
    return gmxAPI.Parsers?gmxAPI.Parsers.parseSQL(sql):null;},'parseSQL':function parseSQL(sql){// парсинг SQL строки
    var zn=sql;if(typeof zn==='string'){zn=zn.replace(/ AND /g,' && ');}return zn;},'chkPropsInString':function chkPropsInString(str,prop,type){// парсинг значений свойств в строке
    var zn=str;if(typeof zn==='string'){var reg=type?/\"([^\"]+)\"/i:/\[([^\]]+)\]/i;var matches=reg.exec(zn);while(matches&&matches.length>1){zn=zn.replace(matches[0],prop[matches[1]]);matches=reg.exec(zn);}zn=eval(zn);}return zn;},clone:function clone(o,level){if(!level)level=0;var type=_typeof(o);if(!o||type!=='object'){return type==='function'?'function':o;}var c='function'===typeof o.pop?[]:{};var p,v;for(p in o){if(o.hasOwnProperty(p)){v=o[p];var type=_typeof(v);if(v&&type==='object'){c[p]=level<100?gmxAPI.clone(v,level+1):'object';}else{c[p]=type==='function'?'function':v;}}}return c;},KOSMOSNIMKI_LOCALIZED:function KOSMOSNIMKI_LOCALIZED(rus,eng){return window.KOSMOSNIMKI_LANGUAGE=="English"?eng:rus;},setStyleHTML:function setStyleHTML(elem,style,setBorder){if(!elem)return false;if(setBorder){elem.style.border=0;elem.style.margin=0;elem.style.padding=0;}if(style){for(var key in style){var value=style[key];elem.style[key]=value;if(key=="opacity")elem.style.filter="alpha(opacity="+Math.round(value*100)+")";}}return true;},newElement:function newElement(tagName,props,style,setBorder){var elem=document.createElement(tagName);if(props){for(var key in props){elem[key]=props[key];}}gmxAPI.setStyleHTML(elem,style,setBorder);return elem;},newStyledDiv:function newStyledDiv(style){return gmxAPI.newElement("div",false,style,true);},newSpan:function newSpan(innerHTML){return gmxAPI.newElement("span",{innerHTML:innerHTML},null,true);},newDiv:function newDiv(className,innerHTML){return gmxAPI.newElement("div",{className:className,innerHTML:innerHTML},null,true);},'domEventUtil':{addHandler:function addHandler(element,type,handler,capturing){if(element.addEventListener){element.addEventListener(type,handler,capturing?true:false);}else if(element.attachEvent){element.attachEvent("on"+type,handler);}else{element["on"+type]=handler;}},removeHandler:function removeHandler(element,type,handler){if(element.removeEventListener){element.removeEventListener(type,handler,capturing?true:false);}else if(element.detachEvent){element.detachEvent("on"+type,handler);}else{element["on"+type]=null;}}},makeImageButton:function makeImageButton(url,urlHover){var btn=document.createElement("img");btn.setAttribute('src',url);btn.style.cursor='pointer';btn.style.border='none';if(urlHover){btn.onmouseover=function(){this.setAttribute('src',urlHover);};btn.onmouseout=function(){this.setAttribute('src',url);};}return btn;},applyTemplate:function applyTemplate(template,properties){return template.replace(/\[([a-zA-Z0-9_а-яА-Я ]+)\]/g,function(){var value=properties[arguments[1]];if(value!=undefined)return ""+value;else return "["+arguments[1]+"]";});},getIdentityField:function getIdentityField(obj){if(!obj||!obj.parent)return 'ogc_fid';if(obj.properties&&obj.properties.identityField)return obj.properties.identityField;return gmxAPI.getIdentityField(obj.parent);},swfWarning:function swfWarning(attr){if(_typeof(attr)=='object'){// отложенные команды от отрисовщика
    if(attr.length>0){// массив команд
    for(var i=0;i<attr.length;i++){var ph=attr[i];if(!ph.func||!window[ph.func])continue;if(ph.eventType==='observeVectorLayer'){window[ph.func](ph.geometry,ph.properties,ph.flag);}}}else if(attr.eventType==='chkLayerVersion'){// сигнал о необходимости проверки версии слоя
    var chkLayer=gmxAPI.mapNodes[attr.layerID]||false;if(chkLayer&&gmxAPI._layersVersion){gmxAPI._layersVersion.chkLayerVersion(chkLayer);}}}else{gmxAPI._debugWarnings.push(attr);}},addDebugWarnings:function addDebugWarnings(attr){if(!window.gmxAPIdebugLevel)return;if(!attr.script)attr.script='api.js';if(attr.event&&attr.event.lineNumber)attr.lineNumber=attr.event.lineNumber;gmxAPI._debugWarnings.push(attr);if(attr.alert){if(window.gmxAPIdebugLevel===10)alert(attr.alert);else if(window.gmxAPIdebugLevel===9)console.log(attr);else if(window.gmxAPIdebugLevel===11&&attr.event)throw attr.event;}},_debugWarnings:[],//isIE: (navigator.appName.indexOf("Microsoft") != -1),
    isIE:'ActiveXObject'in window,isIElt9:gmxAPI.isIE&&!document.addEventListener,isChrome:navigator.userAgent.toLowerCase().indexOf("chrome")!=-1,isSafari:navigator.userAgent.toLowerCase().indexOf("safari")!=-1,show:function show(div){div.style.visibility="visible";div.style.display="block";},hide:function hide(div){div.style.visibility="hidden";div.style.display="none";},getTextContent:function getTextContent(node){if(typeof node.textContent!='undefined')return node.textContent;var data='';for(var i=0;i<node.childNodes.length;i++){data+=node.childNodes[i].data;}return data;},parseXML:function parseXML(str){var xmlDoc;try{if(window.DOMParser){parser=new DOMParser();xmlDoc=parser.parseFromString(str,"text/xml");}else// Internet Explorer
    {xmlDoc=new ActiveXObject("MSXML2.DOMDocument.3.0");xmlDoc.validateOnParse=false;xmlDoc.async=false;xmlDoc.loadXML(str);}}catch(e){gmxAPI.addDebugWarnings({'func':'parseXML','str':str,'event':e,'alert':e});}return xmlDoc;},setPositionStyle:function setPositionStyle(div,attr){for(var key in attr){div.style[key]=attr[key];}},position:function position(div,x,y){div.style.left=x+"px";div.style.top=y+"px";},bottomPosition:function bottomPosition(div,x,y){div.style.left=x+"px";div.style.bottom=y+"px";},size:function size(div,w,h){div.style.width=w+"px";div.style.height=h+"px";},positionSize:function positionSize(div,x,y,w,h){gmxAPI.position(div,x,y);gmxAPI.size(div,w,h);},setVisible:function setVisible(div,flag){(flag?gmxAPI.show:gmxAPI.hide)(div);},setBg:function setBg(t,imageName){if(gmxAPI.isIE)t.style.filter="progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+imageName+"',sizingMethod='scale')";else t.style.backgroundImage="url('"+imageName+"')";},deselect:function deselect(){if(window.disableDeselect)return;if(document.selection&&document.selection.empty)try{document.selection.empty();}catch(e){gmxAPI.addDebugWarnings({'func':'deselect','event':e,'alert':e});}},compatEvent:function compatEvent(event){return event||window.event;},stopEvent:function stopEvent(ev){var event=gmxAPI.compatEvent(ev);if(!event)return false;if(event.stopPropagation)event.stopPropagation();else if(event.preventDefault)event.preventDefault();event.cancelBubble=true;event.cancel=true;event.returnValue=false;return true;},compatTarget:function compatTarget(event){if(!event)event=window.event;return event.srcElement!=null?event.srcElement:event.target;},isInNode:function isInNode(prntNode,node){var i=0;var chkNode=node;while(i<1000&&chkNode){if(chkNode.tagName==='HTML')return false;if(chkNode===prntNode)return true;i++;chkNode=chkNode.parentNode;}return false;},eventX:function eventX(event){var theLeft=document.documentElement&&document.documentElement.scrollLeft?document.documentElement.scrollLeft:document.body.scrollLeft;return gmxAPI.compatEvent(event).clientX+theLeft;},eventY:function eventY(event){var theTop=document.documentElement&&document.documentElement.scrollTop?document.documentElement.scrollTop:document.body.scrollTop;return gmxAPI.compatEvent(event).clientY+theTop;},contDivPos:null// позиция основного контейнера
    ,getOffsetLeft:function getOffsetLeft(div){var ret=0;while(div&&div.tagName!='HTML'){ret+=div.offsetLeft;div=div.offsetParent;}return ret;},getOffsetTop:function getOffsetTop(div){var ret=0;while(div&&div.tagName!='HTML'){ret+=div.offsetTop;div=div.offsetParent;}return ret;},strip:function strip(s){return s.replace(/^\s*/,"").replace(/\s*$/,"");},parseColor:function parseColor(str){var res=0xffffff;if(!str)return res;else{var components=str.split(" ");if(components.length==1)return parseInt("0x"+str);else if(components.length==3)return parseInt(components[0])*0x10000+parseInt(components[1])*0x100+parseInt(components[2]);else return res;}},forEachPoint:function forEachPoint(coords,callback){if(!coords||coords.length==0)return [];if(!coords[0].length){if(coords.length==2)return callback(coords);else{var ret=[];for(var i=0;i<coords.length/2;i++){ret.push(callback([coords[i*2],coords[i*2+1]]));}return ret;}}else{var ret=[];for(var i=0;i<coords.length;i++){if(typeof coords[i]!='string')ret.push(gmxAPI.forEachPoint(coords[i],callback));}return ret;}},transformGeometry:function transformGeometry(geom,callbackX,callbackY){return !geom?geom:{type:geom.type,coordinates:gmxAPI.forEachPoint(geom.coordinates,function(p){return [callbackX(p[0]),callbackY(p[1])];})};},merc_geometry:function merc_geometry(geom){return geom?gmxAPI.transformGeometry(geom,gmxAPI.merc_x,gmxAPI.merc_y):null;},from_merc_geometry:function from_merc_geometry(geom){return geom?gmxAPI.transformGeometry(geom,gmxAPI.from_merc_x,gmxAPI.from_merc_y):null;},'bounds':function bounds(arr){// получить bounds массива точек
    var res={min:{x:Number.MAX_VALUE,y:Number.MAX_VALUE},max:{x:-Number.MAX_VALUE,y:-Number.MAX_VALUE},extend:function extend(x,y){if(x<this.min.x)this.min.x=x;if(x>this.max.x)this.max.x=x;if(y<this.min.y)this.min.y=y;if(y>this.max.y)this.max.y=y;return this;},extendArray:function extendArray(arr){if(!arr){return this;}for(var i=0,len=arr.length;i<len;i++){this.extend(arr[i][0],arr[i][1]);}return this;},addBuffer:function addBuffer(dxmin,dymin,dxmax,dymax){this.min.x-=dxmin;this.min.y-=dymin;this.max.x+=dxmax;this.max.y+=dymax;return this;},intersects:function intersects(bounds,dx,dy){// (Bounds, dx, dy) -> Boolean
    var min=this.min,max=this.max,dx=dx||0,dy=dy||0,min2=bounds.min,max2=bounds.max;return max2.x+dx>=min.x&&min2.x-dx<=max.x&&max2.y+dy>=min.y&&min2.y-dy<=max.y;}};return res.extendArray(arr);},'geoBounds':function geoBounds(geo){// получить bounds по geometry
    var type=geo['type'];var coords=geo['coordinates'];var arr=[];var addToArr=function addToArr(pol){for(var i=0,len=pol.length;i<len;i++){arr.push(pol[i]);}};if(type==='POINT'){arr.push(coords);}else if(type==='MULTIPOINT'){for(var i=0,len=coords.length;i<len;i++){addToArr(coords[i]);}}else if(type==='LINESTRING'){addToArr(coords);}else if(type==='MULTILINESTRING'){for(var i=0,len=coords.length;i<len;i++){addToArr(coords[i]);}}else if(type==='POLYGON'){addToArr(coords[0]);// дырки пропускаем
    }else if(type==='MULTIPOLYGON'){for(var i=0,len=coords.length;i<len;i++){addToArr(coords[i][0]);}}return gmxAPI.bounds(arr);},getBounds:function getBounds(coords){var ret={minX:100000000,minY:100000000,maxX:-100000000,maxY:-100000000,update:function update(data){gmxAPI.forEachPoint(data,function(p){ret.minX=Math.min(p[0],ret.minX);ret.minY=Math.min(p[1],ret.minY);ret.maxX=Math.max(p[0],ret.maxX);ret.maxY=Math.max(p[1],ret.maxY);});}};if(coords)ret.update(coords);return ret;},getTileExtent:function getTileExtent(x,y,z)// получить extent тайла
    {var pz=Math.pow(2,z);var tileSize=256*156543.033928041/pz;var minx=x*tileSize;var miny=y*tileSize;var ext=gmxAPI.getBounds([[minx,miny],[minx+tileSize,miny+tileSize]]);return ext;},boundsIntersect:function boundsIntersect(b1,b2)// в api.js не используется
    {return b1.minX<b2.maxX&&b1.minY<b2.maxY&&b2.minX<b1.maxX&&b2.minY<b1.maxY;},extIntersect:function extIntersect(ext1,ext2){return ext1.maxX<ext2.minX||ext1.minX>ext2.maxX||ext1.maxY<ext2.minY||ext1.minY>ext2.maxY?false:true;},isRectangle:function isRectangle(coords){return coords&&coords[0]&&coords[0].length==5&&coords[0][4][0]==coords[0][0][0]&&coords[0][4][1]==coords[0][0][1]&&(coords[0][0][0]==coords[0][1][0]||coords[0][0][1]==coords[0][1][1])&&(coords[0][1][0]==coords[0][2][0]||coords[0][1][1]==coords[0][2][1])&&(coords[0][2][0]==coords[0][3][0]||coords[0][2][1]==coords[0][3][1])&&(coords[0][3][0]==coords[0][4][0]||coords[0][3][1]==coords[0][4][1]);},getScale:function getScale(z){return Math.pow(2,-z)*156543.033928041;},deg_rad:function deg_rad(ang){return ang*(Math.PI/180.0);},deg_decimal:function deg_decimal(rad){return rad/Math.PI*180.0;},merc_x:function merc_x(lon){var r_major=6378137.000;return r_major*gmxAPI.deg_rad(lon);},from_merc_x:function from_merc_x(x){var r_major=6378137.000;return gmxAPI.deg_decimal(x/r_major);},merc_y:function merc_y(lat){if(lat>89.5)lat=89.5;if(lat<-89.5)lat=-89.5;var r_major=6378137.000;var r_minor=6356752.3142;var temp=r_minor/r_major;var es=1.0-temp*temp;var eccent=Math.sqrt(es);var phi=gmxAPI.deg_rad(lat);var sinphi=Math.sin(phi);var con=eccent*sinphi;var com=.5*eccent;con=Math.pow((1.0-con)/(1.0+con),com);var ts=Math.tan(.5*(Math.PI*0.5-phi))/con;var y=0-r_major*Math.log(ts);return y;},from_merc_y:function from_merc_y(y){var r_major=6378137.000;var r_minor=6356752.3142;var temp=r_minor/r_major;var es=1.0-temp*temp;var eccent=Math.sqrt(es);var ts=Math.exp(-y/r_major);var HALFPI=1.5707963267948966;var eccnth,Phi,con,dphi;eccnth=0.5*eccent;Phi=HALFPI-2.0*Math.atan(ts);var N_ITER=15;var TOL=1e-7;var i=N_ITER;dphi=0.1;while(Math.abs(dphi)>TOL&&--i>0){con=eccent*Math.sin(Phi);dphi=HALFPI-2.0*Math.atan(ts*Math.pow((1.0-con)/(1.0+con),eccnth))-Phi;Phi+=dphi;}return gmxAPI.deg_decimal(Phi);},merc:function merc(lon,lat){return [gmxAPI.merc_x(lon),gmxAPI.merc_y(lat)];},from_merc:function from_merc(x,y){return [gmxAPI.from_merc_x(x),gmxAPI.from_merc_y(y)];},distVincenty:function distVincenty(lon1,lat1,lon2,lat2){var p1=new Object();var p2=new Object();p1.lon=gmxAPI.deg_rad(lon1);p1.lat=gmxAPI.deg_rad(lat1);p2.lon=gmxAPI.deg_rad(lon2);p2.lat=gmxAPI.deg_rad(lat2);var a=6378137,b=6356752.3142,f=1/298.257223563;// WGS-84 ellipsiod
    var L=p2.lon-p1.lon;var U1=Math.atan((1-f)*Math.tan(p1.lat));var U2=Math.atan((1-f)*Math.tan(p2.lat));var sinU1=Math.sin(U1),cosU1=Math.cos(U1);var sinU2=Math.sin(U2),cosU2=Math.cos(U2);var lambda=L,lambdaP=2*Math.PI;var iterLimit=20;while(Math.abs(lambda-lambdaP)>1e-12&&--iterLimit>0){var sinLambda=Math.sin(lambda),cosLambda=Math.cos(lambda);var sinSigma=Math.sqrt(cosU2*sinLambda*(cosU2*sinLambda)+(cosU1*sinU2-sinU1*cosU2*cosLambda)*(cosU1*sinU2-sinU1*cosU2*cosLambda));if(sinSigma==0)return 0;var cosSigma=sinU1*sinU2+cosU1*cosU2*cosLambda;var sigma=Math.atan2(sinSigma,cosSigma);var sinAlpha=cosU1*cosU2*sinLambda/sinSigma;var cosSqAlpha=1-sinAlpha*sinAlpha;var cos2SigmaM=cosSigma-2*sinU1*sinU2/cosSqAlpha;if(isNaN(cos2SigmaM))cos2SigmaM=0;var C=f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha));lambdaP=lambda;lambda=L+(1-C)*f*sinAlpha*(sigma+C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)));}if(iterLimit==0)return NaN;var uSq=cosSqAlpha*(a*a-b*b)/(b*b);var A=1+uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));var B=uSq/1024*(256+uSq*(-128+uSq*(74-47*uSq)));var deltaSigma=B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)-B/6*cos2SigmaM*(-3+4*sinSigma*sinSigma)*(-3+4*cos2SigmaM*cos2SigmaM)));var s=b*A*(sigma-deltaSigma);s=s.toFixed(3);return s;},DegToRad:function DegToRad(deg){return deg/180.0*Math.PI;},RadToDeg:function RadToDeg(rad){return rad/Math.PI*180.0;},worldWidthMerc:20037508,worldWidthMerc2:20037508*2,sm_a:6378137.0,sm_b:6356752.314,//sm_EccSquared: 6.69437999013e-03,
    UTMScaleFactor:0.9996,ArcLengthOfMeridian:function ArcLengthOfMeridian(rad){var alpha,beta,gamma,delta,epsilon,n;var result;n=(gmxAPI.sm_a-gmxAPI.sm_b)/(gmxAPI.sm_a+gmxAPI.sm_b);alpha=(gmxAPI.sm_a+gmxAPI.sm_b)/2.0*(1.0+Math.pow(n,2.0)/4.0+Math.pow(n,4.0)/64.0);beta=-3.0*n/2.0+9.0*Math.pow(n,3.0)/16.0+-3.0*Math.pow(n,5.0)/32.0;gamma=15.0*Math.pow(n,2.0)/16.0+-15.0*Math.pow(n,4.0)/32.0;delta=-35.0*Math.pow(n,3.0)/48.0+105.0*Math.pow(n,5.0)/256.0;epsilon=315.0*Math.pow(n,4.0)/512.0;result=alpha*(phi+beta*Math.sin(2.0*phi)+gamma*Math.sin(4.0*phi)+delta*Math.sin(6.0*phi)+epsilon*Math.sin(8.0*phi));return result;},UTMCentralMeridian:function UTMCentralMeridian(zone){var cmeridian=gmxAPI.DegToRad(-183.0+zone*6.0);return cmeridian;},FootpointLatitude:function FootpointLatitude(y){var y_,alpha_,beta_,gamma_,delta_,epsilon_,n;var result;n=(gmxAPI.sm_a-gmxAPI.sm_b)/(gmxAPI.sm_a+gmxAPI.sm_b);alpha_=(gmxAPI.sm_a+gmxAPI.sm_b)/2.0*(1+Math.pow(n,2.0)/4+Math.pow(n,4.0)/64);y_=y/alpha_;beta_=3.0*n/2.0+-27.0*Math.pow(n,3.0)/32.0+269.0*Math.pow(n,5.0)/512.0;gamma_=21.0*Math.pow(n,2.0)/16.0+-55.0*Math.pow(n,4.0)/32.0;delta_=151.0*Math.pow(n,3.0)/96.0+-417.0*Math.pow(n,5.0)/128.0;epsilon_=1097.0*Math.pow(n,4.0)/512.0;result=y_+beta_*Math.sin(2.0*y_)+gamma_*Math.sin(4.0*y_)+delta_*Math.sin(6.0*y_)+epsilon_*Math.sin(8.0*y_);return result;},MapLatLonToXY:function MapLatLonToXY(phi,lambda,lambda0,xy){var N,nu2,ep2,t,t2,l;var l3coef,l4coef,l5coef,l6coef,l7coef,l8coef;ep2=(Math.pow(gmxAPI.sm_a,2.0)-Math.pow(gmxAPI.sm_b,2.0))/Math.pow(gmxAPI.sm_b,2.0);nu2=ep2*Math.pow(Math.cos(phi),2.0);N=Math.pow(gmxAPI.sm_a,2.0)/(gmxAPI.sm_b*Math.sqrt(1+nu2));t=Math.tan(phi);t2=t*t;l=lambda-lambda0;l3coef=1.0-t2+nu2;l4coef=5.0-t2+9*nu2+4.0*(nu2*nu2);l5coef=5.0-18.0*t2+t2*t2+14.0*nu2-58.0*t2*nu2;l6coef=61.0-58.0*t2+t2*t2+270.0*nu2-330.0*t2*nu2;l7coef=61.0-479.0*t2+179.0*(t2*t2)-t2*t2*t2;l8coef=1385.0-3111.0*t2+543.0*(t2*t2)-t2*t2*t2;xy[0]=N*Math.cos(phi)*l+N/6.0*Math.pow(Math.cos(phi),3.0)*l3coef*Math.pow(l,3.0)+N/120.0*Math.pow(Math.cos(phi),5.0)*l5coef*Math.pow(l,5.0)+N/5040.0*Math.pow(Math.cos(phi),7.0)*l7coef*Math.pow(l,7.0);xy[1]=ArcLengthOfMeridian(phi)+t/2.0*N*Math.pow(Math.cos(phi),2.0)*Math.pow(l,2.0)+t/24.0*N*Math.pow(Math.cos(phi),4.0)*l4coef*Math.pow(l,4.0)+t/720.0*N*Math.pow(Math.cos(phi),6.0)*l6coef*Math.pow(l,6.0)+t/40320.0*N*Math.pow(Math.cos(phi),8.0)*l8coef*Math.pow(l,8.0);return;},MapXYToLatLon:function MapXYToLatLon(x,y,lambda0,philambda){var phif,Nf,Nfpow,nuf2,ep2,tf,tf2,tf4,cf;var x1frac,x2frac,x3frac,x4frac,x5frac,x6frac,x7frac,x8frac;var x2poly,x3poly,x4poly,x5poly,x6poly,x7poly,x8poly;phif=FootpointLatitude(y);ep2=(Math.pow(gmxAPI.sm_a,2.0)-Math.pow(gmxAPI.sm_b,2.0))/Math.pow(gmxAPI.sm_b,2.0);cf=Math.cos(phif);nuf2=ep2*Math.pow(cf,2.0);Nf=Math.pow(gmxAPI.sm_a,2.0)/(gmxAPI.sm_b*Math.sqrt(1+nuf2));Nfpow=Nf;tf=Math.tan(phif);tf2=tf*tf;tf4=tf2*tf2;x1frac=1.0/(Nfpow*cf);Nfpow*=Nf;x2frac=tf/(2.0*Nfpow);Nfpow*=Nf;x3frac=1.0/(6.0*Nfpow*cf);Nfpow*=Nf;x4frac=tf/(24.0*Nfpow);Nfpow*=Nf;x5frac=1.0/(120.0*Nfpow*cf);Nfpow*=Nf;x6frac=tf/(720.0*Nfpow);Nfpow*=Nf;x7frac=1.0/(5040.0*Nfpow*cf);Nfpow*=Nf;x8frac=tf/(40320.0*Nfpow);x2poly=-1.0-nuf2;x3poly=-1.0-2*tf2-nuf2;x4poly=5.0+3.0*tf2+6.0*nuf2-6.0*tf2*nuf2-3.0*(nuf2*nuf2)-9.0*tf2*(nuf2*nuf2);x5poly=5.0+28.0*tf2+24.0*tf4+6.0*nuf2+8.0*tf2*nuf2;x6poly=-61.0-90.0*tf2-45.0*tf4-107.0*nuf2+162.0*tf2*nuf2;x7poly=-61.0-662.0*tf2-1320.0*tf4-720.0*(tf4*tf2);x8poly=1385.0+3633.0*tf2+4095.0*tf4+1575*(tf4*tf2);philambda[0]=phif+x2frac*x2poly*(x*x)+x4frac*x4poly*Math.pow(x,4.0)+x6frac*x6poly*Math.pow(x,6.0)+x8frac*x8poly*Math.pow(x,8.0);philambda[1]=lambda0+x1frac*x+x3frac*x3poly*Math.pow(x,3.0)+x5frac*x5poly*Math.pow(x,5.0)+x7frac*x7poly*Math.pow(x,7.0);return;},LatLonToUTMXY:function LatLonToUTMXY(lat,lon,zone,xy){gmxAPI.MapLatLonToXY(lat,lon,gmxAPI.UTMCentralMeridian(zone),xy);xy[0]=xy[0]*gmxAPI.UTMScaleFactor+500000.0;xy[1]=xy[1]*gmxAPI.UTMScaleFactor;if(xy[1]<0.0)xy[1]=xy[1]+10000000.0;return zone;},UTMXYToLatLon:function UTMXYToLatLon(x,y,zone,southhemi,latlon){var cmeridian;x-=500000.0;x/=gmxAPI.UTMScaleFactor;if(southhemi)y-=10000000.0;y/=gmxAPI.UTMScaleFactor;cmeridian=gmxAPI.UTMCentralMeridian(zone);gmxAPI.MapXYToLatLon(x,y,cmeridian,latlon);return;},truncate9:function truncate9(x){return (""+x).substring(0,9);},prettifyDistance:function prettifyDistance(length){var type=gmxAPI.map.DistanceUnit;if(type==='km')return Math.round(length)/1000+gmxAPI.KOSMOSNIMKI_LOCALIZED(" км"," km");if(length<2000||type==='m')return Math.round(length)+gmxAPI.KOSMOSNIMKI_LOCALIZED(" м"," m");if(length<200000)return Math.round(length/10)/100+gmxAPI.KOSMOSNIMKI_LOCALIZED(" км"," km");return Math.round(length/1000)+gmxAPI.KOSMOSNIMKI_LOCALIZED(" км"," km");},prettifyArea:function prettifyArea(area){var type=gmxAPI.map.SquareUnit;if(type==='km2')return ""+Math.round(area/100)/10000+gmxAPI.KOSMOSNIMKI_LOCALIZED(" кв. км"," sq.km");if(type==='ha')return ""+Math.round(area/100)/100+gmxAPI.KOSMOSNIMKI_LOCALIZED(" га"," ha");if(area<100000||type==='m2')return Math.round(area)+gmxAPI.KOSMOSNIMKI_LOCALIZED(" кв. м"," sq. m");if(area<3000000)return (""+Math.round(area/1000)/1000).replace(".",",")+gmxAPI.KOSMOSNIMKI_LOCALIZED(" кв. км"," sq.km");if(area<30000000)return (""+Math.round(area/10000)/100).replace(".",",")+gmxAPI.KOSMOSNIMKI_LOCALIZED(" кв. км"," sq.km");if(area<300000000)return (""+Math.round(area/100000)/10).replace(".",",")+gmxAPI.KOSMOSNIMKI_LOCALIZED(" кв. км"," sq.km");return Math.round(area/1000000)+gmxAPI.KOSMOSNIMKI_LOCALIZED(" кв. км"," sq. km");},fragmentArea:function fragmentArea(points){var area=0;var rad=Math.PI/180;for(var i=0,len=points.length;i<len;i++){var ipp=i==len-1?0:i+1;area+=points[i][0]*Math.sin(points[ipp][1]*rad)-points[ipp][0]*Math.sin(points[i][1]*rad);}var out=Math.abs(area*gmxAPI.lambertCoefX*gmxAPI.lambertCoefY/2);return out;},fragmentAreaMercator:function fragmentAreaMercator(points){var pts=[];for(var i=0,len=points.length;i<len;i++){pts.push([gmxAPI.from_merc_x(points[i][0]),gmxAPI.from_merc_y(points[i][1])]);}return gmxAPI.fragmentArea(pts);},pad2:function pad2(t){return t<10?"0"+t:""+t;},strToDate:function strToDate(str){var arr=str.split(' ');var arr1=arr[0].split('.');var d=arr1[0];var m=arr1[1]-1;var y=arr1[2];if(d>99)d=arr1[2],y=arr1[0];var ret=new Date(y,m,d);if(arr.length>1){arr1=arr[1].split(':');ret.setHours(arr1.length>0?arr1[0]:0,arr1.length>1?arr1[1]:0,arr1.length>2?arr1[2]:0,arr1.length>3?arr1[3]:0);}return ret;},trunc:function trunc(x){return (""+(Math.round(10000000*x)/10000000+0.00000001)).substring(0,9);},formatDegreesSimple:function formatDegreesSimple(angle){if(angle>180)angle-=360;var str=""+Math.round(angle*100000)/100000;if(str.indexOf(".")==-1)str+=".";for(var i=str.length;i<8;i++){str+="0";}return str;},formatDegrees:function formatDegrees(angle){angle=Math.round(10000000*angle)/10000000+0.00000001;var a1=Math.floor(angle);var a2=Math.floor(60*(angle-a1));var a3=gmxAPI.pad2(3600*(angle-a1-a2/60)).substring(0,2);return gmxAPI.pad2(a1)+"°"+gmxAPI.pad2(a2)+"'"+a3+'"';},LatLon_formatCoordinates:function LatLon_formatCoordinates(x,y){return gmxAPI.formatDegrees(Math.abs(y))+(y>0?" N, ":" S, ")+gmxAPI.formatDegrees(Math.abs(x))+(x>0?" E":" W");},formatCoordinates:function formatCoordinates(x,y){return gmxAPI.LatLon_formatCoordinates(gmxAPI.from_merc_x(x),gmxAPI.from_merc_y(y));},LatLon_formatCoordinates2:function LatLon_formatCoordinates2(x,y){return gmxAPI.trunc(Math.abs(y))+(y>0?" N, ":" S, ")+gmxAPI.trunc(Math.abs(x))+(x>0?" E":" W");},formatCoordinates2:function formatCoordinates2(x,y){return gmxAPI.LatLon_formatCoordinates2(gmxAPI.from_merc_x(x),gmxAPI.from_merc_y(y));},forEachPointAmb:function forEachPointAmb(arg,callback){gmxAPI.forEachPoint(arg.length?arg:arg.coordinates,callback);},geoLength:function geoLength(arg1,arg2,arg3,arg4){if(arg4)return gmxAPI.distVincenty(arg1,arg2,arg3,arg4);var currentX=false,currentY=false,length=0;gmxAPI.forEachPointAmb(arg1,function(p){if(currentX&&currentY)length+=parseFloat(gmxAPI.distVincenty(currentX,currentY,p[0],p[1]));currentX=p[0];currentY=p[1];});return length;},geoArea:function geoArea(arg){if(arg.type=="MULTIPOLYGON"){var ret=0;for(var i=0;i<arg.coordinates.length;i++){ret+=gmxAPI.geoArea({type:"POLYGON",coordinates:arg.coordinates[i]});}return ret;}else if(arg.type=="POLYGON"){var ret=gmxAPI.geoArea(arg.coordinates[0]);for(var i=1;i<arg.coordinates.length;i++){ret-=gmxAPI.geoArea(arg.coordinates[i]);}return ret;}else if(arg.length){var pts=[];gmxAPI.forEachPoint(arg,function(p){pts.push(p);});return gmxAPI.fragmentArea(pts);}else return 0;},geoCenter:function geoCenter(arg1,arg2,arg3,arg4){var minX,minY,maxX,maxY;if(arg4){minX=Math.min(arg1,arg3);minY=Math.min(arg2,arg4);maxX=Math.max(arg1,arg3);maxY=Math.max(arg2,arg4);}else{minX=1000;minY=1000;maxX=-1000;maxY=-1000;gmxAPI.forEachPointAmb(arg1,function(p){minX=Math.min(minX,p[0]);minY=Math.min(minY,p[1]);maxX=Math.max(maxX,p[0]);maxY=Math.max(maxY,p[1]);});}return [gmxAPI.from_merc_x((gmxAPI.merc_x(minX)+gmxAPI.merc_x(maxX))/2),gmxAPI.from_merc_y((gmxAPI.merc_y(minY)+gmxAPI.merc_y(maxY))/2)];},chkPointCenterX:function chkPointCenterX(centerX){if(typeof centerX!='number')centerX=0;else{centerX=centerX%360;if(centerX<-180)centerX+=360;if(centerX>180)centerX-=360;}return centerX;},convertCoords:function convertCoords(coordsStr){var res=[],coordsPairs=gmxAPI.strip(coordsStr).replace(/\s+/,' ').split(' ');if(coordsStr.indexOf(',')==-1){for(var j=0;j<Math.floor(coordsPairs.length/2);j++){res.push([Number(coordsPairs[2*j]),Number(coordsPairs[2*j+1])]);}}else{for(var j=0;j<coordsPairs.length;j++){var parsedCoords=coordsPairs[j].split(',');res.push([Number(parsedCoords[0]),Number(parsedCoords[1])]);}}return res;},parseGML:function parseGML(response){var geometries=[],strResp=response.replace(/[\t\n\r]/g,' '),strResp=strResp.replace(/\s+/g,' '),coordsTag=/<gml:coordinates>([-0-9.,\s]*)<\/gml:coordinates>/,pointTag=/<gml:Point>[\s]*<gml:coordinates>[-0-9.,\s]*<\/gml:coordinates>[\s]*<\/gml:Point>/g,lineTag=/<gml:LineString>[\s]*<gml:coordinates>[-0-9.,\s]*<\/gml:coordinates>[\s]*<\/gml:LineString>/g,polyTag=/<gml:Polygon>[\s]*(<gml:outerBoundaryIs>[\s]*<gml:LinearRing>[\s]*<gml:coordinates>[-0-9.,\s]*<\/gml:coordinates>[\s]*<\/gml:LinearRing>[\s]*<\/gml:outerBoundaryIs>){0,1}[\s]*(<gml:innerBoundaryIs>[\s]*<gml:LinearRing>[\s]*<gml:coordinates>[-0-9.,\s]*<\/gml:coordinates>[\s]*<\/gml:LinearRing>[\s]*<\/gml:innerBoundaryIs>){0,1}[\s]*<\/gml:Polygon>/g,outerTag=/<gml:outerBoundaryIs>(.*)<\/gml:outerBoundaryIs>/,innerTag=/<gml:innerBoundaryIs>(.*)<\/gml:innerBoundaryIs>/;if(strResp.indexOf('gml:posList')>-1){coordsTag=/<gml:posList>([-0-9.,\s]*)<\/gml:posList>/,pointTag=/<gml:Point>[\s]*<gml:posList>[-0-9.,\s]*<\/gml:posList>[\s]*<\/gml:Point>/g,lineTag=/<gml:LineString>[\s]*<gml:posList>[-0-9.,\s]*<\/gml:posList>[\s]*<\/gml:LineString>/g,polyTag=/<gml:Polygon>[\s]*(<gml:exterior>[\s]*<gml:LinearRing>[\s]*<gml:posList>[-0-9.,\s]*<\/gml:posList>[\s]*<\/gml:LinearRing>[\s]*<\/gml:exterior>){0,1}[\s]*(<gml:interior>[\s]*<gml:LinearRing>[\s]*<gml:posList>[-0-9.,\s]*<\/gml:posList>[\s]*<\/gml:LinearRing>[\s]*<\/gml:interior>){0,1}[\s]*<\/gml:Polygon>/g,outerTag=/<gml:exterior>(.*)<\/gml:exterior>/,innerTag=/<gml:interior>(.*)<\/gml:interior>/;}else if(strResp.indexOf('<kml')>-1){coordsTag=/<coordinates>([-0-9.,\s]*)<\/coordinates>/,pointTag=/<Point>[^P]*<\/Point>/g,lineTag=/<LineString>[^L]*<\/LineString>/g,polyTag=/<Polygon>[^P]*<\/Polygon>/g,outerTag=/<outerBoundaryIs>(.*)<\/outerBoundaryIs>/,innerTag=/<innerBoundaryIs>(.*)<\/innerBoundaryIs>/;}strResp=strResp.replace(pointTag,function(str){var coords=gmxAPI.getTagValue(str,coordsTag),parsedCoords=gmxAPI.convertCoords(coords);geometries.push({type:'POINT',coordinates:parsedCoords[0]});return '';});strResp=strResp.replace(lineTag,function(str){var coords=gmxAPI.getTagValue(str,coordsTag),parsedCoords=gmxAPI.convertCoords(coords);geometries.push({type:'LINESTRING',coordinates:parsedCoords});return '';});strResp=strResp.replace(polyTag,function(str){var coords=[],outerCoords=gmxAPI.getTagValue(str,outerTag),innerCoords=gmxAPI.getTagValue(str,innerTag),resultCoords=[];if(outerCoords)coords.push(gmxAPI.getTagValue(outerCoords,coordsTag));if(innerCoords)coords.push(gmxAPI.getTagValue(innerCoords,coordsTag));for(var index=0;index<coords.length;index++){resultCoords.push(gmxAPI.convertCoords(coords[index]));}geometries.push({type:'POLYGON',coordinates:resultCoords});return '';});return geometries;},createGML:function createGML(geometries,format){if(typeof geometries=='undefined'||geometries==null||geometries.length==0)return '';var coordsSeparator=',',pointTag='<gml:Point><gml:coordinates>_REPLACE_<\/gml:coordinates><\/gml:Point>',lineTag='<gml:LineString><gml:coordinates>_REPLACE_<\/gml:coordinates><\/gml:LineString>',polyTag='<gml:Polygon>_REPLACE_<\/gml:Polygon>',outerTag='<gml:outerBoundaryIs><gml:LinearRing><gml:coordinates>_REPLACE_<\/gml:coordinates><\/gml:LinearRing><\/gml:outerBoundaryIs>',innerTag='<gml:innererBoundaryIs><gml:LinearRing><gml:coordinates>_REPLACE_<\/gml:coordinates><\/gml:LinearRing><\/gml:innerBoundaryIs>',elementTag='<gml:featureMember>_REPLACE_<\/gml:featureMember>',headerTag='<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<wfs:FeatureCollection xmlns:ogc=\"http://www.opengis.net/ogc\" xmlns:gml=\"http://www.opengis.net/gml\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:ows=\"http://www.opengis.net/ows\" xmlns:wfs=\"http://www.opengis.net/wfs\">\n_REPLACE_\n</wfs:FeatureCollection>';if(typeof format!='undefined'&&format=='gml3'){coordsSeparator=' ',pointTag='<gml:Point><gml:posList>_REPLACE_<\/gml:posList><\/gml:Point>',lineTag='<gml:LineString><gml:posList>_REPLACE_<\/gml:posList><\/gml:LineString>',polyTag='<gml:Polygon>_REPLACE_<\/gml:Polygon>',outerTag='<gml:exterior><gml:LinearRing><gml:posList>_REPLACE_<\/gml:posList><\/gml:LinearRing><\/gml:exterior>',innerTag='<gml:interior><gml:LinearRing><gml:posList>_REPLACE_<\/gml:posList><\/gml:LinearRing><\/gml:interior>',elementTag='<gml:featureMember>_REPLACE_<\/gml:featureMember>',headerTag='<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<wfs:FeatureCollection xmlns:ogc=\"http://www.opengis.net/ogc\" xmlns:gml=\"http://www.opengis.net/gml\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" xmlns:ows=\"http://www.opengis.net/ows\" xmlns:wfs=\"http://www.opengis.net/wfs\">\n_REPLACE_\n</wfs:FeatureCollection>';}else if(typeof format!='undefined'&&format=='kml'){pointTag='<Point><coordinates>_REPLACE_<\/coordinates><\/Point>',lineTag='<LineString><coordinates>_REPLACE_<\/coordinates><\/LineString>',polyTag='<Polygon>_REPLACE_<\/Polygon>',outerTag='<outerBoundaryIs><LinearRing><coordinates>_REPLACE_<\/coordinates><\/LinearRing><\/outerBoundaryIs>',innerTag='<innererBoundaryIs><LinearRing><coordinates>_REPLACE_<\/coordinates><\/LinearRing><\/innerBoundaryIs>',elementTag='<Placemark>_REPLACE_<\/Placemark>',headerTag='<?xml version=\"1.0\" encoding=\"UTF-8\" ?> <kml xmlns=\"http://earth.google.com/kml/2.0\"> <Document>\n_REPLACE_\n</Document>';}var elementsStr='';for(var i=0;i<geometries.length;i++){var geometriesStr='';if(geometries[i].type=='POINT'){var coordsStr=geometries[i].coordinates.join(coordsSeparator);geometriesStr=pointTag.replace('_REPLACE_',coordsStr);}else if(geometries[i].type=='LINESTRING'){var coordsStr='';for(var j=0;j<geometries[i].coordinates.length;j++){if(j==0)coordsStr+=geometries[i].coordinates[j].join(coordsSeparator);else coordsStr+=' '+geometries[i].coordinates[j].join(coordsSeparator);}geometriesStr=lineTag.replace('_REPLACE_',coordsStr);}else if(geometries[i].type=='POLYGON'){var bounds=[outerTag,innerTag];for(var k=0;k<geometries[i].coordinates.length;k++){var coordsStr='';for(var j=0;j<geometries[i].coordinates[k].length;j++){if(j==0)coordsStr+=geometries[i].coordinates[k][j].join(coordsSeparator);else coordsStr+=' '+geometries[i].coordinates[k][j].join(coordsSeparator);}geometriesStr=bounds[k].replace('_REPLACE_',coordsStr);}geometriesStr=polyTag.replace('_REPLACE_',geometriesStr);}elementsStr+=elementTag.replace('_REPLACE_',geometriesStr);}var xmlStr=headerTag.replace('_REPLACE_',elementsStr);return xmlStr;},getTagValue:function getTagValue(str,tag){var res=null;str.replace(tag,function(){res=arguments[1];});return res;},parseCoordinates:function parseCoordinates(text,callback){// should understand the following formats:
    // 55.74312, 37.61558
    // 55°44'35" N, 37°36'56" E
    // 4187347, 7472103
    if(text.match(/[йцукенгшщзхъфывапролджэячсмитьбюЙЦУКЕНГШЩЗХЪФЫВАПРОЛДЖЭЯЧСМИТЬБЮqrtyuiopadfghjklzxcvbmQRTYUIOPADFGHJKLZXCVBM_:]/))return false;if(text.indexOf(" ")!=-1)text=text.replace(/,/g,".");var regex=/(-?\d+(\.\d+)?)([^\d\-]*)/g;var results=[];while(t=regex.exec(text)){results.push(t[1]);}if(results.length<2)return false;var ii=Math.floor(results.length/2);var x=0;var mul=1;for(var i=0;i<ii;i++){x+=parseFloat(results[i])*mul;mul/=60;}var y=0;mul=1;for(var i=ii;i<results.length;i++){y+=parseFloat(results[i])*mul;mul/=60;}if(Math.abs(x)<180&&Math.abs(y)<180){var tx=x,ty=y;x=gmxAPI.merc_x(ty);y=gmxAPI.merc_y(tx);}if(Math.max(text.indexOf("N"),text.indexOf("S"))>Math.max(text.indexOf("E"),text.indexOf("W"))){var t=gmxAPI.merc_y(gmxAPI.from_merc_x(x));x=gmxAPI.merc_x(gmxAPI.from_merc_y(y));y=t;}if(text.indexOf("W")!=-1)x=-x;if(text.indexOf("S")!=-1)y=-y;callback(gmxAPI.from_merc_x(x),gmxAPI.from_merc_y(y));return true;},parseUri:function parseUri(str){var o={strictMode:false,key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}},m=o.parser["loose"].exec(str),uri={},i=14;while(i--){uri[o.key[i]]=m[i]||"";}uri[o.q.name]={};uri[o.key[12]].replace(o.q.parser,function($0,$1,$2){if($1)uri[o.q.name][$1]=$2;});uri.hostOnly=uri.host;uri.host=uri.authority;// HACK
    return uri;},memoize:memoize,getScriptURL:function getScriptURL(scriptName){var scripts1=document.getElementsByTagName("script");for(var i=0;i<scripts1.length;i++){var src=scripts1[i].getAttribute("src");if(src&&src.indexOf(scriptName)!=-1)return src;}return false;},getScriptBase:function getScriptBase(scriptName){var url=gmxAPI.getScriptURL(scriptName);return url.substring(0,url.indexOf(scriptName));},getBaseMapParam:function getBaseMapParam(paramName,defaultValue){if(_typeof(window.baseMap)!=='object')window.baseMap={};if(!window.baseMap[paramName])window.baseMap[paramName]=defaultValue;return window.baseMap[paramName];//return (window.baseMap && window.baseMap[paramName]) ? window.baseMap[paramName] : defaultValue;
    },getHostAndPath:function getHostAndPath(url){var u=gmxAPI.parseUri(url);if(u.host=="")return "";var s=u.host+u.directory;if(s.charAt(s.length-1)=="/")s=s.substring(0,s.length-1);return s;},getAPIUri:memoize(function(){var scripts1=document.getElementsByTagName("script");for(var i=0;i<scripts1.length;i++){var src=scripts1[i].getAttribute("src");var u=gmxAPI.parseUri(src);if(u&&/\bapi\w*\.js\b/.exec(src)){return u;}}return {};}),getAPIKey:memoize(function(){var u=gmxAPI.getAPIUri();return u.source?/key=([a-zA-Z0-9]+)/.exec(u.source):'';}),getAPIFolderRoot:memoize(function(){var u=gmxAPI.getAPIUri();return u.source?u.source.substring(0,u.source.indexOf(u.file)):'';}),getAPIHost:memoize(function(){var apiHost=gmxAPI.getHostAndPath(gmxAPI.getAPIFolderRoot());if(apiHost==""){apiHost=gmxAPI.getHostAndPath(window.location.href);}var arr=/(.*)\/[^\/]*/.exec(apiHost);res=arr&&arr.length>1?arr[1]:'';//удаляем последний каталог в адресе
    return res;}),getAPIHostRoot:memoize(function(){return "http://"+gmxAPI.getAPIHost()+"/";}),isArray:function isArray(obj){return Object.prototype.toString.apply(obj)==='[object Array]';},removeFromArray:function removeFromArray(arr,value){for(var i=0,len=arr.length;i<len;i++){if(arr[i]==value)return arr.splice(i,1);}return false;},valueInArray:function valueInArray(arr,value){for(var i=0,len=arr.length;i<len;i++){if(arr[i]==value)return true;}return false;},arrayToHash:function arrayToHash(arr){var ret={};for(var i=0;i<arr.length;i++){ret[arr[i][0]]=arr[i][1];}return ret;},propertiesFromArray:function propertiesFromArray(a){a.sort(function(e1,e2){var f1=e1[0],f2=e2[0];return f1<f2?-1:f1==f2?0:1;});var p_={};for(var i=0;i<a.length;i++){p_[a[i][0]]=a[i][1];}return p_;},lastFlashMapId:0,newFlashMapId:function newFlashMapId(){gmxAPI.lastFlashMapId+=1;return "random_"+gmxAPI.lastFlashMapId;},uniqueGlobalName:function uniqueGlobalName(thing){var id=gmxAPI.newFlashMapId();window[id]=thing;return id;},loadVariableFromScript:function loadVariableFromScript(url,name,callback,onError,useTimeout){window[name]=undefined;var script=document.createElement("script");var done=false;var ready=function ready(){if(window[name]!==undefined)callback(window[name]);else if(onError)onError();done=true;};script.onerror=function(){if(!done){window[name]=undefined;ready();}};script.onload=function(){if(!done){ready();}};script.setAttribute("charset","UTF-8");document.getElementsByTagName("head").item(0).appendChild(script);script.setAttribute("src",url);},loadVariableFromScript_old:function loadVariableFromScript_old(url,name,callback,onError,useTimeout){window[name]=undefined;var script=document.createElement("script");var done=false;//var count = 0;		// Попытки загрузки
    script.onerror=function(){if(!done){clearInterval(intervalError);if(onError)onError();done=true;}};script.onload=function(){if(!done){clearInterval(intervalError);if(window[name]!==undefined)callback(window[name]);else if(onError)onError();done=true;}};script.onreadystatechange=function(){if(!done){if(script.readyState==='loaded'||this.readyState==='complete'){var ready=function ready(){clearInterval(intervalError);if(window[name]!==undefined)callback(window[name]);else if(onError)onError();done=true;};if(gmxAPI.isIE)setTimeout(ready,100);else ready();}}};var intervalError=setInterval(function(){//			count++;
    if(!done){if(script.readyState==='loaded'||this.readyState==='complete'){clearInterval(intervalError);if(typeof window[name]==='undefined'){if(onError)onError();}done=true;/*
    				} else if (count > 100)
    				{
    					clearInterval(intervalError);
    					if (onError) onError();
    */}}},50);script.setAttribute("charset","UTF-8");document.getElementsByTagName("head").item(0).appendChild(script);script.setAttribute("src",url);},getPatternIcon:function getPatternIcon(ph,size){return gmxAPI._cmdProxy('getPatternIcon',{'attr':{'size':size||32,'style':ph}});},mapNodes:{}// ноды mapObjects
    ,chkNodeVisibility:function chkNodeVisibility(id)// рекурсивная проверка видимости обьекта по mapNodes
    {var pObj=gmxAPI.mapNodes[id];var ret=!pObj||'isVisible'in pObj&&!pObj['isVisible']?false:pObj.parent?gmxAPI.chkNodeVisibility(pObj.parent.objectId):true;return ret;},isProxyReady:function isProxyReady(){var chkObj=null;if(gmxAPI.proxyType==='leaflet'){// Это leaflet версия
    chkObj=gmxAPI._leaflet&&gmxAPI._leaflet['LMap']?true:false;}else{// Это Flash версия
    chkObj=window.__flash__toXML;}return chkObj?true:false;},getTileBounds:function getTileBounds(z,x,y)// Определение границ тайла
    {var tileSize=gmxAPI.getScale(z)*256;var minX=x*tileSize;var minY=y*tileSize;return {minX:gmxAPI.from_merc_x(minX),minY:gmxAPI.from_merc_y(minY),maxX:gmxAPI.from_merc_x(minX+tileSize),maxY:gmxAPI.from_merc_y(minY+tileSize)};},'getTilePosZoomDelta':function getTilePosZoomDelta(tilePoint,zoomFrom,zoomTo){// получить смещение тайла на меньшем zoom
    var dz=Math.pow(2,zoomFrom-zoomTo);var size=256/dz;var dx=tilePoint.x%dz;var dy=tilePoint.y%dz;return {'size':size,'zDelta':dz,'x':size*(dx<0?dz+dx:dx),'y':size*(dy<0?Math.abs(1+dy):dz-1-dy)};},'filterVisibleTiles':function filterVisibleTiles(arr,tiles,z){// отфильтровать список тайлов по видимому extent
    var count=0;var currPos=gmxAPI.currPosition||gmxAPI.map.getPosition();if(currPos['latlng']){if(!z)z=currPos['z'];var bounds=gmxAPI.map.getVisibleExtent();var pz=Math.pow(2,-z);var tileSize=256*pz*156543.033928041;var xSize=360*pz;var minx=Math.floor(bounds.minX/xSize);var maxx=Math.ceil(bounds.maxX/xSize);var miny=Math.floor(gmxAPI.merc_y(bounds.minY)/tileSize);var maxy=Math.ceil(gmxAPI.merc_y(bounds.maxY)/tileSize);//var arr = ph['dtiles'];
    for(var i=0,len=arr.length;i<len;i+=3){var tx=Number(arr[i]),ty=Number(arr[i+1]),tz=Number(arr[i+2]);var dz=Math.pow(2,z-tz);var tx1=Number(tx*dz),ty1=Number(ty*dz);if(tx1+dz<minx||tx1>maxx||ty1+dz<miny||ty1>maxy){continue;}count+=tiles?tiles[tz][tx][ty].length:1;}}return count;},'chkTileList':function chkTileList(attr){// получить список тайлов по bounds на определенном zoom
    var z=attr.z;var pz=Math.pow(2,-z);var tileSize=256*pz*156543.033928041;var xSize=360*pz;if(attr.bounds){var bounds=attr.bounds;var minx=Math.floor(bounds.minX/xSize);var maxx=Math.ceil(bounds.maxX/xSize);var miny=Math.floor(gmxAPI.merc_y(bounds.minY)/tileSize);var maxy=Math.ceil(gmxAPI.merc_y(bounds.maxY)/tileSize);var res=[];for(var j=miny;j<=maxy;j++){for(var i=minx;i<=maxx;i++){res.push({'x':i,'y':j,'z':z});}}return res;}else{var x=gmxAPI.merc_x(attr.x);var y=gmxAPI.merc_y(attr.y);var tile={'x':Math.floor(x/tileSize),'y':Math.floor(y/tileSize),'z':z,'posInTile':{'x':Math.round(256*(x%tileSize/tileSize)),'y':Math.round(256*(1-y%tileSize/tileSize))}};return tile;// получить атрибуты тайла по POINT
    }},'getTileFromPoint':function getTileFromPoint(x,y,z){// получить атрибуты тайла по POINT на определенном zoom
    return gmxAPI.chkTileList({'x':x,'y':y,'z':z});},'getTileListByGeometry':function getTileListByGeometry(geom,zoom){// получить список тайлов по Geometry для zoom
    var bounds=gmxAPI.getBounds(geom.coordinates);return gmxAPI.getTileListByBounds(bounds,zoom);},'getTileListByBounds':function getTileListByBounds(bounds,z){// получить список тайлов по bounds на определенном zoom
    return gmxAPI.chkTileList({'bounds':bounds,'z':z});},'isPageHidden':function isPageHidden(){// Видимость окна браузера
    return document.hidden||document.msHidden||document.webkitHidden||document.mozHidden||false;}});window.gmxAPI.lambertCoefX=100*gmxAPI.distVincenty(0,0,0.01,0);// 111319.5;
    window.gmxAPI.lambertCoefY=100*gmxAPI.distVincenty(0,0,0,0.01)*180/Math.PI;// 6335440.712613423;
    window.gmxAPI.serverBase='maps.kosmosnimki.ru';// HostName основной карты по умолчанию
    window.gmxAPI.proxyType='flash';// Тип отображения
    window.gmxAPI.miniMapAvailable=false;window.gmxAPI.maxRasterZoom=1;window.gmxAPI.miniMapZoomDelta=-4;(function(){var FlashMapFeature=function FlashMapFeature(geometry,properties,layer){this.geometry=geometry;this.properties=properties;this.layer=layer;};FlashMapFeature.prototype.getGeometry=function(){return this.geometry;};FlashMapFeature.prototype.getLength=function(){return gmxAPI.geoLength(this.geometry);};FlashMapFeature.prototype.getArea=function(){return gmxAPI.geoArea(this.geometry);};gmxAPI._FlashMapFeature=FlashMapFeature;})();(function(){function HandlerMode(div,event,handler){this.div=div;this.event=event;this.handler=handler;}HandlerMode.prototype.set=function(){if(this.div.attachEvent)this.div.attachEvent("on"+this.event,this.handler);if(this.div.addEventListener)this.div.addEventListener(this.event,this.handler,false);};HandlerMode.prototype.clear=function(){if(this.div.detachEvent)this.div.detachEvent("on"+this.event,this.handler);if(this.div.removeEventListener)this.div.removeEventListener(this.event,this.handler,false);};gmxAPI._HandlerMode=HandlerMode;})();window.gmxAPI.GlobalHandlerMode=function(event,handler){return new gmxAPI._HandlerMode(document.documentElement,event,handler);};})();// Блок методов глобальной области видимости
    //var kosmosnimki_API = "1D30C72D02914C5FB90D1D448159CAB6";
    var tmp=['isIE','parseCoordinates','setBg','deselect','compatEvent','compatTarget','eventX','eventY','getOffsetLeft','getOffsetTop','newStyledDiv','show','hide','setPositionStyle','position','bottomPosition','size','makeImageButton','setVisible','getTextContent','parseXML','GlobalHandlerMode','getScriptURL','getScriptBase','getHostAndPath','getBaseMapParam','strip','parseUri','parseColor','forEachPoint','merc_geometry','from_merc_geometry','getBounds','isRectangle','getScale','geoLength','geoArea','geoCenter','parseGML','createGML','merc_x','from_merc_x','merc_y','from_merc_y','distVincenty','KOSMOSNIMKI_LOCALIZED','prettifyDistance','prettifyArea','pad2','formatCoordinates','formatCoordinates2','lastFlashMapId','newFlashMapId','uniqueGlobalName','loadVariableFromScript',// Не используемые в api.js
    'newDiv','newSpan','positionSize','merc','from_merc','formatDegrees','memoize','DegToRad','RadToDeg','ArcLengthOfMeridian','UTMCentralMeridian','FootpointLatitude','MapLatLonToXY','MapXYToLatLon','LatLonToUTMXY','UTMXYToLatLon','trunc','truncate9','lambertCoefX','lambertCoefY','fragmentArea','fragmentAreaMercator','formatDegreesSimple','convertCoords','transformGeometry','boundsIntersect','getTagValue','forEachPointAmb','deg_rad','deg_decimal'];for(var i$1=0;i$1<tmp.length;i$1++){window[tmp[i$1]]=gmxAPI[tmp[i$1]];}var getAPIFolderRoot=gmxAPI.memoize(function(){return gmxAPI.getAPIFolderRoot();});var getAPIHost=gmxAPI.memoize(function(){return gmxAPI.getAPIHost();});var getAPIHostRoot=gmxAPI.memoize(function(){return gmxAPI.getAPIHostRoot();});// Поддержка setHandler и Listeners
    (function(){var flashEvents={// События передающиеся в SWF
    'onClick':true,'onMouseDown':true,'onMouseUp':true,'onMouseOver':true,'onMouseOut':true,'onMove':true,'onMoveBegin':true,'onMoveEnd':true,'onResize':true,'onEdit':true,'onNodeMouseOver':true,'onNodeMouseOut':true,'onEdgeMouseOver':true,'onEdgeMouseOut':true,'onFinish':true,'onRemove':true,'onTileLoaded':true,'onTileLoadedURL':true};function setHandler(obj,eventName,handler){var func=function func(subObjectId,a,attr){var pObj=gmxAPI.mapNodes[subObjectId]?gmxAPI.mapNodes[subObjectId]:new gmxAPI._FMO(subObjectId,{},obj);// если MapObject отсутствует создаем
    if(_typeof(a)==='object'){pObj.properties=gmxAPI.isArray(a)?gmxAPI.propertiesFromArray(a):a;}if('filters'in pObj)attr.layer=pObj.layer=pObj;else if(pObj.parent&&'filters'in pObj.parent)attr.layer=pObj.layer=pObj.parent;else if(pObj.parent&&pObj.parent.parent&&'filters'in pObj.parent.parent){attr.filter=pObj.filter=pObj.parent;attr.layer=pObj.layer=pObj.parent.parent;}if(!attr.latlng&&'mouseX'in attr){attr.latlng={'lng':gmxAPI.from_merc_x(attr.mouseX),'lat':gmxAPI.from_merc_y(attr.mouseY)};}var flag=false;if(obj.handlers[eventName])flag=handler(pObj,attr);if(!flag)flag=gmxAPI._listeners.dispatchEvent(eventName,obj,{'obj':pObj,'attr':attr});return flag;};var callback=handler?func:null;if(callback||!obj.stateListeners[eventName]){// Если есть callback или нет Listeners на обьекте
    gmxAPI._cmdProxy('setHandler',{'obj':obj,'attr':{'eventName':eventName,'callbackName':callback}});}}// Begin: Блок Listeners
    var stateListeners={};// Глобальные события
    function getArr(eventName,obj){var arr=obj?'stateListeners'in obj&&eventName in obj.stateListeners?obj.stateListeners[eventName]:[]:eventName in stateListeners?stateListeners[eventName]:[];return arr;//return arr.sort(function(a, b) {return (b['level'] > a['level'] ? 1 : -1);});
    }// Обработка пользовательских Listeners на obj
    function dispatchEvent(eventName,obj,attr){var out=false;var arr=getArr(eventName,obj);for(var i=0;i<arr.length;i++)// Вызываем по убыванию 'level'
    {if(typeof arr[i].func==='function'){if(window.gmxAPIdebugLevel===11){out=arr[i].func(attr);if(out)break;// если callback возвращает true заканчиваем цепочку вызова
    }else{try{out=arr[i].func(attr);if(out)break;// если callback возвращает true заканчиваем цепочку вызова
    }catch(e){gmxAPI.addDebugWarnings({'func':'dispatchEvent','handler':eventName,'event':e,'alert':e});}}}}return out;}/** Пользовательские Listeners изменений состояния карты
    	* @function addListener
    	* @memberOf api - добавление прослушивателя
    	* @param {eventName} название события
    	* @param {func} вызываемый метод
    	* @param {pID} Listener унаследован от родительского обьекта
    	* @return {id} присвоенный id прослушивателя
    	* @see <a href="http://mapstest.kosmosnimki.ru/api/ex_locationTitleDiv.html">» Пример использования</a>.
    	* @author <a href="mailto:saleks@scanex.ru">Sergey Alexseev</a>
    	*/function addListener(ph){var eventName=ph['eventName'];var pID=ph['pID'];if(pID&&!flashEvents[eventName])return false;// Если есть наследование от родительского Listener и событие не передается в SWF то выходим
    var obj=ph['obj'];var func=ph['func'];var level=ph['level']||0;var arr=getArr(eventName,obj);var id=ph['evID']?ph['evID']:gmxAPI.newFlashMapId();var pt={"id":id,"func":func,"level":level};if(pID)pt['pID']=pID;arr.push(pt);arr=arr.sort(function(a,b){return b['level']>a['level']?1:-1;});if(obj){// Это Listener на mapObject
    obj.stateListeners[eventName]=arr;if('setHandler'in obj&&flashEvents[eventName]&&(!obj.handlers||!obj.handlers[eventName])){obj.setHandler(eventName,function(){});delete obj.handlers[eventName];// для установленных через addListener событий убираем handler
    }}else{// Это глобальный Listener
    stateListeners[eventName]=arr;}return id;}/** Пользовательские Listeners изменений состояния карты
    	* @function removeListener
    	* @memberOf api - удаление прослушивателя
    	* @param {eventName} название события
    	* @param {id} вызываемый метод
    	* @return {Bool} true - удален false - не найден
    	* @see <a href="http://mapstest.kosmosnimki.ru/api/ex_locationTitleDiv.html">» Пример использования</a>.
    	* @author <a href="mailto:saleks@scanex.ru">Sergey Alexseev</a>
    	*/function removeListener(obj,eventName,id){var arr=getArr(eventName,obj);var out=[];for(var i=0;i<arr.length;i++){if(id&&id!=arr[i]["id"]&&id!=arr[i]["pID"])out.push(arr[i]);}if(obj){obj.stateListeners[eventName]=out;if('removeHandler'in obj&&(!obj.handlers||!obj.handlers[eventName])&&out.length==0)obj.removeHandler(eventName);}else stateListeners[eventName]=out;return true;}gmxAPI._listeners={'dispatchEvent':dispatchEvent,'addListener':addListener,'removeListener':removeListener};// End: Блок Listeners
    var InitHandlersFunc=function InitHandlersFunc(){gmxAPI.extendFMO('setHandler',function(eventName,handler){setHandler(this,eventName,handler);this.handlers[eventName]=true;// true если установлено через setHandler
    flashEvents[eventName]=true;});gmxAPI.extendFMO('removeHandler',function(eventName){if(!(eventName in this.stateListeners)||this.stateListeners[eventName].length==0){// Если нет Listeners на обьекте
    gmxAPI._cmdProxy('removeHandler',{'obj':this,'attr':{'eventName':eventName}});}delete this.handlers[eventName];});gmxAPI.extendFMO('setHandlers',function(handlers){for(var key in handlers){this.setHandler(key,handlers[key]);}});gmxAPI.extendFMO('addListener',function(eventName,func,level){var ph={'obj':this,'eventName':eventName,'func':func,'level':level};return addListener(ph);});//gmxAPI.extendFMO('addListener', function(eventName, func, id) {	return addListener(this, eventName, func, id); });
    //gmxAPI.extendFMO('addMapStateListener', function(eventName, func, id) {	return addListener(this, eventName, func, id); });
    gmxAPI.extendFMO('removeListener',function(eventName,id){return removeListener(this,eventName,id);});gmxAPI.extendFMO('removeMapStateListener',function(eventName,id){return removeListener(this,eventName,id);});};var ret={'Init':InitHandlersFunc};//расширяем namespace
    gmxAPI._handlers=ret;})();!function(){//скопирована из API для обеспечения независимости от него
    function parseUri(str){var o=parseUri.options,m=o.parser[o.strictMode?"strict":"loose"].exec(str),uri={},i=14;while(i--){uri[o.key[i]]=m[i]||"";}uri[o.q.name]={};uri[o.key[12]].replace(o.q.parser,function($0,$1,$2){if($1)uri[o.q.name][$1]=$2;});uri.hostOnly=uri.host;uri.host=uri.authority;// HACK
    return uri;}parseUri.options={strictMode:false,key:["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"],q:{name:"queryKey",parser:/(?:^|&)([^&=]*)=?([^&]*)/g},parser:{strict:/^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,loose:/^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/}};var requests={};var lastRequestId=0;var processMessage=function processMessage(e){if(!(e.origin in requests)){return;}var dataStr=decodeURIComponent(e.data.replace(/\n/g,'\n\\'));try{var dataObj=JSON.parse(dataStr);}catch(e){request.callback&&request.callback({Status:"error",ErrorInfo:{ErrorMessage:"JSON.parse exeption",ExceptionType:"JSON.parse",StackTrace:dataStr}});}var request=requests[e.origin][dataObj.CallbackName];if(!request)return;// message от других запросов
    delete request[dataObj.CallbackName];delete dataObj.CallbackName;if(request.iframe.parentNode)request.iframe.parentNode.removeChild(request.iframe);request.callback&&request.callback(dataObj);};gmxAPI.domEventUtil.addHandler(window,'message',processMessage);function createPostIframe2(id,callback,url){var uniqueId='gmxAPI_id'+lastRequestId++;iframe=document.createElement("iframe");iframe.style.display='none';iframe.setAttribute('id',id);iframe.setAttribute('name',id);iframe.src='javascript:true';iframe.callbackName=uniqueId;//iframe.onload = window[callbackName];
    var parsedURL=parseUri(url);var origin=(parsedURL.protocol?parsedURL.protocol+':':window.location.protocol)+'//'+(parsedURL.host||window.location.host);requests[origin]=requests[origin]||{};requests[origin][uniqueId]={callback:callback,iframe:iframe};return iframe;}//расширяем namespace
    gmxAPI.createPostIframe2=createPostIframe2;}();// кроссдоменный POST запрос
    (function(){/** Посылает кроссдоменный POST запрос
    	* @namespace utilities
        * @ignore
    	* @function
    	* 
    	* @param url {string} - URL запроса
    	* @param params {object} - хэш параметров-запросов
    	* @param callback {function} - callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные
    	* @param baseForm {DOMElement} - базовая форма запроса. Используется, когда нужно отправить на сервер файл. 
    	*                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.
    	*/function sendCrossDomainPostRequest(url,params,callback,baseForm){var form,id='$$iframe_'+gmxAPI.newFlashMapId();var iframe=gmxAPI.createPostIframe2(id,callback,url),originalFormAction;if(baseForm){form=baseForm;originalFormAction=form.getAttribute('action');form.setAttribute('action',url);form.target=id;}else{if(gmxAPI.isIElt9){var str='<form id='+id+'" enctype="multipart/form-data" style="display:none" target="'+id+'" action="'+url+'" method="post"></form>';form=document.createElement(str);}else{form=document.createElement("form");form.style.display='none';form.setAttribute('enctype','multipart/form-data');form.target=id;form.setAttribute('method','POST');form.setAttribute('action',url);form.id=id;}}var hiddenParamsDiv=document.createElement("div");hiddenParamsDiv.style.display='none';if(params.WrapStyle==='window'){params.WrapStyle='message';}if(params.WrapStyle==='message'){params.CallbackName=iframe.callbackName;}for(var paramName in params){var input=document.createElement("input");var value=typeof params[paramName]!=='undefined'?params[paramName]:'';input.setAttribute('type','hidden');input.setAttribute('name',paramName);input.setAttribute('value',value);hiddenParamsDiv.appendChild(input);}form.appendChild(hiddenParamsDiv);if(!baseForm)document.body.appendChild(form);document.body.appendChild(iframe);form.submit();if(baseForm){form.removeChild(hiddenParamsDiv);if(originalFormAction!==null)form.setAttribute('action',originalFormAction);else form.removeAttribute('action');}else{form.parentNode.removeChild(form);}}//расширяем namespace
    gmxAPI.sendCrossDomainPostRequest=sendCrossDomainPostRequest;})();////
    var flashMapAlreadyLoading=false;function sendCrossDomainJSONRequest$1(url,callback,callbackParamName,callbackError){callbackParamName=callbackParamName||'CallbackName';var script=document.createElement("script");script.setAttribute("charset","UTF-8");var callbackName=gmxAPI.uniqueGlobalName(function(obj){callback&&callback(obj);window[callbackName]=false;document.getElementsByTagName("head").item(0).removeChild(script);});var sepSym=url.indexOf('?')==-1?'?':'&';script.setAttribute("src",url+sepSym+callbackParamName+"="+callbackName+"&"+Math.random());if(callbackError)script.onerror=function(e){callbackError(e);};document.getElementsByTagName("head").item(0).appendChild(script);}gmxAPI.sendCrossDomainJSONRequest=sendCrossDomainJSONRequest$1;function isRequiredAPIKey(hostName){if(!hostName)hostName='';if(hostName.indexOf("maps.kosmosnimki.ru")!=-1)return true;if(!window.apikeySendHosts)return false;for(var k=0;k<window.apikeySendHosts.length;k++){if(hostName.indexOf(window.apikeySendHosts[k])!=-1)return true;}return false;}gmxAPI.forEachNode=function(layers,callback,notVisible){var forEachNodeRec=function forEachNodeRec(o,isVisible,nodeDepth){isVisible=isVisible&&!!o.content.properties.visible;callback(o,isVisible,nodeDepth);if(o.type=="group"){var a=o.content.children;for(var k=a.length-1;k>=0;k--){forEachNodeRec(a[k],isVisible,nodeDepth+1);}}};for(var k=layers.children.length-1;k>=0;k--){forEachNodeRec(layers.children[k],!notVisible,0);}};function forEachLayer(layers,callback,notVisible){gmxAPI.forEachNode(layers,function(node,isVisible,nodeDepth){node.type==='layer'&&callback(node.content,isVisible,nodeDepth);},notVisible);}gmxAPI.forEachLayer=forEachLayer;var APIKeyResponseCache={};var alertedAboutAPIKey=false;function loadMapJSON(hostName,mapName,callback,onError){if(typeof callback!=='function'){gmxAPI.addDebugWarnings({'hostName':hostName,'mapName':mapName,'alert':'loadMapJSON: bad callback function'});if(typeof onError==='function')onError();return false;}//if(window.apikeyRequestHost) hostName = window.apikeyRequestHost;
    if(hostName.indexOf("http://")==0)hostName=hostName.slice(7);if(hostName.charAt(hostName.length-1)=='/')hostName=hostName.slice(0,-1);//относительный путь в загружаемой карте
    if(hostName.charAt(0)=='/')hostName=getAPIHost()+hostName;var configFlag=false;if(!gmxAPI.getScriptURL("config.js")){gmxAPI.loadVariableFromScript(gmxAPI.getAPIFolderRoot()+"config.js","apiKey",function(key){configFlag=true;},function(){configFlag=true;}// Нет config.js
    );}else{configFlag=true;}if(flashMapAlreadyLoading||!configFlag){setTimeout(function(){loadMapJSON(hostName,mapName,callback,onError);},200);return;}var alertAboutAPIKey=function alertAboutAPIKey(message){if(!alertedAboutAPIKey){alert(message);alertedAboutAPIKey=true;}};flashMapAlreadyLoading=true;var finish=function finish(){var key=window.KOSMOSNIMKI_SESSION_KEY;if(key=="INVALID")key=false;sendCrossDomainJSONRequest$1("http://"+hostName+"/TileSender.ashx?ModeKey=map&MapName="+encodeURIComponent(mapName)+(key?"&key="+encodeURIComponent(key):"")+"&"+Math.random(),function(response){if(response&&response['Status']==='ok'&&response['Result']){var layers=response['Result'];if(layers){gmxAPI._tmpMaps[layers.properties.name]=layers;layers.properties.hostName=hostName;window.sessionKeyCache[mapName]=layers.properties.MapSessionKey;forEachLayer(layers,function(layer){layer.properties.mapName=layers.properties.name;layer.properties.hostName=hostName;//layer.mercGeometry = layer.geometry;
    //delete layer.geometry;
    //layer.mercGeometry = gmxAPI.clone(layer.geometry);
    //layer.geometry = gmxAPI.from_merc_geometry(layer.geometry);
    });}callback(layers);flashMapAlreadyLoading=false;}else{flashMapAlreadyLoading=false;if(onError)onError();else callback(layers);}},null,function(ev){var txt=gmxAPI.KOSMOSNIMKI_LOCALIZED("Сбой при получении карты!","Error in map request!");gmxAPI.addDebugWarnings({'func':'TileSender.ashx?ModeKey=map&MapName='+mapName,'handler':'sendCrossDomainJSONRequest','alert':txt});if(onError)onError();else callback(null);});};if(isRequiredAPIKey(hostName)){var haveNoAPIKey=function haveNoAPIKey(){alertAboutAPIKey(gmxAPI.KOSMOSNIMKI_LOCALIZED("Не указан API-ключ!","API key not specified!"));window.KOSMOSNIMKI_SESSION_KEY="INVALID";finish();};var useAPIKey=function useAPIKey(key){var processResponse=function processResponse(response){if(response.Result.Status)window.KOSMOSNIMKI_SESSION_KEY=response.Result.Key;else{var txt=gmxAPI.KOSMOSNIMKI_LOCALIZED("Указан неверный API-ключ!","Incorrect API key specified!");gmxAPI.addDebugWarnings({'func':'useAPIKey','handler':'processResponse','alert':txt});//alertAboutAPIKey(gmxAPI.KOSMOSNIMKI_LOCALIZED("Указан неверный API-ключ!", "Incorrect API key specified!"));
    }finish();};if(APIKeyResponseCache[key])processResponse(APIKeyResponseCache[key]);else{var apikeyRequestHost=window.apikeyRequestHost?window.apikeyRequestHost:"maps.kosmosnimki.ru";//finish();
    //return;
    sendCrossDomainJSONRequest$1("http://"+apikeyRequestHost+"/ApiKey.ashx?WrapStyle=func&Key="+key,function(response){APIKeyResponseCache[key]=response;processResponse(response);},null,function(ev){var txt=gmxAPI.KOSMOSNIMKI_LOCALIZED("Сбой при получении API-ключа!","Error in API key request!");gmxAPI.addDebugWarnings({'func':'useAPIKey','handler':'sendCrossDomainJSONRequest','alert':txt});//alertAboutAPIKey(gmxAPI.KOSMOSNIMKI_LOCALIZED("Указан неверный API-ключ!", "Incorrect API key specified!"));
    finish();});}};var apiHost=gmxAPI.parseUri(window.location.href).hostOnly;if(apiHost=='')apiHost='localhost';var apiKeyResult=gmxAPI.getAPIKey();if(apiKeyResult)useAPIKey(apiKeyResult[1]);else if(window.apiKey)useAPIKey(window.apiKey);else if(apiHost=="localhost"||apiHost.match(/127\.\d+\.\d+\.\d+/))useAPIKey("localhost");else if(!gmxAPI.getScriptURL("config.js"))gmxAPI.loadVariableFromScript(gmxAPI.getAPIFolderRoot()+"config.js","apiKey",function(key){if(key)useAPIKey(key);else haveNoAPIKey();// Нет apiKey в config.js
    },function(){haveNoAPIKey();}// Нет config.js
    );else haveNoAPIKey();}else finish();}function createFlashMap(div,arg1,arg2,arg3){if(!arg2&&!arg3&&typeof arg1==='function')createKosmosnimkiMapInternal(div,false,arg1);else{var hostName,mapName,callback;if(arg3){hostName=arg1;mapName=arg2;callback=arg3;}else{hostName=getAPIHost();mapName=arg1;callback=arg2;}//hostName = 'maps.kosmosnimki.ru';
    var uri=gmxAPI.parseUri(hostName);if(uri.host)gmxAPI.serverBase=uri.host;// HostName основной карты переопределен
    gmxAPI.currentMapName=mapName;// текущая карта
    var loadStart=function loadStart(){// ID базовой карты подложек
    gmxAPI.kosmosnimki_API=gmxAPI.getBaseMapParam("id",gmxAPI.kosmosnimki_API);loadMapJSON(hostName,mapName,function(layers){if(layers!=null){gmxAPI.currentMapName=layers.properties.name;// Получили текущую карту
    window.KOSMOSNIMKI_LANGUAGE=window.KOSMOSNIMKI_LANGUAGE||{'eng':'English','rus':'Russian'}[layers.properties.DefaultLanguage];var UseKosmosnimkiAPI=gmxAPI.currentMapName===gmxAPI.kosmosnimki_API?false:layers.properties.UseKosmosnimkiAPI;(UseKosmosnimkiAPI?createKosmosnimkiMapInternal:createFlashMapInternal)(div,layers,callback);//createKosmosnimkiMapInternal(div, layers, callback);
    }else callback(null);});};if(!gmxAPI.getScriptURL("config.js")){gmxAPI.loadVariableFromScript(gmxAPI.getAPIFolderRoot()+"config.js","baseMap",loadStart,loadStart// Есть config.js
    );}else{loadStart();}}return true;}window.createKosmosnimkiMap=createFlashMap;window.makeFlashMap=createFlashMap;(function(){var flashId=gmxAPI.newFlashMapId();var FlashMapObject=function FlashMapObject(objectId_,properties_,parent_){this.objectId=objectId_;if(!properties_)properties_={};for(var key in properties_){if(properties_[key]=="null")properties_[key]="";}this.properties=properties_;this.parent=parent_;this.isRemoved=false;this.flashId=flashId;this._attr={};// Дополнительные атрибуты
    this.stateListeners={};// Пользовательские события
    this.handlers={};// Пользовательские события во Flash
    //this.maxRasterZoom = 1;		// Максимальный зум растровых слоев
    this.childsID={};// Хэш ID потомков
    };// расширение FlashMapObject
    gmxAPI.extendFMO=function(name,func){FlashMapObject.prototype[name]=func;};gmxAPI._FMO=FlashMapObject;// Для MapObject
    FlashMapObject.prototype.bringToTop=function(){return gmxAPI._cmdProxy('bringToTop',{'obj':this});};FlashMapObject.prototype.bringToBottom=function(){return gmxAPI._cmdProxy('bringToBottom',{'obj':this});};FlashMapObject.prototype.bringToDepth=function(n){return gmxAPI._cmdProxy('bringToDepth',{'obj':this,'attr':{'zIndex':n}});};FlashMapObject.prototype.setDepth=FlashMapObject.prototype.bringToDepth;FlashMapObject.prototype.startDrawing=function(type){gmxAPI._cmdProxy('startDrawing',{'obj':this,'attr':{'type':type}});};FlashMapObject.prototype.stopDrawing=function(type){gmxAPI._cmdProxy('stopDrawing',{'obj':this});};FlashMapObject.prototype.isDrawing=function(){return gmxAPI._cmdProxy('isDrawing',{'obj':this});};FlashMapObject.prototype.setLabel=function(label){gmxAPI._cmdProxy('setLabel',{'obj':this,'attr':{'label':label}});};FlashMapObject.prototype.setStyle=function(style,activeStyle){var attr={'regularStyle':style,'hoveredStyle':activeStyle};gmxAPI._cmdProxy('setStyle',{'obj':this,'attr':attr});gmxAPI._listeners.dispatchEvent('onSetStyle',this,attr);};FlashMapObject.prototype.getStyle=function(removeDefaults){var flag=typeof removeDefaults=='undefined'?false:removeDefaults;return gmxAPI._cmdProxy('getStyle',{'obj':this,'attr':flag});};FlashMapObject.prototype.getVisibleStyle=function(){return gmxAPI._cmdProxy('getVisibleStyle',{'obj':this});};FlashMapObject.prototype.getVisibility=function(){var val=true;if('isVisible'in this){var currPos=gmxAPI.currPosition||gmxAPI.map.getPosition();var curZ=currPos['z'];if(this.minZoom&&this.minZoom>curZ)val=false;else if(this.maxZoom&&this.maxZoom<curZ)val=false;else val=this.isVisible;if(val&&this.parent)val=this.parent.getVisibility();}else{val=gmxAPI._cmdProxy('getVisibility',{'obj':this});}return val;};FlashMapObject.prototype.setVisible=function(flag,notDispatch){gmxAPI._cmdProxy('setVisible',{'obj':this,'attr':flag,'notView':notDispatch});var val=flag?true:false;if(val&&'backgroundColor'in this&&this!=gmxAPI.map.miniMap)gmxAPI.map.setBackgroundColor(this.backgroundColor);var prev=this.isVisible;this.isVisible=val;if(prev!=val&&!notDispatch)gmxAPI._listeners.dispatchEvent('onChangeVisible',this,val);// Вызов Listeners события 'onChangeVisible'
    if(this.copyright&&'updateCopyright'in gmxAPI.map)gmxAPI.map.updateCopyright();};FlashMapObject.prototype.getChildren=function(){var arr=gmxAPI._cmdProxy('getChildren',{'obj':this});var ret=[];for(var i=0;i<arr.length;i++){var id=arr[i].id;var pObj=gmxAPI.mapNodes[id]?gmxAPI.mapNodes[id]:new FlashMapObject(id,{},this);// если MapObject отсутствует создаем
    //pObj.properties = gmxAPI.propertiesFromArray(arr[i].properties);
    var a=arr[i].properties;//if(typeof(a) === 'object') pObj.properties = ('sort' in a ? gmxAPI.propertiesFromArray(a) : a);
    if(_typeof(a)==='object'){pObj.properties=gmxAPI.isArray(a)?gmxAPI.propertiesFromArray(a):a;}ret.push(pObj);}return ret;};if(gmxAPI._handlers)gmxAPI._handlers.Init();// Инициализация handlers
    FlashMapObject.prototype.addObjectsFromSWF=function(url){gmxAPI._cmdProxy('addObjectsFromSWF',{'obj':this,'attr':{'url':url}});// Отправить команду в SWF
    };/** Добавление набора статических объектов на карту
    * @function
    * @ignore
    * @memberOf api
    * @param {array} data массив добавляемых обьектов
    * @return {array} массив добавленных обьектов
    * @author <a href="mailto:saleks@scanex.ru">Sergey Alexseev</a>
    */FlashMapObject.prototype.addObjects=function(data,format){return gmxAPI._cmdProxy('addObjects',{'obj':this,'attr':{'arr':data,'format':format}});// Отправить команду в SWF
    };FlashMapObject.prototype.addObject=function(geometry,props,propHiden){var objID=gmxAPI._cmdProxy('addObject',{'obj':this,'attr':{'geometry':geometry,'properties':props,'propHiden':propHiden}});if(!objID)objID=false;var pObj=new FlashMapObject(objID,props,this);// обычный MapObject
    // пополнение mapNodes
    var currID=pObj.objectId?pObj.objectId:gmxAPI.newFlashMapId()+'_gen1';gmxAPI.mapNodes[currID]=pObj;if(pObj.parent){pObj.parent.childsID[currID]=true;if(pObj.parent.isMiniMap){pObj.isMiniMap=true;// Все добавляемые к миникарте ноды имеют этот признак
    }}if(propHiden)pObj.propHiden=propHiden;pObj.isVisible=true;return pObj;};FlashMapObject.prototype.remove=function(){if(this.isRemoved)return false;// Обьект уже был удален
    if(this.copyright&&'removeCopyrightedObject'in gmxAPI.map)gmxAPI.map.removeCopyrightedObject(this);if(this.objectId){gmxAPI._cmdProxy('remove',{'obj':this});// Удалять в SWF только если там есть обьект
    if(this.parent)delete this.parent.childsID[this.objectId];delete gmxAPI.mapNodes[this.objectId];}// чистка mapNodes
    for(id in this.childsID){gmxAPI.mapNodes[id].remove();delete gmxAPI.mapNodes[id];}if(this.properties){if(this.propHiden&&this.propHiden.isLayer){// Это слой
    gmxAPI._listeners.dispatchEvent('BeforeLayerRemove',this,this.properties.name);// Удаляется слой
    if('_clearLayer'in this)this._clearLayer(this.properties.name);gmxAPI._listeners.dispatchEvent('onLayerRemove',gmxAPI.map,this);// Удален слой
    }}this.isRemoved=true;};FlashMapObject.prototype.setGeometry=function(geometry){gmxAPI._cmdProxy('setGeometry',{'obj':this,'attr':geometry});};FlashMapObject.prototype.getGeometry=function(){var geom=gmxAPI._cmdProxy('getGeometry',{'obj':this});if(!geom)return null;return geom;};FlashMapObject.prototype.getLength=function(arg1,arg2,arg3,arg4){var out=0;if(arg1)out=gmxAPI.geoLength(arg1,arg2,arg3,arg4);else out=gmxAPI._cmdProxy('getLength',{'obj':this});return out;};FlashMapObject.prototype.getArea=function(arg){var out=0;if(arg)out=gmxAPI.geoArea(arg);else out=gmxAPI._cmdProxy('getArea',{'obj':this});return out;};FlashMapObject.prototype.getGeometryType=function(){return gmxAPI._cmdProxy('getGeometryType',{'obj':this});};FlashMapObject.prototype.setPoint=function(x,y){this.setGeometry({type:"POINT",coordinates:[x,y]});};FlashMapObject.prototype.setLine=function(coords){this.setGeometry({type:"LINESTRING",coordinates:coords});};FlashMapObject.prototype.setPolygon=function(coords){this.setGeometry({type:"POLYGON",coordinates:[coords]});};FlashMapObject.prototype.setRectangle=function(x1,y1,x2,y2){this.setPolygon([[x1,y1],[x1,y2],[x2,y2],[x2,y1]]);};FlashMapObject.prototype.setCircle=function(x,y,r){function v_fi(fi,a,b){return [-Math.cos(fi)*Math.sin(a)+Math.sin(fi)*Math.sin(b)*Math.cos(a),Math.cos(fi)*Math.cos(a)+Math.sin(fi)*Math.sin(b)*Math.sin(a),-Math.sin(fi)*Math.cos(b)];}var n=360;//кол-во точек
    var a=Math.PI*x/180;//долгота центра окружности в радианах
    var b=Math.PI*y/180;//широта центра окружности в радианах
    var R=6372795;// Радиус Земли
    //      6378137 - Некоторые источники дают такое число.
    var d=R*Math.sin(r/R);var Rd=R*Math.cos(r/R);var VR=[];VR[0]=Rd*Math.cos(b)*Math.cos(a);VR[1]=Rd*Math.cos(b)*Math.sin(a);VR[2]=Rd*Math.sin(b);var circle=[],coordinates=[],t1=0,t2=0;for(var fi=0;fi<2*Math.PI+0.000001;fi+=2*Math.PI/n){var v=v_fi(fi,a,b);for(var i=0;i<3;i++){circle[i]=VR[i]+d*v[i];}t1=180*Math.asin(circle[2]/R)/Math.PI;var r=Math.sqrt(circle[0]*circle[0]+circle[1]*circle[1]);t2=circle[1]<0?-180*Math.acos(circle[0]/r)/Math.PI:180*Math.acos(circle[0]/r)/Math.PI;if(t2<x-180)t2+=360;else if(t2>x+180)t2-=360;coordinates.push([t2,t1]);}if(coordinates.length>0&&(coordinates[0][0]!==t2||coordinates[0][1]!==t1)){coordinates.push(coordinates[0]);}this.setPolygon(coordinates);};FlashMapObject.prototype.clearBackgroundImage=function(){gmxAPI._cmdProxy('clearBackgroundImage',{'obj':this});};FlashMapObject.prototype.setImageExtent=function(attr){if(gmxAPI.proxyType==='flash')this.setStyle({fill:{color:0x000000,opacity:100}});if(attr.notSetPolygon){this.setPolygon([[attr.extent.minX,attr.extent.maxY],[attr.extent.maxX,attr.extent.maxY],[attr.extent.maxX,attr.extent.minY],[attr.extent.minX,attr.extent.minY],[attr.extent.minX,attr.extent.maxY]]);}gmxAPI._cmdProxy('setImageExtent',{'obj':this,'attr':attr});};FlashMapObject.prototype.setImageOverlay=function(url,x1,y1,flagGeo){this.setImageExtent({url:url,extent:{minX:x1,minY:y1,maxX:x1,maxY:y1},notSetPolygon:flagGeo||false});};FlashMapObject.prototype.setImageTransform=function(url,x1,y1,x2,y2,x3,y3,x4,y4,tx1,ty1,tx2,ty2,tx3,ty3,tx4,ty4){var styles=this.getStyle();if(!styles.regular)this.setStyle({fill:{color:0x000000,opacity:100}});var attr={};if(tx1){attr={'x1':tx1,'y1':ty1,'x2':tx2,'y2':ty2,'x3':tx3,'y3':ty3,'x4':tx4,'y4':ty4,'tx1':x1,'ty1':y1,'tx2':x2,'ty2':y2,'tx3':x3,'ty3':y3,'tx4':x4,'ty4':y4};}else{if(gmxAPI.proxyType==='flash')this.setPolygon([[x1,y1],[x2,y2],[x3,y3],[x4,y4],[x1,y1]]);attr={'x1':x1,'y1':y1,'x2':x2,'y2':y2,'x3':x3,'y3':y3,'x4':x4,'y4':y4};}attr['url']=url;gmxAPI._cmdProxy('setImage',{'obj':this,'attr':attr});};FlashMapObject.prototype.setImagePoints=function(attr){gmxAPI._cmdProxy('setImagePoints',{'obj':this,'attr':attr});};FlashMapObject.prototype.setImage=FlashMapObject.prototype.setImageTransform;FlashMapObject.prototype.getGeometrySummary=function(){var out='';var geom=this.getGeometry();var geomType=geom?geom.type:'';if(geom){if(geomType.indexOf("POINT")!=-1){var c=geom.coordinates;out="<b>"+gmxAPI.KOSMOSNIMKI_LOCALIZED("Координаты:","Coordinates:")+"</b> ";out+=gmxAPI.formatCoordinates(gmxAPI.merc_x(c[0]),gmxAPI.merc_y(c[1]));}else if(geomType.indexOf("LINESTRING")!=-1){out="<b>"+gmxAPI.KOSMOSNIMKI_LOCALIZED("Длина:","Length:")+"</b> ";out+=gmxAPI.prettifyDistance(this.getLength(geom));}else if(geomType.indexOf("POLYGON")!=-1){out="<b>"+gmxAPI.KOSMOSNIMKI_LOCALIZED("Площадь:","Area:")+"</b> ";//var area = this.getArea();
    var area=this.getArea(geom);out+=gmxAPI.prettifyArea(area);}}return out;};FlashMapObject.prototype.getCenter=function(arg1,arg2,arg3,arg4){var out=0;if(arg1)out=gmxAPI.geoCenter(arg1,arg2,arg3,arg4);else out=gmxAPI._cmdProxy('getCenter',{'obj':this});return out;};FlashMapObject.prototype.setToolImage=function(imageName,activeImageName){var apiBase=gmxAPI.getAPIFolderRoot();this.setStyle({marker:{image:apiBase+"img/"+imageName}},activeImageName?{marker:{image:apiBase+"img/"+activeImageName}}:null);};// Для Filter
    FlashMapObject.prototype.flip=function(){return gmxAPI._cmdProxy('flip',{'obj':this});};FlashMapObject.prototype.setFilter=function(sql){var ret=false;if(this.parent&&'filters'in this.parent){if(!sql)sql='';this._sql=sql;// атрибуты фильтра установленные юзером
    ret=gmxAPI._cmdProxy('setFilter',{'obj':this,'attr':{'sql':sql}});if(!this.clusters&&'_Clusters'in gmxAPI){this.clusters=new gmxAPI._Clusters(this);// атрибуты кластеризации потомков по фильтру
    }if(this.clusters&&this.clusters.attr){this.setClusters(this.clusters.attr);}}else{return this.setVisibilityFilter(sql);}return ret;};FlashMapObject.prototype.setVisibilityFilter=function(sql){if(!sql)sql='';this._sqlVisibility=sql;// атрибуты фильтра видимости mapObject установленные юзером
    var ret=gmxAPI._cmdProxy('setVisibilityFilter',{'obj':this,'attr':{'sql':sql}});return ret;};// Для minimap
    FlashMapObject.prototype.positionWindow=function(x1,y1,x2,y2){gmxAPI._cmdProxy('positionWindow',{'obj':this,'attr':{'x1':x1,'y1':y1,'x2':x2,'y2':y2}});};// Возможно только для Layer
    FlashMapObject.prototype.getIntermediateLength=function(){return gmxAPI._cmdProxy('getIntermediateLength',{'obj':this});};FlashMapObject.prototype.getCurrentEdgeLength=function(){return gmxAPI._cmdProxy('getCurrentEdgeLength',{'obj':this});};FlashMapObject.prototype.setEditable=function(){gmxAPI._cmdProxy('setEditable',{'obj':this});};FlashMapObject.prototype.setTileCaching=function(flag){gmxAPI._cmdProxy('setTileCaching',{'obj':this,'attr':{'flag':flag}});};FlashMapObject.prototype.setDisplacement=function(dx,dy){gmxAPI._cmdProxy('setDisplacement',{'obj':this,'attr':{'dx':dx,'dy':dy}});};FlashMapObject.prototype.setBackgroundTiles=function(imageUrlFunction,projectionCode,minZoom,maxZoom,minZoomView,maxZoomView,attr){var ph={'func':imageUrlFunction,'projectionCode':projectionCode,'minZoom':minZoom,'maxZoom':maxZoom,'minZoomView':minZoomView,'maxZoomView':maxZoomView};if(attr){if('subType'in attr)ph['subType']=attr['subType'];}if(!('setPositionOffset'in this)){this.setPositionOffset=function(dx,dy){gmxAPI._cmdProxy('setPositionOffset',{'obj':this,'attr':{deltaX:dx,deltaY:dy}});};}gmxAPI._cmdProxy('setBackgroundTiles',{'obj':this,'attr':ph});gmxAPI._listeners.dispatchEvent('onLayerAdd',gmxAPI.map,this);// Добавлен слой
    };FlashMapObject.prototype.setTiles=FlashMapObject.prototype.setBackgroundTiles;FlashMapObject.prototype.setActive=function(flag){gmxAPI._cmdProxy('setActive',{'obj':this,'attr':{'flag':flag}});};FlashMapObject.prototype.setVectorTiles=function(dataUrlFunction,cacheFieldName,dataTiles,filesHash){var ph={'tileFunction':dataUrlFunction,'cacheFieldName':cacheFieldName,'filesHash':filesHash,'dataTiles':dataTiles};if(this.properties&&this.properties['tilesVers'])ph['tilesVers']=this.properties['tilesVers'];gmxAPI._cmdProxy('setVectorTiles',{'obj':this,'attr':ph});};// Для Layer
    FlashMapObject.prototype.getDepth=function(attr){return gmxAPI._cmdProxy('getDepth',{'obj':this});};FlashMapObject.prototype.getZoomBounds=function(){return gmxAPI._cmdProxy('getZoomBounds',{'obj':this});};FlashMapObject.prototype.setZoomBounds=function(minZoom,maxZoom){this.minZoom=minZoom;this.maxZoom=maxZoom;return gmxAPI._cmdProxy('setZoomBounds',{'obj':this,'attr':{'minZ':minZoom,'maxZ':maxZoom}});};FlashMapObject.prototype.setCopyright=function(copyright,z1,z2,geo){if('addCopyrightedObject'in gmxAPI.map){this.copyright=copyright;gmxAPI.map.addCopyrightedObject(this,copyright,z1,z2,geo);}};FlashMapObject.prototype.setBackgroundColor=function(color){this.backgroundColor=color;gmxAPI._cmdProxy('setBackgroundColor',{'obj':this,'attr':color});};FlashMapObject.prototype.addOSM=function(){var osm=this.addObject();osm.setOSMTiles();return osm;};// keepGeometry - если не указан или false, объект будет превращён в полигон размером во весь мир (показывать OSM везде), 
    //                иначе геометрия не будет изменяться (например, чтобы делать вклейки из OSM в другие тайлы)
    FlashMapObject.prototype.setOSMTiles=function(keepGeometry){if(!keepGeometry)this.setPolygon([-180,-85,-180,85,180,85,180,-85,-180,-85]);var func=window.OSMTileFunction?window.OSMTileFunction:function(i,j,z){//return "http://b.tile.openstreetmap.org/" + z + "/" + i + "/" + j + ".png";
    var letter=["a","b","c","d"][((i+j)%4+4)%4];//return "http://" + letter + ".tile.osmosnimki.ru/kosmo" + gmxAPI.KOSMOSNIMKI_LOCALIZED("", "-en") + "/" + z + "/" + i + "/" + j + ".png";
    //return "http://" + letter + ".tile.osm.kosmosnimki.ru/kosmo" + gmxAPI.KOSMOSNIMKI_LOCALIZED("", "-en") + "/" + z + "/" + i + "/" + j + ".png";
    return "http://"+letter+".tile.osm.kosmosnimki.ru/kosmo"+gmxAPI.KOSMOSNIMKI_LOCALIZED("","-en")+"/"+z+"/"+i+"/"+j+".png";};var urlOSM="http://{s}.tile.osmosnimki.ru/kosmo"+gmxAPI.KOSMOSNIMKI_LOCALIZED("","-en")+"/{z}/{x}/{y}.png";this._subdomains='abcd';this._urlOSM=urlOSM;if(gmxAPI.proxyType==='leaflet'&&window.OSMhash){// Это leaflet версия
    this._subdomains=window.OSMhash.subdomains;this._urlOSM=window.OSMhash.urlOSM;}this.setBackgroundTiles(function(i,j,z){var size=Math.pow(2,z-1);return func(i+size,size-j-1,z);},1);this.setCopyright(gmxAPI.KOSMOSNIMKI_LOCALIZED("&copy; участники OpenStreetMap","&copy; OpenStreetMap contributers")+", <a href='http://www.opendatacommons.org/licenses/odbl/'>ODbL</a>");this.setBackgroundColor(0xffffff);this.setTileCaching(false);};/* не используется
    FlashMapObject.prototype.loadJSON = function(url)
    {
    	flashDiv.loadJSON(this.objectId, url);
    }
    */ // Будут внешние
    FlashMapObject.prototype.loadGML=function(url,func){var me=this;var _hostname=gmxAPI.getAPIHostRoot()+"ApiSave.ashx?get="+encodeURIComponent(url);sendCrossDomainJSONRequest$1(_hostname,function(response){if(_typeof(response)!='object'||response['Status']!='ok'){gmxAPI.addDebugWarnings({'_hostname':_hostname,'url':url,'Error':'bad response'});return;}var geometries=gmxAPI.parseGML(response['Result']);for(var i=0;i<geometries.length;i++){me.addObject(geometries[i],null);}if(func)func();});};FlashMapObject.prototype.loadWFS=FlashMapObject.prototype.loadGML;/** Заружает WMS слои как подъобъекты данного объекта. Слои добавляются невидимыми
    	@param url {string} - URL WMS сервера
    	@param func {function} - ф-ция, которая будет вызвана когда WMS слои добавятся на карту.
    */FlashMapObject.prototype.loadWMS=function(url,func){gmxAPI._loadWMS(gmxAPI.map,this,url,func);};FlashMapObject.prototype.loadMap=function(arg1,arg2,arg3){var hostName=gmxAPI.map.defaultHostName;var mapName=null;var callback=null;if(arg3){hostName=arg1;mapName=arg2;callback=arg3;}else if(arg2){if(typeof arg2=='function'){mapName=arg1;callback=arg2;}else{hostName=arg1;mapName=arg2;}}else mapName=arg1;var me=this;loadMapJSON(hostName,mapName,function(layers){me.addLayers(layers,true);if(callback)callback(layers);});};function createFlashMapInternal(div,layers,callback){//var prop = layers.properties;
    // if(prop && prop.name) {
    //gmxAPI._tmpMaps[prop.name] = layers;
    // if(prop && gmxAPI.currentMapName !== gmxAPI.kosmosnimki_API && prop.name == gmxAPI.kosmosnimki_API) {
    // if (prop.OnLoad)		//  Обработка маплета базовой карты
    // {
    // try { eval("_kosmosnimki_temp=(" + prop.OnLoad + ")")(); }
    // catch (e) {
    // gmxAPI.addDebugWarnings({'func': 'createKosmosnimkiMapInternal', 'handler': 'маплет карты', 'event': e, 'alert': 'Error in "'+layers.properties.title+'" mapplet: ' + e});
    // }
    // }
    // }
    // }
    gmxAPI._div=div;// DOM элемент - контейнер карты
    if(div.style.position!="absolute")div.style.position="relative";history.navigationMode='compatible';var body=document.getElementsByTagName("body").item(0);if(body&&!body.onunload)body.onunload=function(){};if(!window.onunload)window.onunload=function(){};var apiBase=gmxAPI.getAPIFolderRoot();//var focusLink = document.createElement("a");
    //gmxAPI._dispatchEvent = gmxAPI._listeners.dispatchEvent;
    //addListener = gmxAPI._listeners.addListener;
    //removeListener = gmxAPI._listeners.removeListener;
    var loadCallback=function loadCallback(rootObjectId){var flashDiv=document.getElementById(flashId);if(!flashDiv||!gmxAPI.isProxyReady()){setTimeout(function(){loadCallback(rootObjectId);},100);return;}gmxAPI.flashDiv=flashDiv;flashDiv.style.MozUserSelect="none";var layers=gmxAPI._tmpMaps[gmxAPI.currentMapName];gmxAPI._baseLayersArr=null;gmxAPI._baseLayersHash={};// видимые ID подложек из описания текущей карты
    if(layers){var prop=layers.properties||{};var arr=prop.BaseLayers?JSON.parse(prop.BaseLayers):null;gmxAPI._baseLayersArr=gmxAPI.isArray(arr)?arr:null;if(gmxAPI._baseLayersArr){for(var i=0,len=gmxAPI._baseLayersArr.length;i<len;i++){var id=gmxAPI._baseLayersArr[i];gmxAPI._baseLayersHash[id]=true;}}}var baseMap=gmxAPI._tmpMaps[gmxAPI.kosmosnimki_API];var map=gmxAPI._addNewMap(rootObjectId,layers||baseMap,callback);if(baseMap){map.addLayers(baseMap,false,true);// добавление основной карты
    if(baseMap.properties.OnLoad)//  Обработка маплета базовой карты
    {var runStr="_kosmosnimki_temp=("+baseMap.properties.OnLoad+")";try{eval(runStr)(map);}catch(e){gmxAPI.addDebugWarnings({'func':'createKosmosnimkiMapInternal','handler':'маплет карты','event':e,'alert':'Error in "'+layers.properties.title+'" mapplet: '+e});}}//delete gmxAPI._tmpMaps[gmxAPI.kosmosnimki_API];
    }if(gmxAPI._baseLayersArr&&gmxAPI._baseLayersArr.length){map.needSetMode=gmxAPI._baseLayersArr[0];map.baseLayersManager.setActiveIDs(gmxAPI._baseLayersArr);}if(callback){try{callback(gmxAPI.map,layers);// Вызов createFlashMapInternal
    }catch(e){gmxAPI.addDebugWarnings({'func':'createFlashMapInternal','event':e,'alert':'Error in:\n "'+layers.properties.OnLoad+'"\n Error: '+e});}}// if('miniMap' in gmxAPI.map && !gmxAPI.miniMapAvailable) {
    // gmxAPI.map.miniMap.setVisible(true);
    // }
    var propsBalloon=gmxAPI.map.balloonClassObject?gmxAPI.map.balloonClassObject.propsBalloon:null;if(gmxAPI.proxyType==='flash'){// Это flash версия
    gmxAPI.map.controlsManager.initControls();var needToStopDragging=false;gmxAPI.flashDiv.onmouseout=function(ev){var event=gmxAPI.compatEvent(ev);if(!event||propsBalloon&&propsBalloon.leg==event.relatedTarget)return;if(!needToStopDragging){gmxAPI.map.setCursorVisible(false);needToStopDragging=true;}};gmxAPI.flashDiv.onmouseover=function(ev){var event=gmxAPI.compatEvent(ev);if(!event||propsBalloon&&propsBalloon.leg==event.relatedTarget)return;if(needToStopDragging){gmxAPI.map.stopDragging();gmxAPI.map.setCursorVisible(true);needToStopDragging=false;}};}if(layers&&layers.properties.name!==gmxAPI.kosmosnimki_API)// обработка массива видимых подложек
    {var prop=layers.properties;var baseLayersArr=gmxAPI.clone(gmxAPI._baseLayersArr||['map','satellite','hybrid']);if(!gmxAPI._baseLayersArr&&prop.UseOpenStreetMap){baseLayersArr=['OSM'];gmxAPI._baseLayersHash['OSM']=true;if(!map.needSetMode)map.needSetMode='OSM';}if(baseLayersArr){var baseLayersManager=map.baseLayersManager;for(var i=0,len=baseLayersArr.length;i<len;i++){var id=baseLayersArr[i];baseLayersManager.addActiveID(id,gmxAPI._baseLayersArr?i:null);}}if(prop.OnLoad){//  Обработка маплета карты - mapplet для базовой карты уже вызывали
    var runStr="_currentMap_temp=("+prop.OnLoad+")";try{eval(runStr)(map);}catch(e){gmxAPI.addDebugWarnings({'func':'addLayers','handler':'OnLoad','event':e,'alert':e+'\n---------------------------------'+'\n'+layers.properties.OnLoad});}}}if(map.needSetMode){var needSetMode=map.needSetMode;map.needSetMode=null;map.setMode(needSetMode);}};if('_addProxyObject'in gmxAPI){// Добавление обьекта отображения в DOM
    var o=gmxAPI._addProxyObject(gmxAPI.getAPIFolderRoot(),flashId,"100%","100%","10","#ffffff",loadCallback,window.gmxFlashLSO);if(o===''){var warnDiv=document.getElementById('noflash');if(warnDiv)warnDiv.style.display='block';}else{if(o.nodeName==='DIV'){gmxAPI._div.innerHTML='';gmxAPI._div.appendChild(o);//gmxAPI._div.appendChild(div);
    }else{o.write(div);}}}return true;}window.createFlashMapInternal=createFlashMapInternal;})();function createKosmosnimkiMapInternal(div,layers,callback){var prop=layers?layers.properties:{};var arr=prop.BaseLayers?JSON.parse(prop.BaseLayers):null;//var baseLayersArr = gmxAPI.isArray(arr) ? arr : ['map', 'satellite', 'hybrid', 'OSM'];
    var baseLayersArr=gmxAPI.isArray(arr)?arr:null;var getLayersArr=function getLayersArr(map,arr,color){var out=[];for(var i=0,len=arr.length;i<len;i++){if(arr[i]in map.layers){var layer=map.layers[arr[i]];layer.setBackgroundColor(color);out.push(layer);}}return out;};var finish=function finish(){var parseBaseMap=function parseBaseMap(kosmoLayers){createFlashMapInternal(div,kosmoLayers,function(map){// for (var i = 0; i < map.layers.length; i++) {
    // var obj = map.layers[i];
    // obj.setVisible(false);
    // }
    var mapLayerID=gmxAPI.getBaseMapParam("mapLayerID","");var satelliteLayerID=gmxAPI.getBaseMapParam("satelliteLayerID","");var overlayLayerID=gmxAPI.getBaseMapParam("overlayLayerID","");var osmEmbedID=gmxAPI.getBaseMapParam("osmEmbedID","");if(typeof osmEmbedID!='string')osmEmbedID="06666F91C6A2419594F41BDF2B80170F";var setOSMEmbed=function setOSMEmbed(layer){layer.enableTiledQuicklooksEx(function(o,image){image.setOSMTiles(true);//image.setCopyright("<a href='http://openstreetmap.org'>&copy; OpenStreetMap</a>, <a href='http://creativecommons.org/licenses/by-sa/2.0/'>CC-BY-SA</a>");
    image.setZoomBounds(parseInt(o.properties["text"]),18);},10,18);};var arr=overlayLayerID.split(",")||[];arr.forEach(function(item,i){var layer=map.layers[item];if(layer)layer.properties.type='Overlay';});var baseLayersManager=map.baseLayersManager,mapLayers=[],overlayLayers=[],satelliteLayers=[],baseLayersHash={},arr=['map','satellite','hybrid'];if(baseLayersArr){for(var i=0,len=baseLayersArr.length;i<len;i++){baseLayersHash[baseLayersArr[i]]=true;}}for(var i=0,len=arr.length;i<len;i++){var id=arr[i];baseLayersManager.remove(id);// нет подложки сформируем через getBaseMapParam 
    var attr={id:id,layers:[]};if(id==='satellite'&&satelliteLayerID){attr.rus='Снимки';attr.eng='Satellite';satelliteLayers=getLayersArr(map,satelliteLayerID.split(","),0x000001);attr.layers=satelliteLayers;if(!baseLayersArr)baseLayersManager.addActiveID(id,i);if(!map.needSetMode&&attr.layers.length&&(!baseLayersArr||baseLayersHash[id])){map.needSetMode=id;}}else if(id==='hybrid'&&(satelliteLayerID||overlayLayerID)){attr.rus='Гибрид';attr.eng='Hybrid';overlayLayers=getLayersArr(map,(satelliteLayerID+','+overlayLayerID).split(","),0x000001);attr.layers=overlayLayers;if(!baseLayersArr)baseLayersManager.addActiveID(id,i);if(!map.needSetMode&&attr.layers.length&&(!baseLayersArr||baseLayersHash[id])){map.needSetMode=id;}}else if(id==='map'&&mapLayerID){attr.rus='Карта';attr.eng='Map';mapLayers=getLayersArr(map,mapLayerID.split(","),0xffffff);attr.layers=mapLayers;var osmEmbed=map.layers[osmEmbedID];if(osmEmbed){attr.layers.push(osmEmbed);setOSMEmbed(osmEmbed);}if(!baseLayersArr)baseLayersManager.addActiveID(id,i);if(attr.layers.length&&(!baseLayersArr||baseLayersHash[id])){map.needSetMode=id;}}if(attr.layers.length){baseLayersManager.add(id,attr);}}/*
                    if(baseLayersArr) {
                        if(!baseLayersHash[map.needSetMode]) map.needSetMode = null;
                        for (var i = 0, len = baseLayersArr.length; i < len; i++) {
                            var id = baseLayersArr[i];
                            var baseLayer = baseLayersManager.get(id);
                            if(baseLayer) {
                                baseLayer.setVisible(true);
                                baseLayer.setIndex(i);
                            }
                        }
                    }
    */if(layers){map.defaultHostName=layers.properties.hostName;//map.addLayers(layers, false);		// добавление основной карты
    map.properties=layers.properties;if(map.properties.DistanceUnit){map.setDistanceUnit(map.properties.DistanceUnit);}if(map.properties.SquareUnit){map.setSquareUnit(map.properties.SquareUnit);}}/*  // Устарело
    				var mapLayers = [];
    				var mapLayerID = gmxAPI.getBaseMapParam("mapLayerID", "");
    				if(typeof(mapLayerID) == 'string') {
    					var mapLayerNames = mapLayerID.split(',');
    					var baseLayers = baseLayersManager.add('map', {rus:'Карта', eng:'Map', isVisible:true});
    					for (var i = 0; i < mapLayerNames.length; i++)
    						if (mapLayerNames[i] in map.layers)
    						{
    							var mapLayer = map.layers[mapLayerNames[i]];
    							mapLayer.setBackgroundColor(0xffffff);
                                baseLayers.addLayer(mapLayer);
    							mapLayers.push(mapLayer);
    						}
    				}
    				var satelliteLayers = [];
    				var satelliteLayerID = gmxAPI.getBaseMapParam("satelliteLayerID", "");
    				if(typeof(satelliteLayerID) == 'string') {
    					var satelliteLayerNames = satelliteLayerID.split(",");
    					
    					for (var i = 0; i < satelliteLayerNames.length; i++)
    						if (satelliteLayerNames[i] in map.layers)
    							satelliteLayers.push(map.layers[satelliteLayerNames[i]]);

    					var baseLayers = baseLayersManager.add('satellite', {rus:'Снимки', eng:'Satellite', isVisible:true});
    					for (var i = 0; i < satelliteLayers.length; i++)
    					{
    						satelliteLayers[i].setBackgroundColor(0x000001);
                            baseLayers.addLayer(satelliteLayers[i]);
    					}
    				}
    				
    				var isAnyExists = false;
    				var overlayLayers = [];
    				var overlayLayerID = gmxAPI.getBaseMapParam("overlayLayerID", "");
    				if(typeof(overlayLayerID) == 'string') {
    					var overlayLayerNames = overlayLayerID.split(',');
    					var baseLayers = baseLayersManager.add('hybrid', {rus:'Гибрид', eng:'Hybrid', isVisible:true, index:0 });
    					for (var i = 0; i < overlayLayerNames.length; i++)
    						if (overlayLayerNames[i] in map.layers)
    						{
    							isAnyExists = true;
    							var overlayLayer = map.layers[overlayLayerNames[i]];
    							overlayLayer.setBackgroundColor(0x000001);
                                baseLayers.addLayer(overlayLayer);
    							overlayLayers.push(overlayLayer);
    						}
    					
    					if (isAnyExists)
    					{
    						for (var i = 0; i < satelliteLayers.length; i++) {
    							satelliteLayers[i].setBackgroundColor(0x000001);
                                baseLayers.addLayer(satelliteLayers[i]);
    						}
    					}
    				}
    				
    				var setOSMEmbed = function(layer)
    				{
    					layer.enableTiledQuicklooksEx(function(o, image)
    					{
    						image.setOSMTiles(true);
    						//image.setCopyright("<a href='http://openstreetmap.org'>&copy; OpenStreetMap</a>, <a href='http://creativecommons.org/licenses/by-sa/2.0/'>CC-BY-SA</a>");
    						image.setZoomBounds(parseInt(o.properties["text"]), 18);
    					}, 10, 18);
    				}
    				
    				var osmEmbedID = gmxAPI.getBaseMapParam("osmEmbedID", "");
    				if(typeof(osmEmbedID) != 'string') osmEmbedID = "06666F91C6A2419594F41BDF2B80170F";
    				var osmEmbed = map.layers[osmEmbedID];
    				if (osmEmbed)
    				{
    					baseLayersManager.get('map').addLayer(osmEmbed);
    					setOSMEmbed(osmEmbed);
    				}
    */ /*
    				if('miniMap' in map) {
    					//map.miniMap.setVisible(true);
    					for (var m = 0; m < mapLayers.length; m++) {
    						map.miniMap.addLayer(mapLayers[m], true, true);
    					}
    					if (osmEmbed)
    					{
    						map.miniMap.addLayer(osmEmbed, null, true);
    						setOSMEmbed(map.miniMap.layers[osmEmbed.properties.name]);
    					}
    				}
    */if(!window.baseMap||!window.baseMap.hostName||window.baseMap.hostName=="maps.kosmosnimki.ru")map.geoSearchAPIRoot=typeof window.searchAddressHost!=='undefined'?window.searchAddressHost:"http://maps.kosmosnimki.ru/";/*
    				map.needSetMode = (mapLayers.length > 0 ? 'map' : 'satellite');
    				if (layers)
    				{
    					map.defaultHostName = layers.properties.hostName;
    					map.addLayers(layers, false);		// добавление основной карты
    					map.properties = layers.properties;
    					if (map.properties.DistanceUnit)
    					{
    						map.setDistanceUnit(map.properties.DistanceUnit);
    					}
    					if (map.properties.SquareUnit)
    					{
    						map.setSquareUnit(map.properties.SquareUnit);
    					}
    				}
    */if(gmxAPI.proxyType==='flash'&&map.needSetMode)map.setMode(map.needSetMode);// копирайты
    // var setCopyright = function(o, z1, z2, text)
    // {
    // var c = o.addObject();
    // c.setZoomBounds(z1, z2);
    // c.setCopyright(text);
    // return c;
    // }
    if(mapLayers.length>0){mapLayers[0].setCopyright("<a href='http://www.bartholomewmaps.com/'>&copy; Collins Bartholomew</a>",1,9);mapLayers[0].setCopyright("<a href='http://www.geocenter-consulting.ru/'>&copy; "+gmxAPI.KOSMOSNIMKI_LOCALIZED("ЗАО &laquo;Геоцентр-Консалтинг&raquo;","Geocentre Consulting")+"</a>",10,20,{type:"LINESTRING",coordinates:[29,40,180,80]});// setCopyright(mapLayers[0], 1, 9, "<a href='http://www.bartholomewmaps.com/'>&copy; Collins Bartholomew</a>");
    // var obj = setCopyright(mapLayers[0], 10, 20, "<a href='http://www.geocenter-consulting.ru/'>&copy; " + gmxAPI.KOSMOSNIMKI_LOCALIZED("ЗАО &laquo;Геоцентр-Консалтинг&raquo;", "Geocentre Consulting") + "</a>");
    // obj.geometry = { type: "LINESTRING", coordinates: [29, 40, 180, 80] };
    }//те же копирайты, что и для карт
    if(overlayLayers.length>0){//overlayLayers[0].setCopyright("<a href='http://www.bartholomewmaps.com/'>&copy; Collins Bartholomew</a>", 1, 9);
    overlayLayers[0].setCopyright("<a href='http://www.geocenter-consulting.ru/'>&copy; "+gmxAPI.KOSMOSNIMKI_LOCALIZED("ЗАО &laquo;Геоцентр-Консалтинг&raquo;","Geocentre Consulting")+"</a>",10,20,{type:"LINESTRING",coordinates:[29,40,180,80]});// setCopyright(overlayLayers[0], 1, 9, "<a href='http://www.bartholomewmaps.com/'>&copy; Collins Bartholomew</a>");
    // var obj = setCopyright(overlayLayers[0], 10, 20, "<a href='http://www.geocenter-consulting.ru/'>&copy; " + gmxAPI.KOSMOSNIMKI_LOCALIZED("ЗАО &laquo;Геоцентр-Консалтинг&raquo;", "Geocentre Consulting") + "</a>");
    // obj.geometry = { type: "LINESTRING", coordinates: [29, 40, 180, 80] };
    }if(satelliteLayers.length>0){satelliteLayers[0].setCopyright("<a href='http://www.nasa.gov'>&copy; NASA</a>",1,5);satelliteLayers[0].setCopyright("<a href='http://www.es-geo.com'>&copy; Earthstar Geographics</a>",6,13);satelliteLayers[0].setCopyright("<a href='http://www.antrix.gov.in/'>&copy; ANTRIX</a>",6,14,{type:"LINESTRING",coordinates:[9.9481201,18.265291,45.263671,61.305477]});satelliteLayers[0].setCopyright("<a href='http://www.geoeye.com'>&copy; GeoEye Inc.</a>",9,17);// setCopyright(satelliteLayers[0], 1, 5, "<a href='http://www.nasa.gov'>&copy; NASA</a>");
    // setCopyright(satelliteLayers[0], 6, 13,	"<a href='http://www.es-geo.com'>&copy; Earthstar Geographics</a>");
    // var obj = setCopyright(satelliteLayers[0], 6, 14, "<a href='http://www.antrix.gov.in/'>&copy; ANTRIX</a>");
    // obj.geometry = gmxAPI.from_merc_geometry({ type: "LINESTRING", coordinates: [1107542, 2054627, 5048513, 8649003] });
    // setCopyright(satelliteLayers[0], 9,	17,	"<a href='http://www.geoeye.com'>&copy; GeoEye Inc.</a>");
    }try{callback(map,layers);// Передача управления
    }catch(e){gmxAPI.addDebugWarnings({'func':'createKosmosnimkiMapInternal','event':e,'alert':'Ошибка в callback:\n'+e});}if(map.needMove){gmxAPI.currPosition=null;var x=map.needMove['x'];var y=map.needMove['y'];var z=map.needMove['z'];if(gmxAPI.proxyType==='flash')map.needMove=null;map.moveTo(x,y,z);}// if(map.needSetMode) {
    // var needSetMode = map.needSetMode;
    // map.needSetMode = null;
    // map.setMode(needSetMode);
    // }
    });};var getBaseMap=function getBaseMap(){var mapProp=_typeof(window.gmxNullMap)==='object'?window.gmxNullMap:null;if(mapProp){window.KOSMOSNIMKI_LANGUAGE=window.KOSMOSNIMKI_LANGUAGE||{'eng':'English','rus':'Russian'}[mapProp.properties.DefaultLanguage];createFlashMapInternal(div,mapProp,callback);}else{loadMapJSON(gmxAPI.getBaseMapParam("hostName","maps.kosmosnimki.ru"),gmxAPI.getBaseMapParam("id",gmxAPI.kosmosnimki_API),parseBaseMap,function(){createFlashMapInternal(div,layers,callback);});}};if(!gmxAPI.getScriptURL("config.js")){gmxAPI.loadVariableFromScript(gmxAPI.getAPIFolderRoot()+"config.js","gmxNullMap",getBaseMap,getBaseMap);}else getBaseMap();};if(!gmxAPI.getScriptURL("config.js")){gmxAPI.loadVariableFromScript(gmxAPI.getAPIFolderRoot()+"config.js","baseMap",finish,//errorConfig	// Нет config.js
    finish// Есть config.js
    );}else finish();}/* ======================================================================
        BaseLayersManager.js
       ====================================================================== */ /** Управление подложками

    Позволяет управлять списком подложек. 

    Подложка - массив слоев отображаемых в качестве подложки карты.

    @memberof map.baseLayersManager
    */(function(){var alias={};// варианты наименований подложек - для совместимости
    var manager={map:null// карта
    ,arr:[]// массив подложек
    ,hash:{}// список по ID всех подложек
    ,activeIDs:[]// массив ID подложек(в контролах появляется только при наличии в ID hash)
    ,currentID:null// ID текущей подложки
    ,addListener:function addListener(eventName,func){return gmxAPI._listeners.addListener({'obj':this,'eventName':eventName,'func':func});},removeListener:function removeListener(eventName,id){return gmxAPI._listeners.removeListener(this,eventName,id);},stateListeners:{},init:function init(map){// инициализация
    manager.map=map;gmxAPI.extendFMO('setAsBaseLayer',function(name,attr){this.isBaseLayer=true;var id=name;if(!attr){attr={//index: manager.arr.length
    };}else{id=attr.id?attr.id:name;if(attr.lang){attr.rus=attr.lang.ru?attr.lang.ru:id;attr.eng=attr.lang.en?attr.lang.en:id;}}attr.isVisible=true;var blID=manager.getIDByName(id)||id;var baseLayer=manager.hash[blID];this.setVisible(false);// слои подложек изначально не видимы
    var isActiveID=manager.isActiveID(blID);if(!baseLayer){baseLayer=manager.add(blID,attr);}baseLayer.addLayer(this);if(!isActiveID){manager.updateIndex({id:blID});}});gmxAPI.extend(manager.map,{setMode:function setMode(name){var id=manager.hash[name]?name:manager.getIDByName(name);manager.setCurrentID(id);},getModeID:function getModeID(){return manager.currentID;},setBaseLayer:function setBaseLayer(name){this.setMode(name);},unSetBaseLayer:function unSetBaseLayer(){manager.map.setBaseLayer();},getBaseLayer:function getBaseLayer(){return manager.currentID;},baseLayerControl:{isVisible:true,/**
                         * @deprecated Использовать контрол L.Control.gmxLayers
                         */setVisible:function setVisible(flag){var controls=map.controlsManager.getCurrent();if(!controls)return null;var control=controls.getControl('layers');return control.setVisible(flag);},/**
                         * @deprecated Использовать map.baseLayersManager.getActiveIDs()
                         */getBaseLayerNames:function getBaseLayerNames(){return manager.activeIDs;},/**
                         * @deprecated Использовать map.baseLayersManager.getLayers()
                         */getBaseLayerLayers:function getBaseLayerLayers(name){var baseLayer=manager.get(name);return baseLayer?baseLayer.layers:null;}}});this.addListener('onActiveChanged',function(arr){var flag=false;for(var i=0,len=arr.length;i<len;i++){if(manager.currentID===arr[i]){flag=true;break;}}var current=manager.hash[manager.currentID]||null;if(current){if(!flag)manager.currentID=null;for(var i=0,len=current.layers.length;i<len;i++){current.layers[i].setVisible(flag);}}// Поддержка устаревшего map.baseLayerControl.onChange 
    if('onChange'in manager.map.baseLayerControl)manager.map.baseLayerControl.onChange(manager.currentID);});},removeLayer:function removeLayer(id,layer){// Удаление слоя из подложки - возвращает удаленный слой либо null
    var baseLayer=manager.hash[id];if(!baseLayer||!layer)return null;for(var i=0,len=baseLayer.layers.length;i<len;i++){if(layer===baseLayer.layers[i]){if(len===1){//baseLayer.isVisible = false;
    gmxAPI._listeners.dispatchEvent('onLayerChange',manager.map.baseLayersManager,baseLayer);}return baseLayer.layers.splice(i,1)[0];}}return null;},add:function add(id,attr){// Добавление подложки
    if(!id||manager.hash[id])return null;if(!attr)attr={};// var isVisible = attr.isVisible; // видимость подложки - 3 состояния отражающие видимость в контролах (true - видимая, false - не видимая, undefined - видимость определяется по списку BaseLayers)
    // if(gmxAPI._baseLayersHash[id]) isVisible = true;
    var pt={id:id||'default'// id подложки
    ,layers:attr.layers||[]// массив слоев подложки
    ,rus:attr.rus||id// title подложки 
    ,eng:attr.eng||id,addLayer:function addLayer(layer){manager.removeLayer(id,layer);this.layers.push(layer);layer.isBaseLayer=true;layer.setVisible(false);if(!layer.backgroundColor)layer.backgroundColor=0xffffff;gmxAPI._listeners.dispatchEvent('onLayerChange',manager.map.baseLayersManager,this);return true;},removeLayer:function removeLayer(layer){manager.removeLayer(id,layer);gmxAPI._listeners.dispatchEvent('onLayerChange',manager.map.baseLayersManager,this);}};if(attr.rus)alias[attr.rus]=id;if(attr.eng)alias[attr.eng]=id;if(attr.style)pt.style=attr.style;// стиль для контролов
    if(attr.type)pt.type=attr.type;// тип подложки для контролов имеющих типы подложек
    pt.layers.forEach(function(item,i){item.isBaseLayer=true;item.setVisible(false);});manager.hash[id]=pt;manager.arr.push(pt);//manager.updateIndex(pt);
    gmxAPI._listeners.dispatchEvent('onAdd',manager.map.baseLayersManager,pt);return pt;},setActiveIDs:function setActiveIDs(arr){manager.activeIDs=arr;gmxAPI._listeners.dispatchEvent('onActiveChanged',manager.map.baseLayersManager,manager.activeIDs);return true;},_removeIDFromActive:function _removeIDFromActive(id){for(var i=0,len=manager.activeIDs.length;i<len;i++){if(id===manager.activeIDs[i]){manager.activeIDs.splice(i,1);break;}}},updateIndex:function updateIndex(attr){if(!attr.id)return null;var id=attr.id;manager._removeIDFromActive(id);var len=manager.activeIDs.length;var index='index'in attr&&attr.index!==undefined?attr.index:len;var out=-1;if(index>len-1){out=len;manager.activeIDs.push(id);}else{var arr=manager.activeIDs.slice(0,index);out=arr.length;arr.push(id);manager.activeIDs=arr.concat(manager.activeIDs.slice(index));}gmxAPI._listeners.dispatchEvent('onActiveChanged',manager.map.baseLayersManager,manager.activeIDs);return out;},getAll:function getAll(flag){// Получить список подложек
    return manager.arr;},get:function get(id){// Получить подложку по ID
    return manager.hash[id]||null;},setVisibleCurrentItem:function setVisibleCurrentItem(flag){var baseLayer=manager.hash[manager.currentID]||null;if(baseLayer){for(var i=0,len=baseLayer.layers.length;i<len;i++){var layer=baseLayer.layers[i];layer.setVisible(flag);}}return flag;},getIDByName:function getIDByName(name){return alias[name]||null;},isActiveID:function isActiveID(id){for(var i=0,len=manager.activeIDs.length;i<len;i++){if(id===manager.activeIDs[i]){return true;}}return false;},setCurrentID:function setCurrentID(id){// Установка текущей подложки карты
    var isActive=manager.isActiveID(id);var item=manager.hash[id]||null;//if(manager.currentID && (isActive || !item)) manager.setVisibleCurrentItem(false);
    if(manager.currentID)manager.setVisibleCurrentItem(false);manager.currentID=null;if(item){if(isActive){manager.map.needSetMode=null;manager.currentID=id;manager.setVisibleCurrentItem(true);}}gmxAPI._listeners.dispatchEvent('onSetCurrent',manager.map.baseLayersManager,item);return item;},remove:function remove(id){// Удалить подложку
    if(id===manager.currentID){manager.setVisibleCurrentItem(false);manager.currentID=null;}var item=manager.hash[id]||null;if(item){delete manager.hash[id];for(var i=0,len=manager.arr.length;i<len;i++){if(id===manager.arr[i].id){manager.arr.splice(i,1);break;}}gmxAPI._listeners.dispatchEvent('onRemove',manager.map.baseLayersManager,item);}return item;},toggleVisibility:function toggleVisibility(id){manager.setCurrentID(manager.currentID===id?null:id);}};/**
         * Обьект подложки.
         * @typedef {Object} BaseLayer
         * @property {String} id - Идентификатор подложки.
         * @property {Layer[]} layers - Массив слоев подложки.
         * @property {String} rus - Наименование русскоязычное.
         * @property {String} eng - Наименование англоязычное.
         * @property {function(layer:Layer)} addLayer - Ф-ция добавления слоя в подложку.
         * @property {function(layer:Layer)} removeLayer - Ф-ция удаления слоя из подложки.
         */ /**
            @name BaseLayer~addLayer
            @function
            @param {Layer} layer слой, который нужно добавить в подложку
         */ /**
         * Менеджер подложек (создаётся в API и доступен через свойство карты map.baseLayersManager).
         * @constructor BaseLayersManager
         */gmxAPI.BaseLayersManager=function(map){manager.init(map);return {/** Добавить подложку
                * @memberOf BaseLayersManager#
                * @param {String} id идентификатор подложки.
                * @param {object} attr дополнительные атрибуты подложки.
                * @param {String} attr.rus - наименование русскоязычное(по умолчанию равен id).
                * @param {String} attr.eng - наименование англоязычное(по умолчанию равен id).
                * @param {Layer[]} attr.layers - массив слоев подложки(по умолчанию []).
                * @returns {BaseLayer|null} возвращает обьект добавленной подложки или null если подложка с данным идентификатором уже существует.
                */add:function add(id,attr){return manager.add(id,attr);},/** Удалить подложку
                * @memberOf BaseLayersManager#
                * @param {String} id идентификатор подложки.
                * @returns {BaseLayer|null} возвращает удаленную подложку если она найдена.
                */remove:function remove(id){return manager.remove(id);},/** Получить подложку
                * @memberOf BaseLayersManager#
                * @param {String} id идентификатор подложки.
                * @returns {BaseLayer|null} возвращает подложку если существует иначе null).
                */get:function get(id){return manager.hash[id]||null;},/** Получить список всех подложек
                * @memberOf BaseLayersManager#
                * @returns {BaseLayer[]} возвращает массив всех подложек.
                */getAll:function getAll(){return manager.arr;},/** Получить массив ID активных подложек
                * @memberOf BaseLayersManager#
                * @returns {String[]} возвращает массив ID активных подложек(в порядке возрастания индексов).
                */getActiveIDs:function getActiveIDs(){return manager.activeIDs;},/** Установить массив ID активных подложек
                * @memberOf BaseLayersManager#
                * @param {String[]} массив ID активных подложек.
                */setActiveIDs:function setActiveIDs(arr){return manager.setActiveIDs(arr);},/** Добавить ID активной подложки
                * @memberOf BaseLayersManager#
                * @param {String} id идентификатор подложки.
                * @param {number} index порядковый номер в массиве активных подложек.
                */addActiveID:function addActiveID(id,index){return manager.updateIndex({id:id,index:index});},/** Проверить активность подложки
                * @memberOf BaseLayersManager#
                * @param {String} id идентификатор подложки.
                * @returns {boolean} возвращает true если подложка активна иначе false
                */isActiveID:function isActiveID(id){return manager.isActiveID(id);},/** Установить текущую подложку по идентификатору
                * @memberOf BaseLayersManager#
                * @param {String=} id идентификатор подложки, если подложка с заданным идентификатором отсутствует или не активна то текущая подложка равна null.
                * @returns {BaseLayer|null} возвращает текущую подложку, если она установлена
                */setCurrentID:function setCurrentID(id){return manager.setCurrentID(id);},/** Получить идентификатор текущей подложки
                * @memberOf BaseLayersManager#
                * @returns {String|null} возвращает идентификатор текущей подложки либо null.
                */getCurrentID:function getCurrentID(){return manager.currentID;},/** Получить идентификатор по наименованию подложки
                * @memberOf BaseLayersManager#
                * @returns {String|null} возвращает идентификатор подложки если заданное наименование подложки существует.
                */getIDByName:function getIDByName(name){return manager.getIDByName(name);},/** Добавить слой в подложку
                * @memberOf BaseLayersManager#
                * @param {String} id идентификатор подложки.
                * @param {Layer} layer обьект слоя.
                * @returns {boolean} возвращает false если подложка не найдена иначе true.
                */addLayer:function addLayer(id,layer){var baseLayer=this.get(id);if(!baseLayer)return false;baseLayer.addLayer(layer);//baseLayer.layers.push(layer);
    //gmxAPI._listeners.dispatchEvent('onAdd', this, baseLayer);
    return true;},/** Удалить слой из подложки
                * @memberOf BaseLayersManager#
                * @param {String} id идентификатор подложки.
                * @param {Layer} layer обьект слоя.
                */removeLayer:function removeLayer(id,layer){manager.removeLayer(id,layer);if(id===manager.currentID){layer.setVisible(false);}},/** Получить список слоев подложки
                * @memberOf BaseLayersManager#
                * @param {String} id идентификатор подложки.
                * @returns {Layer[]} возвращает массив слоев подложки.
                */getLayers:function getLayers(id){return manager.get(id).layers;},addListener:manager.addListener,removeListener:manager.removeListener,stateListeners:manager.stateListeners/** Добавлена подложка
             * @event BaseLayersManager#onAdd
             * @type {BaseLayer}
            */ /** Удалена подложка
             * @event BaseLayersManager#onRemove
             * @type {BaseLayer}
            */ /** Изменен список слоев в подложке
             * @event BaseLayersManager#onLayerChange
             * @type {BaseLayer}
            */ /** Установлена текущая подложка
             * @event BaseLayersManager#onSetCurrent
             * @type {BaseLayer}
            */ /** Изменен массив ID активных подложек
             * @event BaseLayersManager#onActiveChanged
             * @type {String[]}
            */};};})();/* ======================================================================
        ControlsManager.js
       ====================================================================== */ /** Управление наборами контролов карты

    Позволяет устанавливать пользовательские наборы контролов карты. 

    Набор контролов - список контролов карты.

    @global

    */(function(){var ControlsManager={isVisible:true,_controls:null,currentID:null//,currentControls: {}
    //,controls: []
    ,parentNode:null,allToolsNode:null,toolsAll:null,addListener:function addListener(eventName,func){return gmxAPI._listeners.addListener({'obj':this,'eventName':eventName,'func':func});},removeListener:function removeListener(eventName,id){return gmxAPI._listeners.removeListener(this,eventName,id);},stateListeners:{},init:function init(parent,map){if(parent)this.parentNode=parent;var allToolsNode=this.allToolsNode=gmxAPI._allToolsDIV=gmxAPI.newStyledDiv({position:"absolute",top:'0px',left:0,height:'1px',width:'100%'// ,marginLeft: '15px'
    // ,marginTop: '15px'
    });this.parentNode.appendChild(allToolsNode);gmxAPI.extend(map,{allControls:{div:allToolsNode/*                    ,
                        setVisible: function() {},
                        minimize: function() {},
                        maximize: function() {}
    */},isToolsMinimized:function isToolsMinimized(){return !ControlsManager.isVisible;},minimizeTools:function minimizeTools(){ControlsManager.setVisible();},maximizeTools:function maximizeTools(){ControlsManager.setVisible(true);}});},initControls:function initControls(){if(!this._controls)return false;this._controls.initControls();return true;},setCurrent:function setCurrent(id){if(this._controls)this._controls.remove();this._controls=gmxAPI._controls[id];},getCurrent:function getCurrent(){return this._controls||null;},getControl:function getControl(id){if(!this._controls)return null;return 'getControl'in this._controls?this._controls.getControl(id):null;},select:function select(controlObj){if(this.curent&&'remove'in this.curent)this.curent.remove();this.curent=controlObj;if('init'in controlObj)controlObj.init();},setVisible:function setVisible(flag){if(!arguments.length)flag=!this.isVisible;for(var key in ControlsManager._controls.controlsHash){var control=ControlsManager._controls.controlsHash[key];if('setVisible'in control)control.setVisible(flag,chkOld);}this.isVisible=flag;gmxAPI._listeners.dispatchEvent('onToolsMinimized',gmxAPI.map,!ControlsManager.isVisible);}// ,
    // addControls: function(controlObj, selectFlag) {
    // if(selectFlag) this.select(controlObj);
    // if(this.currentID === controlObj.id) controlObj.init();
    // for (var i = 0, len = this.controls.length; i < len; i++) {
    // if(controlObj === this.controls[i]) {
    // return;
    // }
    // }
    // this.controls.push(controlObj);
    // this.controls[controlObj.id] = controlObj;
    // }
    // ,
    // removeById: function(id) {
    // if(id && this.controls[id]) {
    // this.remove(this.controls[id]);
    // }
    // for(var key in gmxAPI._tools) {
    // var item = gmxAPI._tools[key];
    // item.remove();
    // delete gmxAPI._tools[key];
    // }
    // var tt = gmxAPI._tools;
    // }
    // ,
    // remove: function(controlObj) {
    // this.forEach(function(item, i) {
    // if(controlObj === item) {
    // this.controls.splice(i, 1);
    // if(controlObj === this.curent) this.curent = null;
    // delete this.controls[controlObj.id];
    // if('remove' in controlObj) controlObj.remove();
    // return false;   // stop iteration
    // }
    // });
    // }
    // ,
    // forEach: function(callback) {
    // for (var i = 0, len = this.controls.length; i < len; i++) {
    // if(callback.call(this, this.controls[i], i) === false) return;
    // }
    // }
    ,addGroupTool:function addGroupTool(pt){return gmxAPI.IconsControl.addGroupTool(pt);}/**
         * Описание класса Controls.
         * @typedef {Object} Controls1
         * @ignore
         * @property {String} id - Идентификатор типа контролов.
         * @property {Function} init - Ф-ция для инициализации.
         * @property {boolean} isVisible - Флаг видимости(по умолчанию true).
         * @property {Array} [Control] items - Массив контролов данного типа контролов.
         * @property {Function} [boolean=] setVisible - Установка видимости(по умолчанию false).
         * @property {Function} remove - Удаление набора контролов.
        */ /**
         * Менеджер контролов.
         * @constructor ControlsManager
         * @ignore
         * @param {Object} map - карта.
         * @param {Object=} div - нода для размещения контролов.
         */};gmxAPI.ControlsManager=function(map,div){ControlsManager.init(div||gmxAPI._div,map);return {// add: function(controls) {
    // ControlsManager.addControls(controls);
    // }
    // ,
    remove:function remove(id){ControlsManager.removeById(id);},/** Получить идентификатор текущего набора контролов
                * @memberof ControlsManager#
                * @returns {String|null} возвращает идентификатор текущего набора контролов или null если контролы не устанавлены.
                */getCurrentID:function getCurrentID(){return ControlsManager.currentID;},/** Получить текущий набор контролов
                * @memberof ControlsManager#
                * @returns {Controls|null} возвращает оъект текущего набора контролов или null если текущий набор контролов не устанавлен.
                */getCurrent:function getCurrent(){return ControlsManager.getCurrent()||null;}/** Установить текущий набор контролов
                * @memberof ControlsManager#
                * @param {String} id идентификатор набора контролов.
                * @returns {Controls|null} возвращает оъект текущего набора контролов или null если текущий набор контролов не устанавлен.
                */,setCurrent:function setCurrent(id){return ControlsManager.setCurrent(id);},setVisible:function setVisible(flag){ControlsManager.setVisible(flag);},toggleVisible:function toggleVisible(){ControlsManager.setVisible(!ControlsManager.isVisible);},addGroupTool:function addGroupTool(hash){return ControlsManager.addGroupTool(hash);},getControl:function getControl(id){var controls=ControlsManager.getCurrent();return controls&&'getControl'in controls?controls.getControl(id):null;},initControls:function initControls(){var controls=ControlsManager.getCurrent();if(controls&&'initControls'in controls){//ControlsManager.currentControls = 
    controls.initControls();return true;}return false;},addListener:ControlsManager.addListener,removeListener:ControlsManager.removeListener,stateListeners:ControlsManager.stateListeners};};})();(function(){var initControls=function initControls(){var outControls={};var mbl=gmxAPI.map.baseLayersManager;(function(){// function ToolsAll(cont)
    // {
    // this.toolsAllCont = gmxAPI._allToolsDIV;
    // gmxAPI._toolsContHash = {};
    // }
    // gmxAPI._ToolsAll = ToolsAll;
    // new gmxAPI._ToolsAll(container);
    gmxAPI._toolsContHash={};/** Класс управления tools контейнерами
                * @function
                * @ignore
                * @memberOf api
                * @param {name} ID контейнера
                * @param {attr} Hash дополнительных атрибутов
                *		ключи:
                *			contType: Int - тип контейнера (по умолчанию 0)
                *					0 - стандартный пользовательский тип контейнера 
                *					1 - тип для drawing вкладки
                *					2 - тип для вкладки базовых подложек
                *           notSticky: 0 - по умолчанию, инструмент выключается только после повторного нажатия или выбора другого инструмента.
                                       1 - автоматически выключать инструмент полсе активации
                *			properties: Hash - properties DIV контейнера (по умолчанию { 'className': 'tools_' + name })
                *			style: Hash - стили DIV контейнера (по умолчанию { 'position': "absolute", 'top': 40 })
                *			regularStyle: Hash - регулярного стиля DIV элементов в контейнере (по умолчанию { paddingTop: "4px", paddingBottom: "4px", paddingLeft: "10px", paddingRight: "10px", fontSize: "12px", fontFamily: "sans-serif", fontWeight: "bold",	textAlign: "center", cursor: "pointer", opacity: 1, color: "wheat" })
                *			activeStyle: Hash - активного стиля DIV элементов в контейнере (по умолчанию { paddingTop: "4px", paddingBottom: "4px", paddingLeft: "10px", paddingRight: "10px", fontSize: "12px", fontFamily: "sans-serif", fontWeight: "bold",	textAlign: "center", cursor: "pointer", opacity: 1, color: "orange" })
                */function ToolsContainer(name,attr){//console.log('ToolsContainer', name, attr);
    if(!attr)attr={};var aliasNames={},// Hash алиасов основных подложек для map.setMode
    toolNames=[],toolHash={},notSticky=attr.notSticky?attr.notSticky:0,contType=attr.contType?attr.contType:0,notSelectedFlag=contType!=1?true:false,createContainerNode=attr.createContainerNode||null,createItemNode=attr.createItemNode||null;if(!name)name='testTool';var properties=attr.properties?attr.properties:{};if(!properties.className){// className по умолчанию tools_ИмяВкладки
    properties.className='tools_'+name;}// стили контейнера
    var style={display:'block',styleFloat:'left',cssFloat:'left',marginTop:'40px',marginLeft:'4px',padding:'0px;'};// стили добавляемых юзером элементов tool
    var regularStyle={paddingTop:"0px",paddingBottom:"0px",paddingLeft:"10px",paddingRight:"10px",fontSize:"12px",fontFamily:"sans-serif",fontWeight:"bold",textAlign:"center",cursor:"pointer",opacity:1,color:"white"};var activeStyle={paddingTop:"4px",paddingBottom:"4px",paddingLeft:"10px",paddingRight:"10px",fontSize:"12px",fontFamily:"sans-serif",fontWeight:"bold",textAlign:"center",cursor:"pointer",opacity:1,color:"orange"};// Установка backgroundColor c alpha
    if(gmxAPI.isIE&&document.documentMode<10){style.filter="progid:DXImageTransform.Microsoft.gradient(startColorstr=#7F016A8A,endColorstr=#7F016A8A)";style.styleFloat='left';}else{style.backgroundColor="rgba(1, 106, 138, 0.5)";style.cssFloat='left';}regularStyle={paddingTop:"4px",paddingBottom:"4px",paddingLeft:"10px",paddingRight:"10px",fontSize:"12px",fontFamily:"sans-serif",fontWeight:"bold",textAlign:"center",cursor:"pointer",opacity:1,color:"wheat"};activeStyle={paddingTop:"4px",paddingBottom:"4px",paddingLeft:"10px",paddingRight:"10px",fontSize:"12px",fontFamily:"sans-serif",fontWeight:"bold",textAlign:"center",cursor:"pointer",opacity:1,color:"orange"};if(attr.style){for(key in attr.style){style[key]=attr.style[key];}}if(attr.regularStyle){// дополнение и переопределение стилей
    for(var key in attr.regularStyle){regularStyle[key]=attr.regularStyle[key];}}if(attr.activeStyle){for(key in attr.activeStyle){activeStyle[key]=attr.activeStyle[key];}}var my=this;gmxAPI.extend(this,{activeToolName:'',node:null,currentlyDrawnObject:null,isVisible:true,setActiveTool:function setActiveTool(toolName){for(var id in toolHash){var tool=toolHash[id];if(tool){tool.isActive=id==toolName?true:false;}}this.activeToolName=toolName;this.repaint();},selectTool:function selectTool(toolName){if(name=='standart'){// только для колонки 'standart'
    if(toolName==my.activeToolName)toolName=toolNames.length>0?toolNames[0]:'';// если toolName совпадает с активным tool переключаем на 1 tool
    // При draw обьектов
    if(my.currentlyDrawnObject&&'stopDrawing'in my.currentlyDrawnObject){my.currentlyDrawnObject.stopDrawing();}my.currentlyDrawnObject=null;}var oldToolName=my.activeToolName;var tool=toolHash[oldToolName];if(tool&&contType!=0){if('onCancel'in tool)tool.onCancel();tool.repaint();}my.activeToolName=notSelectedFlag&&toolName==oldToolName?'':toolName;tool=toolHash[toolName];if(tool){if(contType==0){// для добавляемых юзером меню
    if(tool.isActive){if('onCancel'in tool)tool.onCancel();}else{if('onClick'in tool)tool.onClick();}tool.repaint();}else if(contType==1){// тип для drawing
    if('onClick'in tool){my.currentlyDrawnObject=tool.onClick();tool.repaint();}else{my.currentlyDrawnObject=null;}}else if(contType==2){// тип для подложек
    if('onClick'in tool&&toolName!=oldToolName){tool.onClick();tool.repaint();}}if(notSticky==1){// Если интструмент включен, сразу же выключите его.
    if(tool.isActive){if('onCancel'in tool)tool.onCancel();tool.isActive=false;}}}gmxAPI._listeners.dispatchEvent('onActiveChanged',gmxAPI._tools[name],{id:my.activeToolName,target:my});// Изменились активные tool в контейнере
    gmxAPI._listeners.dispatchEvent('onActiveChanged',gmxAPI.map.controlsManager,{id:my.activeToolName,target:my});},stateListeners:{},addListener:function addListener(eventName,func){return gmxAPI._listeners.addListener({obj:this,eventName:eventName,func:func});},removeListener:function removeListener(eventName,id){return gmxAPI._listeners.removeListener(this,eventName,id);},forEach:function forEach(callback){for(var id in toolHash){callback(toolHash[id]);}},getToolByName:function getToolByName(tn){if(!toolHash[tn])return false;return toolHash[tn];},getTool:function getTool(tn){if(toolHash[tn])return toolHash[tn];for(var key in toolHash){var tool=toolHash[key];var alias=tool.alias||key;if(alias===tn)return tool;}return null;},getAlias:function getAlias(tn){return aliasNames[tn]||tn;},getAliasByName:function getAliasByName(tn){for(var key in toolHash){var tool=toolHash[key];var alias=tool.alias||key;if(alias===tn)return alias;else if(tool.lang){for(var lang in tool.lang){if(tool.lang[lang]===tn)return alias;}}}return null;},getToolIndex:function getToolIndex(tn){for(var i=0;i<toolNames.length;i++){if(tn===toolNames[i])return i;}return -1;},setToolIndex:function setToolIndex(tn,ind){var num=my.getToolIndex(tn);if(num===-1||!toolHash[tn])return false;var hash=toolHash[tn];var tBody=my.itemsContainer;//var obj = tBody.removeChild(hash.row);
    var len=tBody.children.length;if(ind>=len)ind=len-1;toolNames.splice(num,1);toolNames.splice(ind,0,tn);toolHash[tn].row=tBody.insertBefore(hash.row,tBody.children[ind]);//toolHash[tn].row = tBody.insertBefore(obj, tBody.children[ind]);
    return true;},setVisible:function setVisible(flag){gmxAPI.setVisible(my.node,flag);this.isVisible=flag;},chkVisible:function chkVisible(){var flag=false;for(var key in toolHash){var tool=toolHash[key];if(tool.isVisible){flag=true;}}gmxAPI.setVisible(my.node,flag);this.isVisible=flag;},repaint:function repaint(){for(var id in toolHash){var tool=toolHash[id];if(tool){tool.repaint();}}},updateVisibility:function updateVisibility(){},remove:function remove(){for(var key in this.stateListeners){var item=this.stateListeners[key];this.removeListener(key,item.id);}this.stateListeners={};delete gmxAPI._toolsContHash[name];if(this.node.parentNode)this.node.parentNode.removeChild(this.node);},chkBaseLayerTool:function chkBaseLayerTool(tn,attr){if(toolHash[tn])return false;else{if(!attr){attr={onClick:function onClick(){gmxAPI.map.setBaseLayer(tn);},onCancel:function onCancel(){gmxAPI.map.unSetBaseLayer();},onmouseover:function onmouseover(){this.style.color="orange";},onmouseout:function onmouseout(){this.style.color="white";},hint:tn};}return this.addTool(tn,attr);}},addTool:function addTool(tn,attr){//console.log('tool addTool', tn, attr); // wheat
    if(!attr)attr={};if(attr.overlay&&gmxAPI._leaflet&&gmxAPI._leaflet.gmxLayers){attr.id=tn;if(!attr.rus)attr.rus=attr.hint||attr.id;if(!attr.eng)attr.eng=attr.hint||attr.id;var layersControl=gmxAPI.map.controlsManager.getControl('layers');if(layersControl)layersControl.addOverlay(tn,attr);//                    return;
    }else{var controls=gmxAPI.map.controlsManager.getCurrent();if(controls&&'addControl'in controls){ret=controls.addControl(tn,attr);}}//    return;
    //                if(!my.itemsContainer) my.itemsContainer = (createContainerNode ? createContainerNode() : my.createContainerNode('div', properties, style));
    if(!my.itemsContainer){if(createContainerNode)createContainerNode();else my.createContainerNode('div',properties,style);}if(!attr.alias)attr.alias=tn;aliasNames[attr.alias]=tn;var elType='img';var elAttr={title:attr.hint,onclick:function onclick(){my.selectTool(tn);}};if(!('onClick'in attr))attr.onClick=function(){gmxAPI.map.setMode(tn);};if(!('onCancel'in attr))attr.onCancel=function(){gmxAPI.map.unSetBaseLayer();};var setStyle=function setStyle(elem,style){for(var key in style){var value=style[key];elem.style[key]=value;if(key=="opacity")elem.style.filter="alpha(opacity="+Math.round(value*100)+")";}};var myActiveStyle=attr.activeStyle?attr.activeStyle:activeStyle;var myRegularStyle=attr.regularStyle?attr.regularStyle:regularStyle;var repaintFunc=null;if('regularImageUrl'in attr){elAttr.onmouseover=function(){this.src=attr.activeImageUrl;};repaintFunc=function repaintFunc(obj){obj.src=tn==my.activeToolName?attr.activeImageUrl:attr.regularImageUrl;};elAttr.src=attr.regularImageUrl;}else{elType='div';repaintFunc=function repaintFunc(obj,flag){if(toolHash[tn].isActive)flag=true;var resStyle=flag?myActiveStyle:myRegularStyle;setStyle(obj,resStyle);};elAttr.onmouseover=function(){repaintFunc(this,true);};elAttr.innerHTML=attr.hint;}elAttr.onmouseout=function(){repaintFunc(this,false);};var pt=createItemNode?createItemNode(my.itemsContainer):function(parent){var tr=gmxAPI.newElement("tr",{"className":'tools_tr_'+name+'_'+tn});var td=gmxAPI.newElement("td",null,{padding:"4px",cursor:"pointer"});// { padding: "4px", textAlign: "center" }
    tr.appendChild(td);var control=gmxAPI.newElement(elType,elAttr,myRegularStyle);td.appendChild(control);parent.appendChild(tr);return {'control':control// нода для отображения выбранного tool элемента 
    ,'row':tr// нода контейнера tool элемента (по умолчанию без контейнера)
    };}(my.itemsContainer);var itemContainer=pt.control;var row=pt.row||itemContainer;toolHash[tn]={id:tn,key:tn,alias:attr.alias||null,lang:attr.lang||null,backgroundColor:attr.backgroundColor,isActive:false,isVisible:true,control:itemContainer,row:row,setVisible:function setVisible(flag){this.isVisible=flag;if(flag){row.style.display='';row.style.visibility='visible';}else{row.style.display='none';row.style.visibility='hidden';}my.chkVisible();},setToolImage:function setToolImage(a1,a2){},repaint:function repaint(){repaintFunc(itemContainer);},onClick:function onClick(){this.isActive=true;my.activeToolName=tn;return attr.onClick.call();},onCancel:function onCancel(){this.isActive=false;my.activeToolName='';attr.onCancel.call();gmxAPI._listeners.dispatchEvent('onActiveChanged',gmxAPI.map.controlsManager,{id:tn,target:my});},select:function select(){my.selectTool(tn);},setActive:function setActive(){my.selectTool(tn);}};toolHash[tn].line=row;// для обратной совместимости
    var pos=attr.pos>0?attr.pos:toolNames.length;toolNames.splice(pos,0,tn);//positionTools();
    if(!gmxAPI._drawing.tools[tn])gmxAPI._drawing.tools[tn]=toolHash[tn];my.chkVisible();if(gmxAPI._drawing.toolInitFlags&&gmxAPI._drawing.toolInitFlags[tn]){// обратная совместимость
    toolHash[tn].setVisible(gmxAPI._drawing.toolInitFlags[tn].visible);}return toolHash[tn];},removeTool:function removeTool(tn){var num=my.getToolIndex(tn);if(num===-1||!toolHash[tn])return false;toolNames.splice(num,1);my.itemsContainer.removeChild(toolHash[tn].row);delete toolHash[tn];if(gmxAPI._drawing.tools[tn])delete gmxAPI._drawing.tools[tn];if(tn===my.activeToolName)my.activeToolName='';my.chkVisible();return true;},createContainerNode:function createContainerNode(nodeType,properties,style){var node=gmxAPI.newElement(nodeType||'div',properties,style);if(gmxAPI.IconsControl){gmxAPI.IconsControl.node.appendChild(node);}else{gmxAPI._allToolsDIV.appendChild(node);}//gmxAPI._allToolsDIV.appendChild(node);
    this.node=node;gmxAPI._toolsContHash[name]=node;var table=gmxAPI.newElement("table",{},{borderCollapse:'collapse',margin:'0px',width:'auto',backgroundColor:'rgba(1, 106, 138, 0)'});node.appendChild(table);my.itemsContainer=gmxAPI.newElement("tbody",{},{});table.appendChild(this.itemsContainer);return node;}});my.createContainerNode('div',properties,style);if(!gmxAPI._tools)gmxAPI._tools={};gmxAPI._tools[name]=this;return this;}//расширяем namespace
    gmxAPI._ToolsContainer=ToolsContainer;})();gmxAPI._tools=Controls.controlsHash;//Поддержка zoomControl
    var zoomControl={id:'zoomControl',parentNode:null,node:null,listeners:{},init:function init(cont){// инициализация
    zoomControl.parentNode=cont;if(!zoomControl.node)zoomControl.node=zoomControl.createNode(cont);if(!zoomControl.node.parentNode)zoomControl.setVisible(true);zoomControl.toggleHandlers(true);var zoomBounds=gmxAPI.map.getZoomBounds();if(zoomBounds){zoomControl.minZoom=zoomBounds.MinZoom;zoomControl.maxZoom=zoomBounds.MaxZoom;zoomControl.setZoom(gmxAPI.map.getZ());}},setVisible:function setVisible(flag){// инициализация
    var node=zoomControl.node;if(!flag){if(node.parentNode)node.parentNode.removeChild(node);}else{if(!node.parentNode)zoomControl.parentNode.appendChild(node);zoomControl.repaint();}},toggleHandlers:function toggleHandlers(flag){// Добавление/Удаление прослушивателей событий
    if(flag){if(!gmxAPI.map.zoomControl)gmxAPI.map.zoomControl=zoomControl.mapZoomControl;//var cz = (gmxAPI.map.needMove ? gmxAPI.map.needMove.z || 1 : 4);
    //gmxAPI.map.zoomControl.setZoom(cz);
    // Добавление прослушивателей событий
    var key='onMinMaxZoom';zoomControl.listeners[key]=gmxAPI.map.addListener(key,function(ph){var attr=ph.attr;zoomControl.minZoom=attr.minZoom;zoomControl.maxZoom=attr.maxZoom;zoomControl.setZoom(attr.currZ);zoomControl.repaint();});key='positionChanged';zoomControl.listeners[key]=gmxAPI.map.addListener(key,function(ph){zoomControl.setZoom(ph.currZ);});}else{for(var key in zoomControl.listeners){gmxAPI.map.removeListener(key,zoomControl.listeners[key]);}zoomControl.listeners={};gmxAPI.map.zoomControl={};}},remove:function remove(){// удаление
    zoomControl.toggleHandlers(false);zoomControl.setVisible(false);},createNode:function createNode(cont){// инициализация
    var apiBase=gmxAPI.getAPIFolderRoot();var node=zoomControl.zoomParent=gmxAPI.newElement("div",{className:"gmx_zoomParent1"},{position:"absolute",left:"40px",top:"5px"});zoomControl.zoomPlaque=gmxAPI.newElement("div",{className:"gmx_zoomPlaque1"},{backgroundColor:"#016a8a",opacity:0.5,position:"absolute",left:0,top:0});node.appendChild(zoomControl.zoomPlaque);zoomControl.zoomMinus=gmxAPI.newElement("img",{className:"gmx_zoomMinus1",src:apiBase+"img/zoom_minus.png",onclick:function onclick(){gmxAPI.map.zoomBy(-1);},onmouseover:function onmouseover(){this.src=apiBase+"img/zoom_minus_a.png";},onmouseout:function onmouseout(){this.src=apiBase+"img/zoom_minus.png";}},{position:"absolute",left:"5px",top:"7px",cursor:"pointer"});node.appendChild(zoomControl.zoomMinus);for(var i=0,len=zoomControl.maxZoom;i<len;i++){zoomControl.addZoomItem(i);}zoomControl.zoomPlus=gmxAPI.newElement("img",{className:"gmx_zoomPlus1",src:apiBase+"img/zoom_plus.png",onclick:function onclick(){gmxAPI.map.zoomBy(1);},onmouseover:function onmouseover(){this.src=apiBase+"img/zoom_plus_a.png";},onmouseout:function onmouseout(){this.src=apiBase+"img/zoom_plus.png";}},{position:"absolute",cursor:"pointer"});node.appendChild(zoomControl.zoomPlus);return node;},minZoom:1,maxZoom:30,zoomArr:[],zoomObj:null,addZoomItem:function addZoomItem(i){// добавить zoom элемент
    var apiBase=gmxAPI.getAPIFolderRoot();var node=gmxAPI.newElement("img",{src:apiBase+"img/zoom_raw.png",title:""+(i+1),onclick:function onclick(){gmxAPI.map.zoomBy(i+zoomControl.minZoom-gmxAPI.map.getZ());},onmouseover:function onmouseover(){this.src=apiBase+"img/zoom_active.png";this.title=""+(i+zoomControl.minZoom);},onmouseout:function onmouseout(){this.src=this==zoomControl.zoomObj?apiBase+"img/zoom_active.png":apiBase+"img/zoom_raw.png";}},{position:"absolute",left:22+12*i+"px",top:"12px",width:"12px",height:"8px",border:0,cursor:"pointer"});zoomControl.zoomParent.appendChild(node);zoomControl.zoomArr.push(node);},repaint:function repaint(){var dz=zoomControl.maxZoom-zoomControl.minZoom+1;var gap=12*dz;gmxAPI.position(zoomControl.zoomPlus,20+gap,7);gmxAPI.size(zoomControl.zoomPlaque,43+gap,32);//gmxAPI.map.zoomControl.width = 43 + gap;
    for(var i=0;i<dz;i++){if(i==zoomControl.zoomArr.length)zoomControl.addZoomItem(i);gmxAPI.setVisible(zoomControl.zoomArr[i],i<dz);}if(dz<zoomControl.zoomArr.length)for(var i=dz;i<zoomControl.zoomArr.length;i++){gmxAPI.setVisible(zoomControl.zoomArr[i],false);}},onChangeBackgroundColorID:null,onMoveEndID:null,setZoom:function setZoom(z){var newZoomObj=zoomControl.zoomArr[Math.round(z)-zoomControl.minZoom];if(newZoomObj!=zoomControl.zoomObj){var apiBase=gmxAPI.getAPIFolderRoot();if(zoomControl.zoomObj)zoomControl.zoomObj.src=apiBase+"img/zoom_raw.png";zoomControl.zoomObj=newZoomObj;if(zoomControl.zoomObj)zoomControl.zoomObj.src=apiBase+"img/zoom_active.png";}},mapZoomControl:{isVisible:true,isMinimized:false,setVisible:function setVisible(flag){gmxAPI.setVisible(zoomControl.zoomParent,flag);this.isVisible=flag;},setZoom:function setZoom(z){zoomControl.setZoom(z);},repaint:function repaint(){if(!this.isMinimized)zoomControl.repaint();},setMinMaxZoom:function setMinMaxZoom(z1,z2){zoomControl.minZoom=z1;zoomControl.maxZoom=z2;this.repaint();},getMinZoom:function getMinZoom(){return zoomControl.minZoom;},getMaxZoom:function getMaxZoom(){return zoomControl.maxZoom;},minimize:function minimize(){this.isMinimized=true;this.repaint();},maximize:function maximize(){this.isMinimized=false;this.repaint();}},getInterface:function getInterface(){return {setVisible:zoomControl.setVisible};}//Поддержка geomixerLink
    };var geomixerLink={id:'geomixerLink',parentNode:null,node:null,init:function init(cont){// инициализация
    geomixerLink.parentNode=cont.parentNode;if(!geomixerLink.node)geomixerLink.node=geomixerLink.createNode(geomixerLink.parentNode);if(!geomixerLink.node.parentNode)geomixerLink.parentNode.appendChild(geomixerLink.node);},remove:function remove(){// удаление
    if(geomixerLink.node.parentNode)geomixerLink.parentNode.removeChild(geomixerLink.node);},createNode:function createNode(cont){// инициализация
    var apiBase=gmxAPI.getAPIFolderRoot();var node=gmxAPI.newElement("a",{href:"http://geomixer.ru",target:"_blank",className:"gmx_geomixerLink"},{position:"absolute",left:"8px",bottom:"8px"});node.appendChild(gmxAPI.newElement("img",{src:apiBase+"img/geomixer_logo_api.png",title:gmxAPI.KOSMOSNIMKI_LOCALIZED("© 2007-2011 ИТЦ «СканЭкс»","(c) 2007-2011 RDC ScanEx"),width:130,height:34},{border:0}));return node;},getInterface:function getInterface(){return {remove:geomixerLink.remove};}//Поддержка minimizeTools
    };var minimizeTools={id:'minimize',parentNode:null,node:null,init:function init(cont){// инициализация
    minimizeTools.parentNode=cont.parentNode;if(!minimizeTools.node)minimizeTools.node=minimizeTools.createNode(minimizeTools.parentNode);if(!minimizeTools.node.parentNode)minimizeTools.setVisible(true);var apiBase=gmxAPI.getAPIFolderRoot();gmxAPI.map.isToolsMinimized=function(){return minimizeTools.toolsMinimized;};gmxAPI.map.minimizeTools=function(){minimizeTools.toolsMinimized=true;minimizeTools.node.src=apiBase+"img/tools_off.png";minimizeTools.node.title=gmxAPI.KOSMOSNIMKI_LOCALIZED("Показать инструменты","Show tools");gmxAPI.setVisible(gmxAPI._allToolsDIV,false);gmxAPI._listeners.dispatchEvent('onToolsMinimized',gmxAPI.map,minimizeTools.toolsMinimized);};gmxAPI.map.maximizeTools=function(){minimizeTools.toolsMinimized=false;minimizeTools.node.src=apiBase+"img/tools_on.png";minimizeTools.node.title=gmxAPI.KOSMOSNIMKI_LOCALIZED("Скрыть инструменты","Hide tools");gmxAPI.setVisible(gmxAPI._allToolsDIV,true);gmxAPI._listeners.dispatchEvent('onToolsMinimized',gmxAPI.map,minimizeTools.toolsMinimized);};gmxAPI.map.maximizeTools();gmxAPI.extend(gmxAPI.map.allControls,{setVisible:function setVisible(flag){gmxAPI.setVisible(minimizeTools.plaqueNode,flag);gmxAPI.setVisible(minimizeTools.node,flag);gmxAPI.setVisible(gmxAPI._allToolsDIV,flag);},minimize:gmxAPI.map.minimizeTools,maximize:gmxAPI.map.maximizeTools});},remove:function remove(){// удаление
    minimizeTools.setVisible(false);},setVisible:function setVisible(flag){// инициализация
    var node=minimizeTools.node;if(!flag){if(node.parentNode)node.parentNode.removeChild(node);if(minimizeTools.plaqueNode.parentNode)minimizeTools.plaqueNode.parentNode.removeChild(minimizeTools.plaqueNode);}else{if(!minimizeTools.plaqueNode.parentNode)minimizeTools.parentNode.appendChild(minimizeTools.plaqueNode);if(!node.parentNode)minimizeTools.parentNode.appendChild(node);}},createNode:function createNode(cont){// инициализация
    minimizeTools.plaqueNode=gmxAPI.newStyledDiv({position:"absolute",left:"4px",top:"5px",width:"32px",height:"32px",backgroundColor:"#016a8a",opacity:0.5});minimizeTools.toolsMinimized=false;var apiBase=gmxAPI.getAPIFolderRoot();var node=gmxAPI.newElement("img",{onclick:function onclick(){if(minimizeTools.toolsMinimized)gmxAPI.map.maximizeTools();else gmxAPI.map.minimizeTools();},onmouseover:function onmouseover(){if(minimizeTools.toolsMinimized)this.src=apiBase+"img/tools_off_a.png";else this.src=apiBase+"img/tools_on_a.png";},onmouseout:function onmouseout(){if(minimizeTools.toolsMinimized)this.src=apiBase+"img/tools_off.png";else this.src=apiBase+"img/tools_on.png";}},{position:"absolute",left:"8px",top:"8px",cursor:"pointer"});return node;},getInterface:function getInterface(){return {remove:minimizeTools.remove,setVisible:minimizeTools.setVisible};}//Поддержка copyright
    };var copyrightControl={id:'copyrights',parentNode:null,node:null,items:[],currentText:'',addItem:function addItem(obj,copyright,z1,z2,geo){this.removeItem(obj,copyright);var bounds=null;if(geo){bounds=gmxAPI.getBounds(geo.coordinates);}else if(obj.geometry){bounds=obj.bounds||gmxAPI.getBounds(obj.geometry.coordinates);}if(!z1)z1=0;if(!z2)z2=100;this.items.push([obj,copyright,z1,z2,bounds]);this.redraw();return true;},removeItem:function removeItem(obj,copyright){var arr=[];this.items.forEach(function(item,i){if(copyright&&copyright!==item[1]||obj!==item[0]){arr.push(item);}});copyrightControl.items=arr;},setColor:function setColor(color){copyrightControl.node.style.color=color;},init:function init(cont){// инициализация
    copyrightControl.parentNode=cont.parentNode;if(!copyrightControl.node)copyrightControl.node=copyrightControl.createNode(copyrightControl.parentNode);if(!copyrightControl.node.parentNode)copyrightControl.setVisible(true);copyrightControl.toggleHandlers(true);copyrightControl.setColor(gmxAPI.getHtmlColor());copyrightControl.redraw();},createNode:function createNode(cont){// инициализация
    var node=gmxAPI.newElement("span",{className:"gmx_copyright"},{fontSize:"11px",position:"absolute",right:'26px',bottom:'7px'});return node;},remove:function remove(){// удаление
    copyrightControl.toggleHandlers(false);copyrightControl.setVisible(false);},setVisible:function setVisible(flag){// инициализация
    if(!flag){if(copyrightControl.node.parentNode)copyrightControl.node.parentNode.removeChild(copyrightControl.node);}else{copyrightControl.parentNode.appendChild(copyrightControl.node);}},onChangeBackgroundColorID:null,onMoveEndID:null,toggleHandlers:function toggleHandlers(flag){// Добавление прослушивателей событий
    var map=gmxAPI.map;if(flag){map.addCopyrightedObject=function(obj,copyright,z1,z2,geo){copyrightControl.addItem(obj,copyright,z1,z2,geo);};map.removeCopyrightedObject=function(obj){copyrightControl.removeItem(obj);};map.setCopyrightVisibility=function(obj){copyrightControl.setVisible(obj);};map.updateCopyright=function(){copyrightControl.redraw();};// Изменить позицию контейнера копирайтов
    map.setCopyrightAlign=function(attr){if(attr.align)copyrightControl.copyrightAlign=attr.align;copyrightControl.setPosition();};copyrightControl.onChangeBackgroundColorID=map.addListener('onChangeBackgroundColor',function(htmlColor){copyrightControl.setColor(htmlColor);copyrightControl.redraw();});var updateListenerID=null;var evName=gmxAPI.proxyType==='flash'?'positionChanged':'onMoveEnd';copyrightControl.onMoveEndID=map.addListener(evName,function(){if(updateListenerID)return;updateListenerID=setTimeout(function(){copyrightControl.redraw();clearTimeout(updateListenerID);updateListenerID=null;},250);});}else{map.addCopyrightedObject=map.removeCopyrightedObject=map.setCopyrightVisibility=map.setCopyrightAlign=map.updateCopyright=function(){};if(copyrightControl.onChangeBackgroundColorID){map.removeListener('onChangeBackgroundColor',copyrightControl.onChangeBackgroundColorID);copyrightControl.onChangeBackgroundColorID=null;}if(copyrightControl.onMoveEndID){var evName=gmxAPI.proxyType==='flash'?'positionChanged':'onMoveEnd';map.removeListener(evName,copyrightControl.onMoveEndID);copyrightControl.onMoveEndID=null;}}},forEach:function forEach(callback){for(var i=0,len=this.items.length;i<len;i++){if(callback(this.items[i],i)===false)return;}},redraw:function redraw(){// перерисовать с задержкой 
    if(this.redrawTimer)clearTimeout(this.redrawTimer);this.redrawTimer=setTimeout(function(){copyrightControl.redrawTimer=null;copyrightControl.redrawItems();},100);},redrawItems:function redrawItems(){// перерисовать
    var currPos=gmxAPI.currPosition||gmxAPI.map.getPosition();if(!currPos.latlng||!currPos.latlng.extent)return;var chkExists={};var texts=[//первым всегда будет располагаться копирайт СканЭкс. 
    "<a target='_blank' style='color: inherit;' href='http://maps.kosmosnimki.ru/Apikey/License.html'>&copy; 2007-2014 "+gmxAPI.KOSMOSNIMKI_LOCALIZED("&laquo;СканЭкс&raquo;","RDC ScanEx")+"</a>"];this.forEach(function(item,i){var obj=item[0];var copyright=item[1];if(!copyright||!obj.objectId||!obj.getVisibility())return;// обьекта нет на экране или без копирайта
    if(chkExists[copyright])return;// дубли копирайтов
    var z1=item[2],z2=item[3],bounds=item[4],zoom=currPos.z;if(zoom<z1||zoom>z2)return;if(bounds&&!gmxAPI.extIntersect(currPos.latlng.extent,bounds))return;chkExists[copyright]=true;texts.push(copyright.split("<a").join("<a target='_blank' style='color: inherit;'"));});if(gmxAPI.proxyType=='leaflet')texts.push("<a target='_blank' style='color: inherit;' href='http://leafletjs.com'>&copy; Leaflet</a>");var text=texts.join(' ');if(this.currentText!=text){this.currentText=text;copyrightControl.node.innerHTML=text;gmxAPI._listeners.dispatchEvent('copyrightRepainted',gmxAPI.map,text);}if(copyrightControl.copyrightAlign)copyrightControl.setPosition();},copyrightAlign:'',copyrightLastAlign:'',setPosition:function setPosition(){// Изменить координаты HTML элемента
    var node=copyrightControl.node;var center=(copyrightControl.parentNode.clientWidth-node.clientWidth)/2;if(copyrightControl.copyrightLastAlign!=copyrightControl.copyrightAlign){copyrightControl.copyrightLastAlign=copyrightControl.copyrightAlign;if(copyrightControl.copyrightAlign==='bc'){// Позиция bc(BottomCenter)
    gmxAPI.setPositionStyle(node,{'top':'','bottom':copyrightAttr.y,'right':'','left':center+'px'});}else if(copyrightControl.copyrightAlign==='br'){// Позиция br(BottomRight)
    gmxAPI.setPositionStyle(node,{'top':'','bottom':copyrightAttr.y,'right':copyrightAttr.x,'left':''});}else if(copyrightControl.copyrightAlign==='bl'){// Позиция bl(BottomLeft)
    gmxAPI.setPositionStyle(node,{'top':'','bottom':copyrightAttr.y,'right':'','left':copyrightAttr.x});}else if(copyrightControl.copyrightAlign==='tc'){// Позиция tc(TopCenter)
    gmxAPI.setPositionStyle(node,{'top':'0px','bottom':'','right':'','left':center+'px'});}else if(copyrightControl.copyrightAlign==='tr'){// Позиция tr(TopRight)
    gmxAPI.setPositionStyle(node,{'top':'0px','bottom':'','right':copyrightAttr.x,'left':''});}else if(copyrightControl.copyrightAlign==='tl'){// Позиция tl(TopLeft)
    gmxAPI.setPositionStyle(node,{'top':'0px','bottom':'','right':'','left':copyrightAttr.x});}}},getInterface:function getInterface(){return {remove:copyrightControl.remove,setVisible:copyrightControl.setVisible,add:copyrightControl.addItem,removeItem:copyrightControl.removeItem};}//Поддержка - отображения строки текущего положения карты
    };var locationControl={id:'location',parentNode:null,nodes:null,locationTitleDiv:null,scaleBar:null,items:[],currentText:'',init:function init(cont){// инициализация
    locationControl.parentNode=cont.parentNode;if(!locationControl.nodes)locationControl.nodes=locationControl.createNode(locationControl.parentNode);if(!locationControl.nodes[0].parentNode)locationControl.setVisible(true);locationControl.toggleHandlers(true);locationControl.chkExists();},chkExists:function chkExists(){// Проверка уже установленных данных
    locationControl.setColor(gmxAPI.getHtmlColor(),true);locationControl.prpPosition();},remove:function remove(){// удаление
    locationControl.toggleHandlers(false);locationControl.setVisible(false);},setVisible:function setVisible(flag){// инициализация
    if(!flag){for(var i=0,len=this.nodes.length;i<len;i++){var node=this.nodes[i];if(node.parentNode)node.parentNode.removeChild(node);}}else{for(var i=0,len=this.nodes.length;i<len;i++){var node=this.nodes[i];if(!node.parentNode)locationControl.parentNode.appendChild(node);}}},onChangeBackgroundColorID:null,onMoveEndID:null,positionChangedID:null,onResizeMapID:null,toggleHandlers:function toggleHandlers(flag){// Добавление прослушивателей событий
    if(flag){gmxAPI.map.scaleBar={setVisible:function setVisible(flag){gmxAPI.setVisible(locationControl.scaleBar,flag);}};gmxAPI.map.coordinates={setVisible:function setVisible(flag){gmxAPI.setVisible(locationControl.coordinates,flag);gmxAPI.setVisible(locationControl.changeCoords,flag);},addCoordinatesFormat:function addCoordinatesFormat(func){locationControl.coordFormatCallbacks.push(func);return locationControl.coordFormatCallbacks.length-1;},removeCoordinatesFormat:function removeCoordinatesFormat(num){locationControl.coordFormatCallbacks.splice(num,1);return locationControl.coordFormatCallbacks.length-1;},setFormat:locationControl.setCoordinatesFormat};locationControl.positionChangedID=gmxAPI.map.addListener('positionChanged',locationControl.prpPosition);if(gmxAPI.proxyType==='flash'){locationControl.onResizeMapID=gmxAPI.map.addListener('onResizeMap',locationControl.prpPosition);}else{locationControl.onMoveEndID=gmxAPI.map.addListener('onMoveEnd',locationControl.checkPositionChanged);}locationControl.onChangeBackgroundColorID=gmxAPI.map.addListener('onChangeBackgroundColor',function(htmlColor){locationControl.setColor(htmlColor);});}else{gmxAPI.map.coordinates=gmxAPI.map.scaleBar=function(){};if(locationControl.onChangeBackgroundColorID){gmxAPI.map.removeListener('onChangeBackgroundColor',locationControl.onChangeBackgroundColorID);locationControl.onChangeBackgroundColorID=null;}if(locationControl.positionChangedID){gmxAPI.map.removeListener('positionChanged',locationControl.positionChangedID);locationControl.positionChangedID=null;}if(locationControl.onMoveEndID){gmxAPI.map.removeListener('onMoveEnd',locationControl.onMoveEndID);locationControl.onMoveEndID=null;}if(locationControl.onResizeMapID){gmxAPI.map.removeListener('onResizeMap',locationControl.onResizeMapID);locationControl.onResizeMapID=null;}}},showCoordinates:function showCoordinates(){//окошко с координатами
    if(locationControl.coordFormat>2)return;//выдаем окошко с координатами только для стандартных форматов.
    var oldText=locationControl.getCoordinatesText();var text=window.prompt(gmxAPI.KOSMOSNIMKI_LOCALIZED("Текущие координаты центра карты:","Current center coordinates:"),oldText);if(text&&text!=oldText)gmxAPI.map.moveToCoordinates(text);},nextCoordinatesFormat:function nextCoordinatesFormat(){locationControl.coordFormat+=1;locationControl.setCoordinatesFormat(locationControl.coordFormat);},createNode:function createNode(cont){// инициализация
    var nodes=[gmxAPI.newElement("div",{},{}),gmxAPI.newElement("div",{className:"gmx_scaleBar1"},{position:"absolute",border:'1px solid #000000',color:'black',pointerEvents:"none",right:'27px',bottom:'47px',textAlign:"center"}),gmxAPI.newElement("div",{className:"gmx_coordinates",onclick:locationControl.showCoordinates},{position:"absolute",fontSize:"14px",color:'black',right:'27px',bottom:'25px',cursor:"pointer"}),gmxAPI.newElement("div",{className:"gmx_changeCoords",title:gmxAPI.KOSMOSNIMKI_LOCALIZED("Сменить формат координат","Toggle coordinates format"),onclick:locationControl.nextCoordinatesFormat},{position:"absolute",backgroundImage:'url("'+gmxAPI.getAPIFolderRoot()+'img/coord_reload.png")',width:'19px',height:'19px',right:'5px',bottom:'25px',cursor:"pointer"})];gmxAPI._locationTitleDiv=locationControl.locationTitleDiv=nodes[0];locationControl.scaleBar=nodes[1];locationControl.coordinates=nodes[2];locationControl.changeCoords=nodes[3];return nodes;},forEach:function forEach(callback){for(var i=0,len=this.items.length;i<len;i++){if(callback(this.items[i],i)===false)return;}},setColor:function setColor(color,flag){gmxAPI.setStyleHTML(locationControl.coordinates,{'fontSize':"14px",'color':color});gmxAPI.setStyleHTML(locationControl.scaleBar,{'border':"1px solid "+color,'fontSize':"11px",'color':color});var url=gmxAPI.getAPIFolderRoot()+'img/coord_reload'+(color==='white'?'_orange':'')+'.png';gmxAPI.setStyleHTML(locationControl.changeCoords,{'backgroundImage':'url("'+url+'")'});if(flag){locationControl.checkPositionChanged();}},repaintScaleBar:function repaintScaleBar(){if(locationControl.scaleBarText){gmxAPI.size(locationControl.scaleBar,locationControl.scaleBarWidth,16);locationControl.scaleBar.innerHTML=locationControl.scaleBarText;}},checkPositionChanged:function checkPositionChanged(){var attr=gmxAPI.getScaleBarDistance();if(!attr||attr.txt===locationControl.scaleBarText&&attr.width===locationControl.scaleBarWidth)return;locationControl.scaleBarText=attr.txt;locationControl.scaleBarWidth=attr.width;locationControl.repaintScaleBar();},coordFormat:0,prevCoordinates:'',getCoordinatesText:function getCoordinatesText(currPos){return gmxAPI.getCoordinatesText(currPos,locationControl.coordFormat);},clearCoordinates:function clearCoordinates(){var node=locationControl.coordinates;for(var i=node.childNodes.length-1;i>=0;i--){node.removeChild(node.childNodes[i]);}},coordFormatCallbacks:[// методы формирования форматов координат
    function(){return locationControl.getCoordinatesText();},function(){return locationControl.getCoordinatesText();},function(){return locationControl.getCoordinatesText();}],setCoordinatesFormat:function setCoordinatesFormat(num,screenGeometry){if(!num)num=locationControl.coordFormat;if(num<0)num=locationControl.coordFormatCallbacks.length-1;else if(num>=locationControl.coordFormatCallbacks.length)num=0;locationControl.coordFormat=num;if(!screenGeometry)screenGeometry=gmxAPI.map.getScreenGeometry();var attr={'screenGeometry':screenGeometry,'properties':gmxAPI.map.properties};var res=locationControl.coordFormatCallbacks[num](locationControl.coordinates,attr);// если есть res значит запомним ответ
    if(res&&locationControl.prevCoordinates!=res)locationControl.coordinates.innerHTML=res;locationControl.prevCoordinates=res;gmxAPI._listeners.dispatchEvent('onSetCoordinatesFormat',gmxAPI.map,num);},setCoordinatesFormatTimeout:null,prpPosition:function prpPosition(){if(locationControl.setCoordinatesFormatTimeout)return;locationControl.setCoordinatesFormatTimeout=setTimeout(function(){clearTimeout(locationControl.setCoordinatesFormatTimeout);locationControl.setCoordinatesFormatTimeout=null;if(gmxAPI.proxyType==='flash')locationControl.checkPositionChanged();locationControl.setCoordinatesFormat();},150);},getInterface:function getInterface(){return {remove:locationControl.remove,setVisible:locationControl.setVisible};}//Контролы слоев
    };var layersControl={id:'layers',parentNode:null,node:null,itemsContainer:null,mapInitListenerID:null,listeners:{},map:null,init:function init(cont){// инициализация
    layersControl.parentNode=cont;var regularStyle={paddingTop:"4px",paddingBottom:"4px",paddingLeft:"10px",paddingRight:"10px",fontSize:"12px",fontFamily:"sans-serif",fontWeight:"bold",textAlign:"center",cursor:"pointer",opacity:1,color:"white"};var activeStyle={paddingTop:"4px",paddingBottom:"4px",paddingLeft:"10px",paddingRight:"10px",fontSize:"12px",fontFamily:"sans-serif",fontWeight:"bold",textAlign:"center",cursor:"pointer",opacity:1,color:'orange'};var attr={'properties':{'className':'gmxTools'},'style':{},'regularStyle':regularStyle,'activeStyle':activeStyle,'contType':2// режим отключения выбора item
    };var baseLayersTools=new gmxAPI._ToolsContainer('baseLayers',attr);gmxAPI.baseLayersTools=baseLayersTools;gmxAPI.map.baseLayersTools=baseLayersTools;layersControl.toggleHandlers(true);layersControl._chkActiveChanged();gmxAPI.map.baseLayerControl.setVisible=baseLayersTools.setVisible;// обратная совместимость
    },remove:function remove(){// удаление
    layersControl.toggleHandlers(false);gmxAPI.baseLayersTools.remove();},_addBaseLayerTool:function _addBaseLayerTool(ph){var id=ph.id;var attr={onClick:function onClick(){gmxAPI.map.setBaseLayer(id);},onCancel:function onCancel(){gmxAPI.map.unSetBaseLayer();},hint:gmxAPI.KOSMOSNIMKI_LOCALIZED(ph.rus,ph.eng)||id};var tool=layersControl.map.baseLayersTools.chkBaseLayerTool(id,attr);if(tool)tool.setVisible(false);return tool;},_chkActiveChanged:function _chkActiveChanged(){var activeIDs=mbl.getActiveIDs();//console.log('onActiveChanged', activeIDs);
    var tools=layersControl.map.baseLayersTools;var pt={};for(var i=0,len=activeIDs.length;i<len;i++){var id=activeIDs[i];var tool=tools.getTool(id);var baseLayer=mbl.get(id);if(baseLayer){if(!tool)tool=layersControl._addBaseLayerTool(baseLayer);tool.setVisible(true);tools.setToolIndex(id,i);pt[id]=true;}else{if(tool)tool.setVisible(false);}}tools.forEach(function(item,i){var id=item.id;if(!pt[id]){tools.removeTool(id);}});var id=mbl.getCurrentID();if(id)tools.setActiveTool(id);},toggleHandlers:function toggleHandlers(flag){// Добавление прослушивателей событий
    if(flag){layersControl.map=gmxAPI.map;var key='onAdd';layersControl.listeners[key]=mbl.addListener(key,layersControl._chkActiveChanged);key='onActiveChanged';layersControl.listeners[key]=mbl.addListener(key,layersControl._chkActiveChanged);key='onSetCurrent';layersControl.listeners[key]=mbl.addListener(key,function(bl){layersControl.map.baseLayersTools.setActiveTool(bl?bl.id:'');});key='onRemove';layersControl.listeners[key]=layersControl.map.addListener(key,function(bl){layersControl.map.baseLayersTools.removeTool(bl?bl.id:'');});}else{for(var key in layersControl.listeners){layersControl.map.removeListener(key,layersControl.listeners[key]);}layersControl.listeners={};}},getInterface:function getInterface(){return gmxAPI.baseLayersTools;}};var drawingControl={id:'drawing',parentNode:null,node:null,hideNode:null,items:[],init:function init(cont){// инициализация
    // Установка drawing контролов
    var attr={properties:{className:'gmxTools'},style:{marginTop:'40px'},regularStyle:{paddingTop:"0px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",fontSize:"12px",fontFamily:"sans-serif",fontWeight:"bold",textAlign:"center",cursor:"pointer",opacity:1,color:"wheat"},activeStyle:{paddingTop:"0px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",fontSize:"12px",fontFamily:"sans-serif",fontWeight:"bold",textAlign:"center",cursor:"pointer",opacity:1,color:'orange'},contType:1// режим для drawing tools
    };var standartTools=new gmxAPI._ToolsContainer('standart',attr);var apiBase=gmxAPI.getAPIFolderRoot();var arr=[{key:"move",activeStyle:{},regularStyle:{},regularImageUrl:apiBase+"img/move_tool.png",activeImageUrl:apiBase+"img/move_tool_a.png",onClick:gmxAPI._drawFunctions.move,onCancel:function onCancel(){},hint:gmxAPI.KOSMOSNIMKI_LOCALIZED("Перемещение","Move")},{key:"zoom",activeStyle:{},regularStyle:{},regularImageUrl:apiBase+"img/select_tool.png",activeImageUrl:apiBase+"img/select_tool_a.png",onClick:gmxAPI._drawFunctions.zoom,onCancel:function onCancel(){},hint:gmxAPI.KOSMOSNIMKI_LOCALIZED("Увеличение","Zoom")},{key:"POINT",activeStyle:{},regularStyle:{},regularImageUrl:apiBase+"img/marker_tool.png",activeImageUrl:apiBase+"img/marker_tool_a.png",onClick:gmxAPI._drawFunctions.POINT,onCancel:gmxAPI._drawing.endDrawing,hint:gmxAPI.KOSMOSNIMKI_LOCALIZED("Маркер","Marker")},{key:"LINESTRING",activeStyle:{},regularStyle:{},regularImageUrl:apiBase+"img/line_tool.png",activeImageUrl:apiBase+"img/line_tool_a.png",onClick:gmxAPI._drawFunctions.LINESTRING,onCancel:gmxAPI._drawing.endDrawing,hint:gmxAPI.KOSMOSNIMKI_LOCALIZED("Линия","Line")},{key:"POLYGON",activeStyle:{},regularStyle:{},regularImageUrl:apiBase+"img/polygon_tool.png",activeImageUrl:apiBase+"img/polygon_tool_a.png",onClick:gmxAPI._drawFunctions.POLYGON,onCancel:gmxAPI._drawing.endDrawing,hint:gmxAPI.KOSMOSNIMKI_LOCALIZED("Полигон","Polygon")},{key:"FRAME",activeStyle:{},regularStyle:{},regularImageUrl:apiBase+"img/frame_tool.png",activeImageUrl:apiBase+"img/frame_tool_a.png",onClick:gmxAPI._drawFunctions.FRAME,onCancel:gmxAPI._drawing.endDrawing,hint:gmxAPI.KOSMOSNIMKI_LOCALIZED("Рамка","Rectangle")}];for(var i=0;i<arr.length;i++){standartTools.addTool(arr[i].key,arr[i]);}standartTools.selectTool("move");gmxAPI._drawing.control=gmxAPI.map.standartTools=standartTools;gmxAPI._listeners.addListener({level:-10,eventName:'mapCreated',func:function func(map){gmxAPI.map.drawing.addListener('onFinish',function(){var activeToolName=gmxAPI.map.standartTools.activeToolName;if(activeToolName==='FRAME'||activeToolName==='POLYGON'||activeToolName==='LINESTRING'||activeToolName==='POINT'||activeToolName==='zoom')gmxAPI.map.standartTools.selectTool("move");});}});},getInterface:function getInterface(){return gmxAPI.map.standartTools;}};outControls={zoomControl:zoomControl,minimizeTools:minimizeTools,geomixerLink:geomixerLink,copyrightControl:copyrightControl,locationControl:locationControl,drawingControl:drawingControl,layersControl:layersControl};gmxAPI.extend(Controls.controlsHash,outControls);for(var key in outControls){var item=outControls[key];if('init'in item)item.init(gmxAPI._allToolsDIV);}return outControls;};var Controls={id:'controlsBase',isActive:false,controlsHash:{},initControls:initControls,remove:function remove(){// удаление
    for(var key in Controls.controlsHash){var item=Controls.controlsHash[key];if('remove'in item)item.remove();}Controls.controlsHash={};},setControl:function setControl(id,control){if(Controls.controlsHash[id])return false;Controls.controlsHash[id]=control;return true;},getControl:function getControl(id){var control=this.controlsHash[id]||null;return control&&'getInterface'in control?control.getInterface():control;}};if(!gmxAPI._controls)gmxAPI._controls={};gmxAPI._controls[Controls.id]=Controls;})();(function(){var titles={locationTxt:gmxAPI.KOSMOSNIMKI_LOCALIZED("Текущие координаты центра карты","Current center coordinates"),coordFormatChange:gmxAPI.KOSMOSNIMKI_LOCALIZED("Сменить формат координат","Toggle coordinates format"),print:gmxAPI.KOSMOSNIMKI_LOCALIZED("Печать","Print"),permalink:gmxAPI.KOSMOSNIMKI_LOCALIZED("Пермалинк","Link to the map"),boxZoom:gmxAPI.KOSMOSNIMKI_LOCALIZED("Увеличение","BoxZoom"),marker:gmxAPI.KOSMOSNIMKI_LOCALIZED("Маркер","Marker"),polygon:gmxAPI.KOSMOSNIMKI_LOCALIZED("Многоугольник","Polygon"),line:gmxAPI.KOSMOSNIMKI_LOCALIZED("Линия","Line"),rectangle:gmxAPI.KOSMOSNIMKI_LOCALIZED("Прямоугольник","Rectangle"),toggleVisibility:gmxAPI.KOSMOSNIMKI_LOCALIZED("Показать/Скрыть","Show/Hide")};var styleIcon={// стиль ноды иконок по умолчанию
    borderRadius:'4px',display:'block',cursor:'pointer'//,width: '30px'
    //,height: '30px'
    ,marginLeft:'6px',styleFloat:'left',cssFloat:'left'};var standart={// интерфейс для обратной совместимости
    addTool:function addTool(tn,attr){// Добавление иконки или оверлея
    //console.log('tool addTool', tn, attr); // wheat
    if(!attr)attr={};var ret=null;if(attr.overlay&&Controls.items.layers){attr.id=tn;if(!attr.rus)attr.rus=attr.hint||attr.id;if(!attr.eng)attr.eng=attr.hint||attr.id;Controls.items.layers.addOverlay(tn,attr);ret=Controls.items.layers;// var layersControl = gmxAPI.map.controlsManager.getControl('layers');
    // if(layersControl) ret = layersControl.addOverlay(tn, attr);
    }else{ret=Controls.addControl(tn,attr);// var controls = gmxAPI.map.controlsManager.getCurrent();
    // if(controls && 'addControl' in controls) {
    // ret = controls.addControl(tn, attr);
    // }
    }return ret;},getToolByName:function getToolByName(id){return Controls.items[id]||null;},removeTool:function removeTool(id){// Удалить control
    return Controls.removeControl(id);},setVisible:function setVisible(id,flag){// видимость
    var control=Controls.items[id];},selectTool:function selectTool(id){var control=id==='POINT'?Controls.items.drawingPoint:Controls.items.gmxDrawing;control.setActive(id);}};var initControls=function initControls(){var mbl=gmxAPI.map.baseLayersManager;var controlsManager=gmxAPI.map.controlsManager;L.Control.gmxControl=L.Control.extend({options:{isVisible:true,id:'',onclick:null,onAdd:null,position:'topleft'},/** Установка видимости контрола.
                * @memberOf gmxControl#
                * @param {boolean} flag - флаг видимости контрола.
                */setVisible:function setVisible(flag){if(!flag)flag=false;if(this._container){this._container.style.display=flag?'block':'none';}this.options.isVisible=flag;},/** Установка флага активности контрола.
                * @memberOf gmxControl#
                * @param {boolean} flag - флаг активности контрола.
                */setActive:function setActive(flag,notToggle){var container=this._container,opt=this.options,isActive=opt.isActive||false;if(flag){if(!notToggle)opt.isActive=true;if(opt.srcHover)this._Image.src=opt.srcHover;L.DomUtil.addClass(container,'leaflet-control-Active');}else{if(!notToggle)opt.isActive=false;if(opt.src)this._Image.src=opt.src;L.DomUtil.removeClass(container,'leaflet-control-Active');}if(!notToggle&&isActive!==opt.isActive)gmxAPI._listeners.dispatchEvent('onActiveChanged',controlsManager,{id:this.options.id,isActive:opt.isActive,target:this});},addTo:function addTo(map){Controls.items[this.options.id]=this;this._map=map;var container=this._container=this.onAdd(map),pos=this.getPosition(),corner=map._controlCorners[pos]||map._controlContainer;L.DomUtil.addClass(container,'leaflet-control');if(pos.indexOf('bottom')!==-1){corner.insertBefore(container,corner.firstChild);}else{corner.appendChild(container);}return this;},_createDiv:function _createDiv(container,className,title,fn,context){var link=L.DomUtil.create('div',className,container);if(!this.options.isVisible)link.style.display='none';if(title)link.title=title;var stop=L.DomEvent.stopPropagation;L.DomEvent.on(link,'click',stop).on(link,'mousedown',stop).on(link,'dblclick',stop).on(link,'click',L.DomEvent.preventDefault).on(link,'click',fn||stop,context);return link;},_gmxOnClick:function _gmxOnClick(ev){if(this.options.onclick)this.options.onclick.call(this,{id:this.options.id,target:this});gmxAPI._listeners.dispatchEvent('onClick',controlsManager,{id:this.options.id,target:this});},_initLayout:function _initLayout(){var className=this.options.className||'leaflet-control-icons leaflet-control-'+this.options.id;var container=this._container=this._createDiv(null,className,this.options.title,this._gmxOnClick,this);return container;},onAdd:function onAdd(map){Controls.items[this.options.id]=this;var ret=this._initLayout();//gmxAPI.setStyleHTML(this._container, this.options.style || defaultStyle);
    if(this.options.onAdd)this.options.onAdd.call(this,ret);return ret;},setActiveTool:function setActiveTool(flag){// обратная совместимость
    this.setActive(flag);}});/**
             * Описание класса gmxControl.
             * Наследует класс <a href="http://leafletjs.com/reference.html#control">L.Control</a>.
             * @typedef {Object} gmxControl
             * @property {object} options - опции контрола.
             * @property {String} options.id - идентификатор контрола.
             * @property {boolean} options.isVisible - Флаг видимости(по умолчанию true).
             * @property {boolean} options.isActive - Флаг активности(по умолчанию false).
             * @property {Function} options.onclick - Ф-ция обработчик события click(по умолчанию null).
             * @property {Function} options.onAdd - Ф-ция обработчик события добавления контрола к карте(по умолчанию null).
            */L.control.gmxControl=function(options){return new L.Control.gmxControl(options);};// gmxZoom - контрол Zoom
    L.Control.gmxZoom=L.Control.Zoom.extend({options:{current:'',collapsed:false,zoomslider:true,isVisible:true,stepY:7},_y_min:9// min Y слайдера
    ,isDragging:false// min Y слайдера
    ,_listeners:{},onAdd:function onAdd(map){Controls.items[this.options.id]=this;var zoomName='gmx_zoomParent',container=L.DomUtil.create('div',zoomName);this._map=map;this._zoomPlaque=L.DomUtil.create('div','gmx_zoomPlaque',container);this._zoomInButton=this._createDiv(container,'gmx_zoomPlus','Zoom in',this._zoomIn,this);this._zoomOutButton=this._createDiv(container,'gmx_zoomMinus','Zoom out',this._zoomOut,this);map.on('zoomend zoomlevelschange',this._updateDisabled,this);if(this.options.zoomslider){this._chkZoomLevelsChange(container);}/*                var key = 'onMinMaxZoom';
                    this._listeners[key] = gmxAPI.map.addListener(key, function(ph) {
                        this._chkZoomLevelsChange(container);
                        var attr = ph.attr;
                        // zoomControl.minZoom = attr.minZoom;
                        // zoomControl.maxZoom = attr.maxZoom;
                        // zoomControl.setZoom(attr.currZ);
                        // zoomControl.repaint();
                    });
    */return container;},_createDiv:function _createDiv(container,className,title,fn,context){var link=L.DomUtil.create('div',className,container);if(title)link.title=title;var stop=L.DomEvent.stopPropagation;L.DomEvent.on(link,'click',stop).on(link,'mousedown',stop).on(link,'dblclick',stop).on(link,'click',L.DomEvent.preventDefault).on(link,'click',fn||stop,context);return link;},onRemove:function onRemove(map){map.off('zoomend zoomlevelschange',this._updateDisabled,this);},_setPosition:function _setPosition(){if(this._zoomVal){var MinZoom=this._map.getMinZoom(),y=this._y_max-(this._zoom-MinZoom)*7;this._zoomVal.innerHTML=this._zoom;L.DomUtil.setPosition(this._zoomPointer,L.point(4,y));}},_getZoomByY:function _getZoomByY(y){if(y<this._y_min)y=this._y_min;else if(y>this._y_max)y=this._y_max;return 0+Math.floor((this._y_max-y)/this.options.stepY);},_setSliderSize:function _setSliderSize(){var my=this,map=my._map,MinZoom=map.getMinZoom(),MaxZoom=map.getMaxZoom(),delta=MaxZoom-MinZoom;var height=7*(delta+1);my._y_max=height+3;my._zoomSliderBG.style.height=height+'px';height+=66;if(my._zoomSliderCont.style.display!=='block')height=60;my._zoomPlaque.style.height=height+'px';},_chkZoomLevelsChange:function _chkZoomLevelsChange(container){var my=this,map=my._map,MinZoom=map.getMinZoom(),MaxZoom=map.getMaxZoom();if(MinZoom!==my._MinZoom||MaxZoom!==my._MaxZoom){var delta=MaxZoom-MinZoom;if(MaxZoom<100&&delta>=0){if(!my._zoomSliderCont){my._zoomSliderCont=my._createDiv(container,'gmx_sliderCont');my._zoomSliderBG=my._createDiv(my._zoomSliderCont,'gmx_sliderBG');L.DomEvent.on(my._zoomSliderBG,'click',function(ev){my._zoom=my._getZoomByY(ev.layerY)+map.getMinZoom();my._map.setZoom(my._zoom);},my);my._zoomPointer=my._createDiv(my._zoomSliderCont,'gmx_zoomPointer');my._zoomVal=my._createDiv(my._zoomPointer,'gmx_zoomVal');L.DomEvent.on(container,'mouseover',function(ev){my._zoomSliderCont.style.display='block';my._setSliderSize();});var mouseout=function mouseout(){my._zoomSliderCont.style.display='none';my._setSliderSize();};L.DomEvent.on(container,'mouseout',function(ev){if(my._draggable._moving)return;mouseout();});var draggable=new L.Draggable(my._zoomPointer);draggable.on('drag',function(ev){var pos=ev.target._newPos;my._zoom=my._getZoomByY(pos.y)+map.getMinZoom();my._setPosition();});draggable.on('dragend',function(ev){my._map.setZoom(my._zoom);mouseout();});draggable.enable();my._draggable=draggable;}my._setSliderSize();}my._MinZoom=MinZoom,my._MaxZoom=MaxZoom;}my._zoom=map._zoom;my._setPosition();},_updateDisabled:function _updateDisabled(ev){var map=this._map,className='leaflet-disabled';L.DomUtil.removeClass(this._zoomInButton,className);L.DomUtil.removeClass(this._zoomOutButton,className);if(map._zoom===map.getMinZoom()){L.DomUtil.addClass(this._zoomOutButton,className);}if(map._zoom===map.getMaxZoom()){L.DomUtil.addClass(this._zoomInButton,className);}this._zoom=map._zoom;if(this.options.zoomslider){if(ev.type==='zoomlevelschange')this._chkZoomLevelsChange(this._container);this._setPosition();}},setVisible:function setVisible(flag){if(this._container){this._container.style.display=flag?'block':'none';}}});/**
             * Описание класса L.control.gmxZoom.
             * Наследует класс <a href="http://leafletjs.com/reference.html#control-zoom">L.Control.Zoom</a>.
             * @typedef {Object} gmxZoom
             * @property {object} options - опции контрола.
             * @property {String} options.id - идентификатор контрола.
             * @property {boolean} options.isVisible - Флаг видимости(по умолчанию true).
             * @property {boolean} options.zoomslider - Флаг добавления слайдера(по умолчанию true).
            */L.control.gmxZoom=function(options){return new L.Control.gmxZoom(options);};var gmxZoom=L.control.gmxZoom({id:'gmxZoom'});gmxAPI.map.zoomControl={setVisible:function setVisible(flag){gmxZoom.setVisible(flag);},setZoom:function setZoom(z){},repaint:function repaint(){},setMinMaxZoom:function setMinMaxZoom(z1,z2){},getMinZoom:function getMinZoom(){return gmxAPI.map.getMinZoom();},getMaxZoom:function getMaxZoom(){return gmxAPI.map.getMaxZoom();},minimize:function minimize(){},maximize:function maximize(){}};gmxZoom.addTo(gmxAPI._leaflet.LMap);//outControls.gmxZoom = gmxZoom;
    // gmxLayers - контрол слоев
    L.Control.gmxLayers=L.Control.Layers.extend({options:{current:'',collapsed:false,isVisible:true},_onInputClick:function _onInputClick(ev){var layerId=this._chkInput(ev.target);if(!this._layers[layerId].overlay){if(this.current!=layerId){this.current=layerId;ev.target.checked=true;}else{this.current=null;ev.target.checked=false;}mbl.setCurrentID(this.current?this._layers[layerId].layer.id:'');}},_update:function _update(){//L.Control.Layers.prototype._update.call(this);
    if(!this._container){return;}this._baseLayersList.innerHTML='';this._overlaysList.innerHTML='';var overlays=[],i,obj,id,len,hash={};for(i in this._layers){obj=this._layers[i];if(obj.overlay)overlays.push(obj);hash[obj.layer.id]=obj;}var activeIDs=mbl.getActiveIDs();for(i=0,len=activeIDs.length;i<len;i++){id=activeIDs[i];obj=hash[id];if(!obj||!obj.overlay&&!mbl.get(id))continue;this._addItem(obj);}if(overlays.length){for(i=0,len=overlays.length;i<len;i++){this._addItem(overlays[i]);}}len=activeIDs.length+overlays.length;this._container.style.display=len>0?'block':'none';this._separator.style.display=overlays.length&&activeIDs.length?'':'none';if(this.current)this.setCurrent(this.current,true);},setVisible:function setVisible(flag){if(!flag)flag=false;if(this._container){this._container.style.display=flag?'block':'none';}this.options.isVisible=flag;},setVisibility:function setVisibility(id,flag){var target=this._findTargetByID(id);if(target){target.checked=flag?true:false;var item=this._layers[target.layerId];if(item&&item.overlay&&item.layer){item.layer.isActive=target.checked;return true;}}return false;},_findTargetByID:function _findTargetByID(id){// Найти input поле подложки или оверлея
    for(var i=0,len=this._form.length;i<len;i++){var target=this._form[i];var item=this._layers[target.layerId];if(item&&item.layer&&id==item.layer.id)return target;}return null;},setCurrent:function setCurrent(id,skipChkInput){this.current=null;for(var i=0,len=this._form.length;i<len;i++){var input=this._form[i];if(id==input.layerId){if(!skipChkInput)this._chkInput(input);this.current=id;input.checked=true;}var item=this._layers[input.layerId];if(item.overlay&&item.layer.isActive)input.checked=true;}},_chkInput:function _chkInput(target){//var layers = this._layers;
    var layerId=String(target.layerId);var isActive=target.checked;var item=this._layers[layerId].layer;var overlay=item.overlay;if(overlay){if(isActive){if(item.onClick)item.onClick();}else{if(item.onCancel)item.onCancel();}item.isActive=isActive;}return layerId;},_listeners:{},_baseLayersHash:{},onAdd:function onAdd(map){Controls.items[this.options.id]=this;L.Control.Layers.prototype.onAdd.call(this,map);var my=this;var mbl=gmxAPI.map.baseLayersManager;var util={addBaseLayerTool:function addBaseLayerTool(baseLayer){var id=baseLayer.id;var name=gmxAPI.KOSMOSNIMKI_LOCALIZED(baseLayer.rus,baseLayer.eng)||id;my.addBaseLayer(baseLayer,name);},chkExists:function chkExists(){// Получить уже установленные подложки
    var activeIDs=mbl.getActiveIDs();for(var i=0,len=activeIDs.length;i<len;i++){var id=activeIDs[i];var baseLayer=mbl.get(id);if(baseLayer){util.addBaseLayerTool(baseLayer);}}mbl.setCurrentID(mbl.getCurrentID());},onActiveChanged:function onActiveChanged(){var i,obj,id,len,hash={};for(i in my._layers){obj=my._layers[i];hash[obj.layer.id]=obj;}var activeIDs=mbl.getActiveIDs();for(var i=0,len=activeIDs.length;i<len;i++){var id=activeIDs[i];var baseLayer=mbl.get(id);if(baseLayer){delete hash[id];util.addBaseLayerTool(baseLayer);}}for(i in hash){obj=hash[i];my.removeLayer(obj);}}};var key='onAdd';this._listeners[key]=mbl.addListener(key,util.onActiveChanged);key='onLayerChange';this._listeners[key]=mbl.addListener(key,util.onActiveChanged);key='onActiveChanged';this._listeners[key]=mbl.addListener(key,util.onActiveChanged);key='onSetCurrent';this._listeners[key]=mbl.addListener(key,function(bl){if(!bl||!mbl.isActiveID(bl.id)){for(var i=0,len=my._form.length;i<len;i++){var input=my._form[i];var item=my._layers[input.layerId];if(!item.overlay)input.checked=false;}my.current='';return;}//bl.isVisible = true;
    if(!bl._leaflet_id)util.addBaseLayerTool(bl);my.setCurrent(bl._leaflet_id);});key='onRemove';this._listeners[key]=mbl.addListener(key,function(bl){var layer=my._layers[bl._leaflet_id];my.removeLayer(layer);delete my._layers[bl._leaflet_id];my._update();});util.chkExists();return this._container;},onRemove:function onRemove(map){L.Control.Layers.prototype.onRemove.call(this,map);var mbl=gmxAPI.map.baseLayersManager;for(var key in this._listeners){mbl.removeListener(key,this._listeners[key]);}this._listeners={};delete Controls.items.layers;},addOverlayTool:function addOverlayTool(id,attr){// совместимость c addTool
    var my=this;var name=gmxAPI.KOSMOSNIMKI_LOCALIZED(attr.rus,attr.eng)||id;attr.overlay=true;attr.getIndex=function(){return my._overlaysList.childNodes.length;};this.addOverlay(attr,name);return {id:id,setActiveTool:function setActiveTool(flag){return my.setVisibility(this.id,flag);},setVisible:function setVisible(flag){if('setVisible'in my)my.setVisible(flag);else if(my._container)my._container.style.display=flag?'block':'none';},remove:function remove(){my.removeFrom(gmxAPI._leaflet.LMap);}};}});/**
             * Описание класса L.control.gmxLayers.
             * Наследует класс <a href="http://leafletjs.com/reference.html#control-layers">L.Control.Layers</a>.
             * @typedef {Object} gmxLayers
             * @property {object} options - опции контрола.
             * @property {String} options.id - идентификатор контрола.
            */L.control.gmxLayers=function(options){return new L.Control.gmxLayers({},{},options);};var gmxLayers=L.control.gmxLayers({id:'layers'});gmxLayers.addTo(gmxAPI._leaflet.LMap);//outControls.layers = gmxLayers;
    //gmxAPI._leaflet.gmxLayers = gmxLayers;
    // HideControls - кнопка управления видимостью всех контролов
    L.Control.hideControls=L.Control.gmxControl.extend({options:{notHide:true},setVisibility:function setVisibility(flag,allFlag){this.options.isVisible=flag;for(var key in Controls.items){var item=Controls.items[key];if(!item.options.notHide||allFlag){if(item._container)item._container.style.display=flag&&item.options.isVisible?'block':'none';else{console.warn('hideControls',item);}}}},_toggleVisible:function _toggleVisible(e){L.DomEvent.stopPropagation(e);var flag=!this.options.isVisible;this.setVisibility(flag);}});/**
             * Описание класса L.control.hideControls.
             * Наследует класс <a href="global.html#gmxControl">gmxControl</a>.
             * @typedef {Object} hideControls
             * @property {object} options - опции контрола.
             * @property {String} options.id - идентификатор контрола.
            */L.control.hideControls=function(options){return new L.Control.hideControls(options);};var hideControls=L.control.hideControls({title:titles.toggleVisibility,id:'hide',onclick:function onclick(e){this._toggleVisible(e);}});gmxAPI.extend(gmxAPI.map.allControls,{setVisible:function setVisible(flag){hideControls.setVisibility(flag,true);},minimize:function minimize(){this.setVisible(false);},maximize:function maximize(){this.setVisible(true);}});hideControls.addTo(gmxAPI._leaflet.LMap);//outControls.hideControls = hideControls;
    // BottomBG - подвал background
    L.Control.BottomBG=L.Control.gmxControl.extend({options:{notHide:true},onAdd:function onAdd(map){Controls.items[this.options.id]=this;var className='gmx_copyright_location',container=L.DomUtil.create('div',className);L.DomEvent.on(this._map._controlContainer,'dblclick',L.DomEvent.stopPropagation);L.DomUtil.create('div',className+'_bg',container);this._map=map;return container;}});/**
             * Описание класса L.control.BottomBG.
             * Наследует класс <a href="global.html#gmxControl">gmxControl</a>.
             * @typedef {Object} bottomBG
             * @property {object} options - опции контрола.
             * @property {String} options.id - идентификатор контрола.
            */var bottomBG=new L.Control.BottomBG({className:'gmx_copyright_location_bg',id:'bottomBG',position:'bottom'});bottomBG.addTo(gmxAPI._leaflet.LMap);//outControls.bottomBG = bottomBG;
    // LocationControls - 
    L.Control.LocationControls=L.Control.gmxControl.extend({options:{notHide:true},onAdd:function onAdd(map){Controls.items[this.options.id]=this;var className='gmx_location',container=L.DomUtil.create('div',className),my=this;this.locationTxt=L.DomUtil.create('span','gmx_locationTxt',container);this.locationTxt.title=titles.locationTxt;this.coordFormatChange=L.DomUtil.create('span','gmx_coordFormatChange',container);this.coordFormatChange.title=titles.coordFormatChange;this.scaleBar=L.DomUtil.create('span','gmx_scaleBar',container);this.scaleBarTxt=L.DomUtil.create('span','gmx_scaleBarTxt',container);this._map=map;var util={checkPositionChanged:function checkPositionChanged(ev){var attr=gmxAPI.getScaleBarDistance();if(!attr||attr.txt===my._scaleBarText&&attr.width===my._scaleBarWidth)return;my._scaleBarText=attr.txt;my._scaleBarWidth=attr.width;util.repaintScaleBar();},repaintScaleBar:function repaintScaleBar(){if(my._scaleBarText){gmxAPI.size(my.scaleBar,my._scaleBarWidth,4);my.scaleBarTxt.innerHTML=my._scaleBarText;gmxAPI._listeners.dispatchEvent('scaleBarRepainted',gmxAPI.map,container.clientWidth);}},coordFormat:0,setCoordinatesFormat:function setCoordinatesFormat(num,screenGeometry){if(!num)num=this.coordFormat;if(num<0)num=this.coordFormatCallbacks.length-1;else if(num>=this.coordFormatCallbacks.length)num=0;this.coordFormat=num;if(!screenGeometry)screenGeometry=gmxAPI.map.getScreenGeometry();var attr={screenGeometry:screenGeometry,properties:gmxAPI.map.properties};var res=this.coordFormatCallbacks[num](my.locationTxt,attr);// если есть res значит запомним ответ
    if(res&&my.prevCoordinates!=res)my.locationTxt.innerHTML=res;my.prevCoordinates=res;gmxAPI._listeners.dispatchEvent('onSetCoordinatesFormat',gmxAPI.map,num);},coordFormatCallbacks:[// методы формирования форматов координат
    function(){return util.getCoordinatesText();},function(){return util.getCoordinatesText();},function(){return util.getCoordinatesText();}],getCoordinatesText:function getCoordinatesText(currPos){return gmxAPI.getCoordinatesText(currPos,this.coordFormat);},showCoordinates:function showCoordinates(){//окошко с координатами
    if(this.coordFormat>2)return;// только для стандартных форматов.
    var oldText=this.getCoordinatesText();var text=window.prompt(titles.locationTxt+':',oldText);if(text&&text!=oldText)gmxAPI.map.moveToCoordinates(text);},nextCoordinatesFormat:function nextCoordinatesFormat(){this.coordFormat+=1;this.setCoordinatesFormat(this.coordFormat);}};L.DomEvent.on(this.coordFormatChange,'click',function(ev){util.nextCoordinatesFormat();},this);L.DomEvent.on(this.locationTxt,'click',function(ev){util.showCoordinates();},this);this._checkPositionChanged=function(ev){util.checkPositionChanged(ev);};map.on('moveend',this._checkPositionChanged,this);this._setCoordinatesFormat=function(ev){util.setCoordinatesFormat(util.coordFormat);};map.on('move',this._setCoordinatesFormat,this);gmxAPI.map.geomixerLinkSetVisible=function(flag){};gmxAPI.map.scaleBar={setVisible:function setVisible(flag){gmxAPI.setVisible(my.scaleBar,flag);}};gmxAPI.map.coordinates={setVisible:function setVisible(flag){container.style.display=flag?'block':'none';},addCoordinatesFormat:function addCoordinatesFormat(func){util.coordFormatCallbacks.push(func);return util.coordFormatCallbacks.length-1;},removeCoordinatesFormat:function removeCoordinatesFormat(num){util.coordFormatCallbacks.splice(num,1);return util.coordFormatCallbacks.length-1;},setFormat:util.setCoordinatesFormat};return container;},getWidth:function getWidth(){return this._container.clientWidth;},onRemove:function onRemove(map){map.off('moveend',this._checkPositionChanged,this);map.off('move',this._setCoordinatesFormat,this);}});/**
             * Контрол отображения текущего положения карты - класс L.control.LocationControls.
             * Наследует класс <a href="global.html#gmxControl">gmxControl</a>.
             * @typedef LocationControls
             * @property {object} options - опции контрола.
             * @property {String} options.id - идентификатор контрола.
            */var locationControl=new L.Control.LocationControls({position:'bottomright',id:'locationControl'});locationControl.addTo(gmxAPI._leaflet.LMap);//outControls.locationControl = locationControl;
    // CopyrightControls - Copyright
    L.Control.CopyrightControls=L.Control.gmxControl.extend({options:{notHide:true},onAdd:function onAdd(map){Controls.items[this.options.id]=this;var className='gmx_copyright_location',container=this._container=L.DomUtil.create('span',className);this._map=map;var my=this;var util={items:[],addItem:function addItem(obj,copyright,z1,z2,geo){util.removeItem(obj,copyright);var bounds=null;if(geo){bounds=gmxAPI.getBounds(geo.coordinates);}else if(obj.geometry){bounds=obj.bounds||gmxAPI.getBounds(obj.geometry.coordinates);}if(!z1)z1=0;if(!z2)z2=100;this.items.push([obj,copyright,z1,z2,bounds]);this.redraw();return true;},removeItem:function removeItem(obj,copyright){var arr=[];this.items.forEach(function(item,i){if(copyright&&copyright!==item[1]||obj!==item[0]){arr.push(item);}});util.items=arr;},redraw:function redraw(){// перерисовать с задержкой 
    if(util.redrawTimer)clearTimeout(util.redrawTimer);util.redrawTimer=setTimeout(function(){util.redrawTimer=null;util.redrawItems();},100);},redrawItems:function redrawItems(){// перерисовать
    var currPos=gmxAPI.currPosition||gmxAPI.map.getPosition();if(!currPos.latlng||!currPos.latlng.extent)return;var chkExists={};var texts=[//первым всегда будет располагаться копирайт СканЭкс. 
    "<a target='_blank' style='color: inherit;' href='http://maps.kosmosnimki.ru/Apikey/License.html'>&copy; 2007-2014 "+gmxAPI.KOSMOSNIMKI_LOCALIZED("&laquo;СканЭкс&raquo;","RDC ScanEx")+"</a>"];this.items.forEach(function(item,i){var obj=item[0];var copyright=item[1];if(!copyright||!obj.objectId||!obj.getVisibility())return;// обьекта нет на экране или без копирайта
    if(chkExists[copyright])return;// дубли копирайтов
    var z1=item[2],z2=item[3],bounds=item[4],zoom=map._zoom;if(zoom<z1||zoom>z2)return;if(bounds&&!gmxAPI.extIntersect(currPos.latlng.extent,bounds))return;chkExists[copyright]=true;texts.push(copyright.split("<a").join("<a target='_blank' style='color: inherit;'"));});if(gmxAPI.proxyType=='leaflet')texts.push("<a target='_blank' style='color: inherit;' href='http://leafletjs.com'>&copy; Leaflet</a>");var text=texts.join(' ');if(this.currentText!=text){this.currentText=text;container.innerHTML=text;gmxAPI._listeners.dispatchEvent('copyrightRepainted',gmxAPI.map,text);}util.chkWidth();},chkWidth:function chkWidth(locationWidth){if(Controls.items.locationControl&&'getWidth'in Controls.items.locationControl){var width=my._container.parentNode.clientWidth-30-Controls.items.locationControl.getWidth();my._container.style.width=(width>0?width:0)+'px';}}};gmxAPI.extend(gmxAPI.map,{addCopyrightedObject:function addCopyrightedObject(obj,copyright,z1,z2,geo){util.addItem(obj,copyright,z1,z2,geo);},removeCopyrightedObject:function removeCopyrightedObject(obj){util.removeItem(obj);util.redraw();},setCopyrightVisibility:function setCopyrightVisibility(obj){//copyrightControl.setVisible(obj);
    },updateCopyright:function updateCopyright(){util.redraw();},setCopyrightAlign:function setCopyrightAlign(attr){// Изменить позицию контейнера копирайтов
    //if(attr.align) copyrightControl.copyrightAlign = attr.align;
    //copyrightControl.setPosition();
    }});map.on('moveend',function(ev){util.redraw();},this);util.onChangeBackgroundColorID=gmxAPI.map.addListener('onChangeBackgroundColor',function(htmlColor){util.redraw();});return container;}});/**
             * Контрол отображения копирайтов - класс L.control.CopyrightControls.
             * Наследует класс <a href="global.html#gmxControl">L.Control.gmxControl</a>.
             * @typedef CopyrightControls
             * @property {object} options - опции контрола.
             * @property {String} options.id - идентификатор контрола.
            */var copyrightControls=new L.Control.CopyrightControls({position:'bottomleft',id:'copyrightControls'});copyrightControls.addTo(gmxAPI._leaflet.LMap);//outControls.copyrightControls = copyrightControls;
    // PrintControl - кнопка печати
    var printControl=L.control.gmxControl({title:titles.print,id:'print'//,type: 'print'
    ,isVisible:false});printControl.addTo(gmxAPI._leaflet.LMap);//outControls.printControl = printControl;
    // PermalinkControl - кнопка пермалинка
    var permalinkControl=L.control.gmxControl({title:titles.permalink,isVisible:false,id:'permalink'});permalinkControl.addTo(gmxAPI._leaflet.LMap);//outControls.permalinkControl = permalinkControl;
    // DrawingZoomControl - кнопка boxZoom
    var drawingZoomControl=L.control.gmxControl({title:titles.boxZoom,isActive:false,id:'drawingZoom',onclick:function onclick(e){var className='leaflet-control-icons leaflet-control-'+this.options.id+'-Active';if(!gmxAPI._drawing.BoxZoom){gmxAPI._drawFunctions.zoom();L.DomUtil.addClass(this._container,className);this.options.isActive=true;}else{this.options.isActive=false;gmxAPI._drawing.activeState=false;gmxAPI._drawing.BoxZoom=false;L.DomUtil.removeClass(this._container,className);}gmxAPI._listeners.dispatchEvent('onActiveChanged',controlsManager,{id:this.options.id,target:this});},onAdd:function onAdd(cont){Controls.items[this.options.id]=this;var my=this;this._map.on('boxzoomend',function(){L.DomUtil.removeClass(my._container,'leaflet-control-'+my.options.id+'-Active');my.options.isActive=false;gmxAPI._listeners.dispatchEvent('onActiveChanged',controlsManager,{id:my.options.id,target:my});});}});drawingZoomControl.addTo(gmxAPI._leaflet.LMap);//outControls.drawingZoomControl = drawingZoomControl;
    // DrawingPointControl - кнопка маркера
    var drawingPointControl=L.control.gmxControl({title:titles.marker,isActive:false,onFinishID:null,id:'drawingPoint',className:'leaflet-control-icons leaflet-control-drawingPoint',onclick:function onclick(e,pkey){var my=drawingPointControl;var className='leaflet-control-'+my.options.id+'-Active';var stop=function stop(){var isActive=my.options.isActive;if(my.options._drawFunc)my.options._drawFunc.stopDrawing();L.DomUtil.removeClass(my._container,className);if(my.options.onFinishID)gmxAPI.map.drawing.removeListener('onFinish',my.options.onFinishID);my.options.onFinishID=null;my.options.isActive=false;if(isActive)gmxAPI._listeners.dispatchEvent('onActiveChanged',controlsManager,{id:my.options.id,isActive:false,target:my});};my.options.activeStop=stop;if(!my.options.onFinishID){my.options.onFinishID=gmxAPI.map.drawing.addListener('onFinish',stop);}if(!my.options.isActive){my.options._drawFunc=gmxAPI._drawFunctions.POINT();L.DomUtil.addClass(my._container,className);my.options.isActive=true;gmxAPI._listeners.dispatchEvent('onActiveChanged',controlsManager,{id:my.options.id,isActive:true,target:my});}else{//gmxAPI._drawing.endDrawing();
    stop();}}});drawingPointControl.activeStop=function(){var opt=drawingPointControl.options;//if (key !== 'POINT') opt.isActive = true;
    if(opt&&'activeStop'in opt)opt.activeStop();};drawingPointControl.addTo(gmxAPI._leaflet.LMap);//outControls.drawingPointControl = drawingPointControl;
    L.Control.Drawing=L.Control.extend({options:{position:'topleft'},_createButton:function _createButton(item,container,fn,context){var className='leaflet-control-Drawing-'+item.key;var link=L.DomUtil.create('div',className,container);link.title=item.hint;var stop=L.DomEvent.stopPropagation;L.DomEvent.on(link,'click',stop).on(link,'mouseup',stop).on(link,'mousedown',stop).on(link,'dblclick',stop).on(link,'click',L.DomEvent.preventDefault).on(link,'click',fn,context);return link;},onAdd:function onAdd(map){Controls.items[this.options.id]=this;var container=L.DomUtil.create('div','leaflet-control-Drawing');L.DomEvent.on(container,'mouseout',function(e){container.style.height='30px';}).on(container,'mouseover',function(e){container.style.height='98px';});this._map=map;var arr=[{key:"POLYGON",style:{backgroundPosition:'-503px -33px'},hoverStyle:{backgroundPosition:'-503px -2px'// ,onClick: gmxAPI._drawFunctions.POLYGON
    // ,onCancel: gmxAPI._drawFunctions.POLYGON.stopDrawing
    },hint:titles.polygon},{key:"LINESTRING",style:{backgroundPosition:'-393px -33px'},hoverStyle:{backgroundPosition:'-393px -2px'// ,onClick: gmxAPI._drawFunctions.LINESTRING
    // ,onCancel: gmxAPI._drawFunctions.LINESTRING.stopDrawing
    },hint:titles.line},{key:"FRAME",style:{backgroundPosition:'-269px -33px'},hoverStyle:{backgroundPosition:'-269px -2px'// ,onClick: gmxAPI._drawFunctions.FRAME
    // ,onCancel: gmxAPI._drawFunctions.FRAME.stopDrawing
    },hint:titles.rectangle}];var my=this;var items={};my.options.activeKey=null;my.options.activeStop=null;arr.forEach(function(item){var key=item.key;var fn=function fn(){var activeKey=my.options.activeKey;if(activeKey&&activeKey!==key){my.options.activeStop();if(activeKey===key){return;}}var target=items[key];var className='leaflet-control-Drawing-'+key+'-Active';var stop=function stop(){if(target&&target.drawFunc){target.drawFunc.stopDrawing();}//gmxAPI._drawing.endDrawing();
    L.DomUtil.removeClass(target,className);if(my.options.onFinishID)gmxAPI.map.drawing.removeListener('onFinish',my.options.onFinishID);my.options.onFinishID=null;my.options.activeKey=null;my.options.activeStop=null;if(my.options.isActive){my.options.isActive=false;gmxAPI._listeners.dispatchEvent('onActiveChanged',controlsManager,{id:key,isActive:false,target:my});}my.options.isActive=false;};if(!my.options.onFinishID){my.options.onFinishID=gmxAPI.map.drawing.addListener('onFinish',stop);}if(!my.options.isActive){items[key].drawFunc=gmxAPI._drawFunctions[key]();if(target!=target.parentNode.firstChild){target.parentNode.insertBefore(target,target.parentNode.firstChild);}L.DomUtil.addClass(target,className);my.options.isActive=true;my.options.activeStop=stop;my.options.activeKey=key;drawingPointControl.activeStop();gmxAPI._listeners.dispatchEvent('onActiveChanged',controlsManager,{id:key,isActive:true,target:my});}else{stop();}};var resItem=my._createButton(item,container,fn,my);items[key]=resItem;resItem._setActive=fn;});this.options.items=items;return container;},setActive:function setActive(key){var my=this;var opt=my.options;var target=opt.items[key];if(target)target._setActive();else{for(var pKey in opt.items){var target=opt.items[pKey];my.options.isActive=true;target._setActive();}drawingPointControl.activeStop();}},setPosition:function setPosition(key,num){var target=this.options.items[key];if(target){if(num<-1)num=0;if(num>=this._container.childNodes.length-1){this._container.appendChild(target);}else{var source=this._container.childNodes[num];this._container.insertBefore(target,source);}}},onRemove:function onRemove(map){//console.log('onRemove ', this);
    //map.off('zoomend zoomlevelschange', this._updateDisabled, this);
    }});/**
             * Описание класса L.control.Drawing.
             * Наследует класс <a href="http://leafletjs.com/reference.html#control">L.Control</a>.
             * @typedef Drawing
             * @property {object} options - опции контрола.
             * @property {String} options.id - идентификатор контрола.
            */L.control.gmxDrawing=function(options){return new L.Control.Drawing(options);};// if(!gmxAPI.isMobile) {
    var gmxDrawing=L.control.gmxDrawing({id:'gmxDrawing',isVisible:true});gmxDrawing.addTo(gmxAPI._leaflet.LMap);//outControls.gmxDrawing = gmxDrawing;
    //gmxAPI.extend(Controls.controlsHash, outControls);
    //Управление ToolsAll
    (function(){//Управление ToolsAll
    function ToolsAll(cont){this.toolsAllCont=gmxAPI._allToolsDIV;gmxAPI._toolsContHash={};}gmxAPI._ToolsAll=ToolsAll;function ToolsContainer(name,attr){//console.log('ToolsContainer', name, attr);
    if(!attr)attr={};var cont={addTool:function addTool(tn,attr){//console.log('tool addTool', tn, attr); // wheat
    if(!attr)attr={};var ret=null;if(attr.overlay&&Controls.items.layers){//if(attr.overlay && gmxAPI._leaflet.gmxLayers) {
    attr.id=tn;if(!attr.rus)attr.rus=attr.hint||attr.id;if(!attr.eng)attr.eng=attr.hint||attr.id;var layersControl=gmxAPI.map.controlsManager.getControl('layers');if(layersControl){ret=layersControl.addOverlayTool(tn,attr);}}else{ret=Controls.addControl(tn,attr);// var controls = gmxAPI.map.controlsManager.getCurrent();
    // if(controls && 'addControl' in controls) {
    // ret = controls.addControl(tn, attr);
    // }
    }gmxAPI._tools[tn]=ret;return ret;}};//gmxAPI._tools[name] = cont;
    return cont;}gmxAPI._ToolsContainer=ToolsContainer;})();if('_ToolsAll'in gmxAPI){this.toolsAll=new gmxAPI._ToolsAll(parent);}gmxAPI._tools={standart:standart};var attr={'properties':{'className':'gmxTools'},'style':{},'contType':2// режим отключения выбора item
    };var baseLayersTools=new gmxAPI._ToolsContainer('baseLayers',attr);gmxAPI.baseLayersTools=baseLayersTools;return Controls.items;};/**
         * Описание класса Controls.
         * @constructor Controls
         * @property {String} id - Идентификатор набора контролов.
         * @property {boolean} isVisible - Флаг видимости(по умолчанию true).
         * @property {hash} items - список контролов(ниже перечислены создаваемые в API контролы по умолчанию).
         * @property {L.Control.hideControls} items.hide - <a href="global.html#hideControls">контрол управления видимостью</a>.
         * @property {L.Control.gmxLayers} items.layers - <a href="global.html#gmxLayers">контрол слоев</a>.
         * @property {L.Control.gmxZoom} items.gmxZoom - <a href="global.html#gmxZoom">контрол Zoom</a>.
         * @property {L.Control.Drawing} items.gmxDrawing - <a href="global.html#Drawing">контрол рисования геометрий</a>.
         * @property {L.Control.LocationControls} items.locationControl - <a href="global.html#LocationControls">контрол отображения текущего положения карты</a>.
         * @property {L.Control.CopyrightControls} items.copyrightControls - <a href="global.html#CopyrightControls">контрол копирайтов</a>.
         * @property {L.Control.gmxControl} items.print - контрол печати.
         * @property {L.Control.gmxControl} items.permalink - контрол пермалинка.
         * @property {L.Control.gmxControl} items.drawingZoom - контрол зуммирования по прямоугольнику.
         * @property {L.Control.gmxControl} items.drawingPoint - контрол установки маркера.
        */var Controls={id:'controlsBaseIcons',isVisible:true,items:{},/** Получить контрол по его идентификатору
            * @memberOf Controls#
            * @param {String} id идентификатор контрола.
            * @returns {Control| null} возвращает контрол либо null если контрол с данным идентификатором не найден
            */getControl:function getControl(id){//if(id === 'layers') id = 'gmxLayers';   // обратная совместимость
    return this.items[id]||null;},/** Добавить контрол
            * @memberOf Controls#
            * @param {String} id - идентификатор контрола.
            * @param {Object} pt - атрибуты контрола.
            * @param {String} pt.regularImageUrl - URL иконки контрола.
            * @param {String} pt.activeImageUrl - URL иконки при наведении мыши.
            * @param {Object} pt.style - регулярный стиль контрола.
            * @param {Object} pt.hoverStyle - стиль при наведении мыши.
            * @param {String} pt.rus - наименование русскоязычное(по умолчанию равен id).
            * @param {String} pt.eng - наименование англоязычное(по умолчанию равен id).
            * @param {Function} pt.onClick - функция при включении активности контрола (по умолчанию null).
            * @param {Function} pt.onCancel - функция при выключении активности контрола (по умолчанию null).
            * @returns {Control|null} созданный контрол либо null если контрол с данным идентификатором уже существует.
            */addControl:function addControl(id,pt){if(!id)id=pt.id;if(Controls.items[id])return null;// такой контрол уже имеется
    var title=pt.title||pt.hint;var attr={id:id,rus:pt.rus||title,eng:pt.eng||title,style:gmxAPI.extend(pt.style,styleIcon),hoverStyle:pt.hoverStyle};var className='leaflet-control-'+id,imageClassName='leaflet-control-Image';if(pt.regularImageUrl){attr.src=pt.regularImageUrl;// attr.style = {
    // position: 'relative'
    // ,background: 'rgba(154, 154, 154, 0.7)'
    // };
    }if(pt.activeImageUrl){attr.srcHover=pt.activeImageUrl;// attr.hoverStyle = {
    // position: 'relative'
    // ,background: 'rgba(154, 154, 154, 1)'
    // };
    }if(pt.onClick)attr.onClick=pt.onClick;if(pt.onCancel)attr.onCancel=pt.onCancel;//if(pt.overlay) attr.onCancel = pt.onCancel;
    if(!attr.src){// Текстовый контрол
    className+=' leaflet-control-Text';if(pt.innerHTML)attr.innerHTML=pt.innerHTML;else{attr.innerHTML=gmxAPI.KOSMOSNIMKI_LOCALIZED(attr.rus,attr.eng);}}else{className+=' leaflet-control-userIcons';if(!pt.style){className+=' leaflet-control-ImageAuto';}}// Добавление пользовательского контрола
    var userControl=L.control.gmxControl({title:gmxAPI.KOSMOSNIMKI_LOCALIZED(attr.rus,attr.eng),isActive:false,style:{},className:className,src:attr.src||null,srcHover:attr.srcHover||null,onFinishID:null,id:id,onAdd:function onAdd(){Controls.items[this.options.id]=this;var my=this;var container=this._container;if(attr.innerHTML){container.innerHTML=attr.innerHTML;L.DomUtil.addClass(container,'leaflet-control-Text');}else if(pt.regularImageUrl){gmxAPI.setStyleHTML(this._container,attr.style);this._Image=L.DomUtil.create('img',imageClassName);container.appendChild(this._Image);L.DomUtil.addClass(container,className);//L.DomUtil.addClass(container, 'leaflet-control-userIcons');
    }L.DomEvent.on(container,'mouseover',function(e){my.setActive(true,true);});L.DomEvent.on(container,'mouseout',function(e){if(!my.options.isActive)my.setActive(false,true);});this.setActive(false);},onclick:function onclick(e){var container=this._container;if(!this.options.isActive){if(attr.onClick)attr.onClick.call(this);this.setActive(true);}else{if(attr.onCancel)attr.onCancel.call(this);this.setActive(false);}}});userControl.addTo(gmxAPI._leaflet.LMap);Controls.items[id]=userControl;return userControl;},/** Удаление контрола по его идентификатору.
            * @memberOf Controls#
            * @param {String} id идентификатор контрола.
            * @returns {Control} возвращает удаленный контрол либо null если он не найден
            */removeControl:function removeControl(id){var control=this.items[id];if(control&&control._map&&'removeFrom'in control)control.removeFrom(control._map);delete this.items[id];return control;},/** Удаление набора контролов.
            * @memberOf Controls#
            */remove:function remove(){// удаление
    for(var key in this.items){var item=this.items[key];if('remove'in item)item.remove();}this.items={};},setControl:function setControl(id,control){if(Controls.items[id])return false;Controls.items[id]=control;control.addTo(gmxAPI._leaflet.LMap);return true;},initControls:initControls// остальное для обратной совместимости
    };if(!gmxAPI._controls)gmxAPI._controls={};gmxAPI._controls[Controls.id]=Controls;})();(function(){// получить minZoom maxZoom для слоя по фильтрам
    function getMinMaxZoom(prop){var minZoom=20,maxZoom=0;for(var i=0;i<prop.styles.length;i++){var style=prop.styles[i];minZoom=Math.min(style.MinZoom||gmxAPI.defaultMinZoom,minZoom);maxZoom=Math.max(style.MaxZoom||gmxAPI.defaultMaxZoom,maxZoom);}return {'minZoom':minZoom,'maxZoom':maxZoom};}// Подготовка атрибутов фильтра стилей 
    function getFilterAttr(style){// Получение стилей фильтра
    var regularStyle={};if(typeof style.StyleJSON!='undefined')regularStyle=style.StyleJSON;else if(typeof style.RenderStyle!='undefined')regularStyle=style.RenderStyle;else{// стиль по умолчанию
    if(style.PointSize)regularStyle.marker={size:parseInt(style.PointSize)};if(style.Icon){var src=style.Icon.indexOf("http://")!=-1?style.Icon:baseAddress+"/"+style.Icon;regularStyle.marker={image:src,"center":true};}if(style.BorderColor||style.BorderWidth)regularStyle.outline={color:gmxAPI.parseColor(style.BorderColor),thickness:parseInt(style.BorderWidth||"1"),opacity:style.BorderWidth=="0"?0:100};if(style.FillColor)regularStyle.fill={color:gmxAPI.parseColor(style.FillColor),opacity:100-parseInt(style.Transparency||"0")};var label=style.label||style.Label;if(label){regularStyle.label={field:label.FieldName,color:gmxAPI.parseColor(label.FontColor),size:parseInt(label.FontSize||"12")};}}if(regularStyle.marker)regularStyle.marker.center=true;var hoveredStyle=null;if(typeof style.HoverStyle!='undefined')hoveredStyle=style.HoverStyle;else{hoveredStyle=JSON.parse(JSON.stringify(regularStyle));if(hoveredStyle.marker&&hoveredStyle.marker.size)hoveredStyle.marker.size+=1;if(hoveredStyle.outline)hoveredStyle.outline.thickness+=1;}// Получение sql строки фильтра
    var name='';var sql='';if(style.Filter){if(/^\s*\[/.test(style.Filter)){var a=style.Filter.match(/^\s*\[([a-zA-Z0-9_]+)\]\s*([<>=]=?)\s*(.*)$/);if(a&&a.length==4){sql=a[1]+" "+a[2]+" '"+a[3]+"'";}}else{sql=style.Filter;}if(style.Filter.Name)name=style.Filter.Name;// имя фильтра - для map.layers в виде хэша
    }var DisableBalloonOnMouseMove='DisableBalloonOnMouseMove'in style?style.DisableBalloonOnMouseMove:true;var out={'name':name,'BalloonEnable':style.BalloonEnable||true,'DisableBalloonOnClick':style.DisableBalloonOnClick||false,'DisableBalloonOnMouseMove':DisableBalloonOnMouseMove,'regularStyle':regularStyle,'hoveredStyle':hoveredStyle,'MinZoom':style.MinZoom||gmxAPI.defaultMinZoom,'MaxZoom':style.MaxZoom||gmxAPI.defaultMaxZoom,'style':style,'sql':sql};if(style.Balloon)out.Balloon=style.Balloon;if(style.clusters)out.clusters=style.clusters;return out;}// Инициализация фильтра
    var initFilter=function initFilter(prnt,num){var filter=prnt.filters[num];var obj_=prnt.addObject(null,null,{'nodeType':'filter'});filter.objectId=obj_.objectId;var attr=filter._attr;filter.setFilter(attr.sql||'');filter.getPatternIcon=function(size){var ph=filter.getStyle(true);return gmxAPI.getPatternIcon(ph.regular,size);};filter.setZoomBounds(attr.MinZoom,attr.MaxZoom);filter._attr=attr;gmxAPI._listeners.dispatchEvent('initFilter',gmxAPI.map,{'filter':filter});// Проверка map Listeners на reSetStyles - для балунов
    filter.getBalloonTemplate=function(){return filter._balloonTemplate;};prnt.filters[num]=filter;gmxAPI.mapNodes[filter.objectId]=filter;var proxy=gmxAPI._cmdProxy;gmxAPI.extend(filter,{// переопределение свойств после установки видимости
    setStyleHook:function setStyleHook(func){// Установка стилевой функции пользователя
    return proxy('setStyleHook',{obj:filter,attr:{data:func}});},removeStyleHook:function removeStyleHook(){// удаление стилевой функции пользователя
    return proxy('removeStyleHook',{obj:filter,attr:{data:attr}});}});return filter;};// Добавление фильтра
    // Ключи :
    // * Balloon: текст баллуна
    // * BalloonEnable: показывать ли баллун
    // * DisableBalloonOnClick: не показывать при клике
    // * DisableBalloonOnMouseMove: не показывать при наведении
    // * RenderStyle: стиль фильтра
    // * MinZoom: мин.зум
    // * MaxZoom: макс.зум
    // * sql: строка фильтра
    var addFilter=function addFilter(prnt,attr){if(!attr)attr={};var filter=new gmxAPI._FMO(false,{},prnt);// MapObject для фильтра
    var num=prnt.filters.length;// Номер фильтра в массиве фильтров
    var lastFilter=num>0?prnt.filters[num-1]:null;// Последний существующий фильтр
    if(!attr&&lastFilter){attr=gmxAPI.clone(lastFilter._attr);}if(!attr.MinZoom)attr.MinZoom=gmxAPI.defaultMinZoom;if(!attr.MaxZoom)attr.MaxZoom=gmxAPI.defaultMaxZoom;filter._attr=attr;prnt.filters.push(filter);if(attr.name)prnt.filters[attr.name]=filter;if(!filter.clusters&&attr.clusters&&'_Clusters'in gmxAPI){filter.clusters=new gmxAPI._Clusters(filter);// атрибуты кластеризации потомков по фильтру
    filter.setClusters(attr.clusters);}gmxAPI.extend(filter,{// определение свойств до установки видимости
    setStyleHook:function setStyleHook(func){attr.styleHook=func;return true;},removeStyleHook:function removeStyleHook(){delete attr.styleHook;return true;}});gmxAPI._listeners.dispatchEvent('addFilter',prnt,{'filter':filter});// Listeners на слое - произошло добавление фильтра
    if(prnt.objectId)filter=initFilter(prnt,num);// если слой виден - инициализация фильтра
    // Удаление фильтра
    filter.remove=function(){var ret=gmxAPI._FMO.prototype.remove.call(this);if(prnt.filters[attr.name])delete prnt.filters[attr.name];for(var i=0;i<prnt.filters.length;i++){if(this==prnt.filters[i]){prnt.filters.splice(i,1);break;}}};return filter;};// Добавление слоя
    var addLayer=function addLayer(parentObj,layer,isVisible,isMerc){var FlashMapObject=gmxAPI._FMO;if(!parentObj.layers)parentObj.layers=[];if(!parentObj.layersParent){parentObj.layersParent=parentObj.addObject(null,null,{'layersParent':true});}if(!parentObj.overlays){parentObj.overlays=parentObj.addObject(null,null,{'overlaysParent':true});parentObj.addObject=function(geom,props,propHiden){var ret=FlashMapObject.prototype.addObject.call(parentObj,geom,props,propHiden);parentObj.overlays.bringToTop();return ret;};}var proxy=gmxAPI._cmdProxy;if(isVisible===undefined)isVisible=true;var obj=new gmxAPI._FMO(false,{},parentObj);// MapObject слоя
    var zIndex=parentObj.layers.length;if(!layer)layer={};if(!layer.properties)layer.properties={};if(!layer.properties.identityField)layer.properties.identityField="ogc_fid";obj.geometry=layer.geometry;if(obj.geometry){if(isMerc){obj.mercGeometry=obj.geometry;obj.geometry=gmxAPI.from_merc_geometry(obj.mercGeometry);}else{obj.mercGeometry=gmxAPI.merc_geometry(obj.geometry);}}else{obj.mercGeometry={'type':"POLYGON",'coordinates':[[[-20037500,-21133310],[-20037500,21133310],[20037500,21133310],[20037500,-21133310],[-20037500,-21133310]]]};obj.geometry=gmxAPI.from_merc_geometry(obj.mercGeometry);}var isRaster=layer.properties.type=="Raster";var layerName=layer.properties.name||layer.properties.image||gmxAPI.newFlashMapId();if(!layer.properties.name)layer.properties.name=layerName;//obj.geometry = layer.geometry;
    //obj.mercGeometry = layer.mercGeometry;
    obj.properties=layer.properties;obj.propHiden={'isLayer':true,'isMerc':isMerc};var isOverlay=false;var overlayLayerID=gmxAPI.getBaseMapParam("overlayLayerID","");if(typeof overlayLayerID=='string'){var arr=overlayLayerID.split(",");for(var i=0;i<arr.length;i++){if(layerName==arr[i]){isOverlay=true;break;}}}if(isOverlay)layer.properties.type="Overlay";obj.filters=[];obj.filters.foreach=function(callback){for(var i=0,len=obj.filters.length;i<len;i++){if(callback(obj.filters[i],i)===false)return;}};if(!isRaster){if(!layer.properties.styles){// стиль-фильтр по умолчанию
    layer.properties.styles=[{'BalloonEnable':true,'DisableBalloonOnClick':false,'DisableBalloonOnMouseMove':false,'MinZoom':gmxAPI.defaultMinZoom,'MaxZoom':gmxAPI.defaultMaxZoom,'RenderStyle':{'outline':{'color':255,'thickness':1}}}];}// Добавление начальных фильтров
    for(var i=0,len=layer.properties.styles.length;i<len;i++){var style=layer.properties.styles[i],attr=getFilterAttr(style);addFilter(obj,attr);}obj.addFilter=function(attr){return addFilter(obj,attr);};obj.getItem=function(pid,flagMerc){// Получить обьект векторного слоя
    return proxy('getItem',{'obj':obj,'attr':{layerId:obj.objectId,itemId:pid,flagMerc:flagMerc}});};obj.addItems=function(attr){// добавление обьектов векторного слоя
    return proxy('addItems',{'obj':obj,'attr':{'layerId':obj.objectId,'data':attr}});};obj.removeItems=function(attr){// удаление обьектов векторного слоя 
    return proxy('removeItems',{'obj':obj,'attr':{'layerId':obj.objectId,'data':attr}});};obj.setSortItems=function(attr){// установка сортировки обьектов векторного слоя 
    return proxy('setSortItems',{'obj':obj,'attr':{'layerId':obj.objectId,'data':attr}});};obj.setFlipItems=function(arr,flag){// Установить массив flip обьектов
    return proxy('setFlipItems',{'obj':obj,'attr':{layerId:obj.objectId,arr:arr,clear:flag}});};obj.getFlipItems=function(){// Получить массив id flip обьектов
    return proxy('getFlipItems',{'obj':obj,'attr':{layerId:obj.objectId}});};obj.setRasterViewItems=function(arr){// Установить видимость растров обьектов
    return proxy('setRasterViewItems',{'obj':obj,'attr':{'layerId':obj.objectId,'arr':arr}});};obj.bringToTopItem=function(fid){// Добавить обьект к массиву Flips обьектов
    return proxy('addFlip',{'obj':obj,'attr':{'layerId':obj.objectId,'fid':fid}});};obj.disableFlip=function(){// Отменить ротацию обьектов слоя
    return proxy('disableFlip',{'obj':obj,'attr':{'layerId':obj.objectId}});};obj.enableFlip=function(){// Установить ротацию обьектов слоя
    return proxy('enableFlip',{'obj':obj,'attr':{'layerId':obj.objectId}});};obj.setWatcher=function(attr){// Установка подглядывателя обьекта под Hover обьектом
    return proxy('setWatcher',{'obj':obj,'attr':attr});};obj.removeWatcher=function(){// Удалить подглядыватель
    return proxy('removeWatcher',{'obj':obj});};}var hostName=layer.properties.hostName||gmxAPI.map.defaultHostName||"maps.kosmosnimki.ru";var mapName=layer.properties.mapName||gmxAPI.currentMapName||"client_side_layer";var baseAddress="http://"+hostName+"/";var sessionKey=isRequiredAPIKey(hostName)?window.KOSMOSNIMKI_SESSION_KEY:false;var sessionKey2='sessionKeyCache'in window?window.sessionKeyCache[mapName]:false;var bounds=false;// в меркаторе
    var boundsLatLgn=false;var initBounds=function initBounds(geom){// geom в меркаторе
    if(geom){bounds=gmxAPI.getBounds(geom.coordinates);obj.bounds=boundsLatLgn={minX:gmxAPI.from_merc_x(bounds.minX),minY:gmxAPI.from_merc_y(bounds.minY),maxX:gmxAPI.from_merc_x(bounds.maxX),maxY:gmxAPI.from_merc_y(bounds.maxY)};if(geom.type==='MULTIPOLYGON'){obj.boundsArr=[];obj.boundsLatLgnArr=[];for(var i=0,len=geom.coordinates.length;i<len;i++){var ext=gmxAPI.getBounds(geom.coordinates[i]);obj.boundsArr.push(ext);obj.boundsLatLgnArr.push({minX:gmxAPI.from_merc_x(ext.minX),minY:gmxAPI.from_merc_y(ext.minY),maxX:gmxAPI.from_merc_x(ext.maxX),maxY:gmxAPI.from_merc_y(ext.maxY)});}}}};var getBoundsMerc=function getBoundsMerc(){if(!bounds)initBounds(obj.mercGeometry);return bounds;};obj.getLayerBounds=function(){// Получение boundsLatLgn для внешних плагинов
    if(!boundsLatLgn)initBounds(obj.mercGeometry);return obj.boundsLatLgnArr?obj.boundsLatLgnArr[0]:boundsLatLgn;};obj.getLayerBoundsArrayMerc=function(){// Получение массива bounds в меркаторе
    if(!boundsLatLgn)initBounds(obj.mercGeometry);return obj.boundsArr?obj.boundsArr:[bounds];};obj.getBoundsMerc=function(){// Получение boundsMerc в меркаторе
    return getBoundsMerc();};var tileSenderPrefixBase=baseAddress+"TileSender.ashx?ModeKey=tile"+"&MapName="+encodeURIComponent(mapName)+(sessionKey?"&key="+encodeURIComponent(sessionKey):"")+(sessionKey2?"&MapSessionKey="+encodeURIComponent(sessionKey2):"");var tileSenderPrefix=tileSenderPrefixBase+"&LayerName="+layerName;var tileFunction=function tileFunction(i,j,z){if(isRaster){if(!bounds)initBounds(obj.mercGeometry);var tileSize=gmxAPI.getScale(z)*256;var minx=i*tileSize;var maxx=minx+tileSize;if(maxx<bounds.minX){i+=Math.pow(2,z);}else if(minx>bounds.maxX){i-=Math.pow(2,z);}}return tileSenderPrefix+"&z="+z+"&x="+i+"&y="+j;};gmxAPI.extend(obj,{// определение свойств до установки видимости
    setDateInterval:function setDateInterval(dt1,dt2){// Установка временного интервала
    obj.dt1=dt1;obj.dt2=dt2;},getDateInterval:function getDateInterval(){// Получить временной интервал
    return {beginDate:obj.dt1,endDate:obj.dt2};},getTileCounts:function getTileCounts(dt1,dt2){// Получить количество тайлов по временному интервалу
    return 0;},setPositionOffset:function setPositionOffset(dx,dy){obj.shiftX=dx||0;obj.shiftY=dy||0;if(this.objectId)proxy('setPositionOffset',{obj:obj,attr:{shiftX:obj.shiftX,shiftY:obj.shiftY}});},getPositionOffset:function getPositionOffset(){return {shiftX:obj.shiftX||0,shiftY:obj.shiftY||0};},setStyleHook:function setStyleHook(func){// Установка стилевой функции пользователя
    obj.filters.foreach(function(item){item.setStyleHook(func);});return true;},removeStyleHook:function removeStyleHook(){// удаление стилевой функции пользователя
    obj.filters.foreach(function(item){item.removeStyleHook();});return true;},getStatus:function getStatus(pt){// Получить состояние слоя по видимому extent
    if(this.objectId)return proxy('getStatus',{obj:obj,attr:pt});return {isVisible:false};},freezeLoading:function freezeLoading(pt){// установить флаг игнорирования загрузки векторных тайлов
    obj._isLoadingFreezed=true;return true;},unfreezeLoading:function unfreezeLoading(pt){// удалить флаг игнорирования загрузки векторных тайлов
    obj._isLoadingFreezed=false;return true;},isLoadingFreezed:function isLoadingFreezed(pt){// получить флаг игнорирования загрузки векторных тайлов
    return obj._isLoadingFreezed;},chkLayerVersion:function chkLayerVersion(callback){// Запросить проверку версии невидимого слоя
    if(callback)callback({"Status":"notVisible"});return false;}});if(obj.properties){if('MetaProperties'in obj.properties){var meta=layer.properties.MetaProperties;if('shiftX'in meta||'shiftY'in meta){obj.shiftX=meta.shiftX?meta.shiftX.Value:0;obj.shiftY=meta.shiftY?meta.shiftY.Value:0;}}var isLayerVers=obj.properties.tilesVers||obj.properties.TemporalVers||false;if(gmxAPI._layersVersion&&isLayerVers){// Установлен модуль версий слоев + есть версии тайлов слоя
    gmxAPI._layersVersion.chkVersion(obj);obj.chkLayerVersion=function(callback){gmxAPI._layersVersion.chkLayerVersion(obj,callback);};}}if('shiftX'in obj)obj.setPositionOffset(obj.shiftX,obj.shiftY);var deferredMethodNames=['getChildren','getItemsFromExtent','getTileItem','setTileItem','getDepth','getZoomBounds','getVisibility','getStyle','getIntermediateLength','getCurrentEdgeLength','getLength','getArea','getGeometryType','getStat','flip','setZoomBounds','setBackgroundTiles','startLoadTiles','setVectorTiles','setTiles','setTileCaching','setImageExtent','setImage','bringToTop','bringToDepth','setDepth','bringToBottom','setGeometry','setActive','setEditable','startDrawing','stopDrawing','isDrawing','setLabel','setDisplacement','removeHandler','clearBackgroundImage','addObjects','addObjectsFromSWF','setHandler','setVisibilityFilter',//'remove', 'removeListener', 'addListener',
    'setClusters','addImageProcessingHook','removeImageProcessingHook','addClipPolygon','removeClipPolygon','addContextMenuItem','removeContextMenuItem','enableDragging','disableDragging','setStyle','setBackgroundColor','setCopyright','addObserver','enableTiledQuicklooks','enableTiledQuicklooksEx'];// не используемые команды addChildRoot getFeatureGeometry getFeatureLength getFeatureArea
    var createThisLayer=function createThisLayer(){var pObj=isOverlay?parentObj.overlays:parentObj.layersParent;var obj_=pObj.addObject(obj.geometry,obj.properties,obj.propHiden);obj.objectId=obj_.objectId;obj_.backgroundColor=obj.backgroundColor;obj_.stateListeners=obj.stateListeners;if(obj.isBaseLayer)obj_.isBaseLayer=obj.isBaseLayer;//            if(obj['_temporalTiles']) obj_['_temporalTiles'] = obj['_temporalTiles'];
    var isTemporal=obj.properties.Temporal||false;// признак мультивременного слоя
    if(isTemporal&&'_TemporalTiles'in gmxAPI){obj._temporalTiles=new gmxAPI._TemporalTiles(obj);}if(pObj.isMiniMap){obj.isMiniMap=true;// Все добавляемые к миникарте ноды имеют этот признак
    }obj_.getLayerBoundsLatLgn=function(){// Получение boundsLatLgn
    if(!boundsLatLgn)initBounds(obj.mercGeometry);return obj.boundsLatLgnArr?obj.boundsLatLgnArr[0]:boundsLatLgn;};obj_.getLayerBounds=obj_.getLayerBoundsLatLgn;obj_.getLayerBoundsMerc=function(){// Получение bounds в меркаторе
    if(!bounds)initBounds(obj.mercGeometry);return obj.boundsArr?obj.boundsArr:[bounds];};obj.addObject=function(geometry,props,propHiden){return FlashMapObject.prototype.addObject.call(obj,geometry,props,propHiden);};obj.tileSenderPrefix=tileSenderPrefix;// Префикс запросов за тайлами
    gmxAPI._listeners.dispatchEvent('onLayerCreated',obj,{'obj':obj});obj.setVisible=function(flag){FlashMapObject.prototype.setVisible.call(obj,flag);};for(var i=0;i<deferredMethodNames.length;i++){delete obj[deferredMethodNames[i]];}delete obj["getFeatures"];delete obj["getFeatureById"];obj.setHandler=function(eventName,handler){FlashMapObject.prototype.setHandler.call(obj,eventName,handler);if(gmxAPI.proxyType==='flash'){for(var i=0;i<obj.filters.length;i++){obj.filters[i].setHandler(eventName,handler);}}};obj.removeHandler=function(eventName){FlashMapObject.prototype.removeHandler.call(obj,eventName);if(gmxAPI.proxyType==='flash'){for(var i=0;i<obj.filters.length;i++){obj.filters[i].removeHandler(eventName);}}};obj.addListener=function(eventName,handler,level){var pID=FlashMapObject.prototype.addListener.call(obj,eventName,handler,level);if(gmxAPI.proxyType==='flash'){for(var i=0;i<obj.filters.length;i++){var fID=gmxAPI._listeners.addListener({'level':level,'pID':pID,'obj':obj.filters[i],'eventName':eventName,'func':handler});}}return pID;};obj.removeListener=function(eventName,eID){FlashMapObject.prototype.removeListener.call(obj,eventName,eID);if(gmxAPI.proxyType==='flash'){for(var i=0;i<obj.filters.length;i++){obj.filters[i].removeListener(eventName,eID);}// Удаляем массив события eventName по id события слоя
    }};obj._observerOnChange=null;obj.addObserver=function(o,onChange,attr){var observeByLayerZooms=false;if(typeof o=='function'){// вызов без доп. mapObject
    attr=onChange;onChange=o;o=obj.addObject();observeByLayerZooms=true;}var fAttr={'layerId':obj.objectId,'asArray':true,'ignoreVisibilityFilter':attr&&attr['ignoreVisibilityFilter']?true:false};var func=function func(arr){var out=[];for(var i=0;i<arr.length;i++){var item=arr[i];var geo=gmxAPI.proxyType==='leaflet'?item.geometry:gmxAPI.from_merc_geometry(item.geometry);var mObj=new gmxAPI._FlashMapFeature(geo,item.properties,obj);var ph={'onExtent':item.onExtent,'item':mObj,'isVisibleFilter':item['isVisibleFilter'],'status':item['status']};out.push(ph);}for(var j=0;j<obj._observerOnChange.length;j++){var ph=obj._observerOnChange[j];if(out.length)ph[0](out);}};fAttr['func']=func;if(!obj._observerOnChange){proxy('observeVectorLayer',{'obj':o,'attr':fAttr});obj._observerOnChange=[];}obj._observerOnChange.push([onChange,fAttr['ignoreVisibilityFilter']]);if(observeByLayerZooms){proxy('setAPIProperties',{'obj':obj,'attr':{'observeByLayerZooms':true}});// есть новый подписчик события изменения видимости обьектов векторного слоя
    }};if(obj.stateListeners.onChangeLayerVersion)obj.chkLayerVersion();var stylesMinMaxZoom=getMinMaxZoom(layer.properties);if(isRaster){var ph={'func':tileFunction,'projectionCode':0,'minZoom':layer.properties['MinZoom'],'maxZoom':layer.properties['MaxZoom'],'minZoomView':stylesMinMaxZoom['minZoom']||1,'maxZoomView':stylesMinMaxZoom['maxZoom']||30,'tileSenderPrefix':tileSenderPrefix,'bounds':bounds};proxy('setBackgroundTiles',{'obj':obj,'attr':ph});}else{obj.getFeatures=function(){var callback,geometry,str;for(var i=0;i<3;i++){var arg=arguments[i];if(typeof arg=='function')callback=arg;else if(typeof arg=='string')str=arg||' ';else if(_typeof(arg)=='object')geometry=arg;}//if (!str && (obj.properties.GeometryType == "point")) {
    if(!str){proxy('getFeatures',{'obj':obj,'attr':{'geom':geometry,'func':callback}});}else{if(str===' ')str='';gmxAPI.map.getFeatures(str,geometry,callback,[obj.properties.name]);// Поиск через JSONP запрос
    }};obj.getFeaturesByCenter=function(func){proxy('getFeatures',{'obj':obj,'attr':{'center':true,'func':func}});};obj.getFeatureById=function(fid,func){proxy('getFeatureById',{'obj':obj,'attr':{'fid':fid,'func':func}});};obj.setStyle=function(style,activeStyle){for(var i=0;i<obj.filters.length;i++){obj.filters[i].setStyle(style,activeStyle);}};if(obj._temporalTiles){// Для мультивременных слоёв
    obj._temporalTiles.setVectorTiles();}else{if(!layer.properties.tiles)layer.properties.tiles=[];obj.setVectorTiles(tileFunction,layer.properties.identityField,layer.properties.tiles);}for(var i=0;i<obj.filters.length;i++){obj.filters[i]=initFilter(obj,i);}// Изменить атрибуты векторного обьекта из загруженных тайлов
    obj.setTileItem=function(data,flag){var _obj=proxy('setTileItem',{'obj':this,'attr':{'data':data,'flag':flag?true:false}});return _obj;};// Получить атрибуты векторного обьекта из загруженных тайлов id по identityField
    obj.getTileItem=function(vId){var _obj=proxy('getTileItem',{'obj':this,'attr':vId});if(_obj.geometry)_obj.geometry=gmxAPI.from_merc_geometry(_obj.geometry);return _obj;};obj.getStat=function(){// Это только во Flash
    var _obj=proxy('getStat',{'obj':this});return _obj;};obj.setTiles=function(data,flag){var _obj=proxy('setTiles',{'obj':obj,'attr':{'tiles':data,'flag':flag?true:false}});return _obj;};obj.addClipPolygon=function(geo){return proxy('addClipPolygon',{'obj':obj,'attr':{'geo':geo}});};obj.removeClipPolygon=function(){return proxy('removeClipPolygon',{'obj':obj});};if(layer.properties.IsRasterCatalog){var RCMinZoomForRasters=layer.properties.RCMinZoomForRasters||1;obj.enableTiledQuicklooks(function(o){//var qURL = tileSenderPrefix + '&x={x}&y={y}&z={z}&idr=' + o.properties[layer.properties.identityField];
    var qURL=tileSenderPrefixBase+'&x={x}&y={y}&z={z}&LayerName='+encodeURIComponent(o.properties['GMX_RasterCatalogID']);return qURL;},RCMinZoomForRasters,layer.properties.TiledQuicklookMaxZoom,tileSenderPrefix);obj.getRCTileUrl=function(x,y,z,pid){return tileSenderPrefix+'&x='+x+'&y='+y+'&z='+z+'&idr='+pid;};obj.addImageProcessingHook=function(func){return proxy('addImageProcessingHook',{'obj':obj,'attr':{'func':func}});};obj.removeImageProcessingHook=function(){return proxy('removeImageProcessingHook',{'obj':obj});};}else{if(layer.properties.Quicklook);if(layer.properties.TiledQuicklook){obj.enableTiledQuicklooks(function(o){return gmxAPI.applyTemplate(layer.properties.TiledQuicklook,o.properties);},layer.properties.TiledQuicklookMinZoom);}}}for(var i=0,len=obj.filters.length;i<len;i++){var filter=obj.filters[i];filter.setStyle(filter._attr.regularStyle,filter._attr.hoveredStyle);if(filter._attr.clusters)filter.setClusters(filter._attr.clusters);delete filter.setVisible;delete filter.setStyle;delete filter.setFilter;delete filter.enableHoverBalloon;delete filter.setClusters;filter.setZoomBounds=FlashMapObject.prototype.setZoomBounds;}// Установка видимости по Zoom
    obj.setZoomBounds(stylesMinMaxZoom.minZoom,stylesMinMaxZoom.maxZoom);if(!obj.isMiniMap){// если это не miniMap
    if(layer.properties.Copyright){obj.setCopyright(layer.properties.Copyright);}}if(obj_.tilesParent)obj.tilesParent=obj_.tilesParent;gmxAPI.extend(obj,{// переопределение свойств после установки видимости
    removeContextMenuItem:function removeContextMenuItem(itemId){return proxy('removeContextMenuItem',{obj:obj,attr:{id:itemId}});},addContextMenuItem:function addContextMenuItem(text,callback,index){if(!obj.stateListeners.contextmenu){obj.addListener('contextmenu',function(attr){var ev=attr.target;ev.latlng=attr.event.latlng;gmxAPI._leaflet.contextMenu.showMenu({obj:obj,attr:ev});// Показать меню
    });}return proxy('addContextMenuItem',{obj:obj,attr:{text:text,index:index,func:function func(x,y,target){if(gmxAPI.proxyType==='flash'){x=gmxAPI.from_merc_x(x);y=gmxAPI.from_merc_y(y);}callback(x,y,target);}}});},freezeLoading:function freezeLoading(pt){// установить флаг игнорирования загрузки векторных тайлов
    obj._isLoadingFreezed=true;proxy('setFreezeLoading',{obj:obj,attr:true});return true;},unfreezeLoading:function unfreezeLoading(pt){// удалить флаг игнорирования загрузки векторных тайлов
    obj._isLoadingFreezed=false;proxy('setFreezeLoading',{obj:obj,attr:false});return true;},isLoadingFreezed:function isLoadingFreezed(pt){// получить флаг игнорирования загрузки векторных тайлов
    return proxy('isLoadingFreezed',{obj:obj});}});if(obj._isLoadingFreezed)proxy('setFreezeLoading',{obj:obj,attr:true});obj.addListener('onChangeLayerVersion',function(){initBounds(obj.mercGeometry);});};//obj.mercGeometry = layer.mercGeometry;
    if(gmxAPI.proxyType==='flash')initBounds(obj.mercGeometry);obj.isVisible=isVisible;//if (isVisible || gmxAPI.proxyType === 'leaflet') {   // В leaflet версии deferredMethod не нужны
    if(isVisible){createThisLayer();//var zIndexCur = getIndexLayer(obj.objectId);
    obj.bringToDepth(zIndex);gmxAPI._listeners.dispatchEvent('onLayer',obj,obj);// Вызов Listeners события 'onLayer' - слой теперь инициализирован во Flash
    }else{var deferred=[];obj.setVisible=function(flag,notDispatch){if(flag){createThisLayer();if(obj.objectId)FlashMapObject.prototype.setVisible.call(obj,flag,notDispatch);// без Dispatch события
    for(var i=0;i<deferred.length;i++){deferred[i]();}//var zIndexCur = getIndexLayer(obj.objectId);
    gmxAPI._listeners.dispatchEvent('onLayer',obj,obj);// Вызов Listeners события 'onLayer' - слой теперь инициализирован во Flash
    gmxAPI._listeners.dispatchEvent('onChangeVisible',obj,true);// слой теперь виден
    if('backgroundColor'in obj)gmxAPI.map.setBackgroundColor(obj.backgroundColor);}};if(!isRaster){// Изменять атрибуты векторного обьекта при невидимом слое нельзя
    obj.setTileItem=function(data,flag){return false;};// Получить атрибуты векторного обьекта при невидимом слое нельзя
    obj.getTileItem=function(vId){return null;};}obj.addObject=function(geometry,props,propHiden){obj.setVisible(true);var newObj=FlashMapObject.prototype.addObject.call(obj,geometry,props,propHiden);//FlashMapObject.prototype.setVisible.call(obj, false, true);  // без Dispatch события
    //obj.setVisible(false);
    return newObj;};for(var i=0,len=deferredMethodNames.length;i<len;i++){(function(name){obj[name]=function(p1,p2,p3,p4){deferred.push(function(){obj[name].call(obj,p1,p2,p3,p4);});};})(deferredMethodNames[i]);}obj.addListener=function(eventName,handler,level){var evID=gmxAPI.newFlashMapId();if(eventName==='onChangeLayerVersion'){gmxAPI._listeners.addListener({'obj':obj,'evID':evID,'eventName':eventName,'func':handler,'level':level});}else{deferred.push(function(){gmxAPI._listeners.addListener({'obj':obj,'evID':evID,'eventName':eventName,'func':handler,'level':level});if(gmxAPI.proxyType==='flash'){for(var i=0;i<obj.filters.length;i++){gmxAPI._listeners.addListener({'level':level,'pID':evID,'obj':obj.filters[i],'eventName':eventName,'func':handler});}}});}return evID;};if(gmxAPI.proxyType==='leaflet')obj.bringToDepth(zIndex);if(!isRaster){obj.getFeatures=function(arg1,arg2,arg3){obj.setVisible(true,true);obj.getFeatures(arg1,arg2,arg3);FlashMapObject.prototype.setVisible.call(obj,false,true);// без Dispatch события
    //obj.setVisible(false);
    };obj.getFeatureById=function(arg1,arg2,arg3){obj.setVisible(true);obj.getFeatureById(arg1,arg2,arg3);FlashMapObject.prototype.setVisible.call(obj,false,true);// без Dispatch события
    //obj.setVisible(false);
    };for(var i=0,len=layer.properties.styles.length;i<len;i++){(function(i){obj.filters[i].setZoomBounds=function(minZoom,maxZoom){if(!obj.filters[i]['_attr'])obj.filters[i]['_attr']={};obj.filters[i]['_attr']['MinZoom']=minZoom;obj.filters[i]['_attr']['MaxZoom']=maxZoom;deferred.push(function(){obj.filters[i].setZoomBounds(minZoom,maxZoom);});};obj.filters[i].setVisible=function(flag){deferred.push(function(){obj.filters[i].setVisible(flag);});};obj.filters[i].setStyle=function(style,activeStyle){deferred.push(function(){obj.filters[i].setStyle(style,activeStyle);});};obj.filters[i].setFilter=function(sql){if(!obj.filters[i]['_attr'])obj.filters[i]['_attr']={};obj.filters[i]['_attr']['sql']=sql;deferred.push(function(){obj.filters[i].setFilter(sql);});return true;};obj.filters[i].enableHoverBalloon=function(callback,attr){deferred.push(function(){obj.filters[i].enableHoverBalloon(callback,attr);});};obj.filters[i].setClusters=function(attr){obj.filters[i]._clustersAttr=attr;deferred.push(function(){obj.filters[i].setClusters(attr);});};})(i);}}}if(parentObj.layers[layerName]){for(var i=parentObj.layers.length-1;i>=0;i--){// Удаление слоя из массива
    var prop=parentObj.layers[i].properties;if(prop.name===layerName){parentObj.layers.splice(i,1);break;}}}parentObj.layers.push(obj);parentObj.layers[layerName]=obj;if(!layer.properties.title)layer.properties.title='layer from client '+layerName;if(!layer.properties.title.match(/^\s*[0-9]+\s*$/))parentObj.layers[layer.properties.title]=obj;obj.addListener('onChangeVisible',function(flag){// Изменилась видимость слоя
    gmxAPI._listeners.dispatchEvent('hideBalloons',gmxAPI.map,{'from':obj.objectId});// Проверка map Listeners на hideBalloons
    },-10);obj.addListener('BeforeLayerRemove',function(){// Удаляется слой
    gmxAPI._listeners.dispatchEvent('AfterLayerRemove',obj,layerName);// Удален слой
    },-10);obj._clearLayer=function(){// Чистка map.layers при удалении слоя
    //if(!layerName) layerName = obj.properties.name;
    for(var i=0,len=gmxAPI.map.layers.length;i<len;i++){// Удаление слоя из массива
    var prop=gmxAPI.map.layers[i].properties;if(prop.name===layerName){gmxAPI.map.layers.splice(i,1);break;}}for(key in gmxAPI.map.layers){// Удаление слоя из хэша
    var prop=gmxAPI.map.layers[key].properties;if(prop.name===layerName){delete gmxAPI.map.layers[key];}}};obj.addListener('AfterLayerRemove',function(){// Удален слой
    obj._clearLayer(obj.properties.name);},101);// Перед всеми пользовательскими Listeners
    if(obj.objectId)gmxAPI.mapNodes[obj.objectId]=obj;gmxAPI._listeners.dispatchEvent('onLayerAdd',gmxAPI.map,obj);// Добавлен слой
    return obj;};//расширяем FlashMapObject
    gmxAPI.extendFMO('addLayer',function(layer,isVisible,isMerc){//if(layer && layer.geometry && !isMerc) layer.geometry = gmxAPI.merc_geometry(layer.geometry);
    var obj=addLayer(this,layer,isVisible,isMerc);gmxAPI._listeners.dispatchEvent('onAddExternalLayer',gmxAPI.map,obj);// Добавлен внешний слой
    return obj;});})();(function(){var intervalID=0;var chkVersionTimeOut=20000;var versionLayers={};// Версии слоев по картам
    // Запрос обновления версий слоев карты mapName
    function sendVersionRequest(host,mapName,arr,callback){if(arr.length>0){gmxAPI.sendCrossDomainPostRequest('http://'+host+'/Layer/CheckVersion.ashx',{'WrapStyle':'message','layers':'['+arr.join(',')+']'},function(response){if(response&&response.Result&&response.Result.length>0){// Обработка запроса изменения версий слоев
    CheckVersionResponse({host:host,mapName:mapName,arr:response.Result});}if(callback)callback(response);});}}// Проверка версий слоев
    function chkVersion(e){if(gmxAPI.isPageHidden())return;var layersArr=gmxAPI.map.layers;for(var host in versionLayers){var arr=[];for(var mapName in versionLayers[host]){for(var layerName in versionLayers[host][mapName]){var layer=layersArr[layerName];if(layer&&(layer.isVisible||layer.stateListeners.onChangeLayerVersion)){arr.push('{ "Name":"'+layerName+'","Version":'+layer.properties.LayerVersion+' }');}}}if(arr.length>0){sendVersionRequest(host,mapName,arr);arr=[];}}}var setVersionCheck=function setVersionCheck(msek){if(intervalID)clearInterval(intervalID);intervalID=setInterval(chkVersion,msek);};var mapInitID=gmxAPI._listeners.addListener({'eventName':'mapInit','func':function func(map){setVersionCheck(chkVersionTimeOut);gmxAPI._listeners.removeListener(null,'mapInit',mapInitID);}});// Обработка ответа запроса CheckVersion
    function CheckVersionResponse(inp){var mapHost=inp.host;var arr=[];for(var i=0,len=inp.arr.length;i<len;i++){var ph=inp.arr[i],layerName=ph.properties.name,layer=gmxAPI.map.layers[layerName],mapName=layer.properties.mapName,prev=versionLayers[mapHost][mapName],ptOld=prev[layerName]||{};// обновить версию слоя
    layer.properties.LayerVersion=ph.properties.LayerVersion;layer._Processing=chkProcessing(layer,ph.properties);var pt=null;var attr={processing:layer._Processing,notClear:true,refresh:true};if('_temporalTiles'in layer){// мультивременной слой	- обновить в Temporal.js
    pt=layer._temporalTiles.getTilesHash(ph.properties,ptOld.tilesHash);if(pt.count!=ptOld.count||pt.add.length>0||pt.del.length>0){layer.properties.TemporalTiles=ph.properties.TemporalTiles;layer.properties.TemporalVers=ph.properties.TemporalVers;attr.add=pt.add;attr.del=pt.del;attr.ut1=pt.ut1;attr.ut2=pt.ut2;attr.dtiles=pt.dtiles;}}else{pt=getTilesHash(ph.properties,ptOld.tilesHash);if(pt.count!=ptOld.count||pt.add.length>0||pt.del.length>0){layer.properties.tiles=attr.tiles=ph.properties.tiles;layer.properties.tilesVers=attr.tilesVers=ph.properties.tilesVers;attr.add=pt.add;attr.del=pt.del;}}versionLayers[mapHost][mapName][layerName]={'LayerVersion':layer.properties.LayerVersion,'tilesHash':pt.hash,'count':pt.count};layer.geometry=gmxAPI.from_merc_geometry(ph.geometry);// Обновить геометрию слоя
    gmxAPI._listeners.dispatchEvent('onChangeLayerVersion',layer,layer.properties.LayerVersion);// Listeners на слое - произошло изменение LayerVersion
    // обновить список тайлов слоя
    if(attr.add||attr.del||attr.dtiles){gmxAPI._cmdProxy('startLoadTiles',{obj:layer,attr:attr});}}return arr;}// Формирование Hash списка версий тайлов
    function getTilesHash(prop,ph){var tiles=prop.tiles||[],tilesVers=prop.tilesVers||[],len=tiles.length,out={hash:{},del:{},add:[],count:len,res:false};// в hash - Hash списка версий тайлов, в res = true - есть изменения с ph
    for(var i=0;i<len;i+=3){var x=tiles[i],y=tiles[i+1],z=tiles[i+2],v=tilesVers[i/3];var arr=[x,y,z,v];var st=arr.join('_');out.hash[st]=true;if(ph&&!ph[st]){out.add.push(arr);out.del[z+'_'+x+'_'+y]=true;}}if(ph){for(var key in ph){if(!out.hash[key]){var arr=key.split('_');out.del[arr[2]+'_'+arr[0]+'_'+arr[1]]=true;}}}return out;}// Получить список обьектов слоя добавляемых через addobjects
    function getAddObjects(Processing){var arr=[];if(Processing.Updated&&Processing.Updated.length>0){arr=arr.concat(Processing.Updated);}if(Processing.Inserted&&Processing.Inserted.length>0){arr=arr.concat(Processing.Inserted);}return arr;}// Обработка списка редактируемых обьектов слоя	//addobjects
    function chkProcessing(obj,prop){var flagEditItems=false;var removeIDS={};if(prop.Processing.Deleted&&prop.Processing.Deleted.length>0){// список удаляемых обьектов слоя
    for(var i=0,len=prop.Processing.Deleted.length;i<len;i++){// добавляемые обьекты также необходимо удалить из тайлов
    removeIDS[prop.Processing.Deleted[i]]=true;flagEditItems=true;}}var arr=getAddObjects(prop.Processing);// addobjects
    for(var i=0,len=arr.length;i<len;i++){// добавляемые обьекты также необходимо удалить из тайлов
    var pt=arr[i];removeIDS[pt.id]=true;flagEditItems=true;}var out={removeIDS:removeIDS,addObjects:arr};if(flagEditItems){gmxAPI._cmdProxy('setEditObjects',{obj:obj,attr:out});gmxAPI.addDebugWarnings({'func':'chkProcessing','warning':'Processing length: '+arr.length,'layer':prop.title});}return out;}var ret={'chkVersionLayers':function chkVersionLayers(layers,layer){if(!('LayerVersion'in layer.properties))return;var prop=layer.properties;if(!prop.tilesVers&&!prop.TemporalVers)return false;var mapHost=prop.hostName||layers.properties.hostName;var mapName=prop.mapName||layers.properties.name;if(!versionLayers[mapHost])versionLayers[mapHost]={};if(!versionLayers[mapHost][mapName])versionLayers[mapHost][mapName]={};var layerObj='stateListeners'in layer?layer:gmxAPI.map.layers[prop.name];var pt='_temporalTiles'in layerObj?layerObj._temporalTiles.getTilesHash(prop):getTilesHash(prop);versionLayers[mapHost][mapName][prop.name]={'LayerVersion':layer.properties.LayerVersion,'tilesHash':pt.hash,'count':pt.count};},'chkVersion':function chkVersion(layer){// Обработка списка редактируемых обьектов слоя
    if(!layer||!('Processing'in layer.properties))return;var onLayerID=layer.addListener('onLayer',function(ph){layer.removeListener('onLayer',onLayerID);if(!layer.properties.tilesVers&&!layer.properties.TemporalVers)return false;gmxAPI._layersVersion.chkVersionLayers(layer.parent,layer);ph._Processing=chkProcessing(ph,ph.properties);// слой инициализирован во Flash
    });var BeforeLayerRemoveID=layer.addListener('BeforeLayerRemove',function(layerName){// Удаляется слой
    layer.removeListener('BeforeLayerRemove',BeforeLayerRemoveID);if(layer.properties.name!=layerName)return false;var mapHost=layer.properties.hostName;if(!versionLayers[mapHost])return false;var mapName=layer.properties.mapName;if(!versionLayers[mapHost][mapName])return false;delete versionLayers[mapHost][mapName][layer.properties.name];//gmxAPI._listeners.dispatchEvent('AfterLayerRemove', layer, layer.properties.name);	// Удален слой
    },-9);},'chkLayerVersion':function chkLayerVersion(layer,callback){// Запросить проверку версии слоя
    var prop=layer.properties;if(!prop.tilesVers&&!prop.TemporalVers)return false;sendVersionRequest(prop.hostName,prop.mapName,['{ "Name":"'+prop.name+'","Version":'+prop.LayerVersion+' }'],callback);},'setVersionCheck':setVersionCheck// Переустановка задержки запросов проверки версий слоев
    };//расширяем namespace
    gmxAPI._layersVersion=ret;})();(function(){var addNewMap=function addNewMap(rootObjectId,layers,callback){var map=new gmxAPI._FMO(rootObjectId,{},null);// MapObject основной карты
    gmxAPI.map=map;gmxAPI.mapNodes[rootObjectId]=map;// основная карта
    if(!layers.properties)layers.properties={};map.properties=layers.properties;if(!layers.children)layers.children=[];//map.onSetVisible = {};
    map.isVisible=true;map.layers=[];map.rasters=map;map.tiledQuicklooks=map;map.vectors=map;var getDefaultPos=function getDefaultPos(prop){return {x:typeof prop.DefaultLong==='number'?prop.DefaultLong:map.needMove?map.needMove.x:35,y:typeof prop.DefaultLat==='number'?prop.DefaultLat:map.needMove?map.needMove.y:50,z:typeof prop.DefaultZoom==='number'?prop.DefaultZoom:map.needMove?map.needMove.z:4};};map.needMove=getDefaultPos(layers.properties);map.needSetMode=null;// Методы присущие только Map
    map.setDistanceUnit=function(attr){map.DistanceUnit=attr;return true;};map.setSquareUnit=function(attr){map.SquareUnit=attr;return true;};map.getDistanceUnit=function(){return map.DistanceUnit;};map.getSquareUnit=function(){return map.SquareUnit;};map.sendPNG=function(attr){var ret=gmxAPI._cmdProxy('sendPNG',{'attr':attr});return ret;};map.savePNG=function(fileName){gmxAPI._cmdProxy('savePNG',{'attr':fileName});};map.trace=function(val){gmxAPI._cmdProxy('trace',{'attr':val});};map.setQuality=function(val){gmxAPI._cmdProxy('setQuality',{'attr':val});};map.disableCaching=function(){gmxAPI._cmdProxy('disableCaching',{});};map.print=function(){gmxAPI._cmdProxy('print',{});};map.repaint=function(){gmxAPI._cmdProxy('repaint',{});};map.moveTo=function(x,y,z){var pos={'x':x,'y':y,'z':z};if(gmxAPI.proxyType=='leaflet'&&map.needMove){if(!pos.z)pos.z=map.needMove.z||map.getZ();map.needMove=pos;}else{//setCurrPosition(null, {'currPosition': {'x':gmxAPI.merc_x(x), 'y':gmxAPI.merc_y(y), 'z':z}});
    map.needMove=null;gmxAPI._cmdProxy('moveTo',{'attr':pos});}};map.slideTo=function(x,y,z){gmxAPI._cmdProxy('slideTo',{'attr':{'x':x,'y':y,'z':z}});};map.freeze=function(){gmxAPI._cmdProxy('freeze',{});};map.unfreeze=function(){gmxAPI._cmdProxy('unfreeze',{});};map.setCursor=function(url,dx,dy){gmxAPI._cmdProxy('setCursor',{'attr':{'url':url,'dx':dx,'dy':dy}});};map.clearCursor=function(){gmxAPI._cmdProxy('clearCursor',{});};map.zoomBy=function(dz,useMouse){gmxAPI._cmdProxy('zoomBy',{'attr':{'dz':-dz,'useMouse':useMouse}});gmxAPI._listeners.dispatchEvent('zoomBy',gmxAPI.map);// Проверка map Listeners на zoomBy
    };map.getBestZ=function(minX,minY,maxX,maxY){if(minX==maxX&&minY==maxY)return 17;return Math.max(0,17-Math.ceil(Math.log(Math.max(Math.abs(gmxAPI.merc_x(maxX)-gmxAPI.merc_x(minX))/gmxAPI.flashDiv.clientWidth,Math.abs(gmxAPI.merc_y(maxY)-gmxAPI.merc_y(minY))/gmxAPI.flashDiv.clientHeight))/Math.log(2)));};var gplForm=false;map.loadObjects=function(url,callback){var _hostname=gmxAPI.getAPIHostRoot()+"ApiSave.ashx?get="+encodeURIComponent(url);sendCrossDomainJSONRequest$1(_hostname,function(response){if(_typeof(response)!='object'||response['Status']!='ok'){gmxAPI.addDebugWarnings({'_hostname':_hostname,'url':url,'Error':'bad response'});return;}var geometries=gmxAPI.parseGML(response['Result']);callback(geometries);});};map.saveObjects=function(geometries,fileName,format){var inputName,inputText;if(!gplForm){gplForm=document.createElement('<form>'),inputName=document.createElement('<input>'),inputText=document.createElement('<input>');}else{gplForm=document.getElementById('download_gpl_form'),inputName=gplForm.firstChild,inputText=gplForm.lastChild;}gplForm.setAttribute('method','post');var _hostname=gmxAPI.getAPIHostRoot();gplForm.setAttribute('action',_hostname+'ApiSave.ashx');gplForm.style.display='none';inputName.value=fileName;inputName.setAttribute('name','name');if(!format)format="gml";inputText.value=gmxAPI.createGML(geometries,format.toLowerCase());inputText.setAttribute('name','text');gplForm.appendChild(inputName);gplForm.appendChild(inputText);document.body.appendChild(gplForm);gplForm.submit();};map.moveToCoordinates=function(text,z){return gmxAPI.parseCoordinates(text,function(x,y){map.moveTo(x,y,z?z:map.getZ());});};map.getMinZoom=function(){return gmxAPI.proxyType==='flash'?map.zoomControl?map.zoomControl.getMinZoom():17:gmxAPI._cmdProxy('getMinZoom');};map.getMaxZoom=function(){return gmxAPI.proxyType==='flash'?map.zoomControl?map.zoomControl.getMaxZoom():17:gmxAPI._cmdProxy('getMaxZoom');};map.zoomToExtent=function(minx,miny,maxx,maxy){var x=gmxAPI.from_merc_x((gmxAPI.merc_x(minx)+gmxAPI.merc_x(maxx))/2),y=gmxAPI.from_merc_y((gmxAPI.merc_y(miny)+gmxAPI.merc_y(maxy))/2);var z=map.getBestZ(minx,miny,maxx,maxy);var maxZ=map.getMaxZoom();map.moveTo(x,y,z>maxZ?maxZ:z);};map.slideToExtent=function(minx,miny,maxx,maxy){var x=gmxAPI.from_merc_x((gmxAPI.merc_x(minx)+gmxAPI.merc_x(maxx))/2),y=gmxAPI.from_merc_y((gmxAPI.merc_y(miny)+gmxAPI.merc_y(maxy))/2);var z=map.getBestZ(minx,miny,maxx,maxy);var maxZ=map.getMaxZoom();map.slideTo(x,y,z>maxZ?maxZ:z);};var tmp=[// Для обратной совместимости - методы ранее были в MapObject
    'saveObjects','loadObjects','getBestZ','zoomBy','clearCursor','setCursor','unfreeze','freeze','slideTo','moveTo','repaint','print','disableCaching','setQuality','trace','savePNG','sendPNG','moveToCoordinates','zoomToExtent','slideToExtent'];for(var i=0;i<tmp.length;i++){gmxAPI.extendFMO(tmp[i],map[tmp[i]]);}map.stopDragging=function(){gmxAPI._cmdProxy('stopDragging',{});};map.isDragging=function(){return gmxAPI._cmdProxy('isDragging',{});};map.resumeDragging=function(){gmxAPI._cmdProxy('resumeDragging',{});};map.setCursorVisible=function(flag){gmxAPI._cmdProxy('setCursorVisible',{'attr':{'flag':flag}});};map.getPosition=function(){gmxAPI.currPosition=gmxAPI._cmdProxy('getPosition',{});return gmxAPI.currPosition;};map.getX=function(){return map.needMove?map.needMove['x']:gmxAPI._cmdProxy('getX',{});};map.getY=function(){return map.needMove?map.needMove['y']:gmxAPI._cmdProxy('getY',{});};map.getZ=function(){return map.needMove?map.needMove['z']:gmxAPI.currPosition?gmxAPI.currPosition.z:gmxAPI._cmdProxy('getZ',{});};map.getMouseX=function(){return gmxAPI._cmdProxy('getMouseX',{});};map.getMouseY=function(){return gmxAPI._cmdProxy('getMouseY',{});};map.isKeyDown=function(code){return gmxAPI._cmdProxy('isKeyDown',{'attr':{'code':code}});};map.setExtent=function(x1,x2,y1,y2){return gmxAPI._cmdProxy('setExtent',{'attr':{'x1':x1,'x2':x2,'y1':y1,'y2':y2}});};map.addMapWindow=function(callback){var oID=gmxAPI._cmdProxy('addMapWindow',{'attr':{'callbackName':function callbackName(z){return callback(z);}}});return new gmxAPI._FMO(oID,{},null);// MapObject миникарты
    };map.width=function(){return gmxAPI._div.clientWidth;};map.height=function(){return gmxAPI._div.clientHeight;};map.getItemsFromExtent=function(x1,x2,y1,y2){var arr=[];for(var i=0;i<map.layers.length;i++){arr.push(map.layers[i].objectId);}return gmxAPI._cmdProxy('getItemsFromExtent',{'obj':this,'attr':{'layers':arr,'extent':{'x1':gmxAPI.merc_x(x1),'x2':gmxAPI.merc_x(x2),'y1':gmxAPI.merc_y(y1),'y2':gmxAPI.merc_y(y2)}}});};map.getItemsFromPosition=function(){var arr=[];for(var i=0;i<map.layers.length;i++){arr.push(map.layers[i].objectId);}return gmxAPI._cmdProxy('getItemsFromExtent',{'obj':this,'attr':{'layers':arr}});};// Использование SharedObject
    map.setFlashLSO=function(data){return gmxAPI._cmdProxy('setFlashLSO',{'obj':this,'attr':data});};map.baseLayersManager=new gmxAPI.BaseLayersManager(map);map.controlsManager=new gmxAPI.ControlsManager(map,gmxAPI._div);var params=gmxAPI.getURLParams().params;if(gmxAPI.proxyType==='flash')params.gmxControls='controlsBase';map.controlsManager.setCurrent(params.gmxControls||window.gmxControls||'controlsBase');gmxAPI._listeners.dispatchEvent('mapInit',null,map);// Глобальный Listeners
    var toolHandlers={};var userHandlers={};var updateMapHandler=function updateMapHandler(eventName){var h1=toolHandlers[eventName];var h2=userHandlers[eventName];gmxAPI._FMO.prototype.setHandler.call(map,eventName,h1?h1:h2?h2:null);};map.setHandler=function(eventName,callback){userHandlers[eventName]=callback;updateMapHandler(eventName);};var setToolHandler=function setToolHandler(eventName,callback){toolHandlers[eventName]=callback;updateMapHandler(eventName);};gmxAPI._setToolHandler=setToolHandler;var setToolHandlers=function setToolHandlers(handlers){for(var eventName in handlers){setToolHandler(eventName,handlers[eventName]);}};map.getFeatures=function(){var callback,geometry,str=null;for(var i=0;i<3;i++){var arg=arguments[i];if(typeof arg=='function')callback=arg;else if(typeof arg=='string')str=arg;else if(_typeof(arg)=='object')geometry=arg;}var layerNames=arguments[3];if(!layerNames){layerNames=[];for(var i=0;i<map.layers.length;i++){var layer=map.layers[i];if(layer.properties.type=='Vector'&&layer.AllowSearch)layerNames.push(layer.properties.name);}}if(layerNames.length==0){callback([]);return;}//var searchScript = "/SearchObject/SearchVector.ashx";
    var searchScript="/VectorLayer/Search.ashx";var url="http://"+map.layers[layerNames[0]].properties.hostName+searchScript;var attr,func;{attr={'WrapStyle':'message','page':0,'pagesize':100000,'geometry':true,'layer':layerNames.join(","),'query':str!=null?str:''};func=function func(searchReq){var ret=[];if(searchReq.Status=='ok'){var fields=searchReq.Result.fields;var arr=searchReq.Result.values;for(var i=0,len=arr.length;i<len;i++){var req=arr[i];var item={};var prop={};for(var j=0,len1=req.length;j<len1;j++){var fname=fields[j];var it=req[j];if(fname==='geomixergeojson'){item.geometry=gmxAPI.from_merc_geometry(it);}else{prop[fname]=it;}}item.properties=prop;ret.push(new gmxAPI._FlashMapFeature(item.geometry,item.properties,map.layers[layerNames]));}}callback(ret);};if(geometry){attr['border']=JSON.stringify(gmxAPI.merc_geometry(geometry));}}gmxAPI.sendCrossDomainPostRequest(url,attr,func);};map.geoSearchAPIRoot=typeof window.searchAddressHost!=='undefined'?window.searchAddressHost:gmxAPI.getAPIHostRoot();map.sendSearchRequest=function(str,callback){var key=window.KOSMOSNIMKI_SESSION_KEY;if(key==null||key=="INVALID")key=false;sendCrossDomainJSONRequest$1(map.geoSearchAPIRoot+"SearchObject/SearchAddress.ashx?SearchString="+escape(str)+(key?"&key="+encodeURIComponent(key):""),function(res){var ret={};if(res.Status=='ok'){for(var i=0;i<res.Result.length;i++){var name=res.Result[i].name;if(!ret[name])ret[name]=res.Result[i].SearchResult;}}callback(ret);});};map.setMinMaxZoom=function(z1,z2){if(gmxAPI.proxyType==='flash'&&gmxAPI.map.zoomControl)gmxAPI.map.zoomControl.setMinMaxZoom(z1,z2);return gmxAPI._cmdProxy('setMinMaxZoom',{'attr':{'z1':z1,'z2':z2}});};map.setZoomBounds=map.setMinMaxZoom;map.grid={setVisible:function setVisible(flag){gmxAPI._cmdProxy('setGridVisible',{'attr':flag});},getVisibility:function getVisibility(){return gmxAPI._cmdProxy('getGridVisibility',{});},setOneDegree:function setOneDegree(flag){gmxAPI._cmdProxy('setOneDegree',{'attr':flag});}};map.setMinMaxZoom(1,17);if(gmxAPI._drawing){map.drawing=gmxAPI._drawing;}else{map.drawing={'setHandlers':function setHandlers(){return false;},'forEachObject':function forEachObject(){return false;}};}map.removeContextMenuItem=function(itemId){return gmxAPI._cmdProxy('removeContextMenuItem',{'attr':{id:itemId}});};map.addContextMenuItem=function(text,callback,index){return gmxAPI._cmdProxy('addContextMenuItem',{'attr':{text:text,index:index,func:function func(x,y){if(gmxAPI.proxyType==='flash'){x=gmxAPI.from_merc_x(x);y=gmxAPI.from_merc_y(y);}callback(x,y);}}});};if(gmxAPI._drawing){map.addContextMenuItem(gmxAPI.KOSMOSNIMKI_LOCALIZED("Поставить маркер","Add marker"),function(x,y){map.drawing.addObject({type:"POINT",coordinates:[x,y]});});}var haveOSM=false;map.addLayers=function(layers,notMoveFlag,notVisible){var reverse=false;if(layers.properties.name===gmxAPI.currentMapName){// Это основная карта
    if(layers.properties.MinZoom){// установлен MinZoom карты
    gmxAPI.mapMinZoom=layers.properties.MinZoom;}if(layers.properties.MaxZoom){// установлен MaxZoom карты
    gmxAPI.mapMaxZoom=layers.properties.MaxZoom;if(gmxAPI.mapMinZoom>gmxAPI.mapMaxZoom){// mapMinZoom не больше MaxZoom
    gmxAPI.mapMinZoom=1;}}}else if(layers.properties.name===gmxAPI.kosmosnimki_API){reverse=true;}var mapBounds=gmxAPI.getBounds();var minLayerZoom=20;forEachLayer(layers,function(layer,isVisible){var visible=layer.properties.visible?true:isVisible;var lObj=map.addLayer(layer,visible,true);if(reverse){map.layers.pop();map.layers.unshift(lObj);}if('LayerVersion'in layer.properties&&gmxAPI._layersVersion){gmxAPI._layersVersion.chkVersionLayers(layers,layer);}if(visible&&lObj.mercGeometry)mapBounds.update(lObj.mercGeometry.coordinates);var arr=layer.properties.styles||[];for(var i=0;i<arr.length;i++){var mm=arr[i].MinZoom;minLayerZoom=Math.min(minLayerZoom,mm);}if(layer.properties.type=="Raster"&&layer.properties.MaxZoom>gmxAPI.maxRasterZoom)gmxAPI.maxRasterZoom=layer.properties.MaxZoom;},notVisible);//if (layers.properties.UseOpenStreetMap && !haveOSM)
    var baseLayer=map.baseLayersManager.get('OSM');//if (!baseLayer !haveOSM)
    if(!baseLayer){var o=map.addObject();//o.setVisible(false);
    o.bringToBottom();//o.setAsBaseLayer("OSM");
    baseLayer=map.baseLayersManager.add('OSM',{});//map.baseLayersManager.add('OSM', {isVisible:false});
    baseLayer.addLayer(o);o.setOSMTiles();haveOSM=true;o.setVisible(false);/*
                    if('miniMap' in map) {
                        var miniOSM = map.miniMap.addObject();
                        miniOSM.setVisible(false);
                        miniOSM.setOSMTiles();
                        miniOSM.setAsBaseLayer("OSM");
                    }
    */}if(gmxAPI.initParams&&gmxAPI.initParams['center']){// есть переопределение центра карты
    if('x'in gmxAPI.initParams['center'])map.needMove['x']=gmxAPI.initParams['center']['x'];if('y'in gmxAPI.initParams['center'])map.needMove['y']=gmxAPI.initParams['center']['y'];if('z'in gmxAPI.initParams['center'])map.needMove['z']=gmxAPI.initParams['center']['z'];//delete gmxAPI.initParams['center'];
    }else{if(typeof layers.properties.DefaultLat==='number'||typeof layers.properties.DefaultLong==='number'||typeof layers.properties.DefaultZoom==='number'){map.needMove=getDefaultPos(layers.properties);setCurrPosition(null,{'currPosition':{'x':gmxAPI.merc_x(map.needMove.x),'y':gmxAPI.merc_y(map.needMove.y),'z':map.needMove.z}});}else if(!notMoveFlag&&mapBounds&&layers.properties.name!==gmxAPI.kosmosnimki_API){var z=map.getBestZ(gmxAPI.from_merc_x(mapBounds.minX),gmxAPI.from_merc_y(mapBounds.minY),gmxAPI.from_merc_x(mapBounds.maxX),gmxAPI.from_merc_y(mapBounds.maxY));if(minLayerZoom!=20)z=Math.max(z,minLayerZoom);if(z>0){var pos={'x':(mapBounds.minX+mapBounds.maxX)/2,'y':(mapBounds.minY+mapBounds.maxY)/2,'z':z};map.needMove={'x':gmxAPI.from_merc_x(pos['x']),'y':gmxAPI.from_merc_y(pos['y']),'z':z};setCurrPosition(null,{'currPosition':pos});}}}if(layers.properties.ViewUrl&&!window.suppressDefaultPermalink){var result=/permalink=([a-zA-Z0-9]+)/g.exec(layers.properties.ViewUrl);if(result){var permalink=result[1];var callbackName=gmxAPI.uniqueGlobalName(function(obj){if(obj.position){var pos={'x':obj.position.x,'y':obj.position.y,'z':17-obj.position.z};map.needMove={'x':gmxAPI.from_merc_x(pos['x']),'y':gmxAPI.from_merc_y(pos['y']),'z':pos['z']};setCurrPosition(null,{'currPosition':pos});}if(obj.drawnObjects&&gmxAPI._drawing)for(var i=0;i<obj.drawnObjects.length;i++){var o=obj.drawnObjects[i];map.drawing.addObject(gmxAPI.from_merc_geometry(o.geometry),o.properties);}});var script=document.createElement("script");script.setAttribute("charset","UTF-8");script.setAttribute("src","http://"+layers.properties.hostName+"/TinyReference.ashx?id="+permalink+"&CallbackName="+callbackName+"&"+Math.random());document.getElementsByTagName("head").item(0).appendChild(script);}}if(layers.properties.name===gmxAPI.currentMapName){// Это основная карта
    var minX=Number(layers.properties.MinViewX);var maxX=Number(layers.properties.MaxViewX);var minY=Number(layers.properties.MinViewY);var maxY=Number(layers.properties.MaxViewY);if(minX!==0||maxX!==0||minY!==0||maxY!==0){if(minX===0&&maxX===0)minX=-180,maxX=180;if(minY===0&&maxY===0)minY=-85,maxY=85;map.setExtent(minX,maxX,minY,maxY);}if(gmxAPI.maxRasterZoom>17||gmxAPI.mapMinZoom||gmxAPI.mapMaxZoom){map.setMinMaxZoom(gmxAPI.mapMinZoom||gmxAPI.defaultMinZoom,gmxAPI.mapMaxZoom||gmxAPI.maxRasterZoom||gmxAPI.defaultMaxZoom);}}if(layers.properties.Copyright){var obj=map.addObject();obj.setCopyright(layers.properties.Copyright);}if(layers.properties.MiniMapZoomDelta){gmxAPI.miniMapZoomDelta=layers.properties.MiniMapZoomDelta;}};map.getCenter=function(mgeo){if(!mgeo)mgeo=map.getScreenGeometry();return gmxAPI.geoCenter(mgeo);};map.getScreenGeometry=function(){var e=map.getVisibleExtent();return {type:"POLYGON",coordinates:[[[e.minX,e.minY],[e.minX,e.maxY],[e.maxX,e.maxY],[e.maxX,e.minY],[e.minX,e.minY]]]};};map.getVisibleExtent=function(){var currPos=gmxAPI.currPosition||map.getPosition();if(currPos['latlng']&&currPos['latlng']['extent']){return currPos['latlng']['extent'];}var ww=2*gmxAPI.worldWidthMerc;var x=currPos['x']+ww;x=x%ww;if(x>gmxAPI.worldWidthMerc)x-=ww;if(x<-gmxAPI.worldWidthMerc)x+=ww;var y=currPos['y'];var scale=gmxAPI.getScale(currPos['z']);var w2=scale*gmxAPI._div.clientWidth/2;var h2=scale*gmxAPI._div.clientHeight/2;var out={minX:gmxAPI.from_merc_x(x-w2),minY:gmxAPI.from_merc_y(y-h2),maxX:gmxAPI.from_merc_x(x+w2),maxY:gmxAPI.from_merc_y(y+h2)};return out;};var sunscreen=map.addObject();gmxAPI._sunscreen=sunscreen;var checkMapSize=function checkMapSize(){gmxAPI._updatePosition();gmxAPI._listeners.dispatchEvent('onResizeMap',map);};if(gmxAPI.proxyType==='flash'){sunscreen.setStyle({fill:{color:0xffffff,opacity:1}});sunscreen.setRectangle(-180,-85,180,85);sunscreen.setVisible(false);sunscreen.addListener("onResize",function(){checkMapSize();//gmxAPI._updatePosition();
    //gmxAPI._listeners.dispatchEvent('onResizeMap', map);
    });// if('_miniMapInit' in gmxAPI) {
    // gmxAPI._miniMapInit(gmxAPI._div);
    // }
    }else if(gmxAPI.proxyType==='leaflet'){checkMapSize=function checkMapSize(){return gmxAPI._cmdProxy('checkMapSize');};}map.checkMapSize=checkMapSize;var setCurrPosition=function setCurrPosition(ev,attr){var currPos=attr&&attr.currPosition?attr.currPosition:map.getPosition();var eventFlag=gmxAPI.currPosition&&currPos['x']==gmxAPI.currPosition['x']&&currPos['y']==gmxAPI.currPosition['y']&&currPos['z']==gmxAPI.currPosition['z']?false:true;currPos['latlng']={'x':gmxAPI.from_merc_x(currPos['x']),'y':gmxAPI.from_merc_y(currPos['y']),'mouseX':gmxAPI.from_merc_x(currPos['mouseX']),'mouseY':gmxAPI.from_merc_y(currPos['mouseY'])};if(currPos['extent']){if(currPos['extent']['minx']!=0||currPos['extent']['maxx']!=0){currPos['latlng']['extent']={minX:gmxAPI.from_merc_x(currPos['extent']['minX']||currPos['extent']['minx']),minY:gmxAPI.from_merc_y(currPos['extent']['minY']||currPos['extent']['miny']),maxX:gmxAPI.from_merc_x(currPos['extent']['maxX']||currPos['extent']['maxx']),maxY:gmxAPI.from_merc_y(currPos['extent']['maxY']||currPos['extent']['maxy'])};}}gmxAPI.currPosition=currPos;return eventFlag;};var updatePosition=function updatePosition(ev,attr){var eventFlag=setCurrPosition(ev,attr);if(eventFlag){// Если позиция карты изменилась - формируем событие positionChanged
    var currPos=gmxAPI.currPosition;var z=currPos['z'];/** Пользовательское событие positionChanged
                    * @function callback
                    * @ignore
                    * @param {object} атрибуты прослушивателя
                    */if('stateListeners'in map&&'positionChanged'in map.stateListeners){var pattr={'currZ':z,'currX':currPos['latlng']['x'],'currY':currPos['latlng']['y'],'div':gmxAPI._locationTitleDiv,'screenGeometry':map.getScreenGeometry(),'properties':map.properties};gmxAPI._listeners.dispatchEvent('positionChanged',map,pattr);}}};gmxAPI._updatePosition=updatePosition;var eventMapObject=map.addObject();eventMapObject.setHandler("onMove",updatePosition);// onMoveBegin - перед onMove
    // onMoveEnd - после onMove
    //updatePosition();
    setCurrPosition();map.setBackgroundColor=function(color){map.backgroundColor=color;gmxAPI._cmdProxy('setBackgroundColor',{'obj':map,'attr':color});var isWhite=(0xff&color>>16)>80;var htmlColor=isWhite?"black":"white";gmxAPI._listeners.dispatchEvent('onChangeBackgroundColor',map,htmlColor);};map.setBackgroundColor(gmxAPI.proxyType==='leaflet'?0xffffff:0x000001);map.defaultHostName=layers&&layers.properties?layers.properties.hostName:'';map.addLayers(layers,false,false);if(!layers.properties.UseKosmosnimkiAPI)map.moveTo(map.needMove.x,map.needMove.y,map.needMove.z);if(!map.needSetMode&&haveOSM){// если нигде не устанавливалась текущая подложка и есть OSM
    if(!gmxAPI._baseLayersArr||gmxAPI._baseLayersHash['OSM'])map.setMode('OSM');}var startDrag=function startDrag(object,dragCallback,upCallback){map.freeze();sunscreen.setVisible(true);setToolHandlers({onMouseMove:function onMouseMove(o){var currPosition=map.getPosition();var mouseX=gmxAPI.from_merc_x(currPosition['mouseX']);var mouseY=gmxAPI.from_merc_y(currPosition['mouseY']);dragCallback(mouseX,mouseY,o);},onMouseUp:function onMouseUp(){updatePosition();gmxAPI._stopDrag();if(upCallback)upCallback();}});};gmxAPI._startDrag=startDrag;var stopDrag=function stopDrag(){setToolHandlers({onMouseMove:null,onMouseUp:null});map.unfreeze();sunscreen.setVisible(false);};gmxAPI._stopDrag=stopDrag;gmxAPI.extendFMO('startDrag',function(dragCallback,upCallback){gmxAPI._startDrag(this,dragCallback,upCallback);});if(gmxAPI.proxyType==='leaflet'){gmxAPI.extendFMO('enableDragging',function(dragCallback,downCallback,upCallback,options){var attr={'drag':dragCallback,'dragstart':downCallback,'dragend':upCallback,options:options};gmxAPI._cmdProxy('enableDragging',{'obj':this,'attr':attr});});gmxAPI.extendFMO('disableDragging',function(){gmxAPI._cmdProxy('disableDragging',{'obj':this});});gmxAPI._FMO.prototype.addDragHandlers=gmxAPI._FMO.prototype.enableDragging;gmxAPI._FMO.prototype.removeDragHandlers=gmxAPI._FMO.prototype.disableDragging;}else{gmxAPI.extendFMO('enableDragging',function(dragCallback,downCallback,upCallback){var object=this;var mouseDownHandler=function mouseDownHandler(o){if(downCallback){var currPosition=map.getPosition();var mouseX=null;var mouseY=null;if(currPosition['latlng']&&'mouseX'in currPosition['latlng']){mouseX=currPosition['latlng']['mouseX'];mouseY=currPosition['latlng']['mouseY'];}else{mouseX=gmxAPI.from_merc_x(currPosition['mouseX']);mouseY=gmxAPI.from_merc_y(currPosition['mouseY']);}downCallback(mouseX,mouseY,o);}gmxAPI._startDrag(object,dragCallback,upCallback);};if(object==map){setToolHandler("onMouseDown",mouseDownHandler);}else{object.setHandler("onMouseDown",mouseDownHandler);}});gmxAPI.extendFMO('disableDragging',function(dragCallback,downCallback,upCallback){gmxAPI._FMO.prototype.removeHandler.call(map,'onMouseMove');gmxAPI._FMO.prototype.removeHandler.call(map,'onMouseUp');gmxAPI._FMO.prototype.removeHandler.call(map,'onMouseDown');});}window.kosmosnimkiBeginZoom=function(){if(gmxAPI._drawing&&!gmxAPI._drawing.tools['move'].isActive)return false;gmxAPI.map.freeze();sunscreen.setVisible(true);var x1=gmxAPI.map.getMouseX();var y1=gmxAPI.map.getMouseY();var x2,y2;var rect=gmxAPI.map.addObject();rect.setStyle({outline:{color:0xa0a0a0,thickness:1,opacity:70}});setToolHandlers({onMouseMove:function onMouseMove(){x2=gmxAPI.map.getMouseX();y2=gmxAPI.map.getMouseY();rect.setRectangle(x1,y1,x2,y2);},onMouseUp:function onMouseUp(){setToolHandlers({onMouseMove:null,onMouseUp:null});gmxAPI.map.unfreeze();sunscreen.setVisible(false);var d=10*gmxAPI.getScale(gmxAPI.map.getZ());if(!x1||!x2||!y1||!y2||Math.abs(gmxAPI.merc_x(x1)-gmxAPI.merc_x(x2))<d&&Math.abs(gmxAPI.merc_y(y1)-gmxAPI.merc_y(y2))<d)gmxAPI.map.zoomBy(1,true);else gmxAPI.map.zoomToExtent(Math.min(x1,x2),Math.min(y1,y2),Math.max(x1,x2),Math.max(y1,y2));rect.remove();}});return true;};if(gmxAPI.proxyType==='flash'){var onWheel=function onWheel(e){if(!e)e=window.event;var inMap=false;var elem=gmxAPI.compatTarget(e);while(elem!=null){if(elem==gmxAPI._div){inMap=true;break;}elem=elem.parentNode;}if(!inMap)return;var delta=0;if(e.wheelDelta)delta=e.wheelDelta/120;else if(e.detail)delta=-e.detail/3;if(delta)gmxAPI.map.zoomBy(delta>0?1:-1,true);if(e.preventDefault){e.stopPropagation();e.preventDefault();}else{e.returnValue=false;e.cancelBubble=true;}};var addHandler=function addHandler(div,eventName,handler){if(div.attachEvent)div.attachEvent("on"+eventName,handler);if(div.addEventListener)div.addEventListener(eventName,handler,false);};addHandler(window,"mousewheel",onWheel);addHandler(document,"mousewheel",onWheel);if(window.addEventListener)window.addEventListener('DOMMouseScroll',onWheel,false);}map.ToolsContainer=gmxAPI._ToolsContainer;gmxAPI._listeners.dispatchEvent('mapCreated',null,map);// Глобальный Listeners
    // Deferred методы
    var deferred=function deferred(){console.log('Deferred function: ',arguments.callee);};map.setCoordinatesAlign=deferred;// Позиционирование масштабной шкалы (tr tl br bl)
    map.setCopyrightAlign=deferred;// Позиционирование Copyright (tr tl br bl bc)
    map.setGeomixerLinkAlign=deferred;// Позиционирование GeomixerLink (tr tl br bl)
    return map;};//расширяем namespace
    gmxAPI._addNewMap=addNewMap;// Создать map обьект
    })();if(!commonjsGlobal.JSON){JSON={};(function(){function f(n){// Format integers to have at least two digits.
    return n<10?'0'+n:n;}if(typeof Date.prototype.toJSON!=='function'){Date.prototype.toJSON=function(key){return this.getUTCFullYear()+'-'+f(this.getUTCMonth()+1)+'-'+f(this.getUTCDate())+'T'+f(this.getUTCHours())+':'+f(this.getUTCMinutes())+':'+f(this.getUTCSeconds())+'Z';};String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(key){return this.valueOf();};}var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapeable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={// table of character substitutions
    '\b':'\\b','\t':'\\t','\n':'\\n','\f':'\\f','\r':'\\r','"':'\\"','\\':'\\\\'},rep;function quote(string){escapeable.lastIndex=0;return escapeable.test(string)?'"'+string.replace(escapeable,function(a){var c=meta[a];if(typeof c==='string'){return c;}return "\\u"+('0000'+a.charCodeAt(0).toString(16)).slice(-4);})+'"':'"'+string+'"';}function str(key,holder){var i,// The loop counter.
    k,// The member key.
    v,// The member value.
    length,mind=gap,partial,value=holder[key];if(value&&_typeof(value)==='object'&&typeof value.toJSON==='function'){value=value.toJSON(key);}if(typeof rep==='function'){value=rep.call(holder,key,value);}switch(_typeof(value)){case'string':return quote(value);case'number':return isFinite(value)?String(value):'null';case'boolean':case'null':return String(value);case'object':if(!value){return 'null';}gap+=indent;partial=[];if(typeof value.length==='number'&&!value.propertyIsEnumerable('length')){length=value.length;for(i=0;i<length;i+=1){partial[i]=str(i,value)||'null';}v=partial.length===0?'[]':gap?'[\n'+gap+partial.join(',\n'+gap)+'\n'+mind+']':'['+partial.join(',')+']';gap=mind;return v;}if(rep&&_typeof(rep)==='object'){length=rep.length;for(i=0;i<length;i+=1){k=rep[i];if(typeof k==='string'){v=str(k,value);if(v){partial.push(quote(k)+(gap?': ':':')+v);}}}}else{for(k in value){if(Object.hasOwnProperty.call(value,k)){v=str(k,value);if(v){partial.push(quote(k)+(gap?': ':':')+v);}}}}v=partial.length===0?'{}':gap?'{\n'+gap+partial.join(',\n'+gap)+'\n'+mind+'}':'{'+partial.join(',')+'}';gap=mind;return v;}}if(typeof JSON.stringify!=='function'){JSON.stringify=function(value,replacer,space){var i;gap='';indent='';if(typeof space==='number'){for(i=0;i<space;i+=1){indent+=' ';}}else if(typeof space==='string'){indent=space;}rep=replacer;if(replacer&&typeof replacer!=='function'&&(_typeof(replacer)!=='object'||typeof replacer.length!=='number')){throw new Error('JSON.stringify');}return str('',{'':value});};}if(typeof JSON.parse!=='function'){JSON.parse=function(text,reviver){var j;function walk(holder,key){var k,v,value=holder[key];if(value&&_typeof(value)==='object'){for(k in value){if(Object.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v;}else{delete value[k];}}}}return reviver.call(holder,key,value);}cx.lastIndex=0;if(cx.test(text)){text=text.replace(cx,function(a){return "\\u"+('0000'+a.charCodeAt(0).toString(16)).slice(-4);});}if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,'@').replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,']').replace(/(?:^|:|,)(?:\s*\[)+/g,''))){j=eval('('+text+')');return typeof reviver==='function'?walk({'':j},''):j;}throw new SyntaxError('JSON.parse');};}})();}(function(){/**
    	 * Class for working with browser printing
    	 * @see http://www.anychart.com/blog/projects/acprintmanagerlibrary/
    	 * @version 0.1
    	 * @author Alex Batsuev (alex(at)sibental(dot)com)
    	 */var ACPrintManager=function ACPrintManager(){};ACPrintManager.isIE=function(){return gmxAPI.isIE;};ACPrintManager.initIE=function(objId){var obj=document.getElementById(objId);if(obj==null)return;if(obj.onBeforePrint==undefined||obj.onAfterPrint==undefined)return;window.attachEvent("onbeforeprint",function(e){obj.setAttribute("tmpW",obj.width);obj.setAttribute("tmpH",obj.height);var size=ACPrintManager.getContentSize(obj);obj.width=size.width;obj.height=size.height;obj.onBeforePrint();if(obj.getAttribute("tmpW").indexOf("%")!=-1||obj.getAttribute("tmpH").indexOf("%")!=-1){//ie percent width or height hack
    obj.focus();}});window.attachEvent("onafterprint",function(){obj.onAfterPrint();obj.width=obj.getAttribute("tmpW");obj.height=obj.getAttribute("tmpH");});};ACPrintManager.initFF=function(objId,imgData){if(gmxAPI.isIE)return;var obj=document.getElementById(objId);if(obj==null&&document.embeds!=null)obj=document.embeds[objId];if(obj==null)return;//step #1: get parent node
    var parent=obj.parentNode;if(parent==null)return;//step #2: get header
    var head=document.getElementsByTagName('head');head=head.length!=1?null:head[0];//step #3: write normal css rule		
    var style=document.createElement('style');style.setAttribute('type','text/css');style.setAttribute('media','screen');var size=ACPrintManager.getContentSize(obj);var imgDescriptor='img#'+objId+'_screen';var imgRule="width: "+size.width+";\n"+"height: "+size.height+";\n"+"padding: 0;\n"+"margin: 0;\n"+"border: 0;\n"+"display: none;";style.appendChild(document.createTextNode(imgDescriptor+'{'+imgRule+"}\n"));//add style to head
    head.appendChild(style);//step #4: write print css rule
    style=document.createElement('style');style.setAttribute('type','text/css');style.setAttribute('media','print');//write image style
    imgDescriptor='img#'+objId+'_screen';imgRule='display: block;';style.appendChild(document.createTextNode(imgDescriptor+'{'+imgRule+'}'));//write object style
    var objDescriptor='embed#'+objId;var objRule='display: none;';style.appendChild(document.createTextNode(objDescriptor+'{'+objRule+'}'));//add style to head
    head.appendChild(style);//step #5: get image
    var needAppend=false;var img=document.getElementById('img');if(img==null){img=document.createElement('img');needAppend=true;}img.src='data:image/png;base64,'+imgData;img.setAttribute('id',objId+"_screen");if(needAppend)parent.appendChild(img);};ACPrintManager.getContentSize=function(obj){var size={};size.width=obj.width;size.height=obj.height;if(obj.getWidth!=undefined)size.width=obj.getWidth()+'px';if(obj.getHeight!=undefined)size.height=obj.getHeight()+'px';return size;};//расширяем namespace
    window.ACPrintManager=gmxAPI.ACPrintManager=ACPrintManager;})();(function(){var wmsProjections=['EPSG:3395','EPSG:4326','EPSG:41001'];// типы проекций
    /**
         * Возвращает описание WMS-слоёв от XML, которую вернул сервер на запрос GetCapabilities
         * @memberOf gmxAPI
         * @ignore
         * @returns {Array} - массив объектов с описанием слоёв
        */var parseWMSCapabilities=function parseWMSCapabilities(response){var supportedVersions={'1.1.1':true,'1.3.0':true};var SRSTagName={'1.1.1':'SRS','1.3.0':'CRS'};var BBOXTagName={'1.1.1':'LatLonBoundingBox','1.3.0':'EX_GeographicBoundingBox'};var serviceLayers=[],strResp=response.replace(/[\t\n\r]/g,' '),strResp=strResp.replace(/\s+/g,' '),xml=gmxAPI.parseXML(response),version=xml.getElementsByTagName('WMS_Capabilities')[0].getAttribute('version'),layersXML=xml.getElementsByTagName('Layer');if(!(version in supportedVersions)){return [];}for(var i=0;i<layersXML.length;i++){var layer={version:version},name=layersXML[i].getElementsByTagName('Name'),title=layersXML[i].getElementsByTagName('Title'),bbox=layersXML[i].getElementsByTagName(BBOXTagName[version]),srs=layersXML[i].getElementsByTagName(SRSTagName[version]);if(srs.length){layer.srs=null;for(var si=0;si<srs.length;si++){var curSrs=gmxAPI.strip(gmxAPI.getTextContent(srs[si]));if(gmxAPI.valueInArray(wmsProjections,curSrs)){layer.srs=curSrs;break;}}if(!layer.srs)continue;}else layer.srs=wmsProjections[0];if(name.length)layer.name=gmxAPI.getTextContent(name[0]);if(bbox.length){if(version=='1.1.1'){layer.bbox={minx:Number(bbox[0].getAttribute('minx')),miny:Number(bbox[0].getAttribute('miny')),maxx:Number(bbox[0].getAttribute('maxx')),maxy:Number(bbox[0].getAttribute('maxy'))};}else{layer.bbox={minx:Number(gmxAPI.getTextContent(bbox[0].getElementsByTagName('westBoundLongitude')[0])),miny:Number(gmxAPI.getTextContent(bbox[0].getElementsByTagName('southBoundLatitude')[0])),maxx:Number(gmxAPI.getTextContent(bbox[0].getElementsByTagName('eastBoundLongitude')[0])),maxy:Number(gmxAPI.getTextContent(bbox[0].getElementsByTagName('northBoundLatitude')[0]))};}}if(title.length)layer.title=gmxAPI.getTextContent(title[0]);if(layer.name)serviceLayers.push(layer);}return serviceLayers;};/** Формирует URL картинки, который можно использовать для получения WMS слоя для данного положения карты
         * @memberOf gmxAPI
         * @ignore
         * @property {String} url - WMS ссылка.
         * @property {object} props - атрибуты.
         * @property {String} props.srs - тип проекции.
         * @property {String} props.version - версия.
         * @property {String} props.name - Идентификатор слоя.
         * @property {object} props.bbox - ограничение по bounds(в географических координатах).
         * @property {object} requestProperties - атрибуты формата результирующего image.
         * @property {String} requestProperties.format - тип (по умолчанию 'image/jpeg').
         * @property {String} requestProperties.transparent - прозрачность подложки ('TRUE'/'FALSE' по умолчанию 'FALSE').
         * @returns {object} - {url: String, bounds: {Extent}}. bounds в географических координатах.
        */var getWMSMapURL=function getWMSMapURL(url,props,requestProperties){var CRSParam={'1.1.1':'SRS','1.3.0':'CRS'};requestProperties=requestProperties||{};var extend=gmxAPI.map.getVisibleExtent();console.log('visible',extend);var miny=Math.max(extend.minY,-90);var maxy=Math.min(extend.maxY,90);var minx=Math.max(extend.minX,-180);var maxx=Math.min(extend.maxX,180);if(props.bbox){minx=Math.max(props.bbox.minx,minx);miny=Math.max(props.bbox.miny,miny);maxx=Math.min(props.bbox.maxx,maxx);maxy=Math.min(props.bbox.maxy,maxy);if(minx>=maxx||miny>=maxy)return;}var scale=gmxAPI.getScale(gmxAPI.map.getZ());var w=Math.round((gmxAPI.merc_x(maxx)-gmxAPI.merc_x(minx))/scale);var h=Math.round((gmxAPI.merc_y(maxy)-gmxAPI.merc_y(miny))/scale);var isMerc=!(props.srs==wmsProjections[1]);var st=url;var format=requestProperties.format||'image/jpeg';var transparentParam=requestProperties.transparent?'TRUE':'FALSE';var version=props.version||'1.1.1';//st = st.replace(/Service=WMS[\&]*/i, '');
    //st = st.replace(/\&$/, '');
    st+=(st.indexOf('?')==-1?'?':'&')+'request=GetMap&Service=WMS';st+="&layers="+encodeURIComponent(props.name)+"&VERSION="+encodeURIComponent(version)+"&"+CRSParam[version]+"="+encodeURIComponent(props.srs)+"&styles="+"&width="+w+"&height="+h+"&bbox="+(isMerc?gmxAPI.merc_x(minx):minx)+","+(isMerc?gmxAPI.merc_y(miny):miny)+","+(isMerc?gmxAPI.merc_x(maxx):maxx)+","+(isMerc?gmxAPI.merc_y(maxy):maxy);if(url.indexOf('format=')==-1)st+="&format="+encodeURIComponent(format);if(url.indexOf('transparent=')==-1)st+="&transparent="+encodeURIComponent(transparentParam);return {url:st,bounds:{minX:minx,maxX:maxx,minY:miny,maxY:maxy}};};var loadWMS=function loadWMS(map,container,url,func){var urlProxyServer='http://'+gmxAPI.serverBase+'/';var wmsLayers=[];url=url.replace(/Request=GetCapabilities[\&]*/i,'');url=url.replace(/\&$/,'');var st=url;st+=(st.indexOf('?')==-1?'?':'&')+'request=GetCapabilities&version=1.1.1';var _hostname=urlProxyServer+"ApiSave.ashx?debug=1&get="+encodeURIComponent(st);sendCrossDomainJSONRequest$1(_hostname,function(response){if(_typeof(response)!='object'||response['Status']!='ok'){gmxAPI.addDebugWarnings({'_hostname':_hostname,'url':url,'Error':'bad response'});return;}var serviceLayers=gmxAPI.parseWMSCapabilities(response['Result']);for(var i=0;i<serviceLayers.length;i++){var props=serviceLayers[i];var obj=container.addObject(null,props);obj.setVisible(false);wmsLayers.push(obj);(function(obj,props){var timeout=false;var updateFunc=function updateFunc(){if(timeout)clearTimeout(timeout);timeout=setTimeout(function(){var res=getWMSMapURL(url,props);if(res){var bbox=res.bounds;obj.setImage(urlProxyServer+"ImgSave.ashx?now=true&get="+encodeURIComponent(res.url),bbox.minX,bbox.maxY,bbox.maxX,bbox.maxY,bbox.maxX,bbox.minY,bbox.minX,bbox.minY);}},500);};// Добавление прослушивателей событий
    obj.addListener('onChangeVisible',function(flag){if(flag)updateFunc();obj.setHandler("onMove",flag?updateFunc:null);});})(obj,props);}func(wmsLayers);});};//расширяем namespace
    gmxAPI.parseWMSCapabilities=parseWMSCapabilities;gmxAPI._loadWMS=loadWMS;gmxAPI.getWMSMapURL=getWMSMapURL;})();(function(){var kmlParser=function kmlParser(){this.hrefs={};this.oldBalloon=false,this.oldBalloonIndex=-1;this.globalStyles={};this.globalStylesMap={};this.defaultStyles={'point':{outline:{color:0x0000FF,thickness:1},fill:{color:0xFFFFFF,opacity:20},marker:{size:3}},'linestring':{outline:{color:0x0000FF,thickness:1}},'polygon':{outline:{color:0x0000FF,thickness:1}}};this.counter=0;};kmlParser.prototype.value=function(a){if(!a){return "";}var b="";if(a.nodeType==3||a.nodeType==4||a.nodeType==2){b+=a.nodeValue;}else if(a.nodeType==1||a.nodeType==9||a.nodeType==11){for(var c=0;c<a.childNodes.length;++c){b+=arguments.callee(a.childNodes[c]);}}b=b.replace(/^\s*/,"");b=b.replace(/\s*$/,"");return b;};kmlParser.prototype.get=function(url,callback,map){var _this=this;this.globalFlashMap=map;var urlProxyServer='http://'+gmxAPI.serverBase+'/';var _hostname=urlProxyServer+"ApiSave.ashx?debug=1&get="+encodeURIComponent(url);sendCrossDomainJSONRequest$1(_hostname,function(response){if(_typeof(response)!='object'||response['Status']!='ok'){callback(null);gmxAPI.addDebugWarnings({'_hostname':_hostname,'url':url,'Error':'bad response'});return;}var parsed=_this.parse(response['Result']);parsed.url=url;callback(parsed);});};kmlParser.prototype.parse=function(response){var strResp=response.replace(/[\t\n\r]/g,' '),strResp=strResp.replace(/\s+/g,' '),xml=gmxAPI.parseXML(strResp),vals=[];this.globalStyles={};this.globalStylesMap={};var styles=xml.getElementsByTagName("Style");for(var i=0;i<styles.length;i++){var styleID=styles[i].getAttribute("id");if(styleID)this.globalStyles['#'+styleID]=this.parseStyle(styles[i]);}var stylesMap=xml.getElementsByTagName("StyleMap");for(var i=0;i<stylesMap.length;i++){var styleID=stylesMap[i].getAttribute("id");if(styleID)this.globalStylesMap['#'+styleID]=this.parseStyleMap(stylesMap[i]);}var placemarks=xml.getElementsByTagName("Placemark");for(var i=0;i<placemarks.length;i++){var val=this.parsePlacemark(placemarks[i]);if(val)vals.push(val);}var firstNode=xml.getElementsByTagName('Document')[0];var name=false,documentChilds=firstNode?firstNode.childNodes:[];for(var i=0;i<documentChilds.length;++i){if(documentChilds[i].nodeName=='name'){name=this.value(documentChilds[i]);break;}}if(!name)name='KML'+ ++this.counter;var res={vals:vals,name:name};return res;};kmlParser.prototype.parseStyle=function(elem){var style=false,icons=elem.getElementsByTagName("Icon");if(icons.length>0){var href=this.value(icons[0].getElementsByTagName("href")[0]);if(!!href){var urlProxyServer='http://'+gmxAPI.serverBase+'/';href=urlProxyServer+"ImgSave.ashx?now=true&get="+encodeURIComponent(href);style={marker:{image:href,center:true}};}else style={marker:{size:3},outline:{color:0x0000FF,thickness:1},fill:{color:0xFFFFFF,opacity:20}};}var linestyles=elem.getElementsByTagName("LineStyle");if(linestyles.length>0){var width=parseInt(this.value(linestyles[0].getElementsByTagName("width")[0]));if(width<1||isNaN(width))width=5;var color=this.value(linestyles[0].getElementsByTagName("color")[0]),aa=color.substr(0,2),bb=color.substr(2,2),gg=color.substr(4,2),rr=color.substr(6,2);if(!style)style={};style.outline={color:isNaN(parseInt('0x'+rr+gg+bb))?0:parseInt('0x'+rr+gg+bb),thickness:width,opacity:isNaN(parseInt(aa,16))?0:parseInt(aa,16)/256};}var polystyles=elem.getElementsByTagName("PolyStyle");if(polystyles.length>0){var fill=parseInt(this.value(polystyles[0].getElementsByTagName("fill")[0])),outline=parseInt(this.value(polystyles[0].getElementsByTagName("outline")[0])),color=this.value(polystyles[0].getElementsByTagName("color")[0]),aa=color.substr(0,2),bb=color.substr(2,2),gg=color.substr(4,2),rr=color.substr(6,2);if(polystyles[0].getElementsByTagName("fill").length==0)fill=1;if(polystyles[0].getElementsByTagName("outline").length==0)outline=1;if(!style)style={};style.fill={color:isNaN(parseInt('0x'+rr+gg+bb))?0:parseInt('0x'+rr+gg+bb),opacity:isNaN(parseInt(aa,16))?0:parseInt(aa,16)/256};if(!fill)style.fill.opacity=0;if(!outline)style.outline.opacity=0;}return style;};kmlParser.prototype.parseStyleMap=function(elem){var pairs=elem.getElementsByTagName('Pair'),res={};for(var i=0;i<pairs.length;++i){var key=this.value(pairs[i].getElementsByTagName('key')[0]),styleID=this.value(pairs[i].getElementsByTagName('styleUrl')[0]);if(this.globalStyles[styleID])res[key]=this.globalStyles[styleID];}return res;};kmlParser.prototype.convertCoords=function(coordsStr){var res=[],coordsPairs=gmxAPI.strip(coordsStr).replace(/[\t\n\r\s]/g,' ').replace(/\s+/g,' ').replace(/,\s/g,',').split(' ');if(coordsStr.indexOf(',')==-1){for(var j=0;j<Math.floor(coordsPairs.length/2);j++){res.push([Number(coordsPairs[2*j]),Number(coordsPairs[2*j+1])]);}}else{for(var j=0;j<coordsPairs.length;j++){var parsedCoords=coordsPairs[j].split(',');res.push([Number(parsedCoords[0]),Number(parsedCoords[1])]);}}return res;};kmlParser.prototype.parsePlacemark=function(elem){var placemark={items:[]},name=this.value(elem.getElementsByTagName("name")[0]),desc=this.value(elem.getElementsByTagName("description")[0]);if(desc==""){var desc=this.value(elem.getElementsByTagName("text")[0]);desc=desc.replace(/\$\[name\]/,name);desc=desc.replace(/\$\[geDirections\]/,"");}if(desc.match(/^http:\/\//i)||desc.match(/^https:\/\//i))desc='<a href="'+desc+'">'+desc+'</a>';placemark.name=name;placemark.desc=desc;var style=this.value(elem.getElementsByTagName("styleUrl")[0]),points=elem.getElementsByTagName('Point'),lines=elem.getElementsByTagName('LineString'),polygones=elem.getElementsByTagName('Polygon');for(var i=0;i<points.length;i++){var coords=this.value(points[i].getElementsByTagName('coordinates')[0]),convertedCoords=this.convertCoords(coords),item={};item.geometry={type:'POINT',coordinates:convertedCoords[0]};if(this.globalStyles[style])item.style={normal:this.globalStyles[style]};else if(this.globalStylesMap[style])item.style=this.globalStylesMap[style];else item.style={normal:this.defaultStyles['point']};placemark.items.push(item);}for(var i=0;i<lines.length;i++){var coords=this.value(lines[i].getElementsByTagName('coordinates')[0]),convertedCoords=this.convertCoords(coords),item={};item.geometry={type:'LINESTRING',coordinates:convertedCoords};if(this.globalStyles[style])item.style={normal:this.globalStyles[style]};else if(this.globalStylesMap[style])item.style=this.globalStylesMap[style];else item.style={normal:this.defaultStyles['linestring']};placemark.items.push(item);}for(var i=0;i<polygones.length;i++){var coords=[],outerCoords=polygones[i].getElementsByTagName('outerBoundaryIs'),innerCoords=polygones[i].getElementsByTagName('innerBoundaryIs'),resultCoords=[],item={};if(outerCoords.length)coords.push(this.value(outerCoords[0].getElementsByTagName('coordinates')[0]));if(innerCoords.length)coords.push(this.value(innerCoords[0].getElementsByTagName('coordinates')[0]));for(var index=0;index<coords.length;index++){resultCoords.push(this.convertCoords(coords[index]));}item.geometry={type:'POLYGON',coordinates:resultCoords};if(this.globalStyles[style])item.style={normal:this.globalStyles[style]};else if(this.globalStylesMap[style])item.style=this.globalStylesMap[style];else item.style={normal:this.defaultStyles['polygon']};placemark.items.push(item);}return placemark;};kmlParser.prototype.draw=function(vals,parent){var bounds=gmxAPI.getBounds(),_this=this;function getItem(parent,item,flag,name,desc){var props={};if(name)props['name']=name;if(desc)props['desc']=desc;var tmp={"geometry":item['geometry'],"properties":props};if(item.style.normal){var style='';if(item.geometry.type=='POINT'){style=item.style.normal;}else style=_this.removeMarkerStyle(item.style.normal);tmp['setStyle']={'regularStyle':style};}return tmp;}function getItems(vals){var out=[];for(var i=0;i<vals.length;++i){if(vals[i].items.length==1){var item=vals[i].items[0];out.push(getItem(parent,item,true,vals[i].name,vals[i].desc));bounds.update(item.geometry.coordinates);}else{var point=false;for(var j=0;j<vals[i].items.length;++j){if(!point&&vals[i].items[j].geometry.type=='POINT'){point=vals[i].items[j];}else{var item=vals[i].items[j];out.push(getItem(parent,item,false,vals[i].name,vals[i].desc));bounds.update(item.geometry.coordinates);if(item.geometry.type!='POINT'){out.push(getItem(parent,item,false,vals[i].name,vals[i].desc));}}}if(point){out.push(getItem(parent,point,false,vals[i].name,vals[i].desc));bounds.update(point.geometry.coordinates);}}}return out;}var out=getItems(vals);var fobjArray=parent.addObjects(out);for(var j=0;j<fobjArray.length;++j){var elem=fobjArray[j];var item=out[j];if(item.properties['name']){elem.enableHoverBalloon(function(o){var st="<div style=\"margin-bottom: 10px;font-size:12px;color:#000;\" >"+o.properties['name']+"</div>";if(o.properties['desc'])st+='<br>'+o.properties['desc'];return st;});}}return {parent:parent,bounds:bounds};};kmlParser.prototype.removeMarkerStyle=function(style){var newStyle={};if(style.outline)newStyle.outline=style.outline;if(style.fill)newStyle.fill=style.fill;return newStyle;};kmlParser.prototype.createBalloon=function(obj,htmlContent){if(this.oldBalloon)this.oldBalloon.remove();if(this.oldBalloonIndex==obj.objectId){this.oldBalloonIndex=-1;this.oldBalloon=false;return false;}var coords=obj.getGeometry().coordinates,_this=this;this.oldBalloon=this.globalFlashMap.addBalloon();this.oldBalloon.setPoint(coords[0],coords[1]);this.oldBalloon.div.appendChild(htmlContent);var remove=gmxAPI.makeImageButton("img/close.png","img/close_orange.png");remove.onclick=function(){_this.oldBalloon.remove();_this.oldBalloonIndex=-1;_this.oldBalloon=false;};remove.style.position='absolute';remove.style.right='9px';remove.style.top='5px';remove.style.cursor='pointer';this.oldBalloon.div.appendChild(remove);this.oldBalloon.resize();this.oldBalloonIndex=obj.objectId;return true;};kmlParser.prototype.drawItem=function(parent,item,flag,name,desc){var elem=parent.addObject();elem.setGeometry(item.geometry);if(item.style.normal){if(item.geometry.type=='POINT'){if(typeof item.style.normal.marker.image!='undefined'&&typeof this.hrefs[item.style.normal.marker.image]=='undefined')elem.setStyle(this.defaultStyles['point']);else{item.style.normal.marker.image=this.hrefs[item.style.normal.marker.image];if(item.style.normal.marker.fill)delete item.style.normal.marker.fill;if(item.style.normal.marker.outline)delete item.style.normal.marker.outline;elem.setStyle(item.style.normal);}}else elem.setStyle(this.removeMarkerStyle(item.style.normal));}if(flag){elem.enableHoverBalloon(function(o){return "<div style=\"margin-bottom: 10px;font-size:12px;color:#000;\" >"+name+"</div>"+desc;});}return elem;};//расширяем namespace
    gmxAPI._kmlParser=new kmlParser();//расширяем FlashMapObject
    gmxAPI.extendFMO('loadKML',function(url,func){var me=this;gmxAPI._kmlParser.get(url,function(result){if(result)gmxAPI._kmlParser.draw(result.vals,me);if(func)func(result);},gmxAPI.map);});})();/* ======================================================================
        balloon.js
       ====================================================================== */ /** Менеджер управления балунами

    Позволяет управлять балунами на карте. 

    @memberof map
    */(function(){/**
         * Менеджер управления балунами (создаётся в API и доступен через свойство карты map.balloonClassObject).
         * @constructor BalloonClass
         */function BalloonClass(){var map=gmxAPI.map;var div=gmxAPI._div;var apiBase=gmxAPI.getAPIFolderRoot();var balloons=[];map.balloons=balloons;var mapX=0;var mapY=0;var stageZoom=1;// Коэф. масштабирования браузера
    var scale=0;//map.getPosition();
    var currPos=null;// Обновить информацию текущего состояния карты
    function refreshMapPosition(ph){currPos=ph||gmxAPI.currPosition||map.getPosition();mapX=currPos['x'];mapY=currPos['y'];scale=gmxAPI.getScale(currPos['z']);stageZoom=currPos['stageHeight']/div.clientHeight;// Коэф. масштабирования браузера
    }// Формирование ID балуна
    function setID(o){var id=o.objectId+'_balloon';if(o.properties){var identityField=gmxAPI.getIdentityField(o);if(o.properties[identityField])id+='_'+o.properties[identityField];}return id;}function chkBalloonText(text,div){var type=_typeof(text);if(type==='string')div.innerHTML='<div style="white-space: nowrap;">'+text+'</div>';else if(type==='boolean'&&text)div.innerHTML="";// затираем только если true
    // в случае type === 'object' ничего не делаем
    }function callBalloonHook(o,div){for(var key in o._balloonHook){var hook=o._balloonHook[key],//st = '[' + key + ']',
    fid=hook.hookID,span=div.getElementsByTagName("span"),notFound=true;for(var i=0,len=span.length;i<len;i++){var node=span[i];if(node.id===fid){notFound=false;//node.innerHTML = node.innerHTML.replace(st, '');
    node.id+='_'+i;hook.callback(o,div,node);}}if(notFound)hook.callback(o,div,null);}}// Текст по умолчанию для балуна (innerHTML)
    function getDefaultBalloonText(o,attr){var text="";var identityField=gmxAPI.getIdentityField(o);var props=gmxAPI.clone(o.properties);if(o._balloonHook){for(var key in o._balloonHook){props[key]=gmxAPI.applyTemplate(o._balloonHook[key].resStr,props);}}for(var key in props){if(key!=identityField){var value=""+props[key];if(!o._balloonHook){if(value.indexOf("http://")==0)value="<a href='"+value+"'>"+value+"</a>";else if(value.indexOf("www.")==0)value="<a href='http://"+value+"'>"+value+"</a>";}text+="<b>"+key+":</b> "+value+"<br />";}}var summary=o.getGeometrySummary();if(summary!='')text+="<br />"+summary;return text;}this.getDefaultBalloonText=getDefaultBalloonText;// Проверка наличия параметра по ветке родителей
    function chkAttr(name,o){var attr=false;var hash=o._hoverBalloonAttr;if(hash&&name in hash){attr=hash[name];}if(!attr&&o.parent)attr=chkAttr(name,o.parent);return attr;}/*
    		function setDelayHide()
    		{
    			if(propsBalloon.delayHide) clearTimeout(propsBalloon.delayHide);
    			propsBalloon.delayHide = setTimeout(function()
    			{
    				propsBalloon.chkMouseOut();
    				clearTimeout(propsBalloon.delayHide);
    				propsBalloon.delayHide = false;
    			}, 100);
    		}
    		function setDelayShow(text, o)
    		{
    			if(propsBalloon.delayShow) clearTimeout(propsBalloon.delayShow);
    			propsBalloon.delayShow = setTimeout(function()
    			{
    				propsBalloon.updatePropsBalloon(text);
    				clearTimeout(propsBalloon.delayShow);
    				propsBalloon.delayShow = false;
                    if(o._balloonHook) o._balloonHook.callback(o, balloon.div);
    			}, 200);
    		}
    */function disableHoverBalloon(mapObject){var listenersID=mapObject._attr['balloonListeners'];for(var key in listenersID){mapObject.removeListener(key,listenersID[key]);}mapObject._attr['balloonListeners']={};}this.disableHoverBalloon=disableHoverBalloon;/** Установка режима пользовательского балуна
            * @memberOf BalloonClass#
            * @param {MapObject} mapObject - обьект карты для которого устанавливается режим балуна.
            * @param {object} callback - пользовательский метод формирования содержимого балуна.
            * @param {object} attr - атрибуты управления балуном.
            * @param {boolean} attr.disableOnMouseOver - отключить балун при наведении указателя(по умолчанию равен false).
            * @param {boolean} attr.disableOnClick - отключить балун при click(по умолчанию равен false).
            * @param {boolean} attr.maxFixedBallons - максимальное количество фиксированных балунов(по умолчанию равен 1).
            */function enableHoverBalloon(mapObject,callback,attr){mapObject._hoverBalloonAttr=attr?attr:{};// Атрибуты управления балуном
    if(callback){// Пользовательский метод получения текста для балуна
    this.getDefaultBalloonText=mapObject._hoverBalloonAttr['callback']=callback;}else{delete mapObject._hoverBalloonAttr['callback'];}var handlersObj={onMouseOver:function onMouseOver(o,keyPress){if('obj'in o){//if('attr' in o && 'textFunc' in o.attr) keyPress = o.attr;
    if('attr'in o)keyPress=o.attr;o=o.obj;}gmxAPI.contDivPos={'x':gmxAPI.getOffsetLeft(div),'y':gmxAPI.getOffsetTop(div)};if(keyPress&&(keyPress['shiftKey']||keyPress['ctrlKey']))return false;// При нажатых не показываем балун
    if(map.isDragging())return false;if(chkAttr('disableOnMouseOver',mapObject)){// Проверка наличия параметра disableOnMouseOver по ветке родителей 
    return false;}var customBalloonObject=chkAttr('customBalloon',mapObject);// Проверка наличия параметра customBalloon по ветке родителей 
    if(customBalloonObject){currPos=gmxAPI.currPosition||map.getPosition();currPos._x=propsBalloon.mouseX||0;currPos._y=propsBalloon.mouseY||0;var flag=customBalloonObject.onMouseOver(o,keyPress,currPos);// Вызов пользовательского метода вместо или перед балуном
    if(flag)return false;// Если customBalloon возвращает true выходим
    }if(!o._balloonHook&&o.filter&&o.filter._balloonHook)o._balloonHook=o.filter._balloonHook;//if(keyPress['objType'] == 'cluster') {}; // Надо придумать как бороться с фикс.двойником
    var textFunc=chkAttr('callback',mapObject);// Проверка наличия параметра callback по ветке родителей 
    if(keyPress){if('textFunc'in keyPress)textFunc=keyPress['textFunc'];}//var text = (textFunc && (!keyPress['objType'] || keyPress['objType'] != 'cluster') ? textFunc(o, propsBalloon.div) : getDefaultBalloonText(o));
    var text=textFunc?textFunc(o,propsBalloon.div):getDefaultBalloonText(o);if(typeof text=='string'&&text=='')return false;var id=setID(o);lastHoverBalloonId=o.objectId;//if(propsBalloon.delayHide) { clearTimeout(propsBalloon.delayHide); propsBalloon.delayHide = false; }
    if(!fixedHoverBalloons[id]){if(propsBalloon.delayShow)clearTimeout(propsBalloon.delayShow);propsBalloon.delayShow=setTimeout(function(){propsBalloon.updatePropsBalloon(text);clearTimeout(propsBalloon.delayShow);propsBalloon.delayShow=false;if(o._balloonHook){callBalloonHook(o,propsBalloon.div);}},200);//setDelayShow(text);
    //propsBalloon.updatePropsBalloon(text);
    }else{propsBalloon.updatePropsBalloon(false);}map.clickBalloonFix=clickBalloonFix;return true;},onMouseOut:function onMouseOut(o){if('obj'in o){o=o.obj;}var customBalloonObject=chkAttr('customBalloon',mapObject);// Проверка наличия параметра customBalloon по ветке родителей 
    if(customBalloonObject){var flag=customBalloonObject.onMouseOut(o);if(flag)return false;}if(lastHoverBalloonId==o.objectId){//setDelayHide();
    if(propsBalloon.delayShow){clearTimeout(propsBalloon.delayShow);propsBalloon.delayShow=false;}propsBalloon.updatePropsBalloon(false);}return true;},onClick:function onClick(o,keyPress){if('obj'in o){if('attr'in o)keyPress=o.attr;//if('attr' in o && 'textFunc' in o.attr) keyPress = o.attr;
    o=o.obj;if('propForBalloon'in keyPress)o.properties=keyPress.propForBalloon;}refreshMapPosition();var customBalloonObject=chkAttr('customBalloon',mapObject);// Проверка наличия параметра customBalloon по ветке родителей 
    if(customBalloonObject){currPos._x=propsBalloon.x;currPos._y=propsBalloon.y;var flag=customBalloonObject.onClick(o,keyPress,currPos);if(flag)return false;}if(chkAttr('disableOnClick',mapObject)){// Проверка наличия параметра disableOnMouseOver по ветке родителей 
    return false;}if(!keyPress)keyPress={};if(keyPress['objType']==='cluster'){if('clusters'in o)keyPress['textFunc']=o.clusters.getTextFunc();if(keyPress['members'])o['members']=keyPress['members'];// члены кластера 
    }if(!keyPress['textFunc'])keyPress['textFunc']=chkAttr('callback',mapObject);// Проверка наличия параметра callback по ветке родителей 
    return clickBalloonFix(o,keyPress);}};if(mapObject==map)return;// На map Handlers не вешаем
    if(mapObject._hoverBalloonAttr){// есть юзерские настройки балунов
    if(mapObject._hoverBalloonAttr['disableOnMouseOver']){// для отключения балунов при наведении на обьект
    handlersObj['onMouseOver']=null;handlersObj['onMouseOut']=null;}if(mapObject._hoverBalloonAttr['disableOnClick']){// для отключения фиксированных балунов
    handlersObj['onClick']=null;}//mapObject._hoverBalloonAttr['disableOnMouseOver']
    }//mapObject.setHandlers(handlersObj);
    if(!mapObject._attr['balloonListeners'])mapObject._attr['balloonListeners']={};disableHoverBalloon(mapObject);var level=attr&&attr['level']?attr['level']:-10;for(var key in handlersObj){if(handlersObj[key]){var eID=mapObject.addListener(key,handlersObj[key],level);mapObject._attr['balloonListeners'][key]=eID;//gmxAPI._listeners.bringToBottom(mapObject, key, eID);
    }}}this.enableHoverBalloon=enableHoverBalloon;var lastHoverBalloonId=false;var fixedHoverBalloons={};function showHoverBalloons(){for(var key in fixedHoverBalloons){var balloon=fixedHoverBalloons[key];balloon.setVisible(true);}positionBalloons();for(var key in userBalloons){var balloon=userBalloons[key];if(balloon._needShow){balloon.setVisible(true);delete balloon._needShow;}}}this.showHoverBalloons=showHoverBalloons;function removeHoverBalloons(){for(var key in fixedHoverBalloons){fixedHoverBalloons[key].remove();delete fixedHoverBalloons[key];}gmxAPI._mouseOnBalloon=false;}this.removeHoverBalloons=removeHoverBalloons;function hideHoverBalloons(flag,attr){if(propsBalloon.isVisible())propsBalloon.setVisible(false);if(!attr)attr={};for(var key in fixedHoverBalloons){var balloon=fixedHoverBalloons[key];if(!attr.removeAll&&balloon.objType!='cluster'){if(attr.from&&balloon.pID!=attr.from)continue;if(attr.remove)balloon.remove();else{balloon.setVisible(false);}}else{fixedHoverBalloons[key].remove();delete fixedHoverBalloons[key];}}gmxAPI._mouseOnBalloon=false;if(attr.from)return;for(var key in userBalloons){var balloon=userBalloons[key];if(balloon.isVisible){balloon.setVisible(false);balloon._needShow=true;}}/*
    			if(flag && showFlag) {
    				var timeoutShowHoverBalloons = setTimeout(function()
    				{
    					clearTimeout(timeoutShowHoverBalloons);
    					showHoverBalloons();
    				}, 300);
    			}
    */}this.hideHoverBalloons=hideHoverBalloons;// Фиксация балуна
    function clickBalloonFix(o,keyPress){var OnClickSwitcher=chkAttr('OnClickSwitcher',o);// Проверка наличия параметра по ветке родителей 
    if(OnClickSwitcher&&typeof OnClickSwitcher=='function'){var flag=OnClickSwitcher(o,keyPress);// Вызов пользовательского метода вместо или перед балуном
    if(flag)return true;// Если OnClickSwitcher возвращает true выходим
    }if(chkAttr('disableOnClick',o))// Проверка наличия параметра disableOnClick по ветке родителей 
    return false;var textFunc=chkAttr('clickCallback',o)||chkAttr('callback',o);// Проверка наличия параметра callback по ветке родителей 
    if(keyPress){if(keyPress['shiftKey']||keyPress['ctrlKey'])return false;// При нажатых не показываем балун
    if(keyPress['nodeFilter']==o.parent.objectId&&o.parent._hoverBalloonAttr.callback)textFunc=o.parent._hoverBalloonAttr.callback;// взять параметры балуна от фильтра родителя
    else if('textFunc'in keyPress)textFunc=keyPress['textFunc'];}var id=setID(o);if(!fixedHoverBalloons[id]){var maxFixedBallons=chkAttr('maxFixedBallons',o)||1;// Проверка наличия параметра maxFixedBallons по ветке родителей
    if(maxFixedBallons>0&&balloons.length>0){if(maxFixedBallons<=balloons.length){var balloon=null;for(var i=0;i<balloons.length;i++){if(balloons[i].notDelFlag)continue;balloon=balloons[i];break;}if(balloon){var fixedId=balloon.fixedId;balloon.remove();delete fixedHoverBalloons[fixedId];}}}var balloon=addBalloon();balloon.setVisible(false);balloon.pID=o.parent.objectId;if(o.parent&&o.parent.parent&&o.parent.parent.filters){balloon.pID=o.parent.parent.objectId;balloon.filter=o.parent;balloon.layer=o.parent.parent;}balloon.obj=o;balloon.fixedId=id;balloon.keyPress=keyPress;o.balloon=balloon;if(keyPress&&keyPress['objType'])balloon.objType=keyPress['objType'];if(!o._balloonHook&&o.filter&&o.filter._balloonHook)o._balloonHook=o.filter._balloonHook;var text=textFunc?textFunc(o,balloon.div):getDefaultBalloonText(o);if(typeof text=='string'&&text=='')return false;var mx=map.getMouseX();var my=map.getMouseY();if(gmxAPI.proxyType=='flash'){mx=gmxAPI.chkPointCenterX(mx);}if(balloon.objType==='cluster'){keyPress.dx=keyPress.dy=0;}else if(o.getGeometryType()=='POINT'){var gObj=o.getGeometry();var x=gObj.coordinates[0];var y=gObj.coordinates[1];//balloon.fixedDeltaX =  (gmxAPI.merc_x(mx) -  gmxAPI.merc_x(x))/scale;
    //balloon.fixedDeltaY =  (gmxAPI.merc_y(my) -  gmxAPI.merc_y(y))/scale;
    mx=x;my=y;//balloon.fixedDeltaFlag = true;
    }balloon.setVisible(true);balloon.setPoint(mx,my);chkBalloonText(text,balloon.div);if(o._balloonHook){callBalloonHook(o,balloon.div);}balloon.resize();fixedHoverBalloons[id]=balloon;}else{fixedHoverBalloons[id].remove();delete fixedHoverBalloons[id];}propsBalloon.updatePropsBalloon(false);if(propsBalloon.delayShow){clearTimeout(propsBalloon.delayShow);propsBalloon.delayShow=false;}return true;}this.clickBalloonFix=clickBalloonFix;// Создание DIV и позиционирование балуна
    function createBalloon(outerFlag){var brw=20;var legWidth=68;var balloon=gmxAPI.newStyledDiv({position:"absolute",'font-family':'Times New Roman',/*
    				paddingLeft: lw + "px",
    				paddingRight: rw + "px",
    				paddingTop: th + "px",
    				paddingBottom: bh + "px",
    */width:"auto",//whiteSpace: "nowrap",
    zIndex:1000});//if(outerFlag || gmxAPI.proxyType !== 'leaflet') {
    balloon.className='gmx_balloon';div.appendChild(balloon);//} else {
    //	balloon.className = 'gmx_balloon leaflet-pan-anim leaflet-zoom-animated';
    //	gmxAPI._leaflet.LMap['_mapPane'].appendChild(balloon);
    //}
    var css={'table':'background-color: transparent; width: auto; margin: 2px; border-collapse: collapse; font-size: 11px; font-family: sans-serif;','bg_top_left':'background-color: transparent; width: 13px; height: 18px; border: 0px none; padding: 1px; display: block; background-position: 2px 9px; background-image: url(\''+apiBase+'img/tooltip-top-left.png\'); background-repeat: no-repeat;','bg_top':'background-color: transparent; height: 18px; border: 0px none; padding: 0px; background-position: center 9px; background-image: url(\''+apiBase+'img/tooltip-top.png\'); background-repeat: repeat-x;','bg_top_right':'background-color: transparent; width: 18px; height: 18px; border: 0px none; padding: 1px; display: block; background-position: -5px 9px; background-image: url(\''+apiBase+'img/tooltip-top-right.png\'); background-repeat: no-repeat;','bg_left':'background-color: transparent; width: 13px; border: 0px none; padding: 1px; background-position: 2px top; background-image: url(\''+apiBase+'img/tooltip-left.png\'); background-repeat: repeat-y;','bg_center':'background-color: transparent; width: 50px; min-width: 50px; border: 0px none; background-color: white; padding: 4px; padding-right: 14px;','bg_right':'background-color: transparent; width: 13px; height: 18px; border: 0px none; padding: 1px; background-position: 0px top; background-image: url(\''+apiBase+'img/tooltip-right.png\'); background-repeat: repeat-y;','bg_bottom_left':'background-color: transparent; width: 13px; height: 18px; border: 0px none; padding: 1px; background-position: 2px top; background-image: url(\''+apiBase+'img/tooltip-bottom-left.png\'); background-repeat: no-repeat;','bg_bottom':'background-color: transparent; height: 18px; border: 0px none; padding: 1px; background-position: center top; background-image: url(\''+apiBase+'img/tooltip-bottom.png\'); background-repeat: repeat-x;','bg_bottom_right':'background-color: transparent; width: 18px; height: 18px; border: 0px none; padding: 1px; background-position: -2px top; background-image: url(\''+apiBase+'img/tooltip-bottom-right.png\'); background-repeat: no-repeat;','leg':'bottom: 18px; left: 0px; width: 68px; height: 41px; position: relative; background-repeat: no-repeat; background-image: url(\''+apiBase+'img/tooltip-leg.png\');'};var transp='';if(gmxAPI.isChrome||gmxAPI.isIE)transp='<img width="10" height="10" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAABBJREFUeNpi+P//PwNAgAEACPwC/tuiTRYAAAAASUVORK5CYII=">';// Для Chrome добавляем невидимый контент в TD
    var body='<table cols="3" cellspacing="0" cellpadding="0" border="0" style="'+css['table']+'">'+'<tr>'+'<td style="'+css['bg_top_left']+'">'+transp+'</td>'+'<td style="'+css['bg_top']+'">'+transp+'</td>'+'<td style="'+css['bg_top_right']+'">'+transp+'</td>'+'</tr>'+'<tr>'+'<td style="'+css['bg_left']+'">'+transp+'</td>'+'<td style="'+css['bg_center']+'">'+'<div class="kosmosnimki_balloon">'+'</div>'+'</td>'+'<td style="'+css['bg_right']+'">'+transp+'</td>'+'</tr>'+'<tr>'+'<td style="'+css['bg_bottom_left']+'">'+transp+'</td>'+'<td style="'+css['bg_bottom']+'">'+transp+'</td>'+'<td style="'+css['bg_bottom_right']+'">'+transp+'</td>'+'</tr>'+'</table>';balloon.innerHTML=body;var nodes=balloon.getElementsByTagName("div");var balloonText=nodes[0];var imgStyle={position:"absolute",pointerEvents:"none",bottom:"-21px",right:"15px"};if(document.doctype){//if(gmxAPI.isChrome || gmxAPI.isSafari || gmxAPI.isIE) 
    if(!window.opera)imgStyle["bottom"]="-19px";}else if(gmxAPI.isIE&&document.documentMode>=8)imgStyle["bottom"]="-19px";var leg=gmxAPI.newElement("img",{className:'gmx_balloon_leg',src:apiBase+"img/tooltip-leg.png"},imgStyle);balloon.appendChild(leg);var x=0;var y=0;var legX=null;var bposX=0;var bposY=0;var reposition=function reposition(){//if(!wasVisible) return;
    var ww=balloon.clientWidth;var hh=balloon.clientHeight;balloon.style.visibility=ww==0||hh==0?'hidden':'visible';var screenWidth=div.clientWidth;var yy=div.clientHeight-y+20;var xx=x+ww<screenWidth?x:ww<screenWidth?screenWidth-ww:0;xx=Math.max(xx,x-ww+legWidth+brw);var dx=x-xx;if(legX!=dx)leg.style.left=dx+"px";legX=dx;xx+=2;if(bposX!=xx||bposY!=yy){if(balloon.parentNode!=div)gmxAPI.position(balloon,xx,yy);else gmxAPI.bottomPosition(balloon,xx,yy);}bposX=xx;bposY=yy;};var updateVisible=function updateVisible(flag){gmxAPI.setVisible(balloon,flag);if(flag&&!wasVisible){ret.resize();}wasVisible=flag;};var isVisible=function isVisible(){return wasVisible;};var wasVisible=true;var setMousePos=function setMousePos(x_,y_){x=this.mouseX=x_;y=this.mouseY=y_;};var ret={// Возвращаемый обьект
    outerDiv:balloon,div:balloonText,leg:leg,mouseX:0,mouseY:0,//delayHide: false,
    delayShow:false,isVisible:isVisible,setVisible:updateVisible,setMousePos:setMousePos,setScreenPosition:function setScreenPosition(x_,y_){setMousePos(x_,y_);if(wasVisible)reposition();},resize:function resize(){reposition();},updatePropsBalloon:function updatePropsBalloon(text){//ret.outerDiv.style.pointerEvents = 'none';
    updateVisible(text&&!buttons?true:false);chkBalloonText(text,balloonText);reposition();},chkMouseOut:function chkMouseOut(){if(propsBalloon.delayHide)updateVisible(false);},stateListeners:{},addListener:function addListener(eventName,func){return gmxAPI._listeners.addListener({'obj':this,'eventName':eventName,'func':func});},removeListener:function removeListener(eventName,id){return gmxAPI._listeners.removeListener(this,eventName,id);}};return ret;}var propsBalloon=createBalloon(true);// Balloon для mouseOver
    this.propsBalloon=propsBalloon;propsBalloon.setVisible(false);propsBalloon.outerDiv.style.zIndex=10000;propsBalloon.outerDiv.style.display="none";/*
    		document.onmouseover = function(ev)
    		{
    			var event = gmxAPI.compatEvent(ev);
    			if(event && event.target != propsBalloon.leg) setDelayHide();
    		}
    		document.onmouseout = function(event)
    		{
    			if(!gmxAPI.contDivPos) return;
    			var minx = gmxAPI.contDivPos['x'];
    			var maxx = minx + gmxAPI._div.clientWidth;
    			var eventX = gmxAPI.eventX(event);
    			var miny = gmxAPI.contDivPos['y'];
    			var maxy = miny + gmxAPI._div.clientHeight;
    			var eventY = gmxAPI.eventY(event);
    			if(eventX >= minx && eventX <= maxx && eventY >= miny && eventY <= maxy) return;
    			propsBalloon.outerDiv.style.display = "none";
    		}
    */div.onmouseout=function(ev)// скрыть балун по наведению если мышь ушла
    {if(gmxAPI.proxyType==='leaflet')return;if(propsBalloon.isVisible()){var event=gmxAPI.compatEvent(ev);var tg=gmxAPI.compatTarget(event);var reltg=event.toElement||event.relatedTarget;while(reltg&&reltg!=document.documentElement){if(reltg==propsBalloon.outerDiv){return;}reltg=reltg.offsetParent;}while(tg&&tg!=document.documentElement){if(tg==propsBalloon.outerDiv)return;tg=tg.offsetParent;}propsBalloon.outerDiv.style.display="none";}};var positionBalloons=function positionBalloons(ph){if(balloons.length<1)return;refreshMapPosition(ph);balloons.sort(function(b1,b2){return b1.isHovered?1:b2.isHovered?-1:b2.geoY-b1.geoY;});for(var i=0;i<balloons.length;i++){var bal=balloons[i];bal.reposition();if(bal.outerDiv.style.zIndex!=1000+i)bal.outerDiv.style.zIndex=1000+i;}};//map.addObject().setHandler("onMove", positionBalloons);
    gmxAPI.contDivPos=null;var eventXprev=0;var eventYprev=0;var buttons=false;var onmousemove=function onmousemove(ev){var px=0;var py=0;if(gmxAPI._leaflet&&gmxAPI._leaflet['containerPoint']){px=gmxAPI._leaflet['containerPoint']['x'];py=gmxAPI._leaflet['containerPoint']['y'];}else{var event=gmxAPI.compatEvent(ev);if(!event)return;//buttons = event.buttons;
    var eventX=gmxAPI.eventX(event);var eventY=gmxAPI.eventY(event);if(eventX==eventXprev&&eventY==eventYprev)return;eventXprev=eventX;eventYprev=eventY;px=eventX;py=eventY;gmxAPI.contDivPos={'x':gmxAPI.getOffsetLeft(div),'y':gmxAPI.getOffsetTop(div)};px-=gmxAPI.contDivPos['x'];py-=gmxAPI.contDivPos['y'];}propsBalloon.setScreenPosition(px,py);};gmxAPI._div.onmousemove=function(ev){if(gmxAPI.mousePressed)return;onmousemove(ev);};gmxAPI.map.addListener('positionChanged',function(ph){if(ph&&ph.currZ!=Math.floor(ph.currZ))return;positionBalloons();},-10);gmxAPI.map.addListener('onResizeMap',function(){/*			
    				gmxAPI.contDivPos = {
    					'x': gmxAPI.getOffsetLeft(div),
    					'y': gmxAPI.getOffsetTop(div)
    				};
    */gmxAPI.contDivPos={'x':div.offsetLeft,'y':div.offsetTop};positionBalloons();},-10);function addBalloon(_notDelFlag){var balloon=createBalloon();balloon.notDelFlag=_notDelFlag;balloon.geoX=0;balloon.geoY=0;balloon.isDraging=false;balloon.isRemoved=false;var oldSetVisible=balloon.setVisible;balloon.outerDiv.onmouseover=function(ev){balloon.isHovered=true;positionBalloons();gmxAPI._mouseOnBalloon=true;if(propsBalloon.isVisible()){propsBalloon.setVisible(false);gmxAPI._listeners.dispatchEvent('hideHoverBalloon',gmxAPI.map,{});}};balloon.outerDiv.onmouseout=function(){balloon.isHovered=false;positionBalloons();gmxAPI._mouseOnBalloon=false;};balloon.outerDiv.appendChild(gmxAPI.newElement("img",{src:apiBase+"img/close.png",title:gmxAPI.KOSMOSNIMKI_LOCALIZED("Закрыть","Close"),onclick:function onclick(ev){if(balloon.notDelFlag){balloon.setVisible(false);}else{balloon.remove();balloon.isVisible=false;}gmxAPI.stopEvent(ev);gmxAPI._mouseOnBalloon=false;gmxAPI._listeners.dispatchEvent('onClose',balloon,false);},onmouseover:function onmouseover(){this.src=apiBase+"img/close_orange.png";},onmouseout:function onmouseout(){this.src=apiBase+"img/close.png";}},{position:"absolute",top:"15px",right:"15px",cursor:"pointer"}));balloon.isVisible=true;balloon.reposition=function(){if(balloon.isVisible){refreshMapPosition();var sc=scale*stageZoom;// Смещение Балуна к центру
    var deltaX=0;if(!balloon.isDraging&&gmxAPI.proxyType==='flash'){var pos=gmxAPI.chkPointCenterX(this.geoX);var centrGEO=gmxAPI.from_merc_x(mapX);var mind=Math.abs(pos-centrGEO);for(var i=1;i<4;i++){var d1=Math.abs(pos-centrGEO+i*360);if(d1<mind){mind=d1;deltaX=i*360;}d1=Math.abs(pos-centrGEO-i*360);if(d1<mind){mind=d1;deltaX=-i*360;}}deltaX=gmxAPI.merc_x(deltaX)/sc;}var px=(mapX-gmxAPI.merc_x(balloon.geoX))/sc;var py=(mapY-gmxAPI.merc_y(balloon.geoY))/sc;var x=div.clientWidth/2-px+deltaX;var y=div.clientHeight/2+py;if(balloon.keyPress){// если задано смещение в пикселах
    if(balloon.keyPress.dx)x+=balloon.keyPress.dx;if(balloon.keyPress.dy)y+=balloon.keyPress.dy;}/*if(balloon.fixedDeltaFlag) {
    						x += balloon.fixedDeltaX;
    						y -= balloon.fixedDeltaY;
    					}*/var flag=y<0||y>div.clientHeight?false:true;if(flag){if(x<0||x>div.clientWidth)flag=false;}if(flag){this.setScreenPosition(x,y);oldSetVisible(true);}else oldSetVisible(false);}else{oldSetVisible(false);}};balloon.setVisible=function(flag){balloon.isVisible=flag;this.reposition();if(!flag)setTimeout(function(){gmxAPI._mouseOnBalloon=false;},20);};balloon.setPoint=function(x_,y_,isDraging_){this.geoX=x_;this.geoY=y_;this.isDraging=isDraging_;positionBalloons();};balloon.remove=function(){gmxAPI._mouseOnBalloon=false;if(balloon.isRemoved)return false;if(balloon.fixedId)delete fixedHoverBalloons[balloon.fixedId];for(var i=0;i<balloons.length;i++){if(balloons[i]==balloon){balloons.splice(i,1);break;}}if(this.outerDiv.parentNode)this.outerDiv.parentNode.removeChild(this.outerDiv);//div.removeChild(this.outerDiv);
    var gmxNode=gmxAPI.mapNodes[balloon.pID];// Нода gmxAPI
    gmxAPI._listeners.dispatchEvent('onBalloonRemove',gmxNode,{'obj':balloon.obj});// balloon удален
    balloon.isRemoved=true;};balloon.getX=function(){return this.geoX;};balloon.getY=function(){return this.geoY;};balloons.push(balloon);return balloon;}this.addBalloon=addBalloon;/** Установка параметров пользовательского балуна для фильтра слоя
            * @memberOf BalloonClass#
            * @param {Filter} filter - обьект фильтра слоя.
            * @param {object} balloonParams - параметры балуна для фильтра.
            * @param {boolean} balloonParams.DisableBalloonOnMouseMove - отключить балун при наведении указателя(по умолчанию равен false).
            * @param {boolean} balloonParams.DisableBalloonOnClick - отключить балун при click(по умолчанию равен false).
            * @param {String} balloonParams.Balloon - шаблон балуна(по умолчанию равен '').
            */var setBalloonFromParams=function setBalloonFromParams(filter,balloonParams){/*			
    			//по умолчанию балуны показываются
    			if ( typeof balloonParams.BalloonEnable !== 'undefined' && !balloonParams.BalloonEnable )
    			{
    				disableHoverBalloon(filter);
    				//return;
    			}
    */var balloonAttrs={disableOnClick:balloonParams.DisableBalloonOnClick,disableOnMouseOver:balloonParams.DisableBalloonOnMouseMove};if(balloonParams.Balloon){filter['_balloonTemplate']=balloonParams.Balloon;enableHoverBalloon(filter,function(o){var props=gmxAPI.clone(o.properties);props.SUMMARY=o.getGeometrySummary();if(o._balloonHook){for(var key in o._balloonHook){props[key]=gmxAPI.applyTemplate(o._balloonHook[key].resStr,props);}}var text=gmxAPI.applyTemplate(balloonParams.Balloon,props);text=text.replace(/\[SUMMARY\]/g,'');return text;},balloonAttrs);}else{enableHoverBalloon(filter,null,balloonAttrs);}};this.setBalloonFromParams=setBalloonFromParams;//явно прописывает все свойства балунов в стиле.
    var applyBalloonDefaultStyle=function applyBalloonDefaultStyle(balloonStyle){var out=gmxAPI.clone(balloonStyle);//слой только что создали - всё по умолчанию!
    if(typeof out.BalloonEnable==='undefined'){out.BalloonEnable=true;out.DisableBalloonOnClick=false;out.DisableBalloonOnMouseMove=true;}else{//поддержка совместимости - если слой уже был, но новых параметров нет 
    if(typeof out.DisableBalloonOnClick==='undefined')out.DisableBalloonOnClick=false;if(typeof out.DisableBalloonOnMouseMove==='undefined')out.DisableBalloonOnMouseMove=false;}return out;};this.applyBalloonDefaultStyle=applyBalloonDefaultStyle;}var userBalloons={};// Добавление прослушивателей событий
    gmxAPI._listeners.addListener({'level':-10,'eventName':'mapInit','func':function func(map){if(!gmxAPI.map||gmxAPI.map.balloonClassObject)return;gmxAPI.map.balloonClassObject=new BalloonClass();gmxAPI.map.addListener('zoomBy',function(){gmxAPI.map.balloonClassObject.hideHoverBalloons(true);});gmxAPI.map.addListener('hideBalloons',function(attr){gmxAPI.map.balloonClassObject.hideHoverBalloons(null,attr);});gmxAPI.map.addListener('onMoveEnd',function(){gmxAPI.map.balloonClassObject.showHoverBalloons();});gmxAPI.map.addListener('clickBalloonFix',function(o){gmxAPI.map.balloonClassObject.clickBalloonFix(o);});gmxAPI.map.addListener('initFilter',function(data){var fullStyle=gmxAPI.map.balloonClassObject.applyBalloonDefaultStyle(data['filter']['_attr']);gmxAPI.map.balloonClassObject.setBalloonFromParams(data['filter'],fullStyle);});//расширяем FlashMapObject
    gmxAPI.extendFMO('addBalloon',function(){var balloon=map.balloonClassObject.addBalloon();var id=gmxAPI.newFlashMapId();balloon.fixedId=id;userBalloons[id]=balloon;return balloon;});gmxAPI.extendFMO('enableHoverBalloon',function(callback,attr){if(this.filters){this.filters.foreach(function(item){map.balloonClassObject.enableHoverBalloon(item,callback,attr);});}else{map.balloonClassObject.enableHoverBalloon(this,callback,attr);}});gmxAPI.extendFMO('disableHoverBalloon',function(){if(this.filters){this.filters.foreach(function(item){map.balloonClassObject.disableHoverBalloon(item);});}else{map.balloonClassObject.disableHoverBalloon(this);}});gmxAPI.extendFMO('addBalloonHook',function(key,callback){var hookID=gmxAPI.newFlashMapId();var res={key:key,hookID:hookID,resStr:"<span id='"+hookID+"'></span>",callback:callback};if(this.filters){this.filters.foreach(function(item){if(!item._balloonHook)item._balloonHook={};if(item._balloonHook[key])return false;item._balloonHook[key]=res;});}else{if(!this._balloonHook)this._balloonHook={};if(this._balloonHook[key])return false;this._balloonHook[key]=res;}return true;});gmxAPI.extendFMO('removeBalloonHook',function(key){if(this.filters){this.filters.foreach(function(item){if(item._balloonHook)delete item._balloonHook[key];});}else{if(this._balloonHook)delete this._balloonHook[key];}});}});//gmxAPI.BalloonClass = BalloonClass;
    })();(function(){var outlineColor=0x0000ff;var fillColor=0xffffff;var currentDOMObject=null;// текущий обьект рисования
    var regularDrawingStyle={marker:{size:3},outline:{color:outlineColor,thickness:3,opacity:80},fill:{color:fillColor}};var hoveredDrawingStyle={marker:{size:4},outline:{color:outlineColor,thickness:4},fill:{color:fillColor}};var getStyle=function getStyle(removeDefaults,mObj){var out=mObj.getStyle(removeDefaults);if(out&&!removeDefaults){if(!out.regular)out.regular=regularDrawingStyle;if(!out.hovered)out.hovered=hoveredDrawingStyle;}return out;};var objects={};var drawFunctions={};var chkDrawingObjects=function chkDrawingObjects(){for(var id in objects){var cObj=objects[id];if(!cObj.geometry)cObj.remove();}};var endDrawing=function endDrawing(){// Вызывается при выходе из режима редактирования
    chkDrawingObjects();//gmxAPI._listeners.dispatchEvent('endDrawing', drawing, currentDOMObject);	// Генерация события выхода из режима редактирования
    currentDOMObject=null;};var createDOMObject=function createDOMObject(ret,properties){var myId=gmxAPI.newFlashMapId();var callHandler=function callHandler(eventName){var handlers=gmxAPI.map.drawing.handlers[eventName]||[];for(var i=0;i<handlers.length;i++){handlers[i](objects[myId]);}gmxAPI._listeners.dispatchEvent(eventName,gmxAPI.map.drawing,objects[myId]);};var addHandlerCalled=false;objects[myId]={properties:properties||{},setText:ret.setText,setVisible:function setVisible(flag){ret.setVisible(flag);this.properties.isVisible=flag;},update:function update(geometry,text){if(!geometry)return;// Если нет geometry ничего не делаем
    this.properties.text=text;this.properties.isVisible=ret.isVisible;this.geometry=geometry;this.balloon=ret.balloon;callHandler(addHandlerCalled?"onEdit":"onAdd");addHandlerCalled=true;},remove:function remove(){ret.remove();},removeInternal:function removeInternal(){callHandler("onRemove");delete objects[myId];},triggerInternal:function triggerInternal(callbackName){callHandler(callbackName);},getGeometry:function getGeometry(){return this.geometry;},getLength:function getLength(){return gmxAPI.geoLength(this.geometry);},getArea:function getArea(){return gmxAPI.geoArea(this.geometry);},getCenter:function getCenter(){return gmxAPI.geoCenter(this.geometry);},setStyle:function setStyle(regularStyle,hoveredStyle){ret.setStyle(regularStyle,hoveredStyle);},getVisibleStyle:function getVisibleStyle(){return ret.getVisibleStyle();},getStyle:function getStyle(removeDefaults){return ret.getStyle(removeDefaults);},stateListeners:{},addListener:function addListener(eventName,func){return gmxAPI._listeners.addListener({'obj':this,'eventName':eventName,'func':func});},removeListener:function removeListener(eventName,id){return gmxAPI._listeners.removeListener(this,eventName,id);}};currentDOMObject=ret.domObj=objects[myId];return objects[myId];};drawFunctions.POINT=function(coords,props){if(!props)props={};var text=props.text;if(!text)text="";var obj=false;var balloon=false;var domObj;var isDrawing=true;var ret={};var toolsContainer=null;if('_tools'in gmxAPI&&'standart'in gmxAPI._tools){toolsContainer=gmxAPI._tools['standart'];toolsContainer.currentlyDrawnObject=ret;}ret.isVisible=props.isVisible==undefined?true:props.isVisible;ret.stopDrawing=function(){gmxAPI._cmdProxy('stopDrawing');if(!isDrawing)return;isDrawing=false;if(!coords){gmxAPI.map.unfreeze();gmxAPI._sunscreen.setVisible(false);gmxAPI._setToolHandler("onClick",null);gmxAPI._setToolHandler("onMouseDown",null);gmxAPI.map.clearCursor();}};ret.remove=function(){if(obj){gmxAPI._listeners.dispatchEvent('onRemove',domObj,domObj);obj.remove();if(balloon)balloon.remove();domObj.removeInternal();}};ret.setStyle=function(regularStyle,hoveredStyle){};var done=function done(xx,yy){obj=gmxAPI.map.addObject();balloon=gmxAPI.map.balloonClassObject?gmxAPI.map.balloonClassObject.addBalloon(true):null;// Редактируемый балун (только скрывать)
    gmxAPI.map.addListener('zoomBy',function(){if(balloon.isVisible)gmxAPI.setVisible(balloon.outerDiv,false);});gmxAPI.map.addListener('onMoveEnd',function(){if(balloon.isVisible){gmxAPI.setVisible(balloon.outerDiv,true);balloon.reposition();}});var updateDOM=function updateDOM(){xx=gmxAPI.chkPointCenterX(xx);domObj.update({type:"POINT",coordinates:[xx,yy]},text);};ret.setText=function(newText){if(!balloon)return;text=newText;input.value=newText;updateText();};ret.setVisible=function(flag){ret.isVisible=flag;obj.setVisible(ret.isVisible);if(balloon)balloon.setVisible(ret.isVisible&&balloonVisible);};ret.balloon=balloon;ret.getVisibleStyle=function(){return obj.getVisibleStyle();};ret.getStyle=function(removeDefaults){return getStyle(removeDefaults,obj);};var position=function position(x,y){xx=x;yy=y;gmxAPI._cmdProxy('setAPIProperties',{'obj':obj,'attr':{'type':'POINT','isDraging':isDragged}});obj.setPoint(xx,yy);if(balloon)balloon.setPoint(xx,yy,isDragged);updateDOM();};var apiBase=gmxAPI.getAPIFolderRoot();obj.setStyle({marker:{image:apiBase+"img/flag_blau1.png",dx:-6,dy:-36},label:{size:12,color:0xffffc0}},{marker:{image:apiBase+"img/flag_blau1_a.png",dx:-6,dy:-36},label:{size:12,color:0xffffc0}});var startDx,startDy,isDragged=false;var clickTimeout=false;var needMouseOver=true;obj.setHandlers({"onClick":function onClick(){if(domObj.stateListeners['onClick']&&gmxAPI._listeners.dispatchEvent('onClick',domObj,domObj))return;// если установлен пользовательский onClick возвращающий true выходим
    if(clickTimeout){clearTimeout(clickTimeout);clickTimeout=false;ret.remove();}else{clickTimeout=setTimeout(function(){clickTimeout=false;},500);if(balloon){balloonVisible=!balloon.isVisible;balloon.setVisible(balloonVisible);if(balloonVisible)setHTMLVisible(true);else{gmxAPI.hide(input);gmxAPI.hide(htmlDiv);}}}},"onMouseOver":function onMouseOver(){if(!isDragged&&needMouseOver){gmxAPI._listeners.dispatchEvent('onMouseOver',domObj,domObj);needMouseOver=false;}},"onMouseOut":function onMouseOut(){if(!isDragged&&!needMouseOver){gmxAPI._listeners.dispatchEvent('onMouseOut',domObj,domObj);needMouseOver=true;}}});var dragCallback=function dragCallback(x,y){position(x+startDx,y+startDy);gmxAPI._listeners.dispatchEvent('onEdit',domObj,domObj);};var downCallback=function downCallback(x,y){x=gmxAPI.chkPointCenterX(x);startDx=xx-x;startDy=yy-y;isDragged=true;gmxAPI._cmdProxy('setAPIProperties',{'obj':obj,'attr':{'type':'POINT','isDraging':isDragged}});};var upCallback=function upCallback(){gmxAPI._cmdProxy('setAPIProperties',{'obj':obj,'attr':{'type':'POINT','isDraging':false}});if(balloon)balloon.setPoint(xx,yy,false);obj.setPoint(xx,yy);isDragged=false;};obj.enableDragging(dragCallback,downCallback,upCallback);if(balloon){// Это все касается балуна для маркера
    var htmlDiv=document.createElement("div");htmlDiv.onclick=function(event){event=event||window.event;var e=gmxAPI.compatTarget(event);if(e==htmlDiv){setHTMLVisible(false);input.focus();}};balloon.div.appendChild(htmlDiv);var input=document.createElement("textarea");input.style.backgroundColor="transparent";input.style.border=0;input.style.overflow="hidden";var fontSize=16;input.style.fontSize=fontSize+'px';input.setAttribute("wrap","off");input.value=text?text:"";var updateText=function updateText(){var newText=input.value;var rows=1;for(var i=0;i<newText.length;i++){if(newText.charAt(i)=='\n'.charAt(0))rows+=1;}input.rows=rows;var lines=newText.split("\n");var cols=2;for(var i in lines){cols=Math.max(cols,lines[i].length+3);}input.cols=cols;input.style.width=cols*(fontSize-(gmxAPI.isIE?5:6));text=newText;if(balloon)balloon.resize();updateDOM();};input.onkeyup=updateText;input.onblur=function(){setHTMLVisible(true);};input.onmousedown=function(e){if(!e)e=window.event;if(e.stopPropagation)e.stopPropagation();else e.cancelBubble=true;};if(balloon)balloon.div.appendChild(input);var setHTMLVisible=function setHTMLVisible(flag){gmxAPI.setVisible(input,!flag);gmxAPI.setVisible(htmlDiv,flag);if(flag)htmlDiv.innerHTML=gmxAPI.strip(input.value)==""?"&nbsp;":input.value;if(balloon)balloon.resize();};var balloonVisible=text&&text!=""?true:false;setHTMLVisible(balloonVisible);var getEventPoint=function getEventPoint(event){//var currPos = gmxAPI.currPosition || gmxAPI.map.getPosition();
    var currPos=gmxAPI.map.getPosition();var mapX=currPos['x'];var mapY=currPos['y'];var scale=gmxAPI.getScale(currPos['z']);var px=gmxAPI.eventX(event)-gmxAPI.contDivPos['x'];var py=gmxAPI.eventY(event)-gmxAPI.contDivPos['y'];return {'x':gmxAPI.from_merc_x(mapX+(px-gmxAPI._div.clientWidth/2)*scale),'y':gmxAPI.from_merc_y(mapY-(py-gmxAPI._div.clientHeight/2)*scale)};};balloon.outerDiv.onmousedown=function(event){gmxAPI._cmdProxy('startDrawing');gmxAPI._cmdProxy('setAPIProperties',{'obj':obj,'attr':{'type':'POINT','isDraging':true}});var eventPoint=getEventPoint(event);downCallback(eventPoint['x'],eventPoint['y']);gmxAPI._startDrag(obj,dragCallback,upCallback);return false;};balloon.outerDiv.onmouseup=function(event){gmxAPI._cmdProxy('stopDrawing');gmxAPI._cmdProxy('setAPIProperties',{'obj':obj,'attr':{'type':'POINT','isDraging':false}});gmxAPI._stopDrag();upCallback();};balloon.outerDiv.onmousemove=function(event){if(isDragged){var eventPoint=getEventPoint(event);position(startDx+eventPoint['x'],startDy+eventPoint['y']);gmxAPI.deselect();return false;}};}domObj=createDOMObject(ret);domObj.objectId=obj.objectId;position(xx,yy);if(balloon){balloon.setVisible(balloonVisible);updateText();}gmxAPI._listeners.dispatchEvent('onAdd',domObj,domObj);ret.setVisible(ret.isVisible);gmxAPI._listeners.dispatchEvent('onFinish',gmxAPI.map.drawing,domObj);};if(!coords){gmxAPI._sunscreen.bringToTop();gmxAPI._sunscreen.setVisible(true);var apiBase=gmxAPI.getAPIFolderRoot();gmxAPI.map.setCursor(apiBase+"img/flag_blau1.png",-6,-36);gmxAPI._setToolHandler("onClick",function(){done(gmxAPI.map.getMouseX(),gmxAPI.map.getMouseY());if(toolsContainer){toolsContainer.selectTool("move");if(gmxAPI.map.isKeyDown(16)){toolsContainer.selectTool("POINT");}}ret.stopDrawing();});}else done(coords[0],coords[1]);return ret;};drawFunctions.LINESTRING=function(coords,props){if(!props)props={};var text=props.text;if(!text)text="";var ret={};var domObj=false;var toolsContainer=null;if('_tools'in gmxAPI&&'standart'in gmxAPI._tools){toolsContainer=gmxAPI._tools['standart'];toolsContainer.currentlyDrawnObject=ret;}var propsBalloon=gmxAPI.map.balloonClassObject?gmxAPI.map.balloonClassObject.propsBalloon:null;var obj=gmxAPI.map.addObject();obj.setStyle(regularDrawingStyle,hoveredDrawingStyle);obj.setEditable(true);// Проверка пользовательских Listeners LINESTRING
    var chkEvent=function chkEvent(eType,out){if(gmxAPI.map.drawing.enabledHoverBalloon){var st=out?out:false;propsBalloon.updatePropsBalloon(st);}gmxAPI._listeners.dispatchEvent(eType,domObj,domObj);gmxAPI._listeners.dispatchEvent(eType,gmxAPI.map.drawing,domObj);};var needMouseOver=true;obj.setHandlers({onEdit:function onEdit(){var eventName='onEdit';if(!domObj){domObj=createDOMObject(ret,props);domObj.objectId=obj.objectId;eventName='onAdd';}callOnChange();chkEvent(eventName,false);},onFinish:function onFinish(){callOnChange();gmxAPI._listeners.dispatchEvent('onFinish',domObj,domObj);gmxAPI._listeners.dispatchEvent('onFinish',gmxAPI.map.drawing,domObj);if(domObj.geometry&&toolsContainer)toolsContainer.selectTool("move");},onRemove:function onRemove(){ret.remove();},onNodeMouseOver:function onNodeMouseOver(cobj,attr){if(attr&&attr['buttonDown'])return;var out='';var type=obj.getGeometryType();if(type=="LINESTRING")out=gmxAPI.prettifyDistance(obj.getIntermediateLength());else if(type=="POLYGON")out=obj.getGeometrySummary();chkEvent('onNodeMouseOver',out);if(needMouseOver)gmxAPI._listeners.dispatchEvent('onMouseOver',domObj,domObj);needMouseOver=false;},onNodeMouseOut:function onNodeMouseOut(cobj,attr){if(attr&&attr['buttonDown'])return;chkEvent('onNodeMouseOut',false);if(!needMouseOver)gmxAPI._listeners.dispatchEvent('onMouseOut',domObj,domObj);needMouseOver=true;},onEdgeMouseOver:function onEdgeMouseOver(cobj,attr){if(attr&&attr['buttonDown'])return;chkEvent('onEdgeMouseOver',gmxAPI.prettifyDistance(obj.getCurrentEdgeLength()));if(needMouseOver)gmxAPI._listeners.dispatchEvent('onMouseOver',domObj,domObj);needMouseOver=false;},onEdgeMouseOut:function onEdgeMouseOut(cobj,attr){if(attr&&attr['buttonDown'])return;chkEvent('onEdgeMouseOut',false);if(!needMouseOver)gmxAPI._listeners.dispatchEvent('onMouseOut',domObj,domObj);needMouseOver=true;}});ret.isVisible=props.isVisible==undefined?true:props.isVisible;ret.setVisible=function(flag){obj.setVisible(flag);ret.isVisible=flag;};ret.setVisible(ret.isVisible);ret.remove=function(){obj.remove();if(domObj){gmxAPI._listeners.dispatchEvent('onRemove',domObj,domObj);domObj.removeInternal();}};ret.setText=function(newText){text=newText;callOnChange();};ret.setStyle=function(regularStyle,hoveredStyle){obj.setStyle(regularStyle,hoveredStyle);};ret.getVisibleStyle=function(){return obj.getVisibleStyle();};ret.getStyle=function(removeDefaults){return getStyle(removeDefaults,obj);};var callOnChange=function callOnChange(){var geom=obj.getGeometry();if(domObj)domObj.update(geom,text);};ret.stopDrawing=function(){obj.stopDrawing();};if(coords){domObj=createDOMObject(ret,props);domObj.objectId=obj.objectId;obj.setGeometry({type:"LINESTRING",coordinates:coords});callOnChange();}else{obj.startDrawing("LINESTRING");}return ret;};drawFunctions.POLYGON=function(coords,props){if(gmxAPI.isRectangle(coords))return drawFunctions.FRAME(coords,props);if(!props)props={};var text=props.text;if(!text)text="";var ret={};var domObj=false;var toolsContainer=null;if('_tools'in gmxAPI&&'standart'in gmxAPI._tools){toolsContainer=gmxAPI._tools['standart'];toolsContainer.currentlyDrawnObject=ret;}var propsBalloon=gmxAPI.map.balloonClassObject?gmxAPI.map.balloonClassObject.propsBalloon:null;var obj=gmxAPI.map.addObject();obj.setStyle(regularDrawingStyle,hoveredDrawingStyle);obj.setEditable(true);// Проверка пользовательских Listeners POLYGON
    var chkEvent=function chkEvent(eType,out){if(gmxAPI.map.drawing.enabledHoverBalloon){var st=out?out:false;propsBalloon.updatePropsBalloon(st);}gmxAPI._listeners.dispatchEvent(eType,domObj,domObj);gmxAPI._listeners.dispatchEvent(eType,gmxAPI.map.drawing,domObj);};var needMouseOver=true;obj.setHandlers({onEdit:function onEdit(){var eventName='onEdit';if(!domObj){domObj=createDOMObject(ret,props);domObj.objectId=obj.objectId;eventName='onAdd';}callOnChange();chkEvent(eventName,false);},onFinish:function onFinish(){gmxAPI._listeners.dispatchEvent('onFinish',domObj,domObj);gmxAPI._listeners.dispatchEvent('onFinish',gmxAPI.map.drawing,domObj);if(domObj.geometry&&toolsContainer)toolsContainer.selectTool("move");},onRemove:function onRemove(){ret.remove();},onNodeMouseOver:function onNodeMouseOver(cobj,attr){if(attr&&attr['buttonDown'])return;chkEvent('onNodeMouseOver',obj.getGeometrySummary());if(needMouseOver)gmxAPI._listeners.dispatchEvent('onMouseOver',domObj,domObj);needMouseOver=false;},onNodeMouseOut:function onNodeMouseOut(cobj,attr){if(attr&&attr['buttonDown'])return;chkEvent('onNodeMouseOut',false);if(!needMouseOver)gmxAPI._listeners.dispatchEvent('onMouseOut',domObj,domObj);needMouseOver=true;},onEdgeMouseOver:function onEdgeMouseOver(cobj,attr){if(attr&&attr['buttonDown'])return;chkEvent('onEdgeMouseOver',gmxAPI.prettifyDistance(obj.getCurrentEdgeLength()));if(needMouseOver)gmxAPI._listeners.dispatchEvent('onMouseOver',domObj,domObj);needMouseOver=false;},onEdgeMouseOut:function onEdgeMouseOut(cobj,attr){if(attr&&attr['buttonDown'])return;chkEvent('onEdgeMouseOut',false);if(!needMouseOver)gmxAPI._listeners.dispatchEvent('onMouseOut',domObj,domObj);needMouseOver=true;}});ret.isVisible=props.isVisible==undefined?true:props.isVisible;ret.setVisible=function(flag){obj.setVisible(flag);ret.isVisible=flag;};ret.setVisible(ret.isVisible);ret.remove=function(){obj.remove();if(domObj){gmxAPI._listeners.dispatchEvent('onRemove',domObj,domObj);domObj.removeInternal();}};ret.setText=function(newText){text=newText;callOnChange();};ret.setStyle=function(regularStyle,hoveredStyle){obj.setStyle(regularStyle,hoveredStyle);};ret.getVisibleStyle=function(){return obj.getVisibleStyle();};ret.getStyle=function(removeDefaults){return getStyle(removeDefaults,obj);};var callOnChange=function callOnChange(){var geom=obj.getGeometry();if(domObj)domObj.update(geom,text);};ret.stopDrawing=function(){obj.stopDrawing();};if(coords){for(var i=0;i<coords.length;i++){var lastNum=coords[i].length-1;if(coords[i][0][0]==coords[i][lastNum][0]&&coords[i][0][1]==coords[i][lastNum][1]){coords[i].pop();// если последняя точка совпадает с первой удаляем ее
    }}domObj=createDOMObject(ret,props);domObj.objectId=obj.objectId;obj.setGeometry({type:"POLYGON",coordinates:coords});callOnChange();}else{obj.startDrawing("POLYGON");}return ret;};drawFunctions.FRAME=function(coords,props){if(!props)props={};var text=props.text;if(!text)text="";var ret={};var domObj;var toolsContainer=null;if('_tools'in gmxAPI&&'standart'in gmxAPI._tools){toolsContainer=gmxAPI._tools['standart'];toolsContainer.currentlyDrawnObject=ret;}var obj=gmxAPI.map.addObject();gmxAPI._cmdProxy('setAPIProperties',{'obj':obj,'attr':{'type':'FRAME'}});var borders=obj.addObject();var corners=obj.addObject();var x1,y1,x2,y2;var isDraging=false;var eventType='';ret.isVisible=props.isVisible==undefined?true:props.isVisible;ret.setVisible=function(flag){obj.setVisible(flag);ret.isVisible=flag;};ret.setVisible(ret.isVisible);borders.setStyle(regularDrawingStyle,hoveredDrawingStyle);var x1Border=borders.addObject();var y1Border=borders.addObject();var x2Border=borders.addObject();var y2Border=borders.addObject();var propsBalloon=gmxAPI.map.balloonClassObject?gmxAPI.map.balloonClassObject.propsBalloon:null;var mouseUP=function mouseUP(){isDraging=false;if(propsBalloon)propsBalloon.updatePropsBalloon(false);domObj.triggerInternal("onMouseUp");chkEvent(null);gmxAPI._cmdProxy('stopDrawing');};corners.setStyle(regularDrawingStyle,hoveredDrawingStyle);var x1y1Corner=corners.addObject();var x1y2Corner=corners.addObject();var x2y1Corner=corners.addObject();var x2y2Corner=corners.addObject();// Проверка пользовательских Listeners FRAME
    var chkEvent=function chkEvent(){gmxAPI._listeners.dispatchEvent(eventType,domObj,domObj);gmxAPI._listeners.dispatchEvent(eventType,gmxAPI.map.drawing,domObj);};function getGeometryTitle(geom){var geomType=geom['type'];if(geomType.indexOf("POINT")!=-1){var c=geom.coordinates;return "<b>"+gmxAPI.KOSMOSNIMKI_LOCALIZED("Координаты:","Coordinates:")+"</b> "+gmxAPI.LatLon_formatCoordinates(c[0],c[1]);}else if(geomType.indexOf("LINESTRING")!=-1)return "<b>"+gmxAPI.KOSMOSNIMKI_LOCALIZED("Длина:","Length:")+"</b> "+gmxAPI.prettifyDistance(gmxAPI.geoLength(geom));else if(geomType.indexOf("POLYGON")!=-1)return "<b>"+gmxAPI.KOSMOSNIMKI_LOCALIZED("Площадь:","Area:")+"</b> "+gmxAPI.prettifyArea(gmxAPI.geoArea(geom));else return "?";}// Высвечивание балуна в зависимости от типа geometry
    var chkBalloon=function chkBalloon(tp){if(!isDraging&&propsBalloon){var geom={type:"POLYGON",coordinates:[[[x1,y1],[x2,y1],[x2,y2],[x1,y2],[x1,y1]]]};if(gmxAPI.map.drawing.enabledHoverBalloon){switch(tp){case'x1b':geom={type:"LINESTRING",coordinates:[[[x1,y1],[x1,y2]]]};break;case'x2b':geom={type:"LINESTRING",coordinates:[[[x2,y1],[x2,y2]]]};break;case'y1b':geom={type:"LINESTRING",coordinates:[[[x1,y1],[x2,y1]]]};break;case'y2b':geom={type:"LINESTRING",coordinates:[[[x1,y2],[x2,y2]]]};break;}propsBalloon.updatePropsBalloon(getGeometryTitle(geom));}}chkEvent();};var repaint=function repaint(flag){x1Border.setLine([[x1,y1],[x1,y2]]);y1Border.setLine([[x1,y1],[x2,y1]]);x2Border.setLine([[x2,y1],[x2,y2]]);y2Border.setLine([[x1,y2],[x2,y2]]);x1y1Corner.setPoint(x1,y1);x1y2Corner.setPoint(x1,y2);x2y1Corner.setPoint(x2,y1);x2y2Corner.setPoint(x2,y2);var geom={type:"POLYGON",coordinates:[[[x1,y1],[x2,y1],[x2,y2],[x1,y2],[x1,y1]]]};domObj.update(geom,text);};var mouseHandler=function mouseHandler(ev){gmxAPI._listeners.dispatchEvent(ev,domObj,domObj);};var needMouseOver=true;if(!needMouseOver)gmxAPI._listeners.dispatchEvent('onMouseOut',domObj,domObj);needMouseOver=true;x1Border.setHandlers({onMouseOver:function onMouseOver(){eventType='onEdgeMouseOver';chkBalloon('x1b');if(needMouseOver)mouseHandler('onMouseOver');needMouseOver=false;},onMouseOut:function onMouseOut(){eventType='onEdgeMouseOut';if(!isDraging)mouseUP();if(!needMouseOver)mouseHandler('onMouseOut');needMouseOver=true;}});x2Border.setHandlers({onMouseOver:function onMouseOver(){eventType='onEdgeMouseOver';chkBalloon('x2b');if(needMouseOver)mouseHandler('onMouseOver');needMouseOver=false;},onMouseOut:function onMouseOut(){eventType='onEdgeMouseOut';if(!isDraging)mouseUP();if(!needMouseOver)mouseHandler('onMouseOut');needMouseOver=true;}});y1Border.setHandlers({onMouseOver:function onMouseOver(){eventType='onEdgeMouseOver';chkBalloon('y1b');if(needMouseOver)mouseHandler('onMouseOver');needMouseOver=false;},onMouseOut:function onMouseOut(){eventType='onEdgeMouseOut';if(!isDraging)mouseUP();if(!needMouseOver)mouseHandler('onMouseOut');needMouseOver=true;}});y2Border.setHandlers({onMouseOver:function onMouseOver(){eventType='onEdgeMouseOver';chkBalloon('y2b');if(needMouseOver)mouseHandler('onMouseOver');needMouseOver=false;},onMouseOut:function onMouseOut(){eventType='onEdgeMouseOut';if(!isDraging)mouseUP();if(!needMouseOver)mouseHandler('onMouseOut');needMouseOver=true;}});var objHandlerCorner={onMouseOver:function onMouseOver(){eventType='onNodeMouseOver';chkBalloon();if(needMouseOver)mouseHandler('onMouseOver');needMouseOver=false;},onMouseOut:function onMouseOut(){eventType='onNodeMouseOut';if(!isDraging)mouseUP();if(!needMouseOver)mouseHandler('onMouseOut');needMouseOver=true;}};x1y1Corner.setHandlers(objHandlerCorner);x1y2Corner.setHandlers(objHandlerCorner);x2y1Corner.setHandlers(objHandlerCorner);x2y2Corner.setHandlers(objHandlerCorner);var dragMe=function dragMe(tp){gmxAPI._cmdProxy('startDrawing');isDraging=true;chkBalloon(tp);repaint();eventType='onEdit';chkEvent(null);if(propsBalloon&&gmxAPI.map.drawing.enabledHoverBalloon)propsBalloon.updatePropsBalloon(false);};x1Border.enableDragging(function(x,y){x1=x;dragMe('x1b');},null,mouseUP);y1Border.enableDragging(function(x,y){y1=y;dragMe('y1b');},null,mouseUP);x2Border.enableDragging(function(x,y){x2=x;dragMe('x2b');},null,mouseUP);y2Border.enableDragging(function(x,y){y2=y;dragMe('y2b');},null,mouseUP);x1y1Corner.enableDragging(function(x,y){x1=x;y1=y;dragMe();},null,mouseUP);x1y2Corner.enableDragging(function(x,y){x1=x;y2=y;dragMe();},null,mouseUP);x2y1Corner.enableDragging(function(x,y){x2=x;y1=y;dragMe();},null,mouseUP);x2y2Corner.enableDragging(function(x,y){x2=x;y2=y;dragMe();},null,mouseUP);var created=false;ret.remove=function(){eventType='onRemove';chkEvent(null);obj.remove();domObj.removeInternal();};ret.setStyle=function(regularStyle,hoveredStyle){borders.setStyle(regularStyle,hoveredStyle);corners.setStyle(regularStyle,hoveredStyle);};ret.getVisibleStyle=function(){return borders.getVisibleStyle();};ret.getStyle=function(removeDefaults){return getStyle(removeDefaults,borders);};ret.stopDrawing=function(){gmxAPI._cmdProxy('stopDrawing');gmxAPI.map.unfreeze();gmxAPI._sunscreen.setVisible(false);gmxAPI._setToolHandler("onMouseDown",null);};ret.setText=function(newText){text=newText;repaint();};if(coords){x1=coords[0][0][0];y1=coords[0][0][1];x2=coords[0][2][0];y2=coords[0][2][1];domObj=createDOMObject(ret,props);domObj.objectId=obj.objectId;repaint();eventType='onAdd';chkEvent(null);}else{gmxAPI._sunscreen.bringToTop();gmxAPI._sunscreen.setVisible(true);gmxAPI.map.enableDragging(function(x,y){gmxAPI._cmdProxy('startDrawing');isDraging=true;x2=x;y2=y;eventType='onEdit';if(!created){domObj=createDOMObject(ret,props);domObj.objectId=obj.objectId;eventType='onAdd';}chkEvent(null);created=true;repaint();},function(x,y){x1=x;y1=y;},function(){gmxAPI._cmdProxy('stopDrawing');isDraging=false;if(propsBalloon)propsBalloon.updatePropsBalloon(false);gmxAPI._setToolHandler("onMouseDown",null);if(toolsContainer)toolsContainer.selectTool("move");if(domObj)domObj.triggerInternal("onMouseUp");eventType='onFinish';chkEvent(null);});}return ret;};drawFunctions.zoom=function(){var x1,y1,x2,y2;var rect;var toolsContainer=null;if('_tools'in gmxAPI&&'standart'in gmxAPI._tools){toolsContainer=gmxAPI._tools['standart'];}var ret={stopDrawing:function stopDrawing(){gmxAPI._setToolHandler("onMouseDown",null);}};gmxAPI.map.enableDragging(function(x,y){x2=x;y2=y;rect.setRectangle(x1,y1,x2,y2);},function(x,y){x1=x;y1=y;rect=gmxAPI.map.addObject();rect.setStyle({outline:{color:0xa0a0a0,thickness:1,opacity:70}});},function(){var d=10*gmxAPI.getScale(gmxAPI.map.getZ());if(!x1||!x2||!y1||!y2||Math.abs(gmxAPI.merc_x(x1)-gmxAPI.merc_x(x2))<d&&Math.abs(gmxAPI.merc_y(y1)-gmxAPI.merc_y(y2))<d)gmxAPI.map.zoomBy(1,true);else gmxAPI.map.slideToExtent(Math.min(x1,x2),Math.min(y1,y2),Math.max(x1,x2),Math.max(y1,y2));rect.remove();gmxAPI._listeners.dispatchEvent('onFinish',gmxAPI.map.drawing,null);if(toolsContainer)toolsContainer.selectTool("move");});return ret;};drawFunctions["move"]=function(){};var drawing={handlers:{onAdd:[],onEdit:[],onRemove:[]},mouseState:'up',endDrawing:endDrawing,stateListeners:{},addListener:function addListener(eventName,func){return gmxAPI._listeners.addListener({'obj':this,'eventName':eventName,'func':func});},removeListener:function removeListener(eventName,id){return gmxAPI._listeners.removeListener(this,eventName,id);},enabledHoverBalloon:true,enableHoverBalloon:function enableHoverBalloon(){this.enabledHoverBalloon=true;},disableHoverBalloon:function disableHoverBalloon(){this.enabledHoverBalloon=false;},//props опционально
    addObject:function addObject(geom,props){if(geom.type.indexOf("MULTI")!=-1){for(var i=0;i<geom.coordinates.length;i++){this.addObject({type:geom.type.replace("MULTI",""),coordinates:geom.coordinates[i]},props);}}else{var o=drawFunctions[geom.type](geom.coordinates,props);//gmxAPI._tools['standart'].selectTool("move");
    return o.domObj;}},//поддерживаются events: onAdd, onRemove, onEdit
    //onRemove вызывается непосредственно ПЕРЕД удалением объекта
    //для FRAME поддерживается event onMouseUp - завершение изменения формы рамки
    setHandler:function setHandler(eventName,callback){if(!(eventName in this.handlers))this.handlers[eventName]=[];this.handlers[eventName].push(callback);},setHandlers:function setHandlers(handlers){for(var eventName in handlers){this.setHandler(eventName,handlers[eventName]);}},forEachObject:function forEachObject(callback){if(!callback)return;for(var id in objects){var cObj=objects[id];if(cObj.geometry)callback(cObj);}},toolInitFlags:{},tools:{setVisible:function setVisible(flag){if('toolsAll'in gmxAPI.map&&'standartTools'in gmxAPI.map.toolsAll)gmxAPI.map.toolsAll.standartTools.setVisible(flag);},_setVisibleTool:function _setVisibleTool(id,flag){if(!drawing.toolInitFlags[id])drawing.toolInitFlags[id]={};drawing.toolInitFlags[id].visible=flag;},POINT:{setVisible:function setVisible(flag){drawing.tools._setVisibleTool('POINT',flag);}},FRAME:{setVisible:function setVisible(flag){drawing.tools._setVisibleTool('FRAME',flag);}},LINESTRING:{setVisible:function setVisible(flag){drawing.tools._setVisibleTool('LINESTRING',flag);}}},addTool:function addTool(tn,hint,regularImageUrl,activeImageUrl,onClick,onCancel){var standartTools=gmxAPI._tools.standart?gmxAPI._tools.standart:gmxAPI.map.toolsAll.standartTools;var ret=standartTools.addTool(tn,{'key':tn,'activeStyle':{},'regularStyle':{},'regularImageUrl':regularImageUrl,'activeImageUrl':activeImageUrl,'onClick':onClick,'onCancel':onCancel,'hint':hint});return ret;},removeTool:function removeTool(tn){if(this.tools[tn]){gmxAPI.map.toolsAll.standartTools.removeTool(tn);}},selectTool:function selectTool(toolName){gmxAPI._tools['standart'].selectTool(toolName);}//расширяем namespace
    };gmxAPI._drawFunctions=drawFunctions;gmxAPI._drawing=drawing;})();(function(){var TemporalTiles=function TemporalTiles(obj_)// атрибуты временных тайлов
    {var mapObj=obj_,// Мультивременной слой
    prop=mapObj.properties,// Свойства слоя от сервера
    oneDay=1000*60*60*24,// один день
    temporalData=null,ZeroDateString=prop.ZeroDate||'01.01.2008',// нулевая дата
    arr=ZeroDateString.split('.'),zn=new Date(// Начальная дата
    arr.length>2?arr[2]:2008,arr.length>1?arr[1]-1:0,arr.length>0?arr[0]:1),ZeroDate=new Date(zn.getTime()-zn.getTimezoneOffset()*60000),// UTC начальная дата шкалы
    hostName=prop.hostName||'maps.kosmosnimki.ru',baseAddress="http://"+hostName+"/",layerName=prop.name||prop.image,sessionKey=isRequiredAPIKey(hostName)?window.KOSMOSNIMKI_SESSION_KEY:false,sessionKey2='sessionKeyCache'in window?window.sessionKeyCache[prop.mapName]:false,prefix=baseAddress+"TileSender.ashx?ModeKey=tile"+"&MapName="+encodeURIComponent(prop.mapName)+"&LayerName="+encodeURIComponent(layerName)+(sessionKey?"&key="+encodeURIComponent(sessionKey):"")+(sessionKey2?"&MapSessionKey="+encodeURIComponent(sessionKey2):"");if(prop._TemporalDebugPath){prefix=prop._TemporalDebugPath;//temporalData['_TemporalDebugPath'] = prop._TemporalDebugPath;
    }var identityField=prop.identityField;var TemporalColumnName=prop.TemporalColumnName||'Date';// Начальный интервал дат
    var DateEnd=new Date();if(prop.DateEnd){var arr=prop.DateEnd.split('.');if(arr.length>2)DateEnd=new Date(arr[2],arr[1]-1,arr[0]);}function getTilesHash(prop,ph){var tdata=prpTemporalTiles(prop.TemporalTiles,prop.TemporalVers,ph);var currentData=this.temporalData.currentData;var data=getDateIntervalTiles(currentData.dt1,currentData.dt2,tdata);var out={'hash':{},'del':{},'add':[],'count':0};var ptAdd={};for(var key in data.TilesVersionHash){if(!currentData.TilesVersionHash[key]){var arr=key.split('_');var st=arr[0]+'_'+arr[1]+'_'+arr[2];ptAdd[st]=true;out.del[arr[2]+'_'+arr[0]+'_'+arr[1]]=true;}}for(var key in currentData.TilesVersionHash){if(!data.TilesVersionHash[key]){var arr=key.split('_');out.del[arr[2]+'_'+arr[0]+'_'+arr[1]]=true;}}for(var key in ptAdd){var arr=key.split('_');out.add.push([arr[0],arr[1],arr[2]]);}out.count=data.dtiles.length/3;out.dtiles=data.dtiles;out.ut1=data.ut1;out.ut2=data.ut2;this.temporalData=tdata;// Обновление temporalData
    this.temporalData.currentData=data;return out;}this.getTilesHash=getTilesHash;function prpTemporalTiles(data,vers){var deltaArr=[],// интервалы временных тайлов [8, 16, 32, 64, 128, 256]
    deltaHash={},ph={};//var arr = [];
    if(!vers)vers=[];if(!data)data=[];for(var i=0,len=data.length;i<len;i++){var arr1=data[i];if(!arr1||!arr1.length||arr1.length<5){gmxAPI.addDebugWarnings({'func':'prpTemporalTiles','layer':prop.title,'alert':'Error in TemporalTiles array - line: '+nm+''});continue;}var z=Number(arr1[4]),y=Number(arr1[3]),x=Number(arr1[2]),s=Number(arr1[1]),d=Number(arr1[0]),v=Number(vers[i]);//tiles[gmxTileKey] = {x: x, y: y, z: z, s: s, d: d};
    if(!ph[z])ph[z]={};if(!ph[z][x])ph[z][x]={};if(!ph[z][x][y])ph[z][x][y]=[];ph[z][x][y].push(arr1);if(!deltaHash[d])deltaHash[d]={};if(!deltaHash[d][s])deltaHash[d][s]=[];deltaHash[d][s].push([x,y,z,v]);}var arr=[];for(var z in ph){for(var x in ph[z]){for(var y in ph[z][x]){arr.push(x,y,z);}}}for(var delta in deltaHash){deltaArr.push(parseInt(delta));}deltaArr=deltaArr.sort(function(a,b){return a-b;});return {dateTiles:arr,hash:ph,deltaHash:deltaHash,deltaArr:deltaArr};}temporalData=prpTemporalTiles(prop.TemporalTiles,prop.TemporalVers);this.temporalData=temporalData;var prpTemporalFilter=function prpTemporalFilter(DateBegin,DateEnd,columnName)// Подготовка строки фильтра
    {var dt1=DateBegin;// начало периода
    var dt2=DateEnd;// конец периода
    return {'dt1':dt1,'dt2':dt2,'ut1':Math.floor(dt1.getTime()/1000),'ut2':Math.floor(dt2.getTime()/1000)};};var getDateIntervalTiles=function getDateIntervalTiles(dt1,dt2,tdata){// Расчет вариантов от begDate до endDate
    var days=parseInt(1+(dt2-dt1)/oneDay);function getFiles(daysDelta){var ph={'files':[],'dtiles':[],'tiles':{},'TilesVersionHash':{},'out':''};var mn=oneDay*daysDelta;var zn=parseInt((dt1-ZeroDate)/mn);ph.beg=zn;ph.begDate=new Date(ZeroDate.getTime()+daysDelta*zn*oneDay);zn=parseInt(zn);var zn1=Math.floor((dt2-ZeroDate)/mn);ph.end=zn1;ph.endDate=new Date(ZeroDate.getTime()+daysDelta*oneDay*(zn1+1)-1000);zn1=parseInt(zn1);var dHash=tdata.deltaHash[daysDelta]||{};for(var dz in dHash){if(dz<zn||dz>zn1)continue;var arr=dHash[dz]||[];for(var i=0;i<arr.length;i++){var pt=arr[i];var x=pt[0];var y=pt[1];var z=pt[2];var v=pt[3];var file=prefix+"&Level="+daysDelta+"&Span="+dz+"&z="+z+"&x="+x+"&y="+y+"&v="+v;//if(_TemporalDebugPath) file = _prefix + daysDelta + '/' + dz + '/' + z + '/' + x + '/' + z + '_' + x + '_' + y + '.swf'; // тайлы расположены в WEB папке
    if(!ph.tiles[z])ph.tiles[z]={};if(!ph.tiles[z][x])ph.tiles[z][x]={};if(!ph.tiles[z][x][y])ph.tiles[z][x][y]=[];ph.tiles[z][x][y].push(file);ph.files.push(file);var st=x+'_'+y+'_'+z+'_'+daysDelta+'_'+dz+'_'+v;ph.TilesVersionHash[st]=true;}}var arr=[];for(var z in ph.tiles){for(var i in ph.tiles[z]){for(var j in ph.tiles[z][i]){arr.push(i,j,z);}}}ph.dtiles=arr;return ph;}var deltaArr=tdata.deltaArr;var i=deltaArr.length-1;var curDaysDelta=deltaArr[i];while(i>=0){curDaysDelta=deltaArr[i];if(days>=deltaArr[i]){break;}i--;}var ph=getFiles(curDaysDelta);var hash=prpTemporalFilter(dt1,dt2,TemporalColumnName);var tileDateFunction=function tileDateFunction(i,j,z){var filesHash=ph.tiles||{};var outArr=[];if(filesHash[z]&&filesHash[z][i]&&filesHash[z][i][j]){outArr=filesHash[z][i][j];}return outArr;};var out={'daysDelta':curDaysDelta,'files':ph.files,'tiles':ph.tiles,'dtiles':ph.dtiles||[]// список тайлов для daysDelta
    ,'out':ph.out,'beg':ph.beg,'end':ph.end,'begDate':ph.begDate,'endDate':ph.endDate,'ut1':hash.ut1,'ut2':hash.ut2,'dt1':dt1,'dt2':dt2,'tileDateFunction':tileDateFunction,'TilesVersionHash':ph.TilesVersionHash};return out;};this.getDateIntervalTiles=getDateIntervalTiles;var ddt1=new Date();ddt1.setHours(0,0,0,0);// начало текущих суток
    ddt1=new Date(ddt1.getTime()-ddt1.getTimezoneOffset()*60000);// UTC начальная дата
    var ddt2=new Date();ddt2.setHours(23,59,59,999);// конец текущих суток
    ddt2=new Date(ddt2.getTime()-ddt2.getTimezoneOffset()*60000);// UTC
    temporalData.currentData=getDateIntervalTiles(ddt1,ddt2,temporalData);// По умолчанию за текущие сутки
    var me=this;var setDateInterval=function setDateInterval(dt1,dt2,tdata){if(!tdata)tdata=mapObj._temporalTiles.temporalData;var currentData=tdata.currentData;if(!dt1){dt1=currentData.dt1;}else{currentData.dt1=dt1;}if(!dt2){dt2=currentData.dt2;}else{currentData.dt2=dt2;}var oldDt1=currentData.begDate;var oldDt2=currentData.endDate;var oldDaysDelta=currentData.daysDelta;var hash=prpTemporalFilter(dt1,dt2,TemporalColumnName);var ddt1=hash.dt1;var ddt2=hash.dt2;var data=getDateIntervalTiles(ddt1,ddt2,tdata);tdata.currentData=data;//mapObj._temporalTiles.temporalData['currentData'] = data;
    if(!mapObj.isVisible)return;var attr={dtiles:data.dtiles?data.dtiles:[],ut1:data.ut1,ut2:data.ut2};if(oldDaysDelta==data.daysDelta&&data.dt1>=oldDt1&&data.dt2<=oldDt2){// если интервал временных тайлов не изменился и интервал дат не расширяется - только добавление новых тайлов 
    attr.notClear=true;}else{if(mapObj.tilesParent){mapObj.tilesParent.clearItems();}}resetTiles(attr,mapObj);gmxAPI._listeners.dispatchEvent('hideBalloons',gmxAPI.map,{'from':mapObj.objectId});// Проверка map Listeners на hideBalloons
    return data.daysDelta;};this.setDateInterval=setDateInterval;var tileDateFunction=function tileDateFunction(i,j,z){var tdata=mapObj._temporalTiles.temporalData;var currentData=tdata.currentData;var filesHash=currentData.tiles||{};var outArr=[];if(filesHash[z]&&filesHash[z][i]&&filesHash[z][i][j]){outArr=filesHash[z][i][j];}return outArr;};var setVectorTiles=function setVectorTiles(){var tdata=mapObj._temporalTiles.temporalData;var currentData=tdata.currentData;var ph={'tileDateFunction':tileDateFunction,'dtiles':currentData.dtiles?currentData.dtiles:[],'temporal':{'TemporalColumnName':TemporalColumnName,'ut1':currentData.ut1,'ut2':currentData.ut2}};mapObj.setVectorTiles(ph.tileDateFunction,identityField,ph.dtiles,ph.temporal);};this.setVectorTiles=setVectorTiles;startLoadTiles=function startLoadTiles(attr,obj){var ret=gmxAPI._cmdProxy('startLoadTiles',{'obj':obj,'attr':attr});return ret;};this.ut1Prev=0;this.ut2Prev=0;resetTiles=function resetTiles(attr,obj){if(attr){startLoadTiles(attr,obj);if(attr.ut1==obj._temporalTiles.ut1Prev&&attr.ut2==obj._temporalTiles.ut2Prev)return;obj._temporalTiles.ut1Prev=attr.ut1;obj._temporalTiles.ut2Prev=attr.ut2;}for(var i=0;i<obj.filters.length;i++){// переустановка фильтров
    var filt=obj.filters[i];if(filt&&'setFilter'in filt)filt.setFilter(filt._sql,true);}};mapObj.setDateInterval=function(dt1,dt2){if(!mapObj._temporalTiles)return false;var tdata=mapObj._temporalTiles.temporalData;mapObj._temporalTiles.setDateInterval(dt1,dt2,tdata);if(!mapObj.isVisible){delete tdata.currentData.begDate;delete tdata.currentData.endDate;}gmxAPI._listeners.dispatchEvent('onChangeDateInterval',mapObj,{'ut1':dt1,'ut2':dt2});// Изменился календарик
    };mapObj.getDateInterval=function(){if(mapObj.properties.type!=='Vector'||!mapObj._temporalTiles)return null;var tdata=mapObj._temporalTiles.temporalData;return {beginDate:tdata.currentData.dt1,endDate:tdata.currentData.dt2};};mapObj.getTileCounts=function(dt1,dt2){if(mapObj.properties.type!=='Vector')return 0;var tdata=mapObj.properties.tiles;var thash=null;if(mapObj._temporalTiles){var pt=mapObj._temporalTiles.getDateIntervalTiles(dt1,dt2,mapObj._temporalTiles.temporalData);tdata=pt.dtiles;thash=pt.tiles;}return gmxAPI.filterVisibleTiles(tdata,thash);};// Добавление прослушивателей событий
    mapObj.addListener('onChangeVisible',function(flag){if(flag){mapObj.setDateInterval(mapObj.dt1||me.temporalData.currentData.dt1,mapObj.dt2||me.temporalData.currentData.dt2);delete mapObj.dt1;delete mapObj.dt2;}//gmxAPI._listeners.dispatchEvent('hideBalloons', gmxAPI.map, {'from':mapObj.objectId});	// Проверка map Listeners на hideBalloons
    });mapObj.addListener('onLayer',function(obj){var currentData=obj._temporalTiles.temporalData.currentData;obj.setDateInterval(currentData.dt1,currentData.dt2);});};//расширяем namespace
    gmxAPI._TemporalTiles=TemporalTiles;})();(function(){var countKeyName=gmxAPI.KOSMOSNIMKI_LOCALIZED("Количество","Count");var RenderStyle={// стили кластеров
    marker:{image:'http://images.kosmosnimki.ru/clusters/cluster_circ.png',center:true,minScale:0.5,maxScale:2,scale:'['+countKeyName+']/50'},label:{size:12,align:'center',color:0xff00ff,haloColor:0xffffff,value:'[Метка]',field:countKeyName}};var HoverStyle={// стили кластеров при наведении
    marker:{image:'http://images.kosmosnimki.ru/clusters/cluster_circ_hov.png',center:true,minScale:0.5,maxScale:2,scale:'['+countKeyName+']/50'},label:{size:12,align:'center',color:0xff0000,haloColor:0xffffff,value:'[Метка]',field:countKeyName}};var newProperties={// Заполняемые поля properties кластеров
    };newProperties[countKeyName]='[objectInCluster]';// objectInCluster - количество обьектов попавших в кластер (по умолчанию 'Количество')
    var defaultAttr={'radius':20,'iterationCount':1,'newProperties':newProperties,// Заполняемые поля properties кластеров
    'RenderStyle':RenderStyle,// стили кластеров
    'HoverStyle':HoverStyle,// стили кластеров при наведении
    'clusterView':{},// Атрибуты отображения членов кластера (при null не отображать)
    'visible':false};var _chkAttr=function _chkAttr(data){if(data['radius']<1)data['radius']=20;if(!data['RenderStyle'])data['RenderStyle']=RenderStyle;if(!data['HoverStyle'])data['HoverStyle']=HoverStyle;if(!data['clusterView'])data['clusterView']={};if(!data['newProperties'])data['newProperties']=newProperties;return data;};var Clusters=function Clusters(parent)// атрибуты кластеризации потомков
    {this._parent=parent;this._attr=gmxAPI.clone(defaultAttr);// Добавление прослушивателей событий
    var me=this;var evID=null;var chkFilter=function chkFilter(data){if(evID)parent.parent.removeListener('onLayer',evID);var filter=me._parent;if(!filter['clusters']||!filter['clusters']['attr'])return;// Кластеризация не устанавливалась
    filter.setClusters(filter['clusters']['attr']);};evID=parent.parent.addListener('onLayer',chkFilter);// Отложенная установка кластеризации
    };Clusters.prototype={'_chkToFlash':function _chkToFlash(){if(this._attr.visible&&this._parent)gmxAPI._cmdProxy('setClusters',{'obj':this._parent,'attr':this._attr});},'setClustersBalloon':function setClustersBalloon(func){this.textFunc=func;},'getTextFunc':function getTextFunc(){var me=this;return this.textFunc||function(o,div){var text="";var nProp=me.getProperties();var props=o.properties;for(var key in nProp){var value=""+props[key];if(value.indexOf("http://")==0)value="<a href='"+value+"'>"+value+"</a>";else if(value.indexOf("www.")==0)value="<a href='http://"+value+"'>"+value+"</a>";text+="<b>"+key+":</b> "+value+"<br />";}return text;};},'setProperties':function setProperties(prop){var out={};for(key in prop){out[key]=prop[key];}this._attr.newProperties=out;this._chkToFlash();},'getProperties':function getProperties(){var out={};for(key in this._attr.newProperties){out[key]=this._attr.newProperties[key];}return out;},'setStyle':function setStyle(style,hoverStyle){this._attr.RenderStyle=style;this._attr.HoverStyle=hoverStyle?hoverStyle:style;this._chkToFlash();},'getStyle':function getStyle(){var out={};if(this._attr.RenderStyle)out.RenderStyle=this._attr.RenderStyle;if(this._attr.HoverStyle)out.HoverStyle=this._attr.HoverStyle;return out;},'setRadius':function setRadius(radius){this._attr.radius=radius;this._chkToFlash();},'getRadius':function getRadius(){return this._attr.radius;},'setIterationCount':function setIterationCount(iterationCount){this._attr.iterationCount=iterationCount;this._chkToFlash();},'getIterationCount':function getIterationCount(){return this._attr.iterationCount;},'getVisible':function getVisible(){return this._attr.visible;},'setVisible':function setVisible(flag){this._attr.visible=flag?true:false;if(this._attr.visible)this._chkToFlash();else gmxAPI._cmdProxy('delClusters',{'obj':this._parent});},'setClusterView':function setClusterView(hash){this._attr.clusterView=hash;this._chkToFlash();},'getClusterView':function getClusterView(){if(!this._attr.clusterView)return null;var out={};for(key in this._attr.clusterView){out[key]=this._attr.clusterView[key];}return out;}};//расширяем namespace
    gmxAPI._Clusters=Clusters;gmxAPI._getDefaultClustersAttr=function(){return defaultAttr;};//расширяем FlashMapObject
    gmxAPI.extendFMO('setClusters',function(attr){var ph=attr?_chkAttr(attr):this._attr;return gmxAPI._cmdProxy('setClusters',{'obj':this,'attr':ph});});gmxAPI.extendFMO('delClusters',function(){if(this.clusters&&this.clusters.attr)delete this.clusters.attr;return gmxAPI._cmdProxy('delClusters',{'obj':this});});})();(function(){var miniMapInit=function miniMapInit(div){var apiBase=gmxAPI.getAPIFolderRoot();var map=gmxAPI.map;var miniMapBorderWidth=5;var miniMapLeftBorder=gmxAPI.newStyledDiv({position:"absolute",top:0,width:miniMapBorderWidth+"px",backgroundColor:"#216B9C",opacity:0.5});var miniMapBottomBorder=gmxAPI.newStyledDiv({position:"absolute",right:0,height:miniMapBorderWidth+"px",backgroundColor:"#216B9C",opacity:0.5,fontSize:0});div.appendChild(miniMapLeftBorder);div.appendChild(miniMapBottomBorder);var repaintMiniMapBorders=function repaintMiniMapBorders(){gmxAPI.setVisible(miniMapLeftBorder,gmxAPI.miniMapAvailable&&miniMapShown);gmxAPI.setVisible(miniMapBottomBorder,gmxAPI.miniMapAvailable&&miniMapShown);};var miniMapFrame=gmxAPI.newStyledDiv({position:"absolute",backgroundColor:"#216b9c",opacity:0.2});miniMapFrame.onmousedown=function(event){var startMouseX=gmxAPI.eventX(event);var startMouseY=gmxAPI.eventY(event);var currPos=gmxAPI.currPosition||map.getPosition();var startMapX=currPos['x'];var startMapY=currPos['y'];var scale=gmxAPI.getScale(miniMapZ);var mouseMoveMode=new gmxAPI._HandlerMode(document.documentElement,"mousemove",function(event){map.moveTo(gmxAPI.from_merc_x(startMapX-(gmxAPI.eventX(event)-startMouseX)*scale),gmxAPI.from_merc_y(startMapY+(gmxAPI.eventY(event)-startMouseY)*scale),map.getZ());return false;});var mouseUpMode=new gmxAPI._HandlerMode(document.documentElement,"mouseup",function(event){mouseMoveMode.clear();mouseUpMode.clear();});mouseMoveMode.set();mouseUpMode.set();return false;};div.appendChild(miniMapFrame);var repaintMiniMapFrame=function repaintMiniMapFrame(){gmxAPI.setVisible(miniMapFrame,gmxAPI.miniMapAvailable&&miniMapShown);var scaleFactor=Math.pow(2,map.getZ()-miniMapZ);var w=div.clientWidth/scaleFactor;var h=div.clientHeight/scaleFactor;if(w>=miniMapSize||h>=miniMapSize)gmxAPI.setVisible(miniMapFrame,false);else{var ww=miniMapSize/2-w/2;var hh=miniMapSize/2-h/2;var ph={'top':hh+'px','bottom':'','right':ww+'px','left':''};// Позиция миникарты по умолчанию tr(TopRight)
    if(miniMapAlign==='br'){// Позиция миникарты br(BottomRight)
    ph['left']='';ph['right']=ww+'px';ph['bottom']=hh+'px';ph['top']='';}else if(miniMapAlign==='bl'){// Позиция миникарты по умолчанию bl(BottomLeft)
    ph['left']=ww+'px';ph['right']='';ph['bottom']=hh+'px';ph['top']='';}else if(miniMapAlign==='tl'){// Позиция миникарты по умолчанию tl(TopLeft)
    ph['left']=miniMapSize/2-w/2+'px';ph['right']='';}gmxAPI.setPositionStyle(miniMapFrame,ph);gmxAPI.size(miniMapFrame,w,h);}};var miniMapZ=0;//var miniMapAvailable = false;
    var miniMapSize=0;var miniMap=map.addMapWindow(function(z){var minZoom='zoomControl'in gmxAPI.map?gmxAPI.map.zoomControl.getMinZoom():1;miniMapZ=Math.max(minZoom,Math.min(gmxAPI.maxRasterZoom,z+gmxAPI.miniMapZoomDelta));try{repaintMiniMapFrame();}catch(e){gmxAPI.addDebugWarnings({'func':'repaintMiniMapFrame','event':e});}return miniMapZ;});var miniMapShown=true;miniMap.setOpen=function(flag){miniMapShown=flag;miniMapToggler.src=apiBase+(miniMapShown?"img/close_map_a.png":"img/open_map_a.png");resizeMiniMap();gmxAPI._FMO.prototype.setVisible.call(map.miniMap,miniMapShown);};var miniMapToggler=gmxAPI.newElement("img",{className:"gmx_miniMapToggler",src:apiBase+"img/close_map.png",title:gmxAPI.KOSMOSNIMKI_LOCALIZED("Показать/скрыть мини-карту","Show/hide minimap"),onclick:function onclick(){miniMapShown=!miniMapShown;miniMap.setOpen(miniMapShown);},onmouseover:function onmouseover(){miniMapToggler.src=apiBase+(miniMapShown?"img/close_map_a.png":"img/open_map_a.png");},onmouseout:function onmouseout(){miniMapToggler.src=apiBase+(miniMapShown?"img/close_map.png":"img/open_map.png");}},{position:"absolute",right:0,top:0,cursor:"pointer"});div.appendChild(miniMapToggler);var resizeMiniMap=function resizeMiniMap(){var w=div.clientWidth;var h=div.clientHeight;miniMapSize=gmxAPI.miniMapAvailable&&miniMapShown?Math.round(w/7):0;miniMapLeftBorder.style.height=miniMapSize+miniMapBorderWidth+"px";miniMapBottomBorder.style.width=miniMapSize+"px";if(miniMapAlign==='br'){// Позиция миникарты br(BottomRight)
    miniMap.positionWindow((w-miniMapSize)/w,(h-miniMapSize)/h,1,1);gmxAPI.setPositionStyle(miniMapLeftBorder,{'top':'','bottom':'0px','right':miniMapSize+'px','left':''});gmxAPI.setPositionStyle(miniMapBottomBorder,{'top':'','bottom':miniMapSize+'px','right':'0px','left':''});gmxAPI.setPositionStyle(miniMapToggler,{'top':'','bottom':'0px','right':'0px','left':''});}else if(miniMapAlign==='bl'){// Позиция миникарты по умолчанию bl(BottomLeft)
    miniMap.positionWindow(0,(h-miniMapSize)/h,miniMapSize/w,1);gmxAPI.setPositionStyle(miniMapLeftBorder,{'top':'','bottom':'0px','right':'','left':miniMapSize+'px'});gmxAPI.setPositionStyle(miniMapBottomBorder,{'top':'','bottom':miniMapSize+'px','right':'','left':'0px'});gmxAPI.setPositionStyle(miniMapToggler,{'top':'','bottom':'0px','right':'','left':'0px'});}else if(miniMapAlign==='tl'){// Позиция миникарты по умолчанию tl(TopLeft)
    miniMap.positionWindow(0,0,miniMapSize/w,miniMapSize/h);gmxAPI.setPositionStyle(miniMapLeftBorder,{'top':'0px','bottom':'','right':'','left':miniMapSize+'px'});gmxAPI.setPositionStyle(miniMapBottomBorder,{'top':miniMapSize+'px','bottom':'','right':'','left':'0px'});gmxAPI.setPositionStyle(miniMapToggler,{'top':'0px','bottom':'','right':'','left':'0px'});}else{// Позиция миникарты по умолчанию tr(TopRight)
    miniMap.positionWindow((w-miniMapSize)/w,0,1,miniMapSize/h);gmxAPI.setPositionStyle(miniMapLeftBorder,{'top':'0px','bottom':'','right':miniMapSize+'px','left':''});gmxAPI.setPositionStyle(miniMapBottomBorder,{'top':miniMapSize+'px','bottom':'','right':'0px','left':''});gmxAPI.setPositionStyle(miniMapToggler,{'top':'0px','bottom':'','right':'0px','left':''});}repaintMiniMapBorders();repaintMiniMapFrame();};gmxAPI._resizeMiniMap=resizeMiniMap;miniMap.setVisible=function(flag){gmxAPI._FMO.prototype.setVisible.call(map.miniMap,flag);//FlashMapObject.prototype.setVisible.call(map.miniMap, flag);
    gmxAPI.miniMapAvailable=flag;gmxAPI.setVisible(miniMapFrame,flag);gmxAPI.setVisible(miniMapToggler,flag);resizeMiniMap();};map.miniMap=miniMap;map.miniMap.isMiniMap=true;map.miniMap.setBackgroundColor(0xffffff);//miniMap.setVisible(false);
    var miniMapAlign='tr';// Изменить позицию miniMap
    map.setMiniMapAlign=function(attr){if(attr['align'])miniMapAlign=attr['align'];resizeMiniMap();};map.addListener('onResizeMap',resizeMiniMap,-12);miniMap.setVisible(false);};gmxAPI._miniMapInit=miniMapInit;})();(function(){//FlashMapObject.prototype.enableQuicklooks = function(callback)
    var enableQuicklooks=function enableQuicklooks(callback){if(this.shownQuicklooks)for(var url in this.shownQuicklooks){this.shownQuicklooks[url].remove();}var shownQuicklooks={};this.shownQuicklooks=shownQuicklooks;this.addLook=function(o){var identityField=gmxAPI.getIdentityField(o.obj);var id='id_'+o.obj.properties[identityField];if(!shownQuicklooks[id]){var url=callback(o.obj);var d1=100000000;var d2=100000000;var d3=100000000;var d4=100000000;var x1,y1,x2,y2,x3,y3,x4,y4;var geom=o.obj.getGeometry();var coord=geom.coordinates;gmxAPI.forEachPoint(coord,function(p){var x=gmxAPI.merc_x(p[0]);var y=gmxAPI.merc_y(p[1]);if(x-y<d1){d1=x-y;x1=p[0];y1=p[1];}if(-x-y<d2){d2=-x-y;x2=p[0];y2=p[1];}if(-x+y<d3){d3=-x+y;x3=p[0];y3=p[1];}if(x+y<d4){d4=x+y;x4=p[0];y4=p[1];}});var q=o.obj.addObject(null,o.obj.properties);shownQuicklooks[id]=q;q.setStyle({fill:{opacity:100}});q.setImage(url,x1,y1,x2,y2,x3,y3,x4,y4);}else{shownQuicklooks[id].remove();delete shownQuicklooks[id];}};this.addListener('onClick',this.addLook,-5);};var enableTiledQuicklooks=function enableTiledQuicklooks(callback,minZoom,maxZoom,tileSenderPrefix){var IsRasterCatalog=this.properties.IsRasterCatalog;var identityField=this.properties.identityField;this.enableTiledQuicklooksEx(function(o,image){var path=callback(o);var oBounds=gmxAPI.getBounds(o.geometry.coordinates);var boundsType=oBounds&&oBounds.minX<-179.999&&oBounds.maxX>179.999?true:false;var func=function func(i,j,z){if(boundsType&&i<0)i=-i;if(path.indexOf("{")>=0){return path.replace(new RegExp("{x}","gi"),i).replace(new RegExp("{y}","gi"),j).replace(new RegExp("{z}","gi"),z).replace(new RegExp("{key}","gi"),encodeURIComponent(window.KOSMOSNIMKI_SESSION_KEY));}else{return path+z+"/"+i+"/"+z+"_"+i+"_"+j+".jpg";}};if(tileSenderPrefix){var ph={'func':func,'projectionCode':0,'minZoom':minZoom,'maxZoom':maxZoom,'tileSenderPrefix':tileSenderPrefix+(IsRasterCatalog?'&idr='+o.properties[identityField]:''),'boundsType':boundsType,'quicklooks':true};gmxAPI._cmdProxy('setBackgroundTiles',{'obj':image,'attr':ph});}else{image.setTiles(func);}},minZoom,maxZoom);};var enableTiledQuicklooksEx=function enableTiledQuicklooksEx(callback,minZoom,maxZoom){if(!minZoom)minZoom=1;if(!maxZoom)maxZoom=18;var images={};if(this.tilesParent)this.tilesParent.remove();var tilesParent=this.addObject();this.tilesParent=tilesParent;//gmxAPI._cmdProxy('setAPIProperties', { 'obj': this, 'attr':{'addHiddenFill':true} });	// при отсутствии style.fill дополнить невидимым заполнением - ломает старые проекты
    tilesParent.setZoomBounds(minZoom,maxZoom);var propsArray=[];tilesParent.clearItems=function(){for(id in images){images[id].remove();}images={};propsArray=[];};tilesParent.setZoomBounds(minZoom,maxZoom);tilesParent.observeVectorLayer(this,function(arr){var identityField=gmxAPI.getIdentityField(tilesParent);for(var j=0;j<arr.length;j++){var o=arr[j].item;var flag=!arr[j].isVisibleFilter?arr[j].onExtent:false;var id='id_'+o.properties[identityField];if(flag&&!images[id]){var image=tilesParent.addObject(o.geometry,o.properties,{'notRedrawOnDrag':true});callback(o,image);images[id]=image;propsArray.push(o.properties);}else if(!flag&&images[id]){images[id].remove();delete images[id];for(var i=0;i<propsArray.length;i++){if(propsArray[i][identityField]==o.properties[identityField]){propsArray.splice(i,1);break;}}}}return true;});var me=this;this.addListener('onClick',function(o){if('obj'in o)o=o.obj;var idt='id_'+o.flip();var currPos=gmxAPI.currPosition||gmxAPI.map.getPosition();var curZ=currPos['z'];if(images[idt]&&curZ>=minZoom&&curZ<=maxZoom)images[idt].bringToTop();// только для zoom со снимками
    gmxAPI._listeners.dispatchEvent('onFlip',me,images[idt]);return false;},-5);this.bringToTopImage=function(id)// обьект растрового слоя переместить вверх
    {var idt='id_'+id;if(images[idt]){images[idt].bringToTop();return true;}return false;};};//расширяем FlashMapObject
    gmxAPI._listeners.addListener({'eventName':'mapInit','func':function func(map){gmxAPI.extendFMO('observeVectorLayer',function(obj,onChange,attr){obj.addObserver(this,onChange,attr);});gmxAPI.extendFMO('enableTiledQuicklooksEx',enableTiledQuicklooksEx);gmxAPI.extendFMO('enableTiledQuicklooks',enableTiledQuicklooks);gmxAPI.extendFMO('enableQuicklooks',enableQuicklooks);}});})();(function(){var _addObjects=function addObjects(parentId,attr){var out=[];var data=attr['arr'];var fmt=attr['format']?attr['format']:'LatLng';for(var i=0;i<data.length;i++)// Подготовка массива обьектов
    {var ph=data[i];var props=ph['properties']||null;var tmp={"parentId":parentId,"geometry":fmt=='LatLng'?gmxAPI.merc_geometry(ph['geometry']):ph['geometry'],"properties":props};if(ph['setStyle'])tmp['setStyle']=ph['setStyle'];if(ph['setLabel'])tmp['setLabel']=ph['setLabel'];out.push(tmp);}var _obj=gmxAPI.flashDiv.cmdFromJS('addObjects',out);// Отправить команду в SWF
    out=[];var pObj=gmxAPI.mapNodes[parentId];// обычный MapObject
    for(var i=0;i<_obj.length;i++)// Отражение обьектов в JS
    {var aObj=new gmxAPI._FMO(_obj[i],data[i].properties,pObj);// обычный MapObject
    out.push(aObj);// пополнение mapNodes
    var currID=aObj.objectId?aObj.objectId:gmxAPI.newFlashMapId()+'_gen1';gmxAPI.mapNodes[currID]=aObj;if(aObj.parent)aObj.parent.childsID[currID]=true;}return out;};// Команды в SWF
    var commands={// Тип команды
    'setEditObjects':function setEditObjects(hash){// Установка редактируемых обьектов слоя
    return gmxAPI.flashDiv.cmdFromJS('setEditObjects',{'objectId':hash.obj.objectId,'processing':hash['attr']});},'setVisible':function setVisible(hash){// Изменить видимость обьекта
    if(hash['obj']){gmxAPI.flashDiv.cmdFromJS('setVisible',{'objectId':hash.obj.objectId,'flag':hash['attr']});}},'sendPNG':function sendPNG(hash){// Сохранение изображения карты на сервер
    var miniMapFlag=gmxAPI.miniMapAvailable;var attr=hash['attr'];var flag=attr.miniMapSetVisible?true:false;if(miniMapFlag!=flag)gmxAPI.map.miniMap.setVisible(flag);if(attr.func)attr.func=gmxAPI.uniqueGlobalName(attr.func);var ret={'base64':gmxAPI.flashDiv.cmdFromJS('sendPNG',attr)};if(miniMapFlag)gmxAPI.map.miniMap.setVisible(miniMapFlag);return ret;},'savePNG':function savePNG(hash){// Сохранить PNG файл экрана
    return gmxAPI.flashDiv.cmdFromJS('savePNG',hash['attr']);//return gmxAPI.flashDiv.cmdFromJS('savePNG', { 'fileName':hash['attr'] });
    },'setZoomBounds':function setZoomBounds(hash){// Установить ограничения по Zoom
    return gmxAPI.flashDiv.cmdFromJS('setZoomBounds',{'objectId':hash.obj.objectId,'minZ':hash['attr']['minZ'],'maxZ':hash['attr']['maxZ']});},'setClusters':function setClusters(hash){// Установить кластеризацию потомков
    var obj=hash['obj'];var attr=hash['attr'];var ret={};if(attr&&'newProperties'in attr){var keyArray=[];var valArray=[];for(key in attr['newProperties']){keyArray.push(key);valArray.push(attr['newProperties'][key]);}attr['propFields']=[keyArray,valArray];attr['hideFixedBalloons']=gmxAPI.uniqueGlobalName(function(){gmxAPI.map.balloonClassObject.hideHoverBalloons(false);});}var flag='clusters'in obj;// видимость кластеров
    if(!flag)obj['clusters']=new gmxAPI._Clusters(obj);else ret=gmxAPI.flashDiv.cmdFromJS('setClusters',{'objectId':obj.objectId,'data':attr});attr['visible']=flag;obj['clusters']['attr']=attr;// признак наличия кластеризации в SWF
    //if(!obj.parent._hoverBalloonAttr) obj.parent.enableHoverBalloon();	// если балунов не установлено
    return ret;},'delClusters':function delClusters(hash){// Удалить кластеризацию потомков
    var obj=hash['obj'];var ret=gmxAPI.flashDiv.cmdFromJS('delClusters',{'objectId':obj.objectId});if('clusters'in obj&&obj['clusters']['attr'])obj['clusters']['attr']['visible']=false;return ret;},'setGridVisible':function setGridVisible(hash){// Изменить видимость сетки
    return gmxAPI.flashDiv.cmdFromJS('setGridVisible',{'flag':hash['attr']});},'getGridVisibility':function getGridVisibility(hash){// получить видимость сетки
    return gmxAPI.flashDiv.cmdFromJS('getGridVisibility',{});},'getZoomBounds':function getZoomBounds(hash){// Получить ограничения по Zoom
    return gmxAPI.flashDiv.cmdFromJS('getZoomBounds',{'objectId':hash.obj.objectId});},'getDepth':function getDepth(hash){// Получить индекс обьекта
    return gmxAPI.flashDiv.cmdFromJS('getDepth',{'objectId':hash.obj.objectId});},'getVisibility':function getVisibility(hash){// Получить видимость
    return gmxAPI.flashDiv.cmdFromJS('getVisibility',{'objectId':hash.obj.objectId});},'trace':function trace(hash){// Сообщение в SWF
    return gmxAPI.flashDiv.cmdFromJS('trace',{'data':hash['attr']});},'setQuality':function setQuality(hash){// Установка Quality
    return gmxAPI.flashDiv.cmdFromJS('setQuality',{'data':hash['attr']});},'disableCaching':function disableCaching(hash){// ????
    return gmxAPI.flashDiv.cmdFromJS('disableCaching',{});},'print':function print(hash){// Печать
    return gmxAPI.flashDiv.cmdFromJS('print',{});},'repaint':function repaint(hash){// ????
    return gmxAPI.flashDiv.cmdFromJS('repaint',{});},'addContextMenuItem':function addContextMenuItem(hash){// Добавить пункт в контекстное меню SWF
    if(hash['attr'].func)hash['attr'].func=gmxAPI.uniqueGlobalName(hash['attr'].func);return gmxAPI.flashDiv.cmdFromJS('addContextMenuItem',hash['attr']);},'moveTo':function moveTo(hash){//позиционирует карту по координатам центра и выбирает масштаб
    var attr=hash['attr'];attr['x']=gmxAPI.merc_x(attr['x']);attr['y']=gmxAPI.merc_y(attr['y']);return gmxAPI.flashDiv.cmdFromJS('moveTo',attr);},'slideTo':function slideTo(hash){//плавно позиционирует карту по координатам центра и выбирает масштаб
    var attr=hash['attr'];attr['x']=gmxAPI.merc_x(attr['x']);attr['y']=gmxAPI.merc_y(attr['y']);return gmxAPI.flashDiv.cmdFromJS('slideTo',attr);},'zoomBy':function zoomBy(hash){//выбирает масштаб
    return gmxAPI.flashDiv.cmdFromJS('zoomBy',hash['attr']);},'freeze':function freeze(hash){// заморозить
    return gmxAPI.flashDiv.cmdFromJS('freeze',{});},'unfreeze':function unfreeze(hash){// разморозить
    return gmxAPI.flashDiv.cmdFromJS('unfreeze',{});},'setCursor':function setCursor(hash){//установка курсора
    return gmxAPI.flashDiv.cmdFromJS('setCursor',hash['attr']);},'clearCursor':function clearCursor(hash){//убрать курсор
    return gmxAPI.flashDiv.cmdFromJS('clearCursor',{});},'setCursorVisible':function setCursorVisible(hash){//видимость курсора
    return gmxAPI.flashDiv.cmdFromJS('setCursorVisible',hash['attr']);},'stopDragging':function stopDragging(hash){//убрать флаг Drag
    return gmxAPI.flashDiv.cmdFromJS('stopDragging',{});},'isDragging':function isDragging(hash){//получить флаг Drag
    return gmxAPI.flashDiv.cmdFromJS('isDragging',{});},'resumeDragging':function resumeDragging(hash){//возобновить Drag
    return gmxAPI.flashDiv.cmdFromJS('resumeDragging',{});},'getPosition':function getPosition(hash){//получить текущие атрибуты SWF
    return gmxAPI.flashDiv.cmdFromJS('getPosition',{});},'getX':function getX(hash){//получить позицию Х центра SWF
    return gmxAPI.from_merc_x(gmxAPI.flashDiv.cmdFromJS('getX',{}));},'getY':function getY(hash){//получить позицию Y центра SWF
    return gmxAPI.from_merc_y(gmxAPI.flashDiv.cmdFromJS('getY',{}));},'getZ':function getZ(hash){//получить текущий Z
    return gmxAPI.flashDiv.cmdFromJS('getZ',{});},'getMouseX':function getMouseX(hash){//получить позицию Х MouseX
    return gmxAPI.from_merc_x(gmxAPI.flashDiv.cmdFromJS('getMouseX',{}));},'getMouseY':function getMouseY(hash){//получить позицию Y MouseY
    return gmxAPI.from_merc_y(gmxAPI.flashDiv.cmdFromJS('getMouseY',{}));},'isKeyDown':function isKeyDown(hash){//проверить нажатие клавиши в SWF
    return gmxAPI.flashDiv.cmdFromJS('isKeyDown',hash['attr']);},'setExtent':function setExtent(hash){//установить Extent в SWF
    var attr={'x1':gmxAPI.merc_x(hash['attr']['x1']),'x2':gmxAPI.merc_x(hash['attr']['x2']),'y1':gmxAPI.merc_y(hash['attr']['y1']),'y2':gmxAPI.merc_y(hash['attr']['y2'])};return gmxAPI.flashDiv.cmdFromJS('setExtent',attr);},'setMinMaxZoom':function setMinMaxZoom(hash){//установить Zoom ограничения
    return gmxAPI.flashDiv.cmdFromJS('setMinMaxZoom',hash['attr']);},'addMapWindow':function addMapWindow(hash){//Создание окна карты
    var attr=hash['attr'];if(attr.callbackName)attr.callbackName=gmxAPI.uniqueGlobalName(attr.callbackName);return gmxAPI.flashDiv.cmdFromJS('addMapWindow',attr);},'setStyle':function setStyle(hash){// установить Style обьекта
    gmxAPI.flashDiv.cmdFromJS('setStyle',{'objectId':hash.obj.objectId,'data':hash['attr']});},'getStyle':function getStyle(hash){//получить Style обьекта
    return gmxAPI.flashDiv.cmdFromJS('getStyle',{'objectId':hash.obj.objectId,'removeDefaults':hash['attr']});},'getVisibleStyle':function getVisibleStyle(hash){//получить Style обьекта с учетом родителей
    return gmxAPI.flashDiv.cmdFromJS('getVisibleStyle',{'objectId':hash.obj.objectId});},'positionWindow':function positionWindow(hash){// 
    gmxAPI.flashDiv.cmdFromJS('positionWindow',{'objectId':hash.obj.objectId,'data':hash['attr']});},'setBackgroundColor':function setBackgroundColor(hash){// 
    gmxAPI.flashDiv.cmdFromJS('setBackgroundColor',{'objectId':hash.obj.objectId,'color':hash['attr']});},'getChildren':function getChildren(hash){// получить список потомков
    return gmxAPI.flashDiv.cmdFromJS('getChildren',{'objectId':hash.obj.objectId});},'setHandler':function setHandler(hash){// установка обработчика события
    var attr=hash['attr'];if(attr.callbackName)attr.callbackName=gmxAPI.uniqueGlobalName(attr.callbackName);return gmxAPI.flashDiv.cmdFromJS('setHandler',{'objectId':hash.obj.objectId,'eventName':attr['eventName'],'callbackName':attr['callbackName']});},'removeHandler':function removeHandler(hash){// удаление обработчика события
    return gmxAPI.flashDiv.cmdFromJS('removeHandler',{'objectId':hash.obj.objectId,'eventName':hash['attr']['eventName']});},'addObject':function addObject(hash){// добавить обьект
    var attr=gmxAPI.clone(hash['attr']);var geo=gmxAPI.merc_geometry(attr['geometry'])||null;var ph={'objectId':hash.obj.objectId,'geometry':geo,'properties':attr['properties']};if(attr['propHiden'])ph['propHiden']=attr['propHiden'];return gmxAPI.flashDiv.cmdFromJS('addObject',ph);},'addObjects':function addObjects(hash){// добавить обьекты
    return _addObjects(hash.obj.objectId,hash['attr']);},'addObjectsFromSWF':function addObjectsFromSWF(hash){// добавить обьекты из SWF файла
    return gmxAPI.flashDiv.cmdFromJS('addObjectsFromSWF',{'objectId':hash.obj.objectId,'attr':hash['attr']});},'setVisibilityFilter':function setVisibilityFilter(hash){// добавить фильтр видимости к обьекту
    return gmxAPI.flashDiv.cmdFromJS('setVisibilityFilter',{'objectId':hash.obj.objectId,'sql':hash['attr']['sql']});},'setFilter':function setFilter(hash){// добавить фильтр к обьекту
    return gmxAPI.flashDiv.cmdFromJS('setFilter',{'objectId':hash.obj.objectId,'sql':hash['attr']['sql']});},'remove':function remove(hash){// удалить обьект
    gmxAPI.flashDiv.cmdFromJS('remove',{'objectId':hash.obj.objectId});},'bringToTop':function bringToTop(hash){return gmxAPI.flashDiv.cmdFromJS('bringToTop',{'objectId':hash.obj.objectId});},'bringToDepth':function bringToDepth(hash){return gmxAPI.flashDiv.cmdFromJS('bringToDepth',{'objectId':hash.obj.objectId,'zIndex':hash['attr']['zIndex']});},'bringToBottom':function bringToBottom(hash){gmxAPI.flashDiv.cmdFromJS('bringToBottom',{'objectId':hash.obj.objectId});},'setActive':function setActive(hash){gmxAPI.flashDiv.cmdFromJS('setActive',{'objectId':hash.obj.objectId,'flag':hash['attr']['flag']});},'setEditable':function setEditable(hash){gmxAPI.flashDiv.cmdFromJS('setEditable',{'objectId':hash.obj.objectId});},'startDrawing':function startDrawing(hash){var attr=hash?{'objectId':hash.obj.objectId,'type':hash['attr']['type']}:null;gmxAPI.flashDiv.cmdFromJS('startDrawing',attr);},'stopDrawing':function stopDrawing(hash){var attr=hash?{'objectId':hash.obj.objectId}:null;gmxAPI.flashDiv.cmdFromJS('stopDrawing',attr);},'isDrawing':function isDrawing(hash){return gmxAPI.flashDiv.cmdFromJS('isDrawing',{'objectId':hash.obj.objectId});},'getIntermediateLength':function getIntermediateLength(hash){return gmxAPI.flashDiv.cmdFromJS('getIntermediateLength',{'objectId':hash.obj.objectId});},'getCurrentEdgeLength':function getCurrentEdgeLength(hash){return gmxAPI.flashDiv.cmdFromJS('getCurrentEdgeLength',{'objectId':hash.obj.objectId});},'setLabel':function setLabel(hash){gmxAPI.flashDiv.cmdFromJS('setLabel',{'objectId':hash.obj.objectId,'label':hash['attr']['label']});},'setBackgroundTiles':function setBackgroundTiles(hash){var attr=gmxAPI.clone(hash['attr']);if(hash['attr'].func)attr.func=gmxAPI.uniqueGlobalName(hash['attr'].func);attr.objectId=hash.obj.objectId;gmxAPI.flashDiv.cmdFromJS('setBackgroundTiles',attr);},'setDisplacement':function setDisplacement(hash){gmxAPI.flashDiv.cmdFromJS('setDisplacement',{'objectId':hash.obj.objectId,'dx':hash['attr']['dx'],'dy':hash['attr']['dy']});},'setTileCaching':function setTileCaching(hash){gmxAPI.flashDiv.cmdFromJS('setTileCaching',{'objectId':hash.obj.objectId,'flag':hash['attr']['flag']});},'clearBackgroundImage':function clearBackgroundImage(hash){gmxAPI.flashDiv.cmdFromJS('clearBackgroundImage',{'objectId':hash.obj.objectId});},'setGeometry':function setGeometry(hash){var geo=gmxAPI.merc_geometry(hash['attr']);gmxAPI.flashDiv.cmdFromJS('setGeometry',{'objectId':hash.obj.objectId,'data':geo});},'getGeometry':function getGeometry(hash){var geom=gmxAPI.flashDiv.cmdFromJS('getGeometry',{'objectId':hash.obj.objectId});if(!geom)return null;var out={"type":geom.type};var coords=gmxAPI.forEachPoint(geom.coordinates,function(c){return [gmxAPI.from_merc_x(c[0]),gmxAPI.from_merc_y(c[1])];});out["coordinates"]=coords;return out;},'getLength':function getLength(hash){return gmxAPI.flashDiv.cmdFromJS('getLength',{'objectId':hash.obj.objectId});},'getArea':function getArea(hash){return gmxAPI.flashDiv.cmdFromJS('getArea',{'objectId':hash.obj.objectId});},'getGeometryType':function getGeometryType(hash){return gmxAPI.flashDiv.cmdFromJS('getGeometryType',{'objectId':hash.obj.objectId});},'getCenter':function getCenter(hash){return gmxAPI.flashDiv.cmdFromJS('getCenter',{'objectId':hash.obj.objectId});},'addChildRoot':function addChildRoot(hash){return gmxAPI.flashDiv.cmdFromJS('addChildRoot',{'objectId':hash.obj.objectId});},'setVectorTiles':function setVectorTiles(hash){var attr=hash['attr'];if(attr.tileFunction)attr.tileFunction=gmxAPI.uniqueGlobalName(attr.tileFunction);return gmxAPI.flashDiv.cmdFromJS('setVectorTiles',{'objectId':hash.obj.objectId,'tilesVers':attr['tilesVers'],'tileFunction':attr['tileFunction'],'identityField':attr['cacheFieldName'],'tiles':attr['dataTiles'],'filesHash':attr['filesHash']});},'setTiles':function setTiles(hash){return gmxAPI.flashDiv.cmdFromJS('setTiles',{'objectId':hash.obj.objectId,'tiles':attr['tiles'],'flag':attr['flag']});},'startLoadTiles':function startLoadTiles(hash){return gmxAPI.flashDiv.cmdFromJS('startLoadTiles',{'objectId':hash.obj.objectId,'data':hash['attr']});},'getStat':function getStat(hash){return gmxAPI.flashDiv.cmdFromJS('getStat',{'objectId':hash.obj.objectId});},'observeVectorLayer':function observeVectorLayer(hash){var attr=gmxAPI.clone(hash['attr']);if(hash['attr'].func)attr.func=gmxAPI.uniqueGlobalName(hash['attr'].func);attr.objectId=hash.obj.objectId;gmxAPI.flashDiv.cmdFromJS('observeVectorLayer',attr);},'setImageExtent':function setImageExtent(hash){gmxAPI.flashDiv.cmdFromJS('setImageExtent',{'objectId':hash.obj.objectId,'data':hash['attr']});},'setImage':function setImage(hash){var attr=hash['attr'];gmxAPI.flashDiv.cmdFromJS('setImage',{'objectId':hash.obj.objectId,'url':attr['url'],'x1':gmxAPI.merc_x(attr['x1']),'y1':gmxAPI.merc_y(attr['y1']),'x2':gmxAPI.merc_x(attr['x2']),'y2':gmxAPI.merc_y(attr['y2']),'x3':gmxAPI.merc_x(attr['x3']),'y3':gmxAPI.merc_y(attr['y3']),'x4':gmxAPI.merc_x(attr['x4']),'y4':gmxAPI.merc_y(attr['y4']),'tx1':attr['tx1'],'ty1':attr['ty1'],'tx2':attr['tx2'],'ty2':attr['ty2'],'tx3':attr['tx3'],'ty3':attr['ty3'],'tx4':attr['tx4'],'ty4':attr['ty4']});},'flip':function flip(hash){return gmxAPI.flashDiv.cmdFromJS('flip',{'objectId':hash.obj.objectId});},'getFeatureById':function getFeatureById(hash){var attr=hash['attr'];if(attr.func){var func=function func(geom,props){var ret=null;if(geom&&geom['type']!='unknown'){if(_typeof(props)==='object'&&props.length>0){props=gmxAPI.arrayToHash(props);}ret=new gmxAPI._FlashMapFeature(gmxAPI.from_merc_geometry(geom),props,hash.obj);}else if(hash.obj._Processing&&hash.obj._Processing.addObjects){var arr=hash.obj._Processing.addObjects;var identityField=hash.obj.properties.identityField;for(var i=0;i<arr.length;i++){var prop=arr[i].properties;if(prop[identityField]==attr['fid']){ret=new gmxAPI._FlashMapFeature(gmxAPI.from_merc_geometry(arr[i].geometry),arr[i].properties,hash.obj);break;}}}if(ret){attr.func(ret);}else{gmxAPI.addDebugWarnings({'alert':'Object: '+attr['fid']+' not found in layer: '+hash.obj.objectId});}};gmxAPI.flashDiv.cmdFromJS('getFeatureById',{'objectId':hash.obj.objectId,'fid':attr['fid'],'func':gmxAPI.uniqueGlobalName(func)});}},'getFeatures':function getFeatures(hash){var attr=hash['attr'];if(attr.func){var geo=attr.geom?attr.geom:{type:"POLYGON",coordinates:[[-180,-89,-180,89,180,89,180,-89]]};var bound=gmxAPI.getBounds(geo.coordinates);var func=function func(geoms,props){var ret=[];for(var i=0;i<geoms.length;i++){var cProp=props[i];if(_typeof(cProp)==='object'&&cProp.length>0){cProp=gmxAPI.arrayToHash(cProp);}ret.push(new gmxAPI._FlashMapFeature(gmxAPI.from_merc_geometry(geoms[i]),cProp,hash.obj));}if(hash.obj._Processing&&hash.obj._Processing.addObjects){var arr=hash.obj._Processing.addObjects;for(var i=0;i<arr.length;i++){var geom=gmxAPI.from_merc_geometry(arr[i].geometry);var bounds=gmxAPI.getBounds(geom.coordinates);if(gmxAPI.boundsIntersect(bound,bounds)){ret.push(new gmxAPI._FlashMapFeature(geom,arr[i].properties,hash.obj));}}}attr.func(ret);};gmxAPI.flashDiv.cmdFromJS('getFeatures',{'objectId':hash.obj.objectId,'geom':gmxAPI.merc_geometry(geo),'func':gmxAPI.uniqueGlobalName(func)});}},'getTileItem':function getTileItem(hash){return gmxAPI.flashDiv.cmdFromJS('getTileItem',{'objectId':hash.obj.objectId,'vId':hash['attr']});},'setTileItem':function setTileItem(hash){return gmxAPI.flashDiv.cmdFromJS('setTileItem',{'objectId':hash.obj.objectId,'data':hash['attr']['data'],'flag':hash['attr']['flag']});},'getItemsFromExtent':function getItemsFromExtent(hash){return gmxAPI.flashDiv.cmdFromJS('getItemsFromExtent',{'objectId':hash.obj.objectId,'data':hash['attr']});},'setFlashLSO':function setFlashLSO(hash){return gmxAPI.flashDiv.cmdFromJS('setFlashLSO',{'objectId':hash.obj.objectId,'data':hash['attr']});},'setAPIProperties':function setAPIProperties(hash){return gmxAPI.flashDiv.cmdFromJS('setAPIProperties',{'objectId':hash.obj.objectId,'data':hash['attr']});},'getPatternIcon':function getPatternIcon(hash){return gmxAPI.flashDiv.cmdFromJS('getPatternIcon',{'data':hash['attr']});},'addItems':function addItems(hash){return gmxAPI.flashDiv.cmdFromJS('addItems',{'objectId':hash.obj.objectId,'data':hash['attr']});}};// Передача команды в SWF
    function FlashCMD(cmd,hash){var ret={};if(!gmxAPI.flashDiv)return ret;//var startTime = (new Date()).getTime();
    var flashDomTest=_typeof(gmxAPI.flashDiv);ret=cmd in commands?commands[cmd].call(commands,hash):{};/*
    console.log(cmd + ' : ' , hash);
    if(!window._debugTimes) window._debugTimes = { 'jsToFlash': { 'timeSum':0, 'callCount':0, 'callFunc':{} } };
    var delta = (new Date()).getTime() - startTime;
    window._debugTimes.jsToFlash.timeSum += delta;
    window._debugTimes.jsToFlash.callCount += 1;
    if(!window._debugTimes.jsToFlash.callFunc[cmd]) window._debugTimes.jsToFlash.callFunc[cmd] = { 'timeSum':0, 'callCount':0 };
    window._debugTimes.jsToFlash.callFunc[cmd]['timeSum'] += delta;
    window._debugTimes.jsToFlash.callFunc[cmd]['callCount'] += 1;
    */return ret;}if(typeof deconcept=="undefined"){var deconcept=new Object();}if(typeof deconcept.util=="undefined"){deconcept.util=new Object();}if(typeof deconcept.SWFObjectUtil=="undefined"){deconcept.SWFObjectUtil=new Object();}deconcept.SWFObject=function(_1,id,w,h,_5,c,_7,_8,_9,_a){if(!document.getElementById){return;}this.DETECT_KEY=_a?_a:"detectflash";this.skipDetect=deconcept.util.getRequestParameter(this.DETECT_KEY);this.params=new Object();this.variables=new Object();this.attributes=new Array();if(_1){this.setAttribute("swf",_1);}if(id){this.setAttribute("id",id);}if(w){this.setAttribute("width",w);}if(h){this.setAttribute("height",h);}if(_5){this.setAttribute("version",new deconcept.PlayerVersion(_5.toString().split(".")));}this.installedVer=deconcept.SWFObjectUtil.getPlayerVersion();if(!window.opera&&document.all&&this.installedVer.major>7){deconcept.SWFObject.doPrepUnload=true;}if(c){this.addParam("bgcolor",c);}var q=_7?_7:"high";this.addParam("quality",q);this.setAttribute("useExpressInstall",false);this.setAttribute("doExpressInstall",false);var _c=_8?_8:window.location;this.setAttribute("xiRedirectUrl",_c);this.setAttribute("redirectUrl","");if(_9){this.setAttribute("redirectUrl",_9);}};deconcept.SWFObject.prototype={useExpressInstall:function useExpressInstall(_d){this.xiSWFPath=!_d?"expressinstall.swf":_d;this.setAttribute("useExpressInstall",true);},setAttribute:function setAttribute(_e,_f){this.attributes[_e]=_f;},getAttribute:function getAttribute(_10){return this.attributes[_10];},addParam:function addParam(_11,_12){this.params[_11]=_12;},getParams:function getParams(){return this.params;},addVariable:function addVariable(_13,_14){this.variables[_13]=_14;},getVariable:function getVariable(_15){return this.variables[_15];},getVariables:function getVariables(){return this.variables;},getVariablePairs:function getVariablePairs(){var _16=new Array();var key;var _18=this.getVariables();for(key in _18){_16[_16.length]=key+"="+_18[key];}return _16;},getSWFHTML:function getSWFHTML(){var _19="";if(navigator.plugins&&navigator.mimeTypes&&navigator.mimeTypes.length){if(this.getAttribute("doExpressInstall")){this.addVariable("MMplayerType","PlugIn");this.setAttribute("swf",this.xiSWFPath);}_19="<embed type=\"application/x-shockwave-flash\" src=\""+this.getAttribute("swf")+"\" width=\""+this.getAttribute("width")+"\" height=\""+this.getAttribute("height")+"\" style=\""+this.getAttribute("style")+"\"";_19+=" id=\""+this.getAttribute("id")+"\" name=\""+this.getAttribute("id")+"\" ";var _1a=this.getParams();for(var key in _1a){_19+=[key]+"=\""+_1a[key]+"\" ";}var _1c=this.getVariablePairs().join("&");if(_1c.length>0){_19+="flashvars=\""+_1c+"\"";}_19+="/>";}else{if(this.getAttribute("doExpressInstall")){this.addVariable("MMplayerType","ActiveX");this.setAttribute("swf",this.xiSWFPath);}_19="<object id=\""+this.getAttribute("id")+"\" classid=\"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\" width=\""+this.getAttribute("width")+"\" height=\""+this.getAttribute("height")+"\" style=\""+this.getAttribute("style")+"\">";_19+="<param name=\"movie\" value=\""+this.getAttribute("swf")+"\" />";var _1d=this.getParams();for(var key in _1d){_19+="<param name=\""+key+"\" value=\""+_1d[key]+"\" />";}var _1f=this.getVariablePairs().join("&");if(_1f.length>0){_19+="<param name=\"flashvars\" value=\""+_1f+"\" />";}_19+="</object>";}return _19;},write:function write(_20){if(this.getAttribute("useExpressInstall")){var _21=new deconcept.PlayerVersion([6,0,65]);if(this.installedVer.versionIsValid(_21)&&!this.installedVer.versionIsValid(this.getAttribute("version"))){this.setAttribute("doExpressInstall",true);this.addVariable("MMredirectURL",escape(this.getAttribute("xiRedirectUrl")));document.title=document.title.slice(0,47)+" - Flash Player Installation";this.addVariable("MMdoctitle",document.title);}}if(this.skipDetect||this.getAttribute("doExpressInstall")||this.installedVer.versionIsValid(this.getAttribute("version"))){var n=typeof _20=="string"?document.getElementById(_20):_20;n.innerHTML=this.getSWFHTML();return true;}else{if(this.getAttribute("redirectUrl")!=""){document.location.replace(this.getAttribute("redirectUrl"));}}return false;}};deconcept.SWFObjectUtil.getPlayerVersion=function(){var _23=new deconcept.PlayerVersion([0,0,0]);if(navigator.plugins&&navigator.mimeTypes.length){var x=navigator.plugins["Shockwave Flash"];if(x&&x.description){_23=new deconcept.PlayerVersion(x.description.replace(/([a-zA-Z]|\s)+/,"").replace(/(\s+r|\s+b[0-9]+)/,".").split("."));}}else{if(navigator.userAgent&&navigator.userAgent.indexOf("Windows CE")>=0){var axo=1;var _26=3;while(axo){try{_26++;axo=new ActiveXObject("ShockwaveFlash.ShockwaveFlash."+_26);_23=new deconcept.PlayerVersion([_26,0,0]);}catch(e){axo=null;}}}else{try{var axo=new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");}catch(e){try{var axo=new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");_23=new deconcept.PlayerVersion([6,0,21]);axo.AllowScriptAccess="always";}catch(e){if(_23.major==6){return _23;}}try{axo=new ActiveXObject("ShockwaveFlash.ShockwaveFlash");}catch(e){}}if(axo!=null){_23=new deconcept.PlayerVersion(axo.GetVariable("$version").split(" ")[1].split(","));}}}return _23;};deconcept.PlayerVersion=function(_29){this.major=_29[0]!=null?parseInt(_29[0]):0;this.minor=_29[1]!=null?parseInt(_29[1]):0;this.rev=_29[2]!=null?parseInt(_29[2]):0;};deconcept.PlayerVersion.prototype.versionIsValid=function(fv){if(this.major<fv.major){return false;}if(this.major>fv.major){return true;}if(this.minor<fv.minor){return false;}if(this.minor>fv.minor){return true;}if(this.rev<fv.rev){return false;}return true;};deconcept.util={getRequestParameter:function getRequestParameter(_2b){var q=document.location.search||document.location.hash;if(_2b==null){return q;}if(q){var _2d=q.substring(1).split("&");for(var i=0;i<_2d.length;i++){if(_2d[i].substring(0,_2d[i].indexOf("="))==_2b){return _2d[i].substring(_2d[i].indexOf("=")+1);}}}return "";}};deconcept.SWFObjectUtil.cleanupSWFs=function(){var _2f=document.getElementsByTagName("OBJECT");for(var i=_2f.length-1;i>=0;i--){_2f[i].style.display="none";for(var x in _2f[i]){if(typeof _2f[i][x]=="function"){_2f[i][x]=function(){};}}}};if(deconcept.SWFObject.doPrepUnload){if(!deconcept.unloadSet){deconcept.SWFObjectUtil.prepUnload=function(){__flash_unloadHandler=function __flash_unloadHandler(){};__flash_savedUnloadHandler=function __flash_savedUnloadHandler(){};window.attachEvent("onunload",deconcept.SWFObjectUtil.cleanupSWFs);};window.attachEvent("onbeforeunload",deconcept.SWFObjectUtil.prepUnload);deconcept.unloadSet=true;}}if(!document.getElementById&&document.all){document.getElementById=function(id){return document.all[id];};}// Добавить SWF в DOM
    function addSWFObject(apiBase,flashId,ww,hh,v,bg,loadCallback,FlagFlashLSO){// Проверка версии FlashPlayer
    if(deconcept.SWFObjectUtil.getPlayerVersion().major<10)return '';//var url = apiBase + "api.swf?" + Math.random()
    var url=apiBase+"api.swf";var o=new deconcept.SWFObject(url,flashId,ww,hh,v,bg);o.addParam('allowScriptAccess','always');o.addParam('wmode','opaque');o.addVariable("clearCallback",gmxAPI.uniqueGlobalName(function(name){delete window[name];}));o.addVariable("loadCallback",gmxAPI.uniqueGlobalName(loadCallback));if(FlagFlashLSO){o.addVariable("useFlashLSO",true);if(FlagFlashLSO.multiSession)o.addVariable("multiSessionLSO",true);if(FlagFlashLSO.compress)o.addVariable("compressLSO",true);}return o;}//расширяем namespace
    gmxAPI._cmdProxy=FlashCMD;// посылка команд отрисовщику
    gmxAPI._addProxyObject=addSWFObject;// Добавить SWF в DOM
    gmxAPI.APILoaded=true;// Флаг возможности использования gmxAPI сторонними модулями
    })();

    nsGmx$1.Utils = nsGmx$1.Utils || {};
    var domManipulation = {
      // _el(nodeName, [childs], [attrs])
      _el: function _el(str, childs, attributes) {
        var el = document.createElement(str),
            children = childs,
            attrs = attributes;
        if (children) domManipulation._childs(el, children);
        if (attrs && attrs.length) domManipulation._attr(el, attrs);
        return el;
      },
      // _t("some text")
      _t: function _t(str) {
        return document.createTextNode(String(str));
      },
      // children - всегда массив
      _childs: function _childs(el, children) {
        for (var i = 0; i < children.length; ++i) {
          el.appendChild(children[i]);
        }
      },
      //[['css','width','100%']]
      //[['dir','className','name']]
      //[['attr','colSpan',2]]
      _attr: function _attr(el, attrs) {
        for (var i = 0; i < attrs.length; ++i) {
          var atr = attrs[i],
              type = atr[0];

          switch (type) {
            case 'css':
              el.style[atr[1]] = atr[2];
              break;

            case 'dir':
              el[atr[1]] = atr[2];
              break;

            case 'attr':
              el.setAttribute(atr[1], atr[2]);
              break;
          }
        }
      },
      _table: function _table(children, attrs) {
        return _el('TABLE', children, attrs);
      },
      _caption: function _caption(children, attrs) {
        return _el('CAPTION', children, attrs);
      },
      _thead: function _thead(children, attrs) {
        return _el('THEAD', children, attrs);
      },
      _tbody: function _tbody(children, attrs) {
        return _el('TBODY', children, attrs);
      },
      _tfoot: function _tfoot(children, attrs) {
        return _el('TFOOT', children, attrs);
      },
      _textarea: function _textarea(children, attrs) {
        return _el('TEXTAREA', children, attrs);
      },
      _th: function _th(children, attrs) {
        return _el('TH', children, attrs);
      },
      _tr: function _tr(children, attrs) {
        return _el('TR', children, attrs);
      },
      _td: function _td(children, attrs) {
        return _el('TD', children, attrs);
      },
      _span: function _span(children, attrs) {
        return _el('SPAN', children, attrs);
      },
      _label: function _label(children, attrs) {
        return _el('LABEL', children, attrs);
      },
      _li: function _li(children, attrs) {
        return _el('LI', children, attrs);
      },
      _ul: function _ul(children, attrs) {
        return _el('UL', children, attrs);
      },
      _div: function _div(children, attrs) {
        return _el('DIV', children, attrs);
      },
      _radio: function _radio(attrs) {
        return _el('INPUT', null, attrs && attrs.concat([['attr', 'type', 'radio']]) || [['attr', 'type', 'radio']]);
      },
      _button: function _button(children, attrs) {
        return _el('BUTTON', children, attrs);
      },
      _a: function _a(children, attrs) {
        return _el('A', children, attrs);
      },
      _select: function _select(children, attrs) {
        return _el('SELECT', children, attrs);
      },
      _option: function _option(children, attrs) {
        return _el('OPTION', children, attrs);
      },
      _form: function _form(children, attrs) {
        return _el('FORM', children, attrs);
      },
      _iframe: function _iframe(children, attrs) {
        return _el('IFRAME', children, attrs);
      },
      _image: function _image(children, attrs) {
        return _el('IMG', children, attrs);
      },
      _img: function _img(children, attrs) {
        return _el('IMG', children, attrs);
      },
      _br: function _br() {
        return _el('BR');
      },
      _hr: function _hr() {
        return _el('HR');
      },
      _p: function _p(children, attrs) {
        return _el('P', children, attrs);
      },
      _b: function _b(children, attrs) {
        return _el('B', children, attrs);
      },
      _i: function _i(children, attrs) {
        return _el('I', children, attrs);
      },
      _input: function _input(children, attrs) {
        return _el('INPUT', children, attrs);
      }
    };
    var _el = domManipulation._el; // _(elem, [childs], [attrs])

    var _$1 = function _(ent, childs, attributes) {
      var el = ent,
          children = childs,
          attrs = attributes;
      if (children) domManipulation._childs(el, children);
      if (attrs && attrs.length) domManipulation._attr(el, attrs);
      return el;
    };

    var prevGlobals = {};

    for (var k in domManipulation) {
      prevGlobals[k] = window[k];
    }
    /** Удаляет из глобальной видимости часть методов, записанных туда при загрузке utilities.js
    * @memberOf nsGmx.Utils
    */


    nsGmx$1.Utils.noConflicts = function () {
      for (var k in domManipulation) {
        window[k] = prevGlobals[k];
      }

      return nsGmx$1.Utils;
    };

    jQuery.extend(window, domManipulation); //для обратной совместимости

    jQuery.extend(nsGmx$1.Utils, domManipulation);
    nsGmx$1.Utils._ = _$1;

    if (window.Node && window.Node.prototype) {
      Node.prototype.removeNode = function () {
        var parent = this.parentNode;
        parent && parent.removeChild(this);
      };
    }

    function show$1(elem) {
      elem.style.display = '';
    }

    function hide$1(elem) {
      elem.style.display = 'none';
    }

    function hidden(elem) {
      elem.style.visibility = 'hidden';
    }

    function visible(elem) {
      elem.style.visibility = 'visible';
    }

    function switchSelect(sel, value) {
      if (!sel.options || !sel.options.length) return sel;

      for (var i = 0; i < sel.options.length; i++) {
        if (value == sel.options[i].value) {
          sel.options[i].selected = true;
          sel.selectedIndex = i;
          break;
        }
      }

      return sel;
    }

    function objLength$1(obj) {
      var cnt = 0;

      for (var field in obj) {
        cnt++;
      }

      return cnt;
    }

    function getOffsetRect$1(elem) {
      var box = elem.getBoundingClientRect(),
          body = document.body,
          docElem = document.documentElement,
          scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
          scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
          clientTop = docElem.clientTop || body.clientTop || 0,
          clientLeft = docElem.clientLeft || body.clientLeft || 0,
          top = box.top + scrollTop - clientTop,
          left = box.left + scrollLeft - clientLeft;
      return {
        top: Math.round(top),
        left: Math.round(left)
      };
    }

    function attachEffects$1(elem, className) {
      elem.onmouseover = function () {
        jQuery(this).addClass(className);
      };

      elem.onmouseout = function (e) {
        var evt = e || window.event,
            // target = evt.srcElement || evt.target,
        relTarget = evt.relatedTarget || evt.toElement;

        try {
          while (relTarget) {
            if (relTarget == elem) return;
            relTarget = relTarget.parentNode;
          }

          jQuery(elem).removeClass(className);
        } catch (e) {
          jQuery(elem).removeClass(className);
        }
      };
    }

    function makeButton$1(value, id) {
      var inp = _input$1(null, [['dir', 'className', 'btn'], ['attr', 'type', 'submit'], ['attr', 'value', value]]);

      if (typeof id != 'undefined' && id != null) inp.id = id;
      inp.style.padding = '0px 5px';
      return inp;
    }

    function makeImageButton$1(url, urlHover) {
      var btn = _img$1();

      btn.setAttribute('src', url);
      btn.style.cursor = 'pointer';
      btn.style.border = 'none';

      if (urlHover) {
        btn.onmouseover = function () {
          this.setAttribute('src', urlHover);
        };

        btn.onmouseout = function () {
          this.setAttribute('src', url);
        };
      }

      return btn;
    }

    function makeLinkButton$1(text) {
      var span = _span$1([_t$1(String(text))], [['dir', 'className', 'buttonLink']]);

      attachEffects$1(span, 'buttonLinkHover');
      return span;
    }

    function stopEvent$1(e) {
      if (!e) var e = window.event; //e.cancelBubble is supported by IE - this will kill the bubbling process.

      e.cancelBubble = true;
      e.returnValue = false; //e.stopPropagation works only in Firefox.

      if (e.stopPropagation) {
        e.stopPropagation();
        e.preventDefault();
      }

      return false;
    } //Показывает диалог (на основе jQuery UI dialog)
    //Параметры можно передавать явно и в виде объекта params:
    //1. showDialog(title, content, width, height, ?posX, ?posY, ?resizeFunc, ?closeFunc)
    //2. showDialog(title, content, params)
    //Параметры:
    // - title {string} Заголовок диалога
    // - content {HTMLDomElement} контент диалога
    // - width, height {int} высота и ширина диалога (обязательные параметры!)
    // - posX, posY {int} положение диалога относительно экрана. Если не задано - по центру
    // - resizeFunc {function} будет вызываться при изменении размера диалога. Аргумент ф-ции - объект с атриубтами width и height
    // - closeFunc {function} будет вызываться при закрытии диалога
    // - setMinSize {bool} если true (по умолчанию), будут заданы минимальная ширина и высота, равные начальным размерам (width, height)


    function showDialog$1(title, content, width, height, posX, posY, resizeFunc, closeFunc) {
      var params = null;

      if (arguments.length == 3) {
        params = $.extend({
          posX: false,
          posY: false,
          setMinSize: true
        }, width);
      } else {
        params = {
          width: width,
          height: height,
          posX: posX,
          posY: posY,
          resizeFunc: resizeFunc,
          closeFunc: closeFunc,
          setMinSize: true
        };
      }

      var canvas = _div$1([content]);

      document.body.appendChild(canvas);
      var dialogParams = {
        width: params.width,
        height: params.height,
        title: title,
        position: params.posX == false ? 'center' : [params.posX, params.posY],
        resizable: true,
        resize: function resize(event, ui) {
          params.resizeFunc && params.resizeFunc(ui.size);
        },
        close: function close(ev, ui) {
          if (params.closeFunc && params.closeFunc()) return;
          removeDialog$1(canvas);
        },
        open: function open(ev, ui) {},
        closeText: null
      };

      if (params.setMinSize) {
        dialogParams.minWidth = params.width;
        dialogParams.minHeight = params.height;
      }

      jQuery(canvas).dialog(dialogParams);
      var dialog = canvas.parentNode;
      dialog.style.overflow = '';
      $(dialog).focusout(function (event) {
        event.stopImmediatePropagation();
        event.stopPropagation();
        event.preventDefault();
        jQuery.support.focusinBubbles = false;
        var ui = $('.ui-dialog-content', this);
        ui.context.st = $(ui).scrollTop();
      });
      $(dialog).focusin(function () {
        var uis = $('.ui-dialog-content');
        $(uis).each(function (index) {
          var st = $(this).context.st;
          $(this).scrollTop(st);
        });
      });
      jQuery(dialog).children("div.ui-resizable-se").removeClass("ui-icon").removeClass("ui-icon-gripsmall-diagonal-se").removeClass("ui-icon-grip-diagonal-se");
      return canvas;
    }

    function removeDialog$1(canvas) {
      jQuery(canvas).dialog('destroy').remove();
    }

    function showErrorMessage$1(message, removeFlag, title) {
      var canvas = _div$1([_t$1(message)], [['dir', 'className', 'errorDialog']]);

      var jQueryDiv = showDialog$1(title || "Ошибка!", canvas, {
        width: 250,
        height: 150,
        closeFunc: function closeFunc() {
          canvas = null;
        }
      });

      if (removeFlag) {
        setTimeout(function () {
          if (canvas) {
            jQuery(jQueryDiv).dialog("destroy");
            jQuery(canvas.parentNode).remove();
          }
        }, 2500);
      }
    }

    function _checkbox$1(flag, type, name) {
      var box = _input$1(null, [['attr', 'type', type]]);

      box.checked = flag;
      if (name) box.setAttribute('name', name);
      return box;
    }

    function insertAtCursor(myField, myValue, sel) {
      if (myField.id && window.tinyMCE && tinyMCE.get(myField.id)) {
        tinyMCE.execInstanceCommand(myField.id, "mceInsertContent", false, myValue);
        return;
      }

      if (document.selection) {
        if (typeof sel != 'undefined') sel.text = myValue;else {
          myField.focus();
          var sel = document.selection.createRange();
          sel.text = myValue;
        }
      } else if (myField.selectionStart || myField.selectionStart == '0') {
        var startPos = myField.selectionStart,
            endPos = myField.selectionEnd;
        myField.value = myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos, myField.value.length);
      } else myField.value += myValue;
    }

    nsGmx$1.Utils.uniqueGlobalName = function () {
      var freeid = 0;
      return function (thing) {
        var id = 'gmx_unique_' + freeid++;
        window[id] = thing;
        return id;
      };
    }();
    /** Посылает кросс-доменный GET запрос к серверу с использованием транспорта JSONP.
     *
     * @memberOf nsGmx.Utils
     * @param {String} url URL сервера.
     * @param {Function} callback Ф-ция, которая будет вызвана при получении от сервера результата.
     * @param {String} [callbackParamName=CallbackName] Имя параметра для задания имени ф-ции ответа.
     * @param {Function} [errorCallback] Ф-ция, которая будет вызвана в случае ошибки запроса к серверу
     */


    function sendCrossDomainJSONRequest$2(url, callback, callbackParamName, errorCallback) {
      callbackParamName = callbackParamName || 'CallbackName';
      var script = document.createElement("script");
      script.setAttribute("charset", "UTF-8");
      var callbackName = nsGmx$1.Utils.uniqueGlobalName(function (obj) {
        callback && callback(obj);
        window[callbackName] = false;
        document.getElementsByTagName("head").item(0).removeChild(script);
      });
      var sepSym = url.indexOf('?') == -1 ? '?' : '&';

      if (errorCallback) {
        script.onerror = errorCallback;
      }

      script.setAttribute("src", url + sepSym + callbackParamName + "=" + callbackName + "&" + Math.random());
      document.getElementsByTagName("head").item(0).appendChild(script);
    }

    nsGmx$1.Utils.sendCrossDomainJSONRequest = sendCrossDomainJSONRequest$2;

    function createCookie$1(name, value, days) {
      if (days) {
        var date = new Date();
        date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
        var expires = "; expires=" + date.toGMTString();
      } else var expires = "";

      document.cookie = name + "=" + value + expires + "; path=/";
    }

    function readCookie(name) {
      var nameEQ = name + "=";
      var ca = document.cookie.split(';');

      for (var i = 0; i < ca.length; i++) {
        var c = ca[i];

        while (c.charAt(0) == ' ') {
          c = c.substring(1, c.length);
        }

        if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
      }

      return null;
    }

    function eraseCookie(name) {
      createCookie$1(name, "", -1);
    }

    function getWindowWidth() {
      var myWidth = 0;
      if (typeof window.innerWidth == 'number') myWidth = window.innerWidth;else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) myWidth = document.documentElement.clientWidth;else if (document.body && (document.body.clientWidth || document.body.clientHeight)) {
        myWidth = document.body.clientWidth;
      }
      return myWidth;
    }

    function getWindowHeight() {
      var myHeight = 0;
      if (typeof window.innerWidth == 'number') myHeight = window.innerHeight;else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight)) myHeight = document.documentElement.clientHeight;else if (document.body && (document.body.clientWidth || document.body.clientHeight)) myHeight = document.body.clientHeight;
      return myHeight;
    }

    (function () {
      var replacements = {};
      var temp;

      for (var rus in temp = {
        "qwertyuiopasdfghjklzxcvbnm_1234567890": "qwertyuiopasdfghjklzxcvbnm_1234567890",
        "абвгдезийклмнопрстуфыэ ": "abvgdeziyklmnoprstufye_",
        "ёжчхцшщюя": "yozhchkhtsshshyuya",
        "ьъ": "",
        ".": "."
      }) {
        var eng = temp[rus],
            k = eng.length / rus.length;

        for (var i = 0; i < rus.length; i++) {
          var r = rus.substring(i, i + 1),
              e = eng.substring(i * k, (i + 1) * k);
          replacements[r] = e;
          replacements[r.toUpperCase()] = e.toUpperCase();
        }
      }

      nsGmx$1.Utils.translit = function (name) {
        var result = "";

        for (var i = 0; i < name.length; i++) {
          result += replacements[name.substring(i, i + 1)] || "";
        }

        return result;
      };
    })();

    !function () {
      var requests = {},
          lastRequestId = 0,
          uniquePrefix = 'id' + Math.random();

      var processMessage = function processMessage(e) {
        if (!(e.origin in requests)) {
          return;
        }

        var dataStr = decodeURIComponent(e.data.replace(/\n/g, '\n\\'));

        try {
          var dataObj = JSON.parse(dataStr);
        } catch (e) {
          request.callback && request.callback({
            Status: "error",
            ErrorInfo: {
              ErrorMessage: "JSON.parse exeption",
              ExceptionType: "JSON.parse",
              StackTrace: dataStr
            }
          });
        } // console.log(dataObj);


        var request = requests[e.origin][dataObj.CallbackName];
        if (!request) return; // message от других запросов

        delete requests[e.origin][dataObj.CallbackName];
        delete dataObj.CallbackName;
        request.iframe.parentNode.removeChild(request.iframe);
        request.callback && request.callback(dataObj);
      }; //совместимость с IE8


      if (window.addEventListener) {
        window.addEventListener('message', processMessage);
      } else {
        window.attachEvent('onmessage', processMessage);
      } //скопирована из API для обеспечения независимости от него


      var parseUri = function parseUri(str) {
        var o = parseUri.options,
            m = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),
            uri = {},
            i = 14;

        while (i--) {
          uri[o.key[i]] = m[i] || '';
        }

        uri[o.q.name] = {};
        uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
          if ($1) {
            uri[o.q.name][$1] = $2;
          }
        });
        uri.hostOnly = uri.host;
        uri.host = uri.authority; // HACK

        return uri;
      };

      parseUri.options = {
        strictMode: false,
        key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
        q: {
          name: 'queryKey',
          parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
          strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
          loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
      };

      function createPostIframe2(id, callback, url) {
        var uniqueId = uniquePrefix + lastRequestId++;
        var iframe = document.createElement("iframe");
        iframe.style.display = 'none';
        iframe.setAttribute('id', id);
        iframe.setAttribute('name', id);
        iframe.src = 'javascript:true';
        iframe.callbackName = uniqueId; //iframe.onload = window[callbackName];

        var parsedURL = parseUri(url);
        var origin = (parsedURL.protocol ? parsedURL.protocol + ':' : window.location.protocol) + '//' + (parsedURL.host || window.location.host);
        requests[origin] = requests[origin] || {};
        requests[origin][uniqueId] = {
          callback: callback,
          iframe: iframe
        };
        return iframe;
      }

      window.createPostIframe2 = createPostIframe2;
    }();
    /** Посылает кроссдоменный POST запрос
    *
    * @memberOf nsGmx.Utils
    * @param {String} url URL запроса
    * @param {Object} params Хэш параметров-запросов
    * @param {Function} [callback] Callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные
    * @param {DOMElement} [baseForm] базовая форма запроса. Используется, когда нужно отправить на сервер файл.
    *                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.
    */

    function sendCrossDomainPostRequest$1(url, params, callback, baseForm) {
      var form,
          rnd = String(Math.random()),
          id = '$$iframe_' + url + rnd;
      var iframe = createPostIframe2(id, callback, url),
          originalFormAction;

      if (baseForm) {
        form = baseForm;
        originalFormAction = form.getAttribute('action');
        form.setAttribute('action', url);
        form.target = id;
      } else {
        try {
          form = document.createElement('<form id=' + id + '" enctype="multipart/form-data" style="display:none" target="' + id + '" action="' + url + '" method="post"></form>');
        } catch (e) {
          form = document.createElement("form");
          form.style.display = 'none';
          form.setAttribute('enctype', 'multipart/form-data');
          form.target = id;
          form.setAttribute('method', 'POST');
          form.setAttribute('action', url);
          form.id = id;
        }
      }

      var hiddenParamsDiv = document.createElement("div");
      hiddenParamsDiv.style.display = 'none';

      if (params.WrapStyle === 'window') {
        params.WrapStyle = 'message';
      }

      if (params.WrapStyle === 'message') {
        params.CallbackName = iframe.callbackName;
      }

      for (var paramName in params) {
        var input = document.createElement("input");
        var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';
        input.setAttribute('type', 'hidden');
        input.setAttribute('name', paramName);
        input.setAttribute('value', value);
        hiddenParamsDiv.appendChild(input);
      }

      form.appendChild(hiddenParamsDiv);
      if (!baseForm) document.body.appendChild(form);
      document.body.appendChild(iframe);
      form.submit();

      if (baseForm) {
        form.removeChild(hiddenParamsDiv);
        if (originalFormAction !== null) form.setAttribute('action', originalFormAction);else form.removeAttribute('action');
      } else {
        form.parentNode.removeChild(form);
      }
    }

    var hooks = {};
    /** Добавляет "хук", который будет вызван при ответе сервера соответвующего типа
    * @param type {object} - тип хука (соответствует полю "Status" ответа сервера) или '*' - добавить к любому ответу
    * @param hookFunction {function(response, customErrorDescriptions)} - собственно хук
    */

    function addParseResponseHook(type, hookFunction) {
      hooks[type] = hooks[type] || [];
      hooks[type].push(hookFunction);
    }
    /** Обрабатывает результат выполнения серверного скрипта.
    * Для выполнения действий вызывает "хуки" соответствующиего типа, добавленные через addParseResponseHook()
    * @function
    * @global
    * @param {object} response JSON, вернувшийся с сервера
    * @param {object} customErrorDescriptions хэш "тип ошибки" -> "кастомное сообщение пользователям".
    * @return true, если статус ответа "ok", иначе false
    */


    function parseResponse$1(response, customErrorDescriptions) {
      var responseHooks = (hooks[response.Status] || []).concat(hooks['*'] || []);

      for (var h = 0; h < responseHooks.length; h++) {
        responseHooks[h](response, customErrorDescriptions);
      }

      return response.Status == 'ok';
    }

    function _title$1(elem, title) {
      elem.setAttribute('title', title);
    }

    function disableSelection(target) {
      if (typeof target.onselectstart != "undefined") target.onselectstart = function () {
        return false;
      };else if (typeof target.style.MozUserSelect != "undefined") target.style.MozUserSelect = "none";else target.onmousedown = function () {
        return false;
      };
    }

    function stringDate(msec, isUtc) {
      var date = new Date(msec),
          excDate = isUtc ? date.getUTCDate() : date.getDate(),
          excMonth = (isUtc ? date.getUTCMonth() : date.getMonth()) + 1,
          excYear = isUtc ? date.getUTCFullYear() : date.getFullYear();
      return (excDate < 10 ? '0' + excDate : excDate) + '.' + (excMonth < 10 ? '0' + excMonth : excMonth) + '.' + excYear;
    }

    function stringTime(msec, isUtc) {
      var date = new Date(msec),
          excHour = isUtc ? date.getUTCHours() : date.getHours(),
          excMin = isUtc ? date.getUTCMinutes() : date.getMinutes(),
          excSec = isUtc ? date.getUTCSeconds() : date.getSeconds();
      return (excHour < 10 ? '0' + excHour : excHour) + ':' + (excMin < 10 ? '0' + excMin : excMin) + ':' + (excSec < 10 ? '0' + excSec : excSec);
    }

    function stringDateTime(msec, isUtc) {
      return stringDate(msec, isUtc) + ' ' + stringTime(msec, isUtc);
    }
    /**
        @namespace nsGmx.Utils
        @description Разнообразные вспомогательные ф-ции
    */


    $.extend(nsGmx$1.Utils, {
      /**
          Возвращает уникальную строку (16 символов из букв и латинских цифр)
          @function
          @memberOf nsGmx.Utils
      */
      generateUniqueID: function generateUniqueID() {
        var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",
            randomstring = '';

        for (var i = 0; i < 16; i++) {
          var rnum = Math.floor(Math.random() * chars.length);
          randomstring += chars.charAt(rnum);
        }

        return randomstring;
      },

      /**
          Преобразует цвет, заданный в виде числа (0xaabbcc) в строку вида #aabbcc
          @function
          @memberOf nsGmx.Utils
      */
      convertColor: function convertColor(intColor) {
        var r, g, b;
        b = (intColor % 256).toString(16);
        if (b.length == 1) b = '0' + b;
        intColor = Math.floor(intColor / 256);
        g = (intColor % 256).toString(16);
        if (g.length == 1) g = '0' + g;
        intColor = Math.floor(intColor / 256);
        r = (intColor % 256).toString(16);
        if (r.length == 1) r = '0' + r;
        return '#' + r + g + b;
      },

      /**
          Преобразует цвет, заданный в виде строки rgb(255, 255, 255) в строку вида #aabbcc
          @function
          @memberOf nsGmx.Utils
      */
      rgb2hex: function rgb2hex(intColor) {
        var str,
            arr = intColor.substring(4, intColor.length - 1).split(', ');
        arr = arr.map(function (c) {
          var hex = Number(c).toString(16);
          return hex.length == 1 ? "0" + hex : hex;
        });
        str = "#" + arr.join('');
        return str;
      },
      checkForNumber: function checkForNumber(number) {
        return !(isNaN(number) || typeof number === 'undefined' || number === null || number === '');
      },
      isJSON: function isJSON(str) {
        try {
          JSON.parse(str);
        } catch (e) {
          return false;
        }

        if (str === '' || str === 'null' || str === 'undefined' || typeof str === 'Number') {
          return false;
        } else {
          return true;
        }
      },

      /** Возвращает позицию окна такую, чтобы окно не мешало текущему элементу
             @memberOf nsGmx.Utils
         */
      getDialogPos: function getDialogPos(div, offsetFlag, height) {
        var pos = getOffsetRect$1(div),
            left = pos.left + 30,
            top = pos.top - 10,
            windowHeight = getWindowHeight();

        if (offsetFlag) {
          $(div).children('div,img').each(function () {
            if (!this.getAttribute('multiStyle')) left += this.offsetWidth;
          });
        }

        if (top + 15 + height > windowHeight) top -= top + 15 + height - windowHeight;
        return {
          left: left,
          top: top
        };
      },

      /** Устанавливает обычный стиль и генерит похожий стиль при наведении мышки
         @memberOf nsGmx.Utils
      @param layer {L.gmxVectorLayer} Слой
      @param styleIndex {Number} Номер стиля слоя
      @param templateStyle {Style} Стиль, похожий на который надо установить*/
      setMapObjectStyle: function setMapObjectStyle(layer, styleIndex, templateStyle) {
        var hoverStyle = $.extend(true, {}, templateStyle);
        var style = layer.getStyle(styleIndex);
        if (templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined') hoverStyle.outline.thickness = Number(templateStyle.outline.thickness) + 1;
        if (templateStyle.fill && typeof templateStyle.fill.opacity != 'undefined' && templateStyle.fill.opacity > 0) hoverStyle.fill.opacity = Math.min(Number(templateStyle.fill.opacity + 20), 100);
        var newStyle = $.extend(true, {}, style);
        newStyle.RenderStyle = L.gmxUtil.fromServerStyle(templateStyle);
        newStyle.HoverStyle = L.gmxUtil.fromServerStyle(hoverStyle);

        if (templateStyle.labelTemplate) {
          newStyle.RenderStyle.labelTemplate = templateStyle.labelTemplate;
        }

        if (hoverStyle.labelTemplate) {
          newStyle.HoverStyle.labelTemplate = hoverStyle.labelTemplate;
        }

        if (templateStyle.labelAnchor) {
          newStyle.RenderStyle.labelAnchor = templateStyle.labelAnchor;
        }

        if (hoverStyle.labelAnchor) {
          newStyle.HoverStyle.labelAnchor = hoverStyle.labelAnchor;
        }

        layer.setStyle(newStyle, styleIndex);
      },
      // берёт стиль в формате сервера, добавляет в него hover-подсветку
      // и возвращает этот стиль в новом формате Leafelt-Geomixer
      prepareGmxLayerStyle: function prepareGmxLayerStyle(style) {
        var templateStyle = style.RenderStyle,
            newStyle = $.extend(true, {}, style),
            hoverStyle = $.extend(true, {}, templateStyle);
        if (templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined') hoverStyle.outline.thickness = Number(templateStyle.outline.thickness) + 1;
        if (templateStyle.fill && typeof templateStyle.fill.opacity != 'undefined' && templateStyle.fill.opacity > 0) hoverStyle.fill.opacity = Math.min(Number(templateStyle.fill.opacity + 20), 100);
        newStyle.RenderStyle = L.gmxUtil.fromServerStyle(templateStyle);
        newStyle.HoverStyle = L.gmxUtil.fromServerStyle(hoverStyle);
        return newStyle;
      },

      /** Конвертация данных между форматами сервера и клиента. Используется в тегах слоёв и в атрибутах объектов векторных слоёв.
      *
      * Форматы сервера:
      *
      *  * datetime - unix timestamp
      *  * date - unix timestamp, кратный 24*3600 секунд
      *  * time - кол-во секунд с полуночи
      *
      * Форматы клиента:
      *
      *  * все числа превращаются в строки
      *  * дата - строка в формате dd.mm.yy
      *  * время - строка в формате hh:mm:ss
      *  * дата-время - dd.mm.yy hh:mm:ss
      *
      * @memberOf nsGmx.Utils
      */
      convertFromServer: function convertFromServer(type, value) {
        //if (value === null) return "null";
        if (!type) {
          return value;
        }

        var lowerCaseType = type.toLowerCase();

        if (lowerCaseType == 'string') {
          return value !== null ? value : ''; //все null интерпретируем как пустые строки!
        } else if (lowerCaseType == 'integer' || lowerCaseType == 'float' || lowerCaseType == 'number') {
          return value !== null ? String(value) : '';
        } else if (lowerCaseType == 'date') {
          if (value === null) return '';
          return stringDate(value * 1000, true);
        } else if (lowerCaseType == 'time') {
          if (value === null) return '';
          return stringTime(value * 1000, true);
        } else if (lowerCaseType == 'datetime') {
          if (value === null) return '';
          return stringDateTime(value * 1000, true);
        }

        return value;
      },

      /** Конвертация данных между форматами сервера и клиента. Используется в тегах слоёв и в атрибутах объектов векторных слоёв.
      * Описание форматов см. в {@link nsGmx.Utils.convertFromServer}
      * Если конвертация невозможна для данного типа, возвращает null
      * @memberOf nsGmx.Utils
      */
      convertToServer: function convertToServer(type, value) {
        if (!type) {
          return value;
        }

        var lowerCaseType = type.toLowerCase();

        if (lowerCaseType == 'string') {
          return value;
        } else if (lowerCaseType == 'integer' || lowerCaseType == 'float' || lowerCaseType == 'number') {
          if (value === '') return null;
          var num = Number(value);
          return isNaN(num) ? null : num;
        } else if (lowerCaseType == 'date') {
          var localDateValue = $.datepicker.parseDate('dd.mm.yy', value);
          if (localDateValue === null) return null;
          var localValue = localDateValue.valueOf() / 1000;
          var timeOffset = new Date(localValue * 1000).getTimezoneOffset() * 60;
          return localValue - timeOffset;
        } else if (lowerCaseType == 'time') {
          var resTime = $.datepicker.parseTime('HH:mm:ss', value);
          if (!resTime) return null;
          return resTime.hour * 3600 + resTime.minute * 60 + resTime.second;
        } else if (lowerCaseType == 'datetime') {
          var localDateValue = $.datepicker.parseDateTime('dd.mm.yy', 'HH:mm:ss', value);
          if (localDateValue === null) return null;
          var localValue = localDateValue.valueOf() / 1000;
          var timeOffset = new Date(localValue * 1000).getTimezoneOffset() * 60;
          return localValue - timeOffset;
        }

        return value;
      },
      login: function login(redirect_uri, authServerBase, callback, authServer, isHidden) {
        var oAuthServer = authServer || 'MyKosmosnimki';

        window.gmxGetServerBase = function () {
          return authServerBase;
        };

        var redirectUri = redirect_uri + (redirect_uri.indexOf('?') > 0 ? '&' : '?') + 'authServer=' + oAuthServer;

        window.gmxProcessAuthentication = function (userInfo) {
          callback && callback(userInfo);
        };

        var features,
            w = 600,
            h = 350;
        var handlerName = 'LoginDialog';

        if (oAuthServer != 'MyKosmosnimki') {
          handlerName += oAuthServer;
          h = 400;
        }

        var url = authServerBase + handlerName + '.ashx?redirect_uri=' + escape(redirectUri);

        if (!isHidden) {
          var top = (screen.height - h) / 2,
              left = (screen.width - w) / 2;
          features = 'location=0,menubar=0,resizable=0,status=0,toolbar=0,width=' + w + ',height=' + h + ',left=' + left + ',top=' + top;
          window.open(url, '_blank', features);
        } else {
          $('<iframe />', {
            'src': url,
            'style': 'display: block !important; position: absolute; left: -99999px;'
          }).appendTo('body'); //стиль такой кривой иначе будет бага в FF
        }
      },

      /** Загружает пользовательский shp файл.
      * Проверяет на ошибки, выводит предупреждения и ошибки в виде стандартных диалогов.
      * @memberof nsGmx.Utils
      * @function
      * @param {File|Form} shpSource Либо форма с полем file, в которой пользователь выбрал файл, либо HTML5 File. Форма должна иметь атрибуты method="post" и enctype="multipart/form-data"
      * @return {jQuery.Deferred} Возвращает promise (аргумент ф-ции - массив объектов из shp файла)
      */
      parseShpFile: function () //приватные данные
      {
        var translationsAdded = false;

        var addTranslationsLazy = function addTranslationsLazy() {
          if (translationsAdded) return;

          _translationsHash.addtext("rus", {
            "loadShape.Errors.FileTooBigException": "Файл слишком большой. Ограничение на размер файла 1000 Кб.",
            "loadShape.Errors.ErrorUploadExeption": "Произошла ошибка при попытке загрузить файл.",
            "loadShape.Errors.NoGeometryFile": "Загруженный файл не содержит геометрических данных.",
            "loadShape.Errors.ErrorUploadNoDependentFiles": "Не найдено необходимых зависимых файлов. Запакуйте все файлы в ZIP архив и повторите загрузку."
          });

          _translationsHash.addtext("eng", {
            "loadShape.Errors.FileTooBigException": "Too big file. File size limit is 1000 Kb.",
            "loadShape.Errors.ErrorUploadExeption": "Error during file uploading.",
            "loadShape.Errors.NoGeometryFile": "There are no geometry in uploaded file.",
            "loadShape.Errors.ErrorUploadNoDependentFiles": "Not found the necessary dependent files. Add all files in a ZIP archive and upload it again."
          });

          translationsAdded = true;
        }; //непосредственно ф-ция


        return function (shpFileForm) {
          var def = $.Deferred();
          addTranslationsLazy();
          var errorMessages = {
            "CommonUtil.FileTooBigException": _gtxt("loadShape.Errors.FileTooBigException"),
            "CommonUtil.ErrorUploadExeption": _gtxt("loadShape.Errors.ErrorUploadExeption"),
            "CommonUtil.NoGeometryFile": _gtxt("loadShape.Errors.NoGeometryFile"),
            "CommonUtil.ErrorUploadNoDependentFiles": _gtxt("loadShape.Errors.ErrorUploadNoDependentFiles")
          };

          if (window.File && shpFileForm instanceof window.File) {
            if (!window.FormData) {
              def.reject();
              return false;
            }

            var formData = new FormData();
            formData.append('file', shpFileForm);
            var xhr = new XMLHttpRequest();
            xhr.open('POST', serverBase + 'ShapeLoader');

            xhr.onload = function () {
              if (xhr.status === 200) {
                response = JSON.parse(xhr.responseText.substr(1, xhr.responseText.length - 2));

                if (parseResponse$1(response, errorMessages)) {
                  def.resolve(response.Result);
                } else {
                  def.reject(response);
                }
              }
            };

            xhr.send(formData);
          } else {
            sendCrossDomainPostRequest$1(serverBase + "ShapeLoader", {
              WrapStyle: "window"
            }, function (response) {
              if (parseResponse$1(response, errorMessages)) def.resolve(response.Result);else def.reject(response);
            }, shpFileForm);
          }

          return def.promise();
        };
      }(),

      /** Позволяет скачать в браузере геометрию в одном из форматов (упакованный в zip архив).
      * @memberof nsGmx.Utils
      * @function
      * @param {Object[]} geoJSONFeatures Массив GeoJSON Features. К сожалению, другие типы GeoJSON объектов не поддерживаются.
      * @param {Object} [options] Доп. параметры
      * @param {String} [options.fileName=markers] Имя файла для скачивания
      * @param {String} [options.format=Shape] В каком формате скачать (Shape, Tab, gpx или несколько через запятую)
      */
      downloadGeometry: function downloadGeometry(geoJSONFeatures, options) {
        var objectsByType = {},
            markerIdx = 1;
        options = $.extend({
          fileName: 'markers',
          format: 'Shape'
        }, options);
        geoJSONFeatures.forEach(function (item) {
          var geom = item.geometry,
              type = geom.type;
          objectsByType[type] = objectsByType[type] || [];
          var title = item.properties && item.properties.title || '';

          if (type == "Point" && !title) {
            title = "marker " + markerIdx++;
          }

          objectsByType[type].push({
            geometry: {
              type: type.toUpperCase(),
              coordinates: geom.coordinates
            },
            properties: {
              text: title
            }
          });
        });
        sendCrossDomainPostRequest$1(serverBase + "Shapefile", {
          name: options.fileName,
          format: options.format,
          points: JSON.stringify(objectsByType["Point"] || []),
          lines: JSON.stringify([].concat(objectsByType["LineString"] || [], objectsByType["MultiLineString"] || [])),
          polygons: JSON.stringify([].concat(objectsByType["Polygon"] || [], objectsByType["MultiPolygon"] || []))
        });
      },

      /** Объединяет массив полигонов/мультиполигонов в новый полигон/мультиполигон
      * @memberof nsGmx.Utils
      */
      joinPolygons: function joinPolygons(objs) {
        var polygonObjects = [];

        for (var i = 0; i < objs.length; i++) {
          var geom = objs[i];

          if (geom.type == 'POLYGON') {
            polygonObjects.push(geom.coordinates);
          } else if (geom.type == 'MULTIPOLYGON') {
            for (var iC = 0; iC < geom.coordinates.length; iC++) {
              polygonObjects.push(geom.coordinates[iC]);
            }
          }
        }

        if (polygonObjects.length > 1) return {
          type: "MULTIPOLYGON",
          coordinates: polygonObjects
        };else if (polygonObjects.length == 1) {
          return {
            type: "POLYGON",
            coordinates: polygonObjects[0]
          };
        } else return null;
      },
      joinClippedPolygon: function joinClippedPolygon(polygon) {
        if (polygon.type !== 'MULTIPOLYGON') {
          return polygon;
        }

        var origData = [],
            segmentsToJoin = [],
            joinedSegments = [],
            crossPoints = [],
            finalPolygon = [];

        var equal = function equal(a, b) {
          return Math.abs(a - b) < 1e-5;
        };

        var coords = polygon.coordinates;

        for (var c = 0; c < coords.length; c++) {
          for (var r = 0; r < coords[c].length; r++) {
            coords[c][r].length = coords[c][r].length - 1;
          }
        }

        var parseRing = function parseRing(origRing) {
          var ring = origRing.coords,
              len = ring.length;

          var getNextSegment = function getNextSegment(i) {
            var il = (i - 1 + len) % len,
                points = [];

            while (i != il) {
              if (equal(Math.abs(ring[i][0]), 180) && equal(Math.abs(ring[(i + 1) % len][0]), 180)) {
                return [i, points];
              }

              points.push(ring[i]);
              i = (i + 1) % len;
            }

            return [i, points];
          };

          var segment = getNextSegment(0);
          var lastI = segment[0];

          if (!equal(Math.abs(ring[segment[0]][0]), 180)) {
            origRing.regularRing = ring;
            return;
          }

          do {
            startI = (segment[0] + 1) % len;
            segment = getNextSegment((startI + 1) % len);
            var nextSegment = {
              points: [].concat([ring[startI]], segment[1], [ring[segment[0]]])
            };
            segmentsToJoin.push(nextSegment);
            origRing.segments.push(nextSegment);
          } while (segment[0] !== lastI);
        };

        var findSegment = function findSegment(y, joinedSeg) {
          for (var s = 0; s < segmentsToJoin.length; s++) {
            var seg = segmentsToJoin[s];

            if (equal(seg.points[0][1], y) || equal(seg.points[seg.points.length - 1][1], y)) {
              segmentsToJoin.splice(s, 1);
              seg.joinedSeg = joinedSeg;
              var isReg = equal(seg.points[0][1], y);
              return {
                points: isReg ? seg.points.slice(1, seg.points.length - 1) : seg.points.slice(1, seg.points.length - 1).reverse(),
                lastY: isReg ? seg.points[seg.points.length - 1][1] : seg.points[0][1]
              };
            }
          }
        };

        var joinSegment = function joinSegment(y0) {
          var res = {},
              seg = findSegment(y0, res),
              points = seg.points,
              crossPoints = [y0];

          while (seg.lastY !== y0) {
            crossPoints.push(seg.lastY);
            seg = findSegment(seg.lastY);
            points = points.concat(seg.points);
          }
          res.points = points, res.crossPoints = crossPoints, res.minCrossPoint = Math.min.apply(Math, crossPoints);
          return res;
        };

        var parseGeometry = function parseGeometry(geom) {
          for (var c = 0; c < geom.coordinates.length; c++) {
            var origComp = [];
            origData.push(origComp);
            var comp = geom.coordinates[c];

            for (var r = 0; r < comp.length; r++) {
              var origRing = {
                coords: comp[r],
                segments: []
              };
              origComp.push(origRing);
              parseRing(origRing);
            }
          }
        };

        parseGeometry(polygon);
        segmentsToJoin.forEach(function (segment) {
          if (segment.points[0][0] < 0) {
            segment.points = segment.points.map(function (c) {
              return [c[0] + 360, c[1]];
            });
          }
        });

        while (segmentsToJoin.length) {
          var y0 = segmentsToJoin[0].points[0][1];
          var joinedSeg = joinSegment(y0);
          joinedSegments.push(joinedSeg);
          crossPoints = crossPoints.concat(joinedSeg.crossPoints);
        }

        crossPoints = crossPoints.sort();
        joinedSegments = joinedSegments.sort(function (s1, s2) {
          return s1.minCrossPoint - s2.minCrossPoint;
        });
        joinedSegments.forEach(function (s, i) {
          s.isExternal = crossPoints.indexOf(s.minCrossPoint) % 2 === 0;
        }); //собираем объединённые сегменты в мультиполигон

        joinedSegments.forEach(function (s) {
          if (s.isExternal) {
            finalPolygon.push([s.points]);
          } else {
            finalPolygon[finalPolygon.length - 1].push(s.points);
          }

          s.finalComponent = finalPolygon[finalPolygon.length - 1];
        }); //добавляем компоненты, которые не пересекались со 180 градусом

        for (var c = 0; c < origData.length; c++) {
          if (origData[c][0].regularRing) {
            console.log('external component', c);
            var geomToCopy = [];

            for (var r = 0; r < origData[c].length; r++) {
              geomToCopy.push(origData[c][r].regularRing);
            }

            finalPolygon.push(geomToCopy);
            continue;
          }

          for (var r = 1; r < origData[c].length; r++) {
            if (origData[c][r].regularRing) {
              console.log('internal component', c, r, origData[c][0].segments);

              for (var s = 0; s < origData[c][0].segments.length; s++) {
                var joinedSeg = origData[c][0].segments[s].joinedSeg;

                if (joinedSeg.isExternal) {
                  joinedSeg.finalComponent.push(origData[c][r].regularRing);
                  break;
                }
              }
            }
          }
        }

        if (finalPolygon.length === 1) {
          return {
            type: 'POLYGON',
            coordinates: finalPolygon[0]
          };
        } else {
          return {
            type: 'MULTIPOLYGON',
            coordinates: finalPolygon
          };
        }
      },

      /** Методы для работы с сохранёнными на сервере данными.
      * Сервер позволяет сохранять произвольный текст на сервере и получить ID, по которому можно этот текст получить.
      * Используется для формирования пермалинков (сохранение состояния)
      * @namespace
      * @memberOf nsGmx.Utils
      */
      TinyReference: {
        /** Создать новую ссылку
        * @param {String} data Данные, которые нужно сохранить
        * @return {jQuery.Deferred} Промис, который будет resolve при сохранении данных. Параметр при ресолве: ID, по которому можно получить данные обратно
        */
        create: function create(data, tempFlag) {
          var def = $.Deferred();
          sendCrossDomainPostRequest$1(serverBase + "TinyReference/Create.ashx", {
            WrapStyle: 'message',
            content: JSON.stringify(data),
            temp: tempFlag
          }, function (response) {
            if (parseResponse$1(response)) {
              def.resolve(response.Result);
            } else {
              def.reject();
            }
          });
          return def.promise();
        },

        /** Получить ранее сохранённые данные по ID
        * @param {String} id полученный при сохранении ID данных
        * @return {jQuery.Deferred} Промис, который будет resolve при получении данных. Параметр при ресолве: данные с сервера
        */
        get: function get(id) {
          var def = $.Deferred();
          sendCrossDomainJSONRequest$2(serverBase + "TinyReference/Get.ashx?id=" + id, function (response) {
            //если пермалинк не найден, сервер не возвращает ошибку, а просто пустой результат
            if (parseResponse$1(response) && response.Result) {
              def.resolve(JSON.parse(response.Result));
            } else {
              def.reject();
            }
          });
          return def.promise();
        },

        /** Удалить данные по ID
        * @param {String} id полученный при сохранении ID данных
        * @return {jQuery.Deferred} Промис, который будет resolve при удалении данных
        */
        remove: function remove(id) {
          var def = $.Deferred();
          sendCrossDomainJSONRequest$2(serverBase + "TinyReference/Delete.ashx?id=" + id, function (response) {
            if (parseResponse$1(response)) {
              def.resolve();
            } else {
              def.reject();
            }
          });
          return def.promise();
        }
      },
      isIpad: function isIpad() {
        return navigator.userAgent.match(/iPad/i) != null;
      },
      getLatLngBounds: function getLatLngBounds(layer) {
        var gmxBounds = layer._gmx.layerID ? L.gmxUtil.getGeometryBounds(layer._gmx.geometry) : layer._gmx.dataManager.getItemsBounds(),
            srs = layer._gmx.srs,
            array = [],
            projection;
        console.log(gmxBounds);

        if (srs) {
          for (var proj in L.CRS) {
            if (proj.indexOf(srs) !== -1) {
              projection = L.CRS[proj];
              break;
            }
          }
        } else {
          projection = L.CRS['EPSG:3395'];
        }

        array.push(L.Projection.Mercator.unproject(gmxBounds.min));
        array.push(L.Projection.Mercator.unproject(gmxBounds.max));
        return L.latLngBounds(array);
      },
      showDialog: showDialog$1,
      removeDialog: removeDialog$1,
      makeImageButton: makeImageButton$1,
      makeLinkButton: makeLinkButton$1,
      makeButton: makeButton$1,
      _title: _title$1,
      _checkbox: _checkbox$1
    });
    window.gmxCore && window.gmxCore.addModule('utilities', nsGmx$1.Utils);
    var _br$1 = domManipulation._br,
        _div$1 = domManipulation._div,
        _img$1 = domManipulation._img,
        _input$1 = domManipulation._input,
        _li$1 = domManipulation._li,
        _option$1 = domManipulation._option,
        _span$1 = domManipulation._span,
        _a = domManipulation._a,
        _t$1 = domManipulation._t,
        _table$1 = domManipulation._table,
        _tbody$1 = domManipulation._tbody,
        _textarea$1 = domManipulation._textarea,
        _thead = domManipulation._thead,
        _tr$1 = domManipulation._tr,
        _th = domManipulation._th,
        _td$1 = domManipulation._td,
        _ul$1 = domManipulation._ul;
    window.addParseResponseHook = addParseResponseHook;
    window.parseResponse = parseResponse$1;

    // {
    // 	this.hash = {};
    // 	this.flags = {};
    // 	this.titles = {};
    //     this._errorHandlers = [];
    // }

    var DEFAULT_LANGUAGE = 'rus'; //Для запоминания выбора языка пользователем используются куки. 
    //Запоминается выбор для каждого pathname, а не только для домена целиком
    //Формат куки: pathname1=lang1&pathname2=lang2&...

    var _parseLanguageCookie = function _parseLanguageCookie() {
      var text = readCookie("language");
      if (!text) return {};
      var items = text.split('&'); //поддержка старого формата кук (просто названия взыка для всех pathname)

      if (items % 2) items = [];
      var langs = {};

      for (var i = 0; i < items.length; i++) {
        var elems = items[i].split('=');
        langs[decodeURIComponent(elems[0])] = decodeURIComponent(elems[1]);
      }

      return langs;
    };

    var _saveLanguageCookie = function _saveLanguageCookie(langs) {
      var cookies = [];

      for (var h in langs) {
        cookies.push(encodeURIComponent(h) + '=' + encodeURIComponent(langs[h]));
      }

      eraseCookie("language");
      createCookie$1("language", cookies.join('&'));
    };

    var TranslationsManager = function TranslationsManager() {
      this.flags = {};
      this.titles = {};
      this.hash = {};
      this._errorHandlers = [];
    };

    TranslationsManager.prototype._language = null;

    TranslationsManager.prototype._addTextWithPrefix = function (prefix, lang, newHash) {
      var res = true,
          hash = this.hash;

      if (!(lang in hash)) {
        hash[lang] = {};
      }

      for (var k in newHash) {
        var fullKey = prefix + k;

        if (fullKey in hash[lang]) {
          res = false;
        } else if (typeof newHash[k] === 'string') {
          hash[lang][fullKey] = newHash[k];
        } else {
          this._addTextWithPrefix(fullKey + '.', lang, newHash[k]);
        }
      }

      return res;
    };
    /** Добавить строки в словарь локализации
     @func addText
     @memberOf nsGmx.Translations
     @param {String} lang Язык, к которому добавляются строки
     @param {Object} strings Список добавляемых строк. Должен быть объектом, в котором атрибуты являются ключами перевода.
                     Если значение атрибута - строка, то она записывается как результат локализации данного ключа.
                     Если значение атрибута - другой объект, то название текущего атрибута будет добавлено с точкой 
                     к названию атрибутов в этом объекте. Например: {a: {b: 'бэ', c: 'це'}} сформируют ключи локализации 'a.b' и 'a.c'.
    */


    TranslationsManager.prototype.addText = function (lang, newHash) {
      this._addTextWithPrefix('', lang, newHash);
    };
    /** Получить локализованный текст по ключу для текущего языка
     @func getText
     @memberOf nsGmx.Translations
     @param {String} key Ключ локализации
     @return {String} Локализованный текст
    */


    TranslationsManager.prototype.getText = function (dictKey) {
      var lang = this.getLanguage(),
          args = arguments,
          getArg = function getArg(i) {
        return args[i + 1] || '';
      };

      if (!this.hash[lang] || !this.hash[lang][dictKey]) {
        this._errorHandlers.forEach(function (handler) {
          handler(dictKey, lang);
        });

        return '';
      } else {
        return this.hash[lang][dictKey].replace(/\[value(\d)\]/g, function (match, argIndex) {
          return getArg(Number(argIndex));
        });
      }
    };
    /** Установить текущий язык
     @func setLanguage
     @memberOf nsGmx.Translations
     @param {String} lang Текущий язык (eng/rus/...)
    */


    TranslationsManager.prototype.setLanguage = function (lang) {
      TranslationsManager.prototype._language = lang;
    };
    /** Получить текущий язык локализации
     @func getLanguage
     @memberOf nsGmx.Translations
     @return {String} Текущий язык (eng/rus/...)
    */


    TranslationsManager.prototype.getLanguage = function () {
      return TranslationsManager.prototype._language || typeof window !== 'undefined' && window.language || DEFAULT_LANGUAGE;
    };
    /** Добавить обработчик ошибок локализации. 
        При возникновении ошибок (не определён язык, не найден перевод) будет вызываться каждый из обработчиков
     @func addErrorHandler
     @memberOf nsGmx.Translations
     @param {function(text, lang)} Обработчик ошибки. В ф-цию передаётся текст и язык
    */


    TranslationsManager.prototype.addErrorHandler = function (handler) {
      this._errorHandlers.push(handler);
    };
    /** Считать из кук текущий язык локализации.
     * В куках отдельно записываются языки для каждого pathname, а не только для домена целиком
     @func getLanguageFromCookies
     @memberOf nsGmx.Translations
     @param {String} [pathname] Идентификатор проекта, для которого нужно запомнить куку. По умолчанию `window.location.pathname`.
     @return {String} Язык, записанный в куках для данного pathname
    */


    TranslationsManager.prototype.getLanguageFromCookies = function (pathname) {
      return _parseLanguageCookie()[pathname || window.location.pathname];
    };
    /** Записать в куки текущий язык локализации.
     * В куках отдельно записываются языки для каждого pathname, а не только для домена целиком
     @func updateLanguageCookies
     @memberOf nsGmx.Translations
     @param {String} lang Язык, который нужно записать в куку
     @param {String} [pathname] Идентификатор проекта, для которого нужно запомнить куку. По умолчанию `window.location.pathname`.
    */


    TranslationsManager.prototype.updateLanguageCookies = function (lang, pathname) {
      var langs = _parseLanguageCookie();

      langs[pathname || window.location.pathname] = lang;

      _saveLanguageCookie(langs);
    };
    /** Ф-ции для локализации пользовательского интерфейса
     @namespace nsGmx.Translations
    */


    var commonTranslationsManager = new TranslationsManager();
    TranslationsManager.commonManager = commonTranslationsManager; //хелпер для вставки локализованных констант в шаблоны. Например: {{i "layerEditor.dialogTitle"}}

    var addHanlebarsHelper = function addHanlebarsHelper(Handlebars) {
      Handlebars.registerHelper('i', function (dictKey) {
        return commonTranslationsManager.getText(dictKey);
      });
    };

    addHanlebarsHelper(Handlebars);
    nsGmx$1.Translations = commonTranslationsManager; //Поддерживаем обратную совместимость - глобальные объекты _gtxt, _translationsHash, translationsHash

    var prev_gtxt = window._gtxt,
        prev_translationsHash = window._translationsHash,
        prevTranslationsHash = window.translationsHash;
    /** Убирает из глобальной видимости все объекты и ф-ции, связанные с локализацией
     @name noConflicts
     @memberOf nsGmx.Translations
    */

    TranslationsManager.prototype.noConflicts = function () {
      window._gtxt = prev_gtxt;
      window._translationsHash = prev_translationsHash;
      window.translationsHash = prevTranslationsHash;
    }; //Явно добавляем объекты в глобальную видимость


    var DumpClass = function DumpClass() {};

    DumpClass.prototype = commonTranslationsManager;
    window._translationsHash = new DumpClass();
    _translationsHash.gettext = commonTranslationsManager.getText.bind(commonTranslationsManager), _translationsHash.addtext = commonTranslationsManager.addText.bind(commonTranslationsManager), _translationsHash.showLanguages = function () {
      var langCanvas = _div$1(null, [['dir', 'className', 'floatRight'], ['css', 'margin', ' 7px 10px 0px 0px']]);

      for (var lang in this.hash) {
        if (lang != window.language) {
          var button = makeLinkButton$1(_translationsHash.titles[lang]);
          button.style.marginLeft = '5px';
          button.style.fontSize = '11px';

          button.onclick = function (lang) {
            window.translationsHash.updateLanguageCookies(lang);

            if (nsGmx$1 && nsGmx$1.GeomixerFramework) {
              window.language = lang;

              _mapHelper.reloadMap();
            } else {
              window.location.reload();
            }
          }.bind(null, lang);

          _title$1(button, this.titles[lang]);

          langCanvas.appendChild(button);
        } else {
          langCanvas.appendChild(_span$1([_t$1(_translationsHash.titles[lang])], [['css', 'marginLeft', '5px'], ['css', 'color', '#fc830b']]));
        }
      }

      document.getElementById("headerLinks").appendChild(langCanvas);
    };

    window._gtxt = function () {
      return commonTranslationsManager.getText.apply(commonTranslationsManager, arguments);
    };

    window.translationsHash = {
      getLanguageFromCookies: commonTranslationsManager.getLanguageFromCookies.bind(commonTranslationsManager),
      updateLanguageCookies: commonTranslationsManager.updateLanguageCookies.bind(commonTranslationsManager)
    };
    gmxCore$1 && gmxCore$1.addModule('translations', {
      _translationsHash: window._translationsHash
    });
    var translationsHash = window.translationsHash;

    _translationsHash.flags["rus"] = "img/flag_ru.png";
    _translationsHash.titles["rus"] = "Русский";
    _translationsHash.hash["rus"] = {
      "Да": "Да",
      "Нет": "Нет",
      "Карта": "Карта",
      "Создать": "Создать",
      "Создать карту": "Создать карту",
      "Сохранить": "Сохранить",
      "Сохранить как": "Сохранить как",
      "Сохранить карту как": "Сохранить карту как",
      "Сохранить карту": "Сохранить карту",
      "Экспорт": "Экспорт",
      "Ссылки": "Ссылки",
      "Карта пожаров": "Карта пожаров",
      "Платформа Геомиксер": "Веб-ГИС GeoMixer",
      "http://fires.ru": "http://fires.ru",
      "https://search.kosmosnimki.ru": "https://search.kosmosnimki.ru",
      "Данные": "Данные",
      "Сервисы": "Сервисы",
      "Поделиться": "Поделиться",
      "Открыть слой": "Открыть слой",
      "Создать слой": "Создать слой",
      "Растровый": "Растровый",
      "Векторный": "Векторный",
      "Создать группу": "Создать группу",
      "Базовые слои": "Базовые слои",
      "Подключить WMS": "Подключить WMS",
      "Подключить WFS": "Подключить WFS",
      "Объекты": "Объекты",
      "Результаты поиска": "Результаты поиска",
      "Буфер": "Буфер",
      "Создание буферных зон": "Создание буферных зон",
      "Ручная привязка растров": "Ручная привязка растров",
      "Поиск слоев на карте": "Поиск слоев на карте",
      "Краудсорсинг данных": "Краудсорсинг данных",
      "Пакетный геокодинг": "Пакетный геокодинг",
      "Маршруты": "Маршруты",
      "Кадастр Росреестра": "Кадастр Росреестра",
      "Выбрать кадастровый объект": "Выбрать кадастровый объект",
      "Викимапиа": "Викимапиа",
      "Каталог СКАНЭКС": "Поиск снимков",
      "Космоснимки-пожары": "Космоснимки-пожары",
      "GIBS NASA": "Съёмка MODIS (NASA)",
      "Руководство пользователя": "Документация",
      "Руководство": "Руководство пользователя",
      "GeoMixer API": "GeoMixer API",
      "Использование плагинов": "Использование плагинов",
      "копия": "копия",
      "Открыть": "Открыть",
      "Слой": "Слой",
      "Создать векторный слой": "Создать векторный слой",
      "Создать растровый слой": "Создать растровый слой",
      "Создать мультислой": "Создать мультислой",
      "Вид": "Вид",
      "Дерево слоев": "Дерево слоев",
      "Объекты на карте": "Объекты на карте",
      "Координатная сетка": "Координатная сетка",
      "Индексная сетка": "Индексная сетка",
      "Панель оверлеев": "Панель оверлеев",
      "Загрузить объекты": "Загрузить объекты",
      "Загрузить фотографии": "Загрузить фотографии",
      "Загрузить данные": "Загрузить данные",
      "WFS сервер": "WFS сервер",
      "WMS сервер": "WMS сервер",
      "Кадастровые данные": "Кадастровые данные",
      "Ссылка на карту": "Ссылка на карту",
      "Код для вставки": "Код для вставки карты",
      "Печать": "Печать",
      "Привязать изображение": "Привязать изображение",
      "Сообщить об ошибке на карте": "Сообщить об ошибке на карте",
      "Справка": "Справка",
      "Использование": "Использование",
      "О проекте": "О проекте/Контакты",
      "$$phrase$$_1": "Укажите карту в параметре defaultMapID в файле config.js",
      "У вас нет прав на просмотр данной карты": "У вас нет прав на просмотр данной карты",
      "Access error": "У вас нет прав на просмотр данной карты",
      "Map not found": "Данная карта не существует",
      "Unable to locate EXIF content": "отсутствуют координаты в EXIF",
      "Развернуть карту": "Развернуть карту",
      "Свернуть карту": "Свернуть карту",
      "Точки на изображении:": "Точки на изображении:",
      "Точки на карте:": "Точки на карте:",
      "Координаты": "Координаты",
      "Нарисовать": "Нарисовать",
      "Восстановить": "Восстановить",
      "Видимость": "Видимость",
      "Привязка изображения": "Привязка изображения",
      "$$phrase$$_2": "Точка [value0] находится за пределами изображения",
      "$$phrase$$_3": "Не задана точка [value0] на карте",
      "Соответствие точек": "Соответствие точек",
      "$$phrase$$_4": "Точки 1 и 2 на изображении совпадают",
      "$$phrase$$_5": "Точки 1 и 3 на изображении совпадают",
      "$$phrase$$_6": "Точки 2 и 3 на изображении совпадают",
      "$$phrase$$_7": "Точки 1 и 2 на карте совпадают",
      "$$phrase$$_8": "Точки 1 и 3 на карте совпадают",
      "$$phrase$$_9": "Точки 2 и 3 на карте совпадают",
      "$$phrase$$_10": "Точки на изображении лежат на одной прямой",
      "Создать экскурсию": "Создать экскурсию",
      "Чтобы пользоваться этим сайтом, установите Flash Player": "Чтобы пользоваться этим сайтом, установите Flash Player",
      "из Интернет": "из Интернет",
      "или с локального диска ": "или с локального диска ",
      "для Internet Explorer": "для Internet Explorer",
      " или ": " или ",
      "для Internet Firefox": "для Internet Firefox",
      "Скачать shp-файл": "Скачать shp-файл",
      "shp-файл": "shp-файл",
      "gpx-файл": "gpx-файл",
      "Скачать фрагмент растра": "Скачать фрагмент растра",
      "точка": "точка",
      "линия": "линия",
      "прямоугольник": "прямоугольник",
      "многоугольник": "многоугольник",
      "Скачать": "Скачать",
      "Введите имя файла для скачивания": "Введите имя файла для скачивания",
      "Выберите область рамкой на карте": "Выберите область рамкой на карте",
      "Вырезать фрагмент растра": "Вырезать фрагмент растра",
      "К прямоугольнику не подходит ни одного растрового слоя": "К прямоугольнику не подходит ни одного растрового слоя",
      "Загруженный shp-файл пуст": "Загруженный shp-файл пуст",
      "Ошибка скачивания": "Ошибка скачивания",
      "Обновить": "Обновить",
      "Домашняя директория": "Директория проекта",
      "Имя папки": "Имя папки",
      "Имя": "Имя",
      "Размер": "Размер",
      "Дата": "Дата",
      "Дата создания": "Дата создания",
      "Снять выделение": "Снять выделение",
      "Скопировать": "Скопировать",
      "Удалить": "Удалить",
      "Извлечь": "Извлечь",
      "Упаковать": "Упаковать",
      "Загрузить": "Загрузить",
      "Параметр": "Параметр",
      "Значение": "Значение",
      "VALUE": "VALUE",
      "WHERE": "WHERE",
      "Операторы": "Операторы",
      "Функции": "Функции",
      "Метаданные": "Метаданные",
      "Редактировать колонки": "Редактировать колонки",
      "URL сервера": "URL сервера",
      "Формат изображения": "Формат изображения",
      "Введите имя gml-файла для скачивания:": "Введите имя gml-файла для скачивания:",
      "точки": "точки",
      "линии": "линии",
      "полигоны": "полигоны",
      "(ссылка)": "(ссылка)",
      "Сохранить состояние карты": "Сохранить состояние карты",
      "Ссылка на текущее состояние карты": "Ссылка на текущее состояние карты",
      "Добавить стиль": "Добавить стиль",
      "Атрибут >": "Атрибут >",
      "Значение >": "Значение >",
      "Операция >": "Операция >",
      "Накладываемое изображение": "Накладываемое изображение",
      "Цвет": "Цвет",
      "Прозрачность": "Прозрачность",
      "Авторизуйтесь для редактирования фильтров": "Авторизуйтесь для редактирования фильтров",
      "Имя фильтра": "Имя фильтра",
      "Переместить фильтр вверх": "Переместить фильтр вверх",
      "Переместить фильтр вниз": "Переместить фильтр вниз",
      "Удалить фильтр": "Удалить фильтр",
      "Размер шрифта": "Размер шрифта",
      "Смещение": "Смещение",
      "Смещение по x": "Смещение по x",
      "Смещение по y": "Смещение по y",
      "Имя атрибута": "Имя атрибута",
      "Граница обрезки": "Граница обрезки",
      "Граница": "Граница",
      "Толщина линии": "Толщина линии",
      "Заливка": "Заливка",
      "Заливка цветом": "Заливка цветом",
      "Заливка штриховкой": "Заливка штриховкой",
      "Заливка рисунком": "Заливка рисунком",
      "Ширина паттерна": "Ширина паттерна",
      "Ширина отступа": "Ширина отступа",
      "URL рисунка": "URL рисунка",
      "Маркер URL": "Маркер URL",
      "URL изображения": "URL изображения",
      "Изображение": "Изображение",
      "Размер точек": "Размер точек",
      "Редактировать стили": "Редактировать стили",
      "Авторизуйтесь для редактирования настроек слоя": "Авторизуйтесь для редактирования настроек слоя",
      "Недостаточно прав для редактирования настроек слоя": "Недостаточно прав для редактирования настроек слоя",
      "Недостаточно прав для редактирования объектов слоя": "Недостаточно прав для редактирования объектов слоя",
      "ID": "ID",
      "Описание": "Описание",
      "Файл": "Файл",
      "Таблица": "Таблица",
      "Каталог с тайлами": "Каталог с тайлами",
      "Каталог растров": "Каталог растров",
      "Источник": "Источник",
      "Данные с датой": "Разбить по датам",
      "Дополнительно": "Дополнительно",
      "Шаблон названий объектов": "Шаблон названий объектов",
      "Y (широта)": "Y (широта)",
      "X (долгота)": "X (долгота)",
      "Каталог": "Каталог",
      "Изменить": "Изменить",
      "Вид вложенных элементов": "Вид вложенных элементов",
      "Использовать KosmosnimkiAPI": "Загрузить подложки Kosmosnimki",
      "Использовать OpenStreetMap": "Использовать OpenStreetMap",
      "Язык по умолчанию": "Язык по умолчанию",
      "Единицы длины": "Единицы длины",
      "Единицы площади": "Единицы площади",
      "Формат координат": "Формат координат",
      "units.auto": "авто",
      "units.m": "м",
      "units.km": "км",
      "units.nm": "м. мили",
      "units.m2": "м<sup>2",
      "units.ha": "га",
      "units.km2": "км<sup>2",
      "coords.dd": "dd.dddd",
      "coords.dms": "dd°mm′ss″",
      "Генерализация": "Генерализация",
      "gereralization.on": "включить",
      "gereralization.off": "выключить",
      "gereralization.disable": "использовать настройки слоев",
      "Количество информационных окошек": "Количество информационных окошек",
      "layerOrder.title": "Порядок слоёв",
      "layerOrder.native": "Стандартный",
      "layerOrder.vectorOnTop": "Вектора сверху",
      "Разрешить поиск в векторных слоях": "Разрешить поиск в векторных слоях",
      "Начальная позиция": "Начальная позиция",
      "Широта": "Широта",
      "Долгота": "Долгота",
      "placeholder degrees": "dd.dddd",
      "placeholder zoom": "1-21",
      "placeholder minZoom": "1",
      "placeholder maxZoom": "21",
      "Зум": "Зум",
      "Ссылка (permalink)": "Ссылка (permalink)",
      "Разрешить скачивание": "Разрешить скачивание",
      "Векторных слоев": "Векторных слоев",
      "Растровых слоев": "Растровых слоев",
      "Масштабирование в миникарте": "Масштабирование в миникарте",
      "Показывать всплывающие подсказки": "Показывать всплывающие подсказки",
      "Свойства": "Свойства",
      "Создать копию слоя": "Создать копию слоя",
      "Стили": "Стили",
      "Изображение на карте": "Изображение на карте",
      "Слой [value0]": "Слой [value0]",
      "Стили слоя [value0]": "Стили слоя [value0]",
      "Мультислой [value0]": "Мультислой [value0]",
      "Группа [value0]": "Группа [value0]",
      "Карта [value0]": "Карта [value0]",
      "Редактировать стиль": "Редактировать стиль",
      "Редактирование стилей объекта": "Редактирование стилей объекта",
      "Стили слоя": "Стили слоя",
      "Навигация по карте и инструменты": "Навигация по карте и инструменты",
      "Стиль векторного слоя": "Стиль векторного слоя",
      "Управление содержанием карты": "Управление содержанием карты",
      "Пользовательские инструменты": "Пользовательские инструменты",
      "$$help$$_1": "Держите нажатой левую клавишу мыши – перетаскивайте карту курсором. Для приближения и удаления используйте колесико мыши (карта зуммируется к точке под курсором). Для перецентровки по координатам – введите их в строке поиска.",
      "$$help$$_2": "В левой панели отображается список слоев в виде дерева. Для перецентровки карты по экстенту слоя – кликните по его названию в списке. Если данная опция включена администратором карты, вы можете скачивать векторные слои и вырезать и скачивать фрагменты растровых слоев.",
      "$$help$$_3": "Для редактирования стиля векторного слоя кликните на иконку перед названием слоя.",
      "$$help$$_4": "Карта представляет собой набор слоев, отображение которого задается с помощью списка слоев. Чтобы иметь возможность редактировать набор слоев (создавать группы, изменять порядок отображения и т.д.) и сохранять изменения – необходимо авторизоваться. Более подробно см ",
      " - Руководство пользователя": " - Руководство пользователя",
      "$$help$$_5": "Пользовательские инструменты одновременно служат для создания объектов на карте, которые затем можно сохранять через «ссылку на карту», и для выполнения простых аналитических функций. ",
      "В режиме маркеров: ": "В режиме маркеров: ",
      "$$help$$_6": "одиночный клик - добавить маркер. Двойной клик по маркеру - удалить. Клик на маркер – открыть всплывающее окошко (балун), клик по балуну – добавить надпись.",
      "В режиме линейка/измерения расстояния, полигон/измерение площади: ": "В режиме линейка/измерения расстояния, полигон/измерение площади: ",
      "$$help$$_7": "одиночный клик - добавить вершину. Двойной клик - завершить фигуру. Клик на линию - добавить вершину. Двойной клик по вершине - удалить.",
      "$$help$$_8": "Кликните по объекту в списке «объектов на карте», чтобы перецентровать карту на него. Вы можете скачать контуры объектов в shp/tab/kml формате.",
      "$$about$$_1": "это веб-приложение для интерактивного просмотра геоданных и доступа к источникам базовых геоданных в интернете, таким как: ",
      "$$about$$_2": "С помощью GeoMixer можно публиковать собственные геоданные во внутренней сети предприятий или в интернет, накладывать их поверх базовых источников и предоставлять к ним доступ для совместной работы сколь угодно большому числу пользователей, разграничивая права доступа.",
      "$$about$$_3": "GeoMixer также включает компонент API, который позволяет встраивать созданные проекты в сторонние веб-сайты и приложения и программно управлять фукционалом интерактивной карты.",
      " - Общее описание": " - Общее описание",
      " - Руководство разработчика": " - Руководство разработчика",
      "Получить API-ключ": "Получить API-ключ",
      "Введите API-ключ": "Введите API-ключ",
      "Печать карты": "Печать карты",
      "$$serviceHelp$$_1": "Позволяет на лету загрузить shp/tab/kml файл небольшого размера в виде пользовательских объектов. После загрузки пользователь может редактировать геометрию объектов и скачивать объекты в том же наборе форматов.",
      "$$serviceHelp$$_2": "По ссылке запоминается текущее положение карты, а так же пользовательские объекты и надписи.",
      "$$serviceHelp$$_3": "Отправляет на печать текущий фрагмент карты.",
      "Редактировать": "Редактировать",
      "Удалить объект?": "Удалить объект?",
      "Удалить отмеченные объекты?": "Удалить отмеченные объекты?",
      "Длина": "Длина",
      "Площадь": "Площадь",
      "Добавить подгруппу": "Добавить группу",
      "Введите имя группы": "Создание новой группы",
      "Имя группы": "Имя группы",
      "Включая вложенные слои": "Включая вложенные слои",
      "Удаление группы [value0]": "Удаление группы [value0]",
      "Сохранено": "Сохранено",
      "Прозрачность выбранного слоя/группы/карты": "Прозрачность выбранного слоя/группы/карты",
      "$$updateInfo$$_1": "Для отображения нового слоя необходимо сохранить и перезагрузить карту",
      "Любой": "Любой",
      "Владелец": "Владелец",
      "Последнее изменение": "Последнее изменение",
      "Список слоев": "Список слоев",
      "Вы действительно хотите удалить этот слой?": "Вы действительно хотите удалить этот слой?",
      "Ошибка!": "Ошибка!",
      "Ошибка": "Ошибка",
      "Выберите колонку": "Выберите колонку",
      "Список карт": "Список карт",
      "Показать": "Показать",
      "загрузка...": "загрузка...",
      "удаление...": "удаление...",
      "Вы действительно хотите удалить эту карту?": "Вы действительно хотите удалить эту карту?",
      "maplist.hint": "Группы и слои можно перетащить в текущую карту",
      "Слоя нет в базе": "Слоя нет в базе",
      "ScanEx Web Geomixer - просмотр карты": "ScanEx Web Geomixer - просмотр карты",
      "Изменить параметры поиска": "Изменить параметры поиска",
      "$$search$$_1": "Поиск по векторным слоям и адресной базе",
      "$$search$$_2": "Поиск по адресной базе",
      "Поиск не дал результатов": "Поиск не дал результатов",
      "Очистить": "Очистить",
      "Регистрация": "Регистрация",
      "Восстановление пароля": "Восстановление пароля",
      "Вход": "Вход",
      "Выход": "Выход",
      "Логин": "Логин",
      "Пароль": "Пароль",
      "пароль": "пароль",
      "Псевдоним": "Псевдоним",
      "Полное имя": "Полное имя",
      "Пожалуйста, авторизуйтесь": "Пожалуйста, авторизуйтесь",
      "адрес электронной почты": "адрес электронной почты",
      "Ошибка сервера": "Ошибка сервера",
      "Папка": "Папка",
      " и ": " и ",
      "Название": "Название",
      "Рейтинг": "Рейтинг",
      "Автор": "Автор",
      "Тематика": "Тематика",
      "Развлекательная": "Развлекательная",
      "Спортивная": "Спортивная",
      "Историческая": "Историческая",
      "Экологическая": "Экологическая",
      "Любая": "Любая",
      "Создать новую тему": "Создать новую тему",
      "Начало периода": "Начало периода",
      "Окончание периода": "Окончание периода",
      "Накладываемые тайлы": "Накладываемые тайлы",
      "Отображать с зума": "Отображать с зума",
      "По": "по",
      "Фильтр": "Фильтр",
      "Подпись": "Подпись",
      "Балун": "Подсказка при наведении и клике",
      "По умолчанию": "По умолчанию",
      "Показывать при клике": "Показывать при клике",
      "Показывать при наведении": "Показывать при наведении",
      "Символика": "Символика",
      "Библиотека стилей": "Библиотека стилей",
      "Настройка стилей": "Настройка стилей",
      "скопировать": "скопировать",
      "применить везде": "применить везде",
      "Применить": "Применить",
      "Кластеризация": "Кластеризация",
      "Минимальный": "Минимальный",
      "Максимальный": "Максимальный",
      "Мин. зум": "Мин. зум",
      "Макс. зум": "Макс. зум",
      "Тип": "Тип",
      "Пешеходная": "Пешеходная",
      "Велосипедная": "Велосипедная",
      "Автомобильная": "Автомобильная",
      "Речная": "Речная",
      "Места": "Места",
      "Маршрут": "Маршрут",
      "Редактировать экскурсию": "Редактировать экскурсию",
      "Добавьте маршрут": "Добавьте маршрут",
      "Выберете темы на пути следования": "Выберете темы на пути следования",
      "$$phrase$$_11": "Добавьте маршрут при помощи инструмента \"Линия\" на панели инструментов",
      "$$phrase$$_12": "Нет подходящих объектов на карте",
      "Выбор маршрута": "Выбор маршрута",
      "Выбор мест": "Выбор мест",
      "$$phrase$$_13": "У вас нет опубликованных тем на карте. Вы можете добавить тему в разделе Вид-Обсуждения",
      "Обсуждения": "Обсуждения",
      "Экскурсии": "Экскурсии",
      "$$phrase$$_14": "Невозможно удалить карту, использующуюся в качестве карты по умолчанию",
      "$$phrase$$_15": "Невозможно удалить загруженную карту",
      "Назад": "Назад",
      "Вперед": "Вперед",
      "$$phrase$$_16": "Альбома с указанным ID изображения не существует",
      "Редактировать альбом": "Редактировать альбом",
      "Оценить": "Оценить",
      "Поставьте маркер": "Поставьте маркер",
      "на карту и переместите его в нужное место.": "на карту и переместите его в нужное место.",
      "Недостаточно прав для совершения операции": "Недостаточно прав для совершения операции",
      "Новая папка": "Новая папка",
      "Выбрать": "Выбрать",
      "Добавить": "Добавить",
      "$$serviceHelp$$_4": "Пользователь может встроить созданную карту в другой сайт, скопировав код и вставив его внутрь HTML. Требуется указать api-ключ для сайта, на котором будет использоваться данный код.",
      "Масштаб": "Масштаб",
      "Угол поворота": "Угол поворота",
      "Диаграммы": "Диаграммы",
      "График по времени": "График по времени",
      "Маска атрибутов": "Маска атрибутов",
      "Закладки": "Закладки",
      "Добавить закладку": "Добавить закладку",
      "Имя закладки": "Имя закладки",
      "Дерево": "Дерево",
      "Поиск слоев": "Поиск слоев",
      "Пример выражения": "[Атрибут1]\n[Атрибут2]\nпроизвольный текст",
      "Шкала прозрачности": "Шкала прозрачности",
      "Цвет заливки": "Цвет заливки",
      "Цвет обводки": "Цвет обводки",
      "Цвет шрифта": "Цвет шрифта",
      "Легенда": "Легенда",
      "Событие загрузки карты": "Событие загрузки карты",
      "Мин": "Мин",
      "Макс": "Макс",
      "График": "График",
      "Гистограмма": "Гистограмма",
      "Столбчатая": "Столбчатая",
      "Временная": "Временная",
      "Круговая": "Круговая",
      "Копировать стиль": "Копировать стиль",
      "Применить стиль": "Применить стиль",
      "Не выбран стиль": "Не выбран стиль",
      "Невозможно применить стиль к другому типу геометрии": "Невозможно применить стиль к другому типу геометрии",
      "Общие": "Общие",
      "Доступ": "Доступ",
      "Окно карты": "Окно карты",
      "Загрузка": "Загрузка",
      "Копирайт": "Копирайт",
      "Инструменты": "Инструменты",
      "Загрузить KML": "Загрузить KML",
      "URL файла": "URL файла",
      "Поиск": "Поиск",
      "Подложки": "Подложки",
      "Доступные подложки": "Доступные подложки",
      "Подложки карты": "Подложки карты",
      "Выберите слои для поиска по атрибутам": "Выберите слои для поиска по атрибутам",
      "Включить синхронизацию слоев": "Включить синхронизацию слоев",
      "Выключить синхронизацию слоев": "Выключить синхронизацию слоев",
      "Редактирование прав доступа карты [value0]": "Редактирование прав доступа карты [value0]",
      "Редактирование прав доступа слоя [value0]": "Редактирование прав доступа слоя [value0]",
      "Редактирование прав доступа слоев карты [value0]": "Редактирование прав доступа слоев карты [value0]",
      "Состав группы [value0]": "Состав группы [value0]",
      "Роль": "Роль",
      "Добавить пользователя": "Добавить пользователя",
      "Права доступа": "Права доступа",
      "Права доступа к слоям": "Права доступа к слоям",
      "Пользователи без прав доступа:": "Пользователи без прав доступа:",
      "Пользователи с правами доступа:": "Пользователи с правами доступа:",
      "Выберите нового владельца": "Выберите нового владельца",
      "Сменить владельца": "Сменить владельца",
      "Объекты RuMap": "Данные RuMap",
      "Объекты пользователей": "Данные пользователей",
      "Контакты": "Контакты",
      "Фотографии": "Фотографии",
      "Момент съемки": "Момент съемки",
      "Видео": "Видео",
      "Сообщения": "Сообщения",
      "Ссылка на место": "Ссылка на место",
      "Ссылка на экскурсию": "Ссылка на экскурсию",
      "Ссылка на событие": "Ссылка на событие",
      "Создать новое событие": "Создать новое событие",
      "События": "События",
      "Календарь": "Календарь",
      "Новости": "Новости",
      "Мероприятия": "Мероприятия",
      "Отмена": "Отмена",
      "Пропустить": "Пропустить",
      "Время": "Время",
      "Альбом OpenPhotoVR": "Фотоальбом",
      "Встраиваемый код": "Встраиваемое видео",
      "Объекты экологического риска": "Объекты экологического риска",
      "Санкционированные свалки": "Санкционированные свалки",
      "Несанкционированные свалки": "Несанкционированные свалки",
      "Полигоны отходов": "Полигоны отходов",
      "Предприятия переработки отходов": "Предприятия переработки отходов",
      "Факельные установки, ТЭЦ, трубы": "Факельные установки, ТЭЦ, трубы",
      "Закрытые свалки": "Закрытые свалки",
      "Пункты приема отходов": "Пункты приема отходов",
      "Оползни": "Оползни",
      "Карстовые явления": "Карстовые явления",
      "Суффозионные явления": "Суффозионные явления",
      "Государство и общество": "Государство и общество",
      "Радио": "Радиостанции",
      "Правительственные учреждения": "Правительственные учреждения",
      "Оптики": "Оптики",
      "Охранные агенства": "Охранные агенства",
      "Травмпункты": "Травмпункты",
      "Таможня": "Таможня",
      "Ветеринарные клиники": "Ветеринарные клиники",
      "ЗАГС": "ЗАГС",
      "Больницы": "Больницы",
      "Аптеки": "Аптеки",
      "Поликлиники": "Поликлиники",
      "Колледжи": "Колледжи",
      "Университеты": "Университеты",
      "ОВИР": "ОВИР",
      "Посольства": "Посольства",
      "Почтовые отделения": "Почтовые отделения",
      "Суды": "Суды",
      "Банки": "Банки",
      "Родильные дома": "Родильные дома",
      "Дома престарелых": "Дома престарелых",
      "Детские сады": "Детские сады",
      "Школы": "Школы",
      "Инспекции": "Инспекции",
      "Адвокаты": "Адвокаты",
      "МЧС": "МЧС",
      "Муниципальные учреждения": "Муниципальные учреждения",
      "Администрация": "Администрация",
      "Культура и отдых": "Культура и отдых",
      "Боулинг": "Боулинг",
      "Аквапарки": "Аквапарки",
      "Парки развлечений": "Парки развлечений",
      "Библиотеки": "Библиотеки",
      "Памятники": "Памятники",
      "Лагери отдыха": "Лагери отдыха",
      "Кинотеатры": "Кинотеатры",
      "Цирки": "Цирки",
      "Галереи": "Галереи",
      "Отели": "Отели",
      "Мотели": "Мотели",
      "Музеи": "Музеи",
      "Концертные залы": "Концертные залы",
      "Ночные клубы": "Ночные клубы",
      "Театры": "Театры",
      "Санатории": "Санатории",
      "Зоопарки": "Зоопарки",
      "Общественное питание": "Общественное питание",
      "Кафе": "Кафе",
      "Фастфуды": "Фастфуды",
      "Рестораны": "Рестораны",
      "Кафе-мороженое": "Кафе-мороженое",
      "Столовые": "Столовые",
      "Природные достопримечательности": "Природные достопримечательности",
      "Ботанический сад": "Ботанические сады",
      "Пещеры": "Пещеры",
      "Водопады": "Водопады",
      "Парки": "Парки",
      "Источники": "Источники",
      "Заповедники": "Заповедники",
      "Прочие архитектурные и природные достопримечательности": "Архитектурные достопримечательности",
      "Религия": "Религия",
      "Культовые сооружения": "Культовые сооружения",
      "Мечети": "Мечети",
      "Монастыри": "Монастыри",
      "Церкви других христианских конфессий": "Церкви других христианских конфессий",
      "Православные церкви": "Православные церкви",
      "Синагоги": "Синагоги",
      "Спорт": "Спорт",
      "Стадионы": "Стадионы",
      "Теннисные корты": "Теннисные корты",
      "Катки": "Катки",
      "Ипподромы": "Ипподромы",
      "Фитнес": "Фитнес",
      "Бассейны": "Бассейны",
      "Прокат спортинвентаря": "Прокат спортинвентаря",
      "Торговля и услуги": "Торговля и услуги",
      "Солярии": "Солярии",
      "Интернет-кафе": "Интернет-кафе",
      "Рынки": "Рынки",
      "Стоматологические клиники": "Стоматологические клиники",
      "Магазины одежды": "Магазины одежды",
      "Парикмахерские": "Парикмахерские",
      "Бани": "Бани",
      "Магазины обуви": "Магазины обуви",
      "Магазины": "Магазины",
      "Ателье": "Ателье",
      "Такси": "Такси",
      "Туризм": "Туризм",
      "Транспорт и услуги": "Транспорт и услуги",
      "Аэропорты": "Аэропорты",
      "Автосервисы": "Автосервисы",
      "Автовокзалы": "Автовокзалы",
      "ДПС": "ДПС",
      "ГИБДД": "ГИБДД",
      "Шиномонтаж": "Шиномонтаж",
      "Парковки бесплатные": "Парковки бесплатные",
      "Парковки платные": "Парковки платные",
      "АЗС": "АЗС",
      "Автомойки": "Автомойки",
      "Экстренные службы": "Экстренные службы",
      "Пожарные/спасатели": "Пожарные/спасатели",
      "Милиция": "Милиция",
      "Скорая помощь": "Скорая помощь",
      "Другие темы": "Другие темы",
      "Разное": "Разное",
      "Изменение пароля": "Изменение пароля",
      "Новый пароль": "Новый пароль",
      "Старый пароль": "Старый пароль",
      "Подтвердите пароль": "Подтвердите пароль",
      "Контур": "Контур",
      "$$phrase$$_17": "Добавьте контур при помощи инструмента \"Полигон\" на панели инструментов",
      "Выбор контура": "Выбор контура",
      "Таблица атрибутов слоя [value0]": "Таблица атрибутов слоя [value0]",
      "Показать параметры поиска": "Показать параметры поиска",
      "Скрыть параметры поиска": "Скрыть параметры поиска",
      "Скрыть": "Скрыть",
      "SQL-условие WHERE": "SQL-условие WHERE",
      "Искать внутри полигона": "Искать внутри полигона",
      "Искать по пересечению с объектом": "Искать по пересечению с объектом",
      "Колонки": "Колонки",
      "Показывать колонки": "Показывать колонки",
      "Скрыть колонки": "Скрыть колонки",
      "Найти": "Найти",
      "Нет полей": "Нет полей",
      "Нет данных": "Нет данных",
      "Таблица атрибутов": "Таблица атрибутов",
      "Разрешить поиск": "Разрешить поиск",
      "Произвольный": "Произвольный",
      "День": "День",
      "Неделя": "Неделя",
      "Месяц": "Месяц",
      "Год": "Год",
      "Ежегодно": "Ежегодно",
      "Облачность": "Облачность",
      "Период": "Период",
      "Спутниковые покрытия": "Спутниковые покрытия",
      "Редактировать объект слоя [value0]": "Редактировать объект слоя [value0]",
      "Создать объект слоя [value0]": "Создать объект слоя [value0]",
      "Геометрия": "Геометрия",
      "Найти объекты": "Найти объекты",
      "Добавить объекты": "Добавить объекты",
      "Обновить объекты": "Обновить объекты",
      "Копировать объекты": "Копировать объекты",
      "Объекты скопированы": "Объекты скопированы",
      "Объекты добавлены": "Объекты добавлены",
      "Вставить объекты": "Вставить объекты",
      "Вставить объекты не удалось": "Вставить объекты не удалось",
      "Выберите правым кликом слой в левой панели и нажмите \"Вставить объекты\"": "Выберите правым кликом слой в левой панели и нажмите \"Вставить объекты\"",
      "Изменить колонки": "Изменить колонки",
      "Обновить колонку": "Обновить колонку",
      "Очистить поиск": "Очистить поиск",
      "Скачать shp": "Скачать shp",
      "Скачать gpx": "Скачать gpx",
      "Скачать csv": "Скачать csv",
      "Скачать geojson": "Скачать geojson",
      "Рассчитать площадь": "Суммарная площадь",
      "Создать столбец": "Создать столбец",
      "Мультислой": "Мультислой",
      "В дереве слоев остались несохраненные изменения!": "В дереве слоев остались несохраненные изменения!",
      "файл версии отсутствует": "файл версии отсутствует",
      "оверлеи отсутствуют": "оверлеи отсутствуют",
      "Хост": "Хост",
      "Дополнительные карты": "Дополнительные карты",
      "Добавить карту": "Добавить карту",
      "Добавить в таймлайн": "Добавить в таймлайн",
      "Удалить из таймлайна": "Удалить из таймлайна",
      "Невозможно загрузить карту [value0] с домена [value1]": "Невозможно загрузить карту [value0] с домена [value1]",
      "Показывать": "Показывать",
      "Поиск снимков": "Поиск снимков",
      "Принудительно обновить тайлы": "Принудительно обновить тайлы",
      "Обводка": "Обводка",
      "Карта имеет более новую версию. Сохранить?": "Карта имеет более новую версию. Сохранить?",
      "Кодировка": "Кодировка",
      "helpPostfix": "_rus.html",
      "Показывать чекбокс видимости": "Чекбокс видимости",
      "Разворачивать автоматически": "Разворачивать автоматически",
      "Другая": "Другая",
      "Временнóй слой": "Мультивременнóй слой",
      "Колонка даты": "Колонка даты",
      "Минимальный период": "Мин. период (дни)",
      "Максимальный период": "Макс. период (дни)",
      "Отсутствует временной атрибут": "Отсутствует атрибут типа 'Дата'",
      "Период 1 день": "Период 1 день",
      "Показывать на карте данные за": "Показывать на карте данные за",
      "1 день": "1 день",
      "произвольный период": "произвольный период",
      "По границе экрана": "По границе экрана",
      "По центру экрана": "По центру экрана",
      "Пересечение": "Пересечение",
      "Пролистывать слои": "Пролистывать слои",
      "Следующий слой": "Следующий слой",
      "Предыдущий слой": "Предыдущий слой",
      "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.": "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.",
      "WMS доступ": "WMS/WFS доступ",
      "ссылка": "ссылка",
      "Слой '[value0]' уже есть в карте": "Слой '[value0]' уже есть в карте",
      "Группа '[value0]' уже есть в карте": "Группа '[value0]' уже есть в карте",
      "Плагины": "Плагины",
      "Вручную": "Вручную",
      "Добавить атрибут": "Добавить поле",
      "Проекция": "Проекция",
      "Широта/Долгота (EPSG:4326)": "Широта/Долгота (EPSG:4326)",
      "Меркатор (EPSG:3395)": "Меркатор (EPSG:3395)",
      "Из файла": "Из файла",
      "Мультиполигон": "Мультиполигон",
      "Мультилиния": "Мультилиния",
      "Мультиточка": "Мультиточка",
      "Администрирование": "Администрирование",
      "Системные настройки": "Системные настройки",
      "Управление группами": "Управление группами",
      "Управление группами пользователей": "Управление группами пользователей",
      "Добавить снимки": "Добавить растры",
      "Существующие слои": "Существующие слои",
      "Слои из карты": "Слои из карты",
      "Слои из КР": "Слои из КР",
      "Новый слой": "Новый слой",
      "С экрана": "С экрана",
      "Добавлен растр": "Добавлен растр",
      "Добавлены растры": "Добавлены растры",
      "Выбранный объект не имеет растра": "Выбранный объект не имеет растра",
      "Этот растр уже был выбран": "Этот растр уже был выбран",
      "Каталог Растров": "Каталог растров",
      "Растр": "Растр",
      "Добавить выбранные растры": "Добавить выбранные растры",
      "EditObject.menuTitle": "Добавить объект",
      "FileBrowser.ExceedLimitMessage": "Размер файла превышает 500 Мб. Используйте GeoMixerFileBrowser для загрузки больших файлов.",
      "FileBrowser.DropInfo": "Перетащите файлы сюда",
      "EditObject.drawingMenuTitle": "Добавить объект в активный слой",
      "Поставить маркер": "Поставить маркер",
      "Центрировать": "Центрировать",
      "Пароль изменён": "Пароль изменён",
      "портретная": "портретная",
      "альбомная": "альбомная",
      "gmx_geometry": "gmx_geometry"
    };

    _translationsHash.flags["eng"] = "img/flag_en.png";
    _translationsHash.titles["eng"] = "English";
    _translationsHash.hash["eng"] = {
      "Да": "Yes",
      "Нет": "No",
      "Карта": "Map",
      "Создать": "Create",
      "Создать карту": "Create map",
      "Сохранить": "Save",
      "Сохранить как": "Save as",
      "Сохранить карту как": "Save map as",
      "Сохранить карту": "Save map",
      "Экспорт": "Export",
      "Ссылки": "Links",
      "Карта пожаров": "Fires map",
      "Поиск снимков": "Search Imagery",
      "Платформа Геомиксер": "GeoMixer Web-GIS",
      "http://fires.ru": "http://fires-map.com",
      "https://search.kosmosnimki.ru": "https://search.kosmosnimki.ru/index_eng.html",
      "Данные": "Datasets",
      "Сервисы": "Services",
      "Поделиться": "Share",
      "Открыть слой": "Open layer",
      "Создать слой": "Create layer",
      "Растровый": "Raster",
      "Векторный": "Vector",
      "Создать группу": "Create group",
      "Базовые слои": "Base layers",
      "Подключить WMS": "Add WMS",
      "Подключить WFS": "Add WFS",
      "Объекты": "User objects",
      "Результаты поиска": "Search results",
      "Буфер": "Buffer",
      "Создание буферных зон": "Buffer zones",
      "Ручная привязка растров": "Manual rasters shift",
      "Поиск слоев на карте": "Search layers on map",
      "Краудсорсинг данных": "Crowdsourcing",
      "Пакетный геокодинг": "Batch geocode",
      "Маршруты": "Directions",
      "Кадастр Росреестра": "Cadastre data of Rosreestr",
      "Выбрать кадастровый объект": "Select Cadastre item",
      "Викимапиа": "Wikimapia",
      "Каталог СКАНЭКС": "Search imagery",
      "Космоснимки-пожары": "Kosmosnimki-fires",
      "GIBS NASA": "MODIS Images (NASA)",
      "Руководство пользователя": "Documentation",
      "Руководство": "User guide",
      "GeoMixer API": "GeoMixer API",
      "Использование плагинов": "Plugins usage",
      "копия": "копия",
      "Открыть": "Open",
      "Слой": "Layer",
      "Создать векторный слой": "Create vector layer",
      "Создать растровый слой": "Create raster layer",
      "Создать мультислой": "Create multilayer",
      "Вид": "View",
      "Дерево слоев": "Layers tree",
      "Объекты на карте": "Objects on map",
      "Координатная сетка": "Coordinate grid",
      "Индексная сетка": "Index grid",
      "Панель оверлеев": "Overlays panel",
      "Загрузить объекты": "Upload objects",
      "Загрузить фотографии": "Upload photos",
      "Загрузить данные": "Load data",
      "WFS сервер": "WFS server",
      "WMS сервер": "WMS server",
      "Кадастровые данные": "Cadastre data",
      "Ссылка на карту": "Link to the map",
      "Код для вставки": "Embed code",
      "Печать": "Print",
      "Привязать изображение": "Bind image",
      "Сообщить об ошибке на карте": "Report a map error",
      "Справка": "Help",
      "Использование": "Usage",
      "О проекте": "About/Contacts",
      "$$phrase$$_1": "Choose parameter defaultMapID in config.js file",
      "У вас нет прав на просмотр данной карты": "Sorry, you don’t have permission to view this map",
      "Access error": "Sorry, you don’t have permission to view this map",
      "Map not found": "Sorry, this map not found",
      "Unable to locate EXIF content": "Unable to locate EXIF content",
      "Развернуть карту": "Unfold map",
      "Свернуть карту": "Fold map",
      "Точки на изображении:": "Points on image:",
      "Точки на карте:": "Points on map:",
      "Координаты": "Coordinates",
      "Нарисовать": "Draw",
      "Восстановить": "Restore",
      "Прозрачность": "Transparency",
      "Видимость": "Visibility",
      "Привязка изображения": "Image binding",
      "$$phrase$$_2": "Point [value0] is outside the limits of image",
      "$$phrase$$_3": "Point [value0] is not specified on a map",
      "Соответствие точек": "Point correspondence",
      "$$phrase$$_4": "Points 1 and 2 coincide at the image",
      "$$phrase$$_5": "Points 1 and 3 coincide at the image",
      "$$phrase$$_6": "Points 2 and 3 coincide at the image",
      "$$phrase$$_7": "Points 1 and 2 coincide at the map",
      "$$phrase$$_8": "Points 1 and 3 coincide at the map ",
      "$$phrase$$_9": "Points 2 and 3 coincide at the map ",
      "$$phrase$$_10": "Points lie on a straight line at the image ",
      "Создать экскурсию": "Create guide",
      "Чтобы пользоваться этим сайтом, установите Flash Player": "To use this web site, please, install Flash Player",
      "из Интернет": "from Internet",
      "или с локального диска ": "or from local disc",
      "для Internet Explorer": "for Internet Explorer",
      " или ": " or ",
      "для Firefox": "for Firefox",
      "Скачать shp-файл": "Download shp-file",
      "shp-файл": "shp-file",
      "gpx-файл": "gpx-file",
      "Скачать фрагмент растра": "Download fragment of raster",
      "Очистить": "Delete",
      "точка": "point",
      "линия": "line",
      "прямоугольник": "rectangle",
      "многоугольник": "polygon",
      "Скачать": "Download",
      "Введите имя файла для скачивания": "Enter file name to download",
      "Выберите область рамкой на карте": "Select region using frame",
      "Вырезать фрагмент растра": "Cut fragment of raster",
      "К прямоугольнику не подходит ни одного растрового слоя": "No one raster layer fit the rectangle",
      "Загруженный shp-файл пуст": "The uploaded shp-file is empty",
      "Ошибка скачивания": "Download error",
      "Обновить": "Update",
      "Домашняя директория": "Project directory",
      "Имя папки": "Folder name",
      "Имя": "Name",
      "Тип": "Type",
      "Размер": "Size",
      "Дата": "Date",
      "Дата создания": "Дата создания",
      "Снять выделение": "Clear selection",
      "Скопировать": "Copy",
      "Удалить": "Delete",
      "Извлечь": "Extract",
      "Упаковать": "Add to archive",
      "Загрузить": "Download",
      "Параметр": "Parameter",
      "Значение": "Value",
      "VALUE": "VALUE",
      "WHERE": "WHERE",
      "Колонки": "Columns",
      "Операторы": "Operators",
      "Функции": "Functions",
      "Метаданные": "Metadata",
      "Редактировать колонки": "Edit columns",
      "URL сервера": "Server URL",
      "Формат изображения": "Image format",
      "Введите имя gml-файла для скачивания:": "Enter gml-file name to download:",
      "точки": "points",
      "линии": "lines",
      "полигоны": "polygons",
      "(ссылка)": "(link)",
      "Сохранить состояние карты": "Save map state",
      "Ссылка на текущее состояние карты": "Link to the map",
      "Добавить стиль": "Add style",
      "Атрибут >": "Attribute >",
      "Значение >": "Value >",
      "Операция >": "Operation >",
      "Накладываемое изображение": "Ground overlay",
      "Цвет": "Color",
      "Авторизуйтесь для редактирования фильтров": "Authorize to edit filters",
      "Имя фильтра": "Filter name",
      "Переместить фильтр вверх": "Move filter up",
      "Переместить фильтр вниз": "Move filter down",
      "Удалить фильтр": "Delete filter",
      "Размер шрифта": "Typesize",
      "Смещение": "Shift",
      "Смещение по x": "X shift",
      "Смещение по y": "Y shift",
      "Имя атрибута": "Attribute name",
      "Граница обрезки": "Clip region",
      "Граница": "Outline",
      "Толщина линии": "Line thickness",
      "Заливка": "Fill",
      "Заливка цветом": "Color fill",
      "Заливка штриховкой": "Pattern fill",
      "Заливка рисунком": "Image fill",
      "Ширина паттерна": "Pattern width",
      "Ширина отступа": "Indent width",
      "URL рисунка": "Image URL",
      "Маркер URL": "Icon URL ",
      "URL изображения": "Image URL",
      "Изображение": "Image",
      "Размер точек": "Point size",
      "Редактировать стили": "Edit styles",
      "Авторизуйтесь для редактирования настроек слоя": " Authorize to edit layer properties",
      "Недостаточно прав для редактирования настроек слоя": "You have not enough permission to edit layer properties ",
      "Недостаточно прав для редактирования объектов слоя": "You have not enough permission to edit layer objects ",
      "ID": "ID",
      "Описание": "Description",
      "Файл": "File",
      "Таблица": "Table",
      "Каталог с тайлами": "Tile catalogue",
      "Каталог растров": "Raster catalogue",
      "Данные с датой": "Split through time",
      "Источник": "Source",
      "Дополнительно": "Advanced options",
      "Шаблон названий объектов": "Objects title template",
      "Y (широта)": "Y (latitude)",
      "X (долгота)": "X (longitude)",
      "Каталог": "Catalogue",
      "Изменить": "Change",
      "Вид вложенных элементов": "Form of attached elements",
      "Использовать KosmosnimkiAPI": "Load Kosmosnimki base layers",
      "Использовать OpenStreetMap": "Use OpenStreetMap",
      "Язык по умолчанию": "Default language",
      "Единицы длины": "Distance unit",
      "Единицы площади": "Square unit",
      "Формат координат": "Coordinates format",
      "units.auto": "auto",
      "units.m": "m",
      "units.km": "km",
      "units.nm": "nmi",
      "units.m2": "m<sup>2</sup>",
      "units.ha": "ha",
      "units.km2": "km<sup>2</sup>",
      "coords.dd": "dd.dddd",
      "coords.dms": "dd°mm′ss″",
      "Генерализация": "Generalization",
      "gereralization.on": "on",
      "gereralization.off": "off",
      "gereralization.disable": "use layers settings",
      "Количество информационных окошек": "Max popup count",
      "layerOrder.title": "Layers order",
      "layerOrder.native": "Native",
      "layerOrder.vectorOnTop": "Vector on top",
      "Разрешить поиск в векторных слоях": "Allow search vector layers",
      "Начальная позиция": "Start position",
      "Широта": "Latitude",
      "Долгота": "Longitude",
      "placeholder degrees": "dd.dddd",
      "placeholder zoom": "1-21",
      "placeholder minZoom": "1",
      "placeholder maxZoom": "21",
      "Зум": "Zoom",
      "Ссылка (permalink)": "Permalink",
      "Разрешить скачивание": "Allow to download",
      "Векторных слоев": "Vector layers",
      "Растровых слоев": "Raster layers",
      "Масштабирование в миникарте": "Minimap zoom delta",
      "Показывать всплывающие подсказки": "Show tooltips",
      "Свойства": "Properties",
      "Создать копию слоя": "Create layer copy",
      "Стили": "Styles",
      "Изображение на карте": "Ground overlay",
      "Слой [value0]": "Layer [value0]",
      "Стили слоя [value0]": "Styles of layer [value0]",
      "Мультислой [value0]": "Multilayer [value0]",
      "Группа [value0]": "Group [value0]",
      "Карта [value0]": "Map [value0]",
      "Редактировать стиль": "Edit style",
      "Редактирование стилей объекта": "Object styles editing",
      "Стили слоя": "Layer styles",
      "Навигация по карте и инструменты": "Map navigation and tools",
      "Список слоев": "List of layers",
      "Стиль векторного слоя": "Vector layer style",
      "Управление содержанием карты": "Map content management",
      "Пользовательские инструменты": "Users tools",
      "$$help$$_1": "Hold mouse left button – move map with cursor. To zoom in or out use mouse wheel (or map zoom slider to zoom to the cursor position). In order to move map center to specified coordinates – enter coordinates in search line.",
      "$$help$$_2": "Layer tree is represented in the left panel. To change map center according to layer extent – click its title in the list. If this option was activated by map administrator, you can download vector layers and cut and download raster layers fragments.",
      "$$help$$_3": "To edit vector layer style click icon near layer name.",
      "$$help$$_4": "Map is a collection of layers, which is displayed using layer tree. It is necessary to authorize to be able to edit the collection of layers (create groups, change display order etc.) and save changes. For more information see ",
      " - Руководство пользователя": " – User guide",
      "$$help$$_5": "User tools serve the purpose of creation of objects on map, which can be saved via «save link to the map», and, at the same time, simple analytic functions fulfillment.",
      "В режиме маркеров: ": "Creating markers: ",
      "$$help$$_6": "single click – add marker. Double click on marker – delete. Click on marker – open pop-up window (balloon), click on balloon – add text.",
      "В режиме линейка/измерения расстояния, полигон/измерение площади: ": "Drawing lines/distance measurement, polygon/area measurement: ",
      "$$help$$_7": "single click – add vertex. Double click – complete figure. Click on line – add vertex. Double click on vertex – delete.",
      "$$help$$_8": "Click on object in list of «objects on map» to move map center to it. You can download object in shp/tab/kml format.",
      "$$about$$_1": "this web application for interactive geodata view and access to basic data sources in the Internet, such as: ",
      "$$about$$_2": " Using GeoMixer you can publish own geodata in intranet or in the Internet, put them over basic data coverages and give access to them for however large number of users, changing access permissions.",
      "$$about$$_3": "GeoMixer also includes API component, which enables integrating the created projects into other web sites and applications and carry out program control over interactive map functional.",
      " - Общее описание": " – General manual",
      " - Руководство разработчика": " – Developer’s gudie",
      "Получить API-ключ": "Get API-key",
      "Введите API-ключ": "Enter API-key",
      "$$serviceHelp$$_1": "Allows to upload small shp/tab/kml file on the fly in the form of user objects. After uploading user can edit geometry of objects and download objects in the same format kit.",
      "$$serviceHelp$$_2": "Link saves current map state, and also user objects and texts.",
      "$$serviceHelp$$_3": "Print current map fragment.",
      "Редактировать": "Edit",
      "Удалить объект?": "Delete object?",
      "Удалить отмеченные объекты?": "Delete selected objects?",
      "Длина": "Length",
      "Площадь": "Area",
      "Добавить подгруппу": "Create group",
      "Введите имя группы": "New group creation",
      "Имя группы": "Group name",
      "Включая вложенные слои": "Including attached layers",
      "Удаление группы [value0]": "Delete group [value0]",
      "Сохранено": "Saved",
      "Прозрачность выбранного слоя/группы/карты": "Transparency of the selected layer/group/map",
      "$$updateInfo$$_1": "To display new layer it is necessary to save and reload map",
      "Любой": "Any",
      "Владелец": "Owner",
      "Последнее изменение": "Last modification",
      "Вы действительно хотите удалить этот слой?": "Do you really want to delete the selected layer?",
      "Ошибка!": "Error!",
      "Ошибка": "Error",
      "Выберите колонку": "Select column",
      "Список карт": "Maps list",
      "Показать": "Show",
      "загрузка...": "loading...",
      "удаление...": "deleting...",
      "Вы действительно хотите удалить эту карту?": " Do you really want to delete the selected map?",
      "maplist.hint": "You can drag layers and folders from here to current map",
      "Слоя нет в базе": "Layer is not in base",
      "ScanEx Web Geomixer - просмотр карты": "ScanEx Web Geomixer – map view",
      "Изменить параметры поиска": "Change search parameters",
      "$$search$$_1": "Search vector layers and address base",
      "$$search$$_2": "Search address base",
      "Поиск не дал результатов": "There are no search results",
      "Регистрация": "Registration",
      "Восстановление пароля": "Restore password",
      "Вход": "Login",
      "Выход": "Logout",
      "Логин": "User name",
      "Пароль": "Password",
      "пароль": "password",
      "Псевдоним": "Nickname",
      "Полное имя": "Full name",
      "Пожалуйста, авторизуйтесь": "Please, authorize",
      "адрес электронной почты": "enter your e-mail",
      "Ошибка сервера": "Server error",
      "Папка": "Folder",
      " и ": " and ",
      "Название": "Title",
      "Рейтинг": "Rating",
      "Автор": "Author",
      "Тематика": "Theme",
      "Развлекательная": "Fun",
      "Спортивная": "Sport",
      "Историческая": "History",
      "Экологическая": "Ecology",
      "Любая": "All",
      "Создать новую тему": "Create topic",
      "Начало периода": "Since",
      "Окончание периода": "Till",
      "Накладываемые тайлы": "Ground tiles",
      "Отображать с зума": "Show with zoom",
      "По": "to",
      "Фильтр": "Filter",
      "Подпись": "Label",
      "Балун": "Balloon",
      "По умолчанию": "Default",
      "Показывать при клике": "Show on click",
      "Показывать при наведении": "Show on mouse over",
      "Символика": "Shown style",
      "Библиотека стилей": "Style library",
      "Настройка стилей": "Style settings",
      "скопировать": "copy style",
      "применить везде": "apply to all",
      "Применить": "Apply",
      "Кластеризация": "Clustering",
      "Минимальный": "Mininmal",
      "Максимальный": "Maximal",
      "Мин. зум": "Min. zoom",
      "Макс. зум": "Max. zoom",
      "Пешеходная": "Footpath",
      "Велосипедная": "Bicycle",
      "Автомобильная": "Automobile",
      "Места": "Places",
      "Маршрут": "Route",
      "Редактировать экскурсию": "Edit excursion",
      "Добавьте маршрут": "Add route",
      "Выберете темы на пути следования": "Choose places throughout the journey",
      "$$phrase$$_11": "Add route by clicking \"Line\" tool on toolbar",
      "$$phrase$$_12": "There are no corresponding objects on the map",
      "Выбор маршрута": "Routes choice",
      "Выбор мест": "Places choice",
      "$$phrase$$_13": "You haven't places om map. You can add place in View-Forum tab",
      "Обсуждения": "Forum",
      "Экскурсии": "Excursions",
      "$$phrase$$_14": "Unable to delete default map",
      "$$phrase$$_15": "Unable to delete current map",
      "Назад": "Back",
      "Вперед": "Forward",
      "$$phrase$$_16": "There is no album with given image ID",
      "Редактировать альбом": "Edit album",
      "Оценить": "Vote",
      "Поставьте маркер": "Add marker",
      "на карту и переместите его в нужное место.": "to map and move it to choosen place.",
      "Недостаточно прав для совершения операции": "Insufficient rights to perform operation",
      "Новая папка": "New folder",
      "Выбрать": "Choose",
      "Добавить": "Add",
      "$$serviceHelp$$_4": "Embedding the map: the user can embed a map window into their site by copying and pasting an HTML snippet. An API key for the site's domain is required.",
      "Масштаб": "Scale",
      "Угол поворота": "Angle",
      "Диаграммы": "Charts",
      "График по времени": "Time chart",
      "Круговая": "Pie chart",
      "Маска атрибутов": "Attributes mask",
      "Закладки": "Bookmarks",
      "Добавить закладку": "Add bookmark",
      "Имя закладки": "Bookmark name",
      "Дерево": "Tree view",
      "Поиск слоев": "Layers search",
      "Пример выражения": "[Field1]\n[Field2]\nsimple text",
      "Шкала прозрачности": "Transparency bar",
      "Цвет заливки": "Fill color",
      "Цвет обводки": "Outline color",
      "Цвет шрифта": "Font color",
      "Легенда": "Legend",
      "Событие загрузки карты": "Событие загрузки карты",
      "Мин": "Min",
      "Макс": "Max",
      "График": "График",
      "Гистограмма": "Гистограмма",
      "Столбчатая": "Столбчатая",
      "Временная": "Временная",
      "Копировать стиль": "Copy style",
      "Применить стиль": "Apply style",
      "Не выбран стиль": "There is no copied style",
      "Невозможно применить стиль к другому типу геометрии": "Can't apply style to different geometry type",
      "Общие": "Common",
      "Доступ": "Policy",
      "Окно карты": "View",
      "Загрузка": "Onload",
      "Копирайт": "Copyright",
      "Инструменты": "Tools",
      "Загрузить KML": "Load KML",
      "URL файла": "File URL",
      "Поиск": "Search",
      "Подложки": "Base Layers",
      "Доступные подложки": "Available base layers",
      "Подложки карты": "Base layers on map",
      "Выберите слои для поиска по атрибутам": "Select layers for attributes search",
      "Включить синхронизацию слоев": "Enable sync layers",
      "Выключить синхронизацию слоев": "Disable sync layers",
      "Редактирование прав доступа карты [value0]": "Map [value0] access editor",
      "Редактирование прав доступа слоя [value0]": "Layer [value0] access editor",
      "Редактирование прав доступа слоев карты [value0]": "Map [value0] layers access editor",
      "Состав группы [value0]": "Users of group [value0]",
      "Роль": "Role",
      "Добавить пользователя": "Add user",
      "Права доступа": "Access permissions",
      "Права доступа к слоям": "Layers access permissions",
      "Пользователи без прав доступа:": "Users wihout access:",
      "Пользователи с правами доступа:": "Users with access:",
      "Выберите нового владельца": "Select new owner",
      "Сменить владельца": "Change owner",
      "Объекты RuMap": "RuMap objects",
      "Объекты пользователей": "User objects",
      "Контакты": "Contacts",
      "Фотографии": "Photo",
      "Момент съемки": "Image date",
      "Видео": "Video",
      "Сообщения": "Messages",
      "Ссылка на место": "Ссылка на место",
      "Ссылка на экскурсию": "Ссылка на экскурсию",
      "Ссылка на событие": "Ссылка на событие",
      "Создать новое событие": "Создать новое событие",
      "События": "События",
      "Календарь": "Календарь",
      "Новости": "Новости",
      "Мероприятия": "Мероприятия",
      "Отмена": "Отмена",
      "Пропустить": "Skip",
      "Время": "Время",
      "Альбом OpenPhotoVR": "Фотоальбом",
      "Встраиваемый код": "Embed video",
      "Объекты экологического риска": "Объекты экологического риска",
      "Санкционированные свалки": "Санкционированные свалки",
      "Несанкционированные свалки": "Несанкционированные свалки",
      "Полигоны отходов": "Полигоны отходов",
      "Предприятия переработки отходов": "Предприятия переработки отходов",
      "Факельные установки, ТЭЦ, трубы": "Факельные установки, ТЭЦ, трубы",
      "Закрытые свалки": "Закрытые свалки",
      "Пункты приема отходов": "Пункты приема отходов",
      "Оползни": "Оползни",
      "Карстовые явления": "Карстовые явления",
      "Суффозионные явления": "Суффозионные явления",
      "Государство и общество": "Государство и общество",
      "Радио": "Радио",
      "Правительственные учреждения": "Правительственные учреждения",
      "Оптики": "Оптики",
      "Охранные агенства": "Охранные агенства",
      "Травмпункты": "Травмпункты",
      "Таможня": "Таможня",
      "Ветеринарные клиники": "Ветеринарные клиники",
      "ЗАГС": "ЗАГС",
      "Больницы": "Больницы",
      "Аптеки": "Аптеки",
      "Поликлиники": "Поликлиники",
      "Колледжи": "Колледжи",
      "Университеты": "Университеты",
      "ОВИР": "ОВИР",
      "Посольства": "Посольства",
      "Почтовые отделения": "Почтовые отделения",
      "Суды": "Суды",
      "Банки": "Банки",
      "Родильные дома": "Родильные дома",
      "Дома престарелых": "Дома престарелых",
      "Детские сады": "Детские сады",
      "Школы": "Школы",
      "Инспекции": "Инспекции",
      "Адвокаты": "Адвокаты",
      "МЧС": "МЧС",
      "Муниципальные учреждения": "Муниципальные учреждения",
      "Администрация": "Администрация",
      "Культура и отдых": "Культура и отдых",
      "Боулинг": "Боулинг",
      "Аквапарки": "Аквапарки",
      "Парки развлечений": "Парки развлечений",
      "Библиотеки": "Библиотеки",
      "Памятники": "Памятники",
      "Лагери отдыха": "Лагери отдыха",
      "Кинотеатры": "Кинотеатры",
      "Цирки": "Цирки",
      "Галереи": "Галереи",
      "Отели": "Отели",
      "Мотели": "Мотели",
      "Музеи": "Музеи",
      "Концертные залы": "Концертные залы",
      "Ночные клубы": "Ночные клубы",
      "Театры": "Театры",
      "Санатории": "Санатории",
      "Зоопарки": "Зоопарки",
      "Общественное питание": "Общественное питание",
      "Кафе": "Кафе",
      "Фастфуды": "Фастфуды",
      "Рестораны": "Рестораны",
      "Кафе-мороженое": "Кафе-мороженое",
      "Столовые": "Столовые",
      "Природные достопримечательности": "Природные достопримечательности",
      "Ботанический сад": "Ботанические сады",
      "Пещеры": "Пещеры",
      "Водопады": "Водопады",
      "Парки": "Парки",
      "Источники": "Источники",
      "Заповедники": "Заповедники",
      "Прочие архитектурные и природные достопримечательности": "Архитектурные достопримечательности",
      "Религия": "Религия",
      "Культовые сооружения": "Культовые сооружения",
      "Мечети": "Мечети",
      "Монастыри": "Монастыри",
      "Церкви других христианских конфессий": "Церкви других христианских конфессий",
      "Православные церкви": "Православные церкви",
      "Синагоги": "Синагоги",
      "Спорт": "Спорт",
      "Стадионы": "Стадионы",
      "Теннисные корты": "Теннисные корты",
      "Катки": "Катки",
      "Ипподромы": "Ипподромы",
      "Фитнес": "Фитнес",
      "Бассейны": "Бассейны",
      "Прокат спортинвентаря": "Прокат спортинвентаря",
      "Торговля и услуги": "Торговля и услуги",
      "Солярии": "Солярии",
      "Интернет-кафе": "Интернет-кафе",
      "Рынки": "Рынки",
      "Стоматологические клиники": "Стоматологические клиники",
      "Магазины одежды": "Магазины одежды",
      "Парикмахерские": "Парикмахерские",
      "Бани": "Бани",
      "Магазины обуви": "Магазины обуви",
      "Магазины": "Магазины",
      "Ателье": "Ателье",
      "Такси": "Такси",
      "Туризм": "Туризм",
      "Транспорт и услуги": "Транспорт и услуги",
      "Аэропорты": "Аэропорты",
      "Автосервисы": "Автосервисы",
      "Автовокзалы": "Автовокзалы",
      "ДПС": "ДПС",
      "ГИБДД": "ГИБДД",
      "Шиномонтаж": "Шиномонтаж",
      "Парковки бесплатные": "Парковки бесплатные",
      "Парковки платные": "Парковки платные",
      "АЗС": "АЗС",
      "Автомойки": "Автомойки",
      "Экстренные службы": "Экстренные службы",
      "Пожарные/спасатели": "Пожарные/спасатели",
      "Милиция": "Милиция",
      "Скорая помощь": "Скорая помощь",
      "Другие темы": "Другие темы",
      "Разное": "Разное",
      "Изменение пароля": "Password change",
      "Новый пароль": "New password",
      "Старый пароль": "Old password",
      "Подтвердите пароль": "Confirm password",
      "Контур": "Border",
      "$$phrase$$_17": "Add border by clicking \"Polygon\" tool on toolbar",
      "Выбор контура": "Border select",
      "Таблица атрибутов слоя [value0]": "[value0] attributes table",
      "Показать параметры поиска": "Show search params",
      "Скрыть параметры поиска": "Hide search params",
      "Скрыть": "Hide",
      "Искать внутри полигона": "Search inside polygon",
      "Искать по пересечению с объектом": "Search by geometry",
      "SQL-условие WHERE": "WHERE SQL expression",
      "Показывать колонки": "Show columns",
      "Скрыть колонки": "Hide columns",
      "Найти": "Search",
      "Нет полей": "Empty fields",
      "Нет данных": "Empty data",
      "Таблица атрибутов": "Attributes table",
      "Разрешить поиск": "Allow search",
      "Произвольный": "Any",
      "День": "Day",
      "Неделя": "Week",
      "Месяц": "Month",
      "Год": "Year",
      "Ежегодно": "Every year",
      "Облачность": "Clouds",
      "Период": "Period",
      "Спутниковые покрытия": "Satellite cover",
      "Редактировать объект слоя [value0]": "Edit layer [value0] object",
      "Создать объект слоя [value0]": "Add layer [value0] object",
      "Геометрия": "Geometry",
      "Найти объекты": "Find objects",
      "Добавить объекты": "Add objects",
      "Обновить объекты": "Update objects",
      "Копировать объекты": "Copy objects",
      "Объекты скопированы": "Objects are copied",
      "Объекты добавлены": "Объекты добавлены",
      "Вставить объекты": "Paste objects",
      "Вставить объекты не удалось": "Paste objects failed",
      "Выберите правым кликом слой в левой панели и нажмите \"Вставить объекты\"": "Right-click on layer name and select \"Paste objects\"",
      "Изменить колонки": "Update columns",
      "Обновить колонку": "Update column",
      "Очистить поиск": "Clean search",
      "Скачать shp": "Download shp",
      "Скачать gpx": "Download gpx",
      "Скачать csv": "Download csv",
      "Скачать geojson": "Download geojson",
      "Рассчитать площадь": "Total square",
      "Создать столбец": "Create column",
      "Мультислой": "Multilayer",
      "В дереве слоев остались несохраненные изменения!": "There are unsaved changes on layers tree!",
      "файл версии отсутствует": "version file doesn't exists",
      "оверлеи отсутствуют": "no overlays present",
      "Хост": "Host",
      "Дополнительные карты": "Additional maps",
      "Добавить карту": "Add map",
      "Добавить в таймлайн": "Add to timeLine",
      "Удалить из таймлайна": "Remove from timeline",
      "Невозможно загрузить карту [value0] с домена [value1]": "Unable to load map [value0] from domain [value1]",
      "Показывать": "Show",
      "Принудительно обновить тайлы": "Forced retiling",
      "Обводка": "Outline",
      "Карта имеет более новую версию. Сохранить?": "The map has a newer version. Save anyway?",
      "Кодировка": "Encoding",
      "helpPostfix": "_eng.html",
      "Показывать чекбокс видимости": "Visibility checkbox",
      "Разворачивать автоматически": "Expand automatically",
      "Другая": "Another",
      "Временнóй слой": "Multitemporal layer",
      "Колонка даты": "Date column",
      "Минимальный период": "Min. period (days)",
      "Максимальный период": "Max. period (days)",
      "Отсутствует временной атрибут": "Missing attribute with type 'Date'",
      "Период 1 день": "Period 1 day",
      "Показывать на карте данные за": "Show data on map within",
      "1 день": "single day",
      "произвольный период": "arbitrary period",
      "По границе экрана": "Screen border",
      "По центру экрана": "Screen center",
      "Пересечение": "Intersection",
      "Пролистывать слои": "Scroll layers",
      "Следующий слой": "Next layer",
      "Предыдущий слой": "Previous layer",
      "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.": "Geometry is not saved. This feature will be implemented in future Geomixer versions",
      "WMS доступ": "WMS/WFS access",
      "ссылка": "link",
      "Слой '[value0]' уже есть в карте": "Layer '[value0]' already exists in this map",
      "Группа '[value0]' уже есть в карте": "Group '[value0]' already exists in this map",
      "Плагины": "Plugins",
      "Вручную": "Manually",
      "Добавить атрибут": "Add attribute",
      "Проекция": "Projection",
      "Широта/Долгота (EPSG:4326)": "Lat/Lon (EPSG:4326)",
      "Меркатор (EPSG:3395)": "Mercator (EPSG:3395)",
      "Из файла": "From file",
      "Мультиполигон": "Multipolygon",
      "Мультилиния": "Multipolyline",
      "Мультиточка": "Multipoint",
      "Администрирование": "Administration",
      "Системные настройки": "System settings",
      "Управление группами": "User group management",
      "Управление группами пользователей": "User group management",
      "Добавить снимки": "Add rasters",
      "Существующие слои": "Existing layers",
      "Слои из карты": "Layers from map",
      "Слои из КР": "Layers from RC",
      "Новый слой": "New layer",
      "С экрана": "Select on map",
      "Добавлен растр": "Raster is added",
      "Добавлены растры": "Rasters are added",
      "Выбранный объект не имеет растра": "Selected object has no raster",
      "Этот растр уже был выбран": "This raster is already selected",
      "Каталог Растров": "Raster catalog",
      "Растр": "Raster",
      "Добавить выбранные растры": "Add selected rasters",
      "EditObject.menuTitle": "Add object",
      "FileBrowser.ExceedLimitMessage": "File size exceeds 500 Mb. Use GeoMixerFileBrowser tool to upload large files.",
      "FileBrowser.DropInfo": "Drop files here",
      "EditObject.drawingMenuTitle": "Add object to active layer",
      "Поставить маркер": "Add marker",
      "Центрировать": "Set center",
      "Пароль изменён": "Password has been changed",
      "портретная": "portrait view",
      "альбомная": "layout view",
      "gmx_geometry": "gmx_geometry"
    };

    /**
      @class
      @virtual
      @name IMenuElem
      @desc Описание пункта верхнего меню ГеоМиксера
      @property {String} id Уникальный идентификатор элемента меню
      @property {String} title Tекст, который будет показываться пользователю
      @property {Function} func Ф-ция, которую нужно вызвать при клике
      @property {IMenuElem[]} childs Массив элементов подменю
    */

    /**
        Верхнее меню ГеоМиксера. Может содержать до 3 уровней вложенности элементов.
        @class
    */

    var UpMenu = function UpMenu() {
      this.submenus = [];
      this.currSel = null;
      this.currUnSel = null;
      this.refs = {};
      this.parent = null;
      this.loginContainer = null;
      this._isCreated = false;
      this.defaultHash = 'layers';
      this.clicked = false;
      this.openedMenus = [];
      this.currentTopHash = null;
      document.addEventListener('click', this.hideOnClick.bind(this));
    };

    UpMenu.prototype.hideOnClick = function (e) {
      var parents = $(e.target).parents(),
          parentsArr = $(parents).toArray(),
          isHeader = $(e.target).hasClass('header1Internal'),
          isInsideHeader = parentsArr.some(function (elem) {
        return $(elem).hasClass('header1');
      });

      if (!isInsideHeader) {
        this.clicked = false;
        this.hideMenus();
        this.currentTopHash = null;
      }

      if (!isHeader) {
        $(document).find('.header1').each(function () {
          $(this).removeClass('menuActive');
        });
      }
    }; //предполагает, что если callback возвращает true, то итерирование можно прекратить


    UpMenu.prototype._iterateMenus = function (elem, callback) {
      if (!elem.childs) {
        return;
      }

      for (var i = 0; i < elem.childs.length; i++) {
        if (elem.childs[i] && (callback(elem.childs[i]) || this._iterateMenus(elem.childs[i], callback))) {
          return true;
        }
      }
    };
    /** Добавляет к меню новый элемент верхнего уровня
    *
    * Если меню уже было нарисовано, вызов этой ф-ции приведёт к перерисовке
    *
    *    @param {IMenuElem} elem Элемент меню
    */


    UpMenu.prototype.addItem = function (elem) {
      this.submenus.push(elem);
      this._isCreated && this.draw();
    };
    /** Добавляет к меню новый элемент.
    *
    * Если меню уже было нарисовано, вызов этой ф-ции приведёт к перерисовке
    *
    *    @param {IMenuElem} newElem Вставляемый элемент меню
    *    @param {String} parentID ID элемента меню, к которому добавляется новый элемент
    *    @param {String} [insertBeforeID] ID элемента меню, перед которым нужно вставить пункт меню.
    *                    Если не указан, пункт меню будет добавлен в конец списка.
    */


    UpMenu.prototype.addChildItem = function (newElem, parentID, insertBeforeID) {
      this._iterateMenus({
        childs: this.submenus
      }, function (elem) {
        if (elem.id && elem.id === parentID) {
          elem.childs = elem.childs || [];
          var index = elem.childs.length;
          elem.childs.forEach(function (childElem, i) {
            if (childElem.id === insertBeforeID) {
              index = i;
            }
          });
          elem.childs.splice(index, 0, newElem);
          this._isCreated && this.draw();
          return true;
        }
      }.bind(this));
    };
    /** Задаёт родителя в DOM дереве для меню
    * @param {DOMElement} parent Родительский элемент в DOM дереве
    */


    UpMenu.prototype.setParent = function (parent) {
      this.parent = parent;

      if (parent) {
        $(parent).empty();
        parent.appendChild(_span$1());
      }

      this.disabledTabs = {};
    }; // Показывает элемент меню


    UpMenu.prototype.showmenu = function (elem) {
      elem.style.visibility = 'visible';

      if (this.openedMenus.indexOf(elem) === -1) {
        this.openedMenus.push(elem);
      }
    }; // Скрывает элемент меню


    UpMenu.prototype.hidemenu = function (elem) {
      elem.style.visibility = 'hidden';

      if (this.openedMenus.indexOf(elem) !== -1) {
        this.openedMenus.splice(this.openedMenus.indexOf(elem), 1);
      }
    };

    UpMenu.prototype._template = Handlebars.compile('<div class="headerContainer">\
{{#childs}}{{#if id}}\
    <div class = "header1{{#unless childs}} menuClickable{{/unless}}" hash = "{{id}}">\
        <div class = "header1Internal">{{title}}</div>\
        {{#if childs}}\
            <ul class = "header2" id="{{id}}">\
            {{#childs}}{{#if id}}\
                <li class = "header2{{#unless childs}} menuClickable{{/unless}}" hash = "{{id}}">\
                    <div class = "header2{{#if disabled}} menuDisabled{{/if}}{{#delimiter}} menuDelimiter{{/delimiter}}">\
                        <div class = "menuMarkerLeft {{#if checked}} ui-icon ui-icon-check{{/if}}"></div>\
                        {{title}}\
                        {{#if childs}}\
                            <div class = "menuMarkerRight"></div>\
                        {{/if}}\
                    </div>\
                    {{#if childs}}\
                        <ul class = "header3" id="{{id}}">\
                        {{#childs}}{{#if id}}\
                            <li class = "header3 menuClickable" hash = "{{id}}">\
                                <div class = "header3{{#if disabled}} menuDisabled{{/if}}{{#delimiter}} menuDelimiter{{/delimiter}}">\
                                    <div class = "menuMarkerLeft {{#if checked}} ui-icon ui-icon-check{{/if}}"></div>\
                                    {{title}}\
                                </div>\
                            </li>\
                        {{/if}}{{/childs}}\
                        </ul>\
                    {{/if}}\
                </li>\
            {{/if}}{{/childs}}\
            </ul>\
        {{/if}}\
    </div>\
    {{/if}}{{/childs}}\
</div>');
    /** Основная функция  - рисует меню по заданной структуре
    */

    UpMenu.prototype.draw = function () {
      var ui = $(this._template({
        childs: this.submenus
      })),
          _this = this;

      $(this.parent.firstChild).empty().append(ui);
      $(ui).find('.header1').each(function () {
        _this.attachEventOnClick(this, 'menuActive');

        _this.attachEventOnMouseover(this, 'menuActive');

        _this.attachEventOnMouseout(this, 'menuActive');

        $(this).width($(this).width() + 10);
      });
      $(ui).find('li.header2').each(function () {
        _this.attachEventOnMouseover(this, 'menu2Active');

        _this.attachEventOnMouseout(this, 'menu2Active');
      });
      $(ui).find('li.header3').each(function () {
        attachEffects$1(this, 'menu3Active');
      });
      $(ui).find('.menuClickable').each(function () {
        var id = $(this).attr('hash');
        $(this).click(function (e) {
          e.stopPropagation();
          _this.refs[id].disabled || _this.openTab(id, e);
        });
      });

      this._iterateMenus({
        childs: this.submenus
      }, function (elem) {
        _this.refs[elem.id] = elem;
      }); //убираем все скрытые меню


      for (var d in this.disabledTabs) {
        this.disableMenus([d]);
      }

      this._isCreated = true;
    };

    UpMenu.prototype.checkItem = function (id, isChecked) {
      if (this.refs[id]) {
        this.refs[id].checked = isChecked;
        $(this.parent).find('li[hash=' + id + ']').find('.menuMarkerLeft').toggleClass('ui-icon ui-icon-check', isChecked);
      }
    };

    UpMenu.prototype.removeSelections = function (id) {
      $('li.menu3Active').removeClass('menu3Active');
      $('li.menu2Active').removeClass('menu2Active');
      $('li.menuActive').removeClass('menuActive');
    }; // Закрывает открытые меню


    UpMenu.prototype.hideMenus = function () {
      var _this = this;

      $('ul.header2').each(function () {
        _this.hidemenu(this);
      });
      $('ul.header3').each(function () {
        _this.hidemenu(this);
      });
    }; // Открывает закладку


    UpMenu.prototype.openRef = function (hash) {
      _menuUp.removeSelections();

      _menuUp.hideMenus();

      _menuUp.openTab(hash);
    };

    UpMenu.prototype.attachEventOnClick = function (elem, className) {
      var _this = this;

      elem.onclick = function (e) {
        if (!_this.clicked) {
          var isTopLevel = $(elem).hasClass('header1'),
              hash = this.getAttribute('hash');

          if (isTopLevel && !_this.currentTopHash) {
            _this.currentTopHash = hash;
            _this.clicked = true;
          }

          if ($('#' + hash)[0]) {
            _this.showmenu($('#' + this.getAttribute('hash'))[0]);
          }
        } else {
          return;
        }
      };
    };

    UpMenu.prototype.attachEventOnMouseover = function (elem, className) {
      var _this = this;

      elem.onmouseover = function (e) {
        $(this).addClass(className);

        if (_this.clicked) {
          var itemsToClose = [];

          for (var i = 0; i < _this.openedMenus.length; i++) {
            if (!_this.checkInsideElem(elem, _this.openedMenus[i])) {
              itemsToClose.push(_this.openedMenus[i]);
            }
          }

          for (var i = 0; i < itemsToClose.length; i++) {
            var ee = itemsToClose[i];

            _this.hidemenu(ee);
          }

          if ($('#' + this.getAttribute('hash'))[0]) {
            _this.showmenu($('#' + this.getAttribute('hash'))[0]);
          } //add top-level hash


          var isTopLevel = $(elem).hasClass('header1'),
              hash = this.getAttribute('hash');

          if (isTopLevel) {
            _this.currentTopHash = hash;
            $(document).find('.header1').each(function () {
              $(this).removeClass('menuActive');
            });
            $(this).addClass(className);
          }
        }
      };
    };

    UpMenu.prototype.checkInsideElem = function (elem, descendant) {
      var parents = $(descendant).parents(),
          parentsArr = $(parents).toArray(),
          isInsideElem = parentsArr.some(function (em) {
        return $(em).attr('hash') === $(elem).attr('hash');
      });
      return isInsideElem;
    };

    UpMenu.prototype.attachEventOnMouseout = function (elem, className) {
      var _this = this;

      elem.onmouseout = function (e) {
        var evt = e || window.event,
            target = evt.srcElement || evt.target,
            relTarget = evt.relatedTarget || evt.toElement,
            elem = this,
            isTopLevel = $(elem).hasClass('header1'),
            hash = this.getAttribute('hash');

        try {
          while (relTarget) {
            if (relTarget == elem) {
              stopEvent$1(e);
              return false;
            }

            relTarget = relTarget.parentNode;
          }

          if (isTopLevel && hash === _this.currentTopHash) {
            return false;
          } else {
            // _this.currentTopHash = null;
            $(elem).removeClass(className);
          }
        } catch (e) {
          if (isTopLevel && hash === _this.currentTopHash) {
            return false;
          } else {
            // _this.currentTopHash = null;
            $(elem).removeClass(className);
          }
        }
      };
    };

    UpMenu.prototype.getNavigatePath = function (path) {
      for (var menuIdx = 0; menuIdx < this.submenus.length; menuIdx++) {
        var submenu = this.submenus[menuIdx];

        if (!submenu) {
          continue;
        }

        if (path == submenu.id) {
          return [submenu.title];
        }

        if (submenu.childs) {
          var childsLevel2 = submenu.childs;

          for (var i = 0; i < childsLevel2.length; i++) {
            if (!childsLevel2[i]) {
              continue;
            }

            if (childsLevel2[i].childs) {
              var childsLevel3 = childsLevel2[i].childs; // есть подменю, смотрим там

              for (var j = 0; j < childsLevel3.length; j++) {
                if (!childsLevel3[j]) {
                  continue;
                }

                if (path == childsLevel3[j].id) {
                  return [submenu.title, childsLevel2[i].title, childsLevel3[j].title];
                }
              }
            }

            if (path == childsLevel2[i].id) {
              // совпадение в меню 2го уровня
              return [submenu.title, childsLevel2[i].title];
            }
          }
        }
      }

      return [];
    };
    /** Показывает все ранее скрытые элементы меню
    */


    UpMenu.prototype.enableMenus = function () {
      for (var name in this.disabledTabs) {
        $(this.parent).find("li[hash='" + name + "']").children('div').css('display', '');
        delete this.disabledTabs[name];
      }
    };
    /** Скрывает заданные элементы меню
    * @param {String[]} arr Массив ID элементов меню, которые нужно скрыть
    */


    UpMenu.prototype.disableMenus = function (arr) {
      for (var i = 0; i < arr.length; i++) {
        $(this.parent).find("li[hash='" + arr[i] + "']").children('div').css('display', 'none');
        this.disabledTabs[arr[i]] = true;
      }
    };

    UpMenu.prototype.checkView = function () {
      if (!nsGmx$1.AuthManager.isLogin()) {
        this.enableMenus();
        this.disableMenus(['mapCreate', 'mapSave', 'mapSaveAs', 'layersMenu', 'pictureBinding']);
      } else if (_queryMapLayers.currentMapRights() != "edit") {
        this.enableMenus();
        this.disableMenus(['mapSave', 'mapSaveAs', 'layersVector', 'layersRaster', 'layersMultiRaster']);
      }

      if (!nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN)) {
        this.disableMenus(['stileLibrary']);
      }

      if (_queryMapLayers.currentMapRights() !== "edit") {
        this.disableMenus(['mapTabsNew']);
      }

      if (!nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_CREATE_LAYERS)) {
        this.disableMenus(['layersVector', 'layersRaster', 'layersMultiRaster']);
      }

      if (!nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_CREATE_MAP)) {
        this.disableMenus(['mapCreate']);
      }
    };

    UpMenu.prototype.go = function (container) {
      this.setParent(container);
      this.createMenu();
      this.draw();
      this.checkView();

      if (window.location.hash) {
        this.currUnsel = function () {};
      }

      this.openTab(this.defaultHash);
    };

    UpMenu.prototype.openTab = function (id, event) {
      if (this.disabledTabs[id] || !this.refs[id]) {
        return;
      }

      var item = this.refs[id];
      this.removeSelections();
      this.hideMenus();

      if (item.func) {
        this.clicked = false;
        event.stopPropagation();
        this.hideOnClick(event);
        item.func(id);
      } else {
        var func = item[item.checked ? 'onunsel' : 'onsel'];
        this.checkItem(id, !item.checked);
        func && func(id);
      }
    };
    /** Блок (контейнер с заголовком) левой панели
        @class
        @param {String} canvasID Уникальный идентификатор блока
        @param {Object} options Параметры
        @param {function} [options.closeFunc] Ф-ция, которая будет вызвана при нажатии на иконку закрытия блока. По умолчанию ничего не делается.
        @param {String[]} [options.path] Массив строк для формирования названия блока (см. метод setTitle()).
                          По умолчанию будет сформирован из верхнего меню ГеоМиксера по canvasID.
        @param {Boolean} [options.showCloseButton=true] Показывать ли кнопку закрытия блока
        @param {Boolean} [options.showMinimizeButton=true] Показывать ли кнопку сворачивания блока
    */


    nsGmx$1.LeftPanelItem = function (canvasID, options) {
      /** Изменение видимости контента ("свёрнутости") панели
       * @event nsGmx.LeftPanelItem.changeVisibility
      */
      options = $.extend({
        closeFunc: function closeFunc() {},
        showCloseButton: true,
        showMinimizeButton: true
      }, options); //по умолчанию оставляем только последний элемент списка

      if (!options.path) {
        var menuPath = _menuUp.getNavigatePath(canvasID);

        options.path = menuPath.length ? [menuPath[menuPath.length - 1]] : [];
      }

      var getPathHTML = function getPathHTML(path) {
        if (!path) return '';
        return Handlebars.compile('<tr>' + '{{#path}}' + '<td class="leftmenu-path-item {{#last}}menuNavigateCurrent{{/last}}">{{name}}</td>' + '{{^last}}<td><div class="markerRight"></div></td>{{/last}}' + '{{/path}}' + '</tr>')({
          path: path.map(function (item, index, arr) {
            return {
              name: item,
              last: index === arr.length - 1
            };
          })
        });
      };

      var ui = Handlebars.compile('<div class="leftmenu-canvas {{id}}" id="{{id}}">' + '{{#isTitle}}<div class="leftTitle">' + '{{#showMinimizeButton}}' + '<div class = "leftmenu-toggle-zone">' + '<div class="ui-helper-noselect leftmenu-toggle-icon leftmenu-down-icon"></div>' + '</div>' + '{{/showMinimizeButton}}' + '<table class="leftmenu-path ui-helper-noselect">{{{pathTR}}}</table>' + '{{#showCloseButton}}<div class="gmx-icon-close"></div>{{/showCloseButton}}' + '</div>{{/isTitle}}' + '<div class = "workCanvas"></div>' + '</div>');
      /**HTML элемент с блоком (содержит шапку и рабочую область)*/

      this.panelCanvas = $(ui({
        isTitle: !!(options.path.length || options.showCloseButton || options.showMinimizeButton),
        id: 'left_' + canvasID,
        pathTR: getPathHTML(options.path),
        showCloseButton: options.showCloseButton,
        showMinimizeButton: options.showMinimizeButton
      }))[0];
      /**Рабочая область блока*/

      this.workCanvas = $(this.panelCanvas).find('.workCanvas')[0];
      /** Программная имитация нажатия кнопки закрытия блока
          @function
      */

      this.close = options.closeFunc;

      var isUICollapsed = false,
          _this = this;

      var toggleContentVisibility = function toggleContentVisibility(isCollapsed) {
        if (isUICollapsed !== isCollapsed) {
          isUICollapsed = !isUICollapsed;
          $(_this.workCanvas).toggle();
          $(_this.panelCanvas).find('.leftmenu-toggle-zone div').toggleClass('leftmenu-down-icon leftmenu-right-icon');
          $(_this).trigger('changeVisibility');
        }
      };

      $('.leftmenu-toggle-zone, .leftmenu-path', this.panelCanvas).click(function () {
        toggleContentVisibility(!isUICollapsed);
      });
      /** Свернуть панель
          @function
      */

      this.hide = toggleContentVisibility.bind(null, true);
      /** Развернуть панель
          @function
      */

      this.show = toggleContentVisibility.bind(null, false);
      /** Свёрнута ли панель */

      this.isCollapsed = function () {
        return isUICollapsed;
      };

      $('.leftTitle .gmx-icon-close', this.panelCanvas).click(options.closeFunc);
      /** Задать новый заголовок окна
       @param {String[]} [path] Массив строк для формирования названия блока.
                        Предполагается, что последний элемент является собственно названием, а предыдущие - названиями категорий.
      */

      this.setTitle = function (path) {
        $('.leftmenu-path', this.panelCanvas).html(getPathHTML(path));
      };
    };
    /** Основное меню ГеоМиксера
     * @global
     * @type {UpMenu}
     */


    var _menuUp = new UpMenu(); // содержит ссылку на рабочую область для текущей вкладки


    var leftMenu$1 = function leftMenu() {
      this.workCanvas = null;
      this.parentWorkCanvas = null;
    }; //варианты вызова:
    //    function(canvasID, closeFunc, options) - для обратной совместимости
    //    function(canvasID, options)
    // options - те же, что и в LeftPanelItem


    leftMenu$1.prototype.createWorkCanvas = function (canvasID, closeFunc, options) {
      if (typeof closeFunc !== 'function') {
        options = closeFunc || {};
        closeFunc = options.closeFunc;
      } else {
        options = options || {};
      }

      options.closeFunc = function () {
        $(_this.parentWorkCanvas).hide();
        closeFunc && closeFunc();
      };

      var _this = this;

      if (!$('#left_' + canvasID).length) {
        var leftPanelItem = new nsGmx$1.LeftPanelItem(canvasID, options);
        this.parentWorkCanvas = leftPanelItem.panelCanvas;
        this.workCanvas = leftPanelItem.workCanvas;
        this.leftPanelItem = leftPanelItem; // так как мы используем dom элементы для поиска панелей после первого добавления
        // возможно, лучше сделать полноценный менеджер панелей левой вкладки

        this.parentWorkCanvas.leftPanelItem = leftPanelItem;
        $('#leftContentInner').prepend(this.parentWorkCanvas);
        return false;
      } else {
        this.parentWorkCanvas = $('#left_' + canvasID)[0];
        this.workCanvas = this.parentWorkCanvas.lastChild;
        this.leftPanelItem = this.parentWorkCanvas.leftPanelItem;
        this.leftPanelItem.close = options.closeFunc;
        $(this.parentWorkCanvas).show();
        $('#leftContentInner').prepend(this.parentWorkCanvas);
        return true;
      }
    };

    nsGmx$1.VirtualLayerManager = function () {
      this._classes = window.gmxVirtualClasses || {};
      this.loader = this.loader.bind(this);
    };

    nsGmx$1.VirtualLayerManager.prototype.loader = function (type) {
      var promise = new L.gmx.Deferred(),
          classInfo = this._classes[type];

      if (!classInfo) {
        promise.resolve();
        return promise;
      }

      gmxCore$1.loadModule(classInfo.module, classInfo.file).then(function (module) {
        promise.resolve(module.layerClass);
      }, promise.reject);
      return promise;
    };

    (function () {
      //внутреннее представление плагина
      var Plugin = function Plugin(moduleName, file, body, params, pluginName, mapPlugin, isPublic, lazyLoad) {
        var usageState = mapPlugin && !lazyLoad ? 'unknown' : 'used'; //used, notused, unknown

        var _this = this;

        var doLoad = function doLoad() {
          if (_this.body || _this.isLoading) return;
          _this.isLoading = true;
          gmxCore$1.loadModule(moduleName, file).then(function () {
            _this.body = gmxCore$1.getModule(moduleName);
            _this.isLoading = false;
            _this.pluginName = _this.pluginName || _this.body.pluginName;

            _this.def.resolve();
          }, function () {
            _this.isLoading = false;

            _this.def.reject();
          });
        };

        this.body = body;
        this.moduleName = moduleName;
        this.params = params || {};
        this.def = $.Deferred(); //будет resolve когда плагин загрузится

        this.isLoading = false;
        this.mapPlugin = mapPlugin || body && body.pluginName;
        this.pluginName = pluginName || this.body && this.body.pluginName;
        this.isPublic = isPublic;
        this.lazyLoad = lazyLoad;
        this.file = file;
        if (this.body) this.def.resolve(); //мы не будем пока загружать плагин только если он не глобальный и имеет имя
        // и только если специально не указана загрузка по требованию

        if (!mapPlugin || !pluginName) {
          if (!lazyLoad) {
            doLoad();
          }
        }

        this.setUsage = function (usage) {
          usageState = usage;

          if (usageState === 'used') {
            doLoad();
          }
        };

        this.isUsed = function () {
          return usageState === 'used';
        };

        this.updateParams = function (newParams) {
          $.extend(true, _this.params, newParams);
        };
      };
      /**
        @name IGeomixerPlugin
        @desc Интерфейс плагинов ГеоМиксера
        @class
        @abstract
        @property {String} pluginName Имя плагина для списка плагинов
      */

      /**
        @memberOf IGeomixerPlugin.prototype
        @method
        @name beforeMap
        @desc Вызывется сразу после загрузки всех модулей ядра вьюера (до инициализации карты, проверки пользователя и т.п.).
              Ещё нет информации о пользователе, но пока можно сменить карту для загрузки.
        @param {Object} params Параметры плагина
      */

      /**
        @memberOf IGeomixerPlugin.prototype
        @method
        @name preloadMap
        @desc Вызывется непосредственно перед началом создания слоёв по загруженной информации о карте.
              Карту сменить уже нельзя, но можно как-нибудь повлиять на процесс создания слоёв (например, добавить новые классы слоёв)
        @param {Object} params Параметры плагина
      */

      /**
        @memberOf IGeomixerPlugin.prototype
        @method
        @name beforeViewer
        @desc вызовется до начала инициализации ГеоМиксера, но сразу после инициализации карты
        @param {Object} params Параметры плагина
        @param {gmxAPI.Map} map Основная карта
      */

      /**
        @memberOf IGeomixerPlugin.prototype
        @method
        @name afterViewer
        @desc вызовется после окончания инициализации ГеоМиксера
        @param {Object} params Параметры плагина
        @param {gmxAPI.Map} map Основная карта
      */

      /** Менеджер плагинов. Загружает плагины из конфигурационного файла
      *
      * Загрузка плагинов происходит из массива window.gmxPlugins.
      *
      * Каждый элемент этого массива - объект со следующими свойствами:
      *
      *   * module (имя модуля)
      *   * file (из какого файла подгружать модуль, может отсутствовать). Только если указано module
      *   * plugin (сам плагин). Если указано, плагин подгружается в явном виде, иначе используется module (и file)
      *   * params - объект параметров, будет передаваться в методы модуля
      *   * pluginName - имя плагина. Должно быть уникальным. Заменяет IGeomixerPlugin.pluginName. Не рекомендуется использовать без особых причин
      *   * mapPlugin {bool, default: true} - является ли плагин плагином карт. Если является, то не будет грузиться по умолчанию.
      *   * isPublic {bool, default: false} - нужно ли показывать плагин в списках плагинов (для некоторых плагинов хочется иметь возможность подключать их к картам, но не показывать всем пользователям)
      *
      * Если очередной элемент массива просто строка (например, "name"), то это эквивалентно {module: "name", file: "plugins/name.js"}
      *
      * Каждый плагин хранится в отдельном модуле (через свойство module) или подгружается в явном виде (через свойство plugin). Модуль должен реализовывать интерфейс IGeomixerPlugin.
      *  @class PluginsManager
      */


      var PluginsManager = function PluginsManager() {
        var _plugins = [];
        var _pluginsWithName = {};
        var joinedPluginInfo = {}; //сначала загружаем инфу о плагинах из переменной nsGmx._defaultPlugins - плагины по умолчанию

        window.nsGmx && nsGmx$1._defaultPlugins && $.each(nsGmx$1._defaultPlugins, function (i, info) {
          if (typeof info === 'string') {
            info = {
              module: info,
              file: 'plugins/' + info + '.js'
            };
          }

          joinedPluginInfo[info.module] = info;
        }); //дополняем её инфой из window.gmxPlugins с возможностью перезаписать

        window.gmxPlugins && $.each(window.gmxPlugins, function (i, info) {
          if (typeof info === 'string') {
            info = {
              module: info,
              file: 'plugins/' + info + '.js'
            };
          }

          joinedPluginInfo[info.module] = $.extend(true, joinedPluginInfo[info.module], info);
        });
        $.each(joinedPluginInfo, function (key, info) {
          if (typeof info === 'string') info = {
            module: info,
            file: 'plugins/' + info + '.js'
          };
          var plugin = new Plugin(info.module, info.file, info.plugin, info.params, info.pluginName, info.mapPlugin, info.isPublic || false, info.lazyLoad || false);

          _plugins.push(plugin);

          if (plugin.pluginName) {
            _pluginsWithName[plugin.pluginName] = plugin;
          } else {
            plugin.def.done(function () {
              if (plugin.pluginName) {
                _pluginsWithName[plugin.pluginName] = plugin;
              }
            });
          }
        });

        var _genIterativeFunction = function _genIterativeFunction(funcName) {
          return function (map) {
            for (var p = 0; p < _plugins.length; p++) {
              if (_plugins[p].isUsed() && _plugins[p].body && _plugins[p].body[funcName]) {
                //передаём в плагин deep clone параметров, чтобы плагин не мог их менять in-place
                var params = $.extend(true, {}, _plugins[p].params);

                try {
                  _plugins[p].body[funcName](params, map || nsGmx$1.leafletMap);
                } catch (e) {
                  console && console.error('Error in function ' + funcName + '() of plugin ' + _plugins[p].moduleName + ': ' + e);
                  console && console.error(e.stack);
                }
              }
            }
          };
        }; //public interface

        /**
        Вызывет callback когда будут загружены все плагины, загружаемые в данный момент
        @memberOf PluginsManager
         @name done
         @method
         @param {Function} callback Ф-ция, которую нужно будет вызвать
        */


        this.done = function (f) {
          //не можем использовать $.when, так как при первой ошибке результирующий promise сразу же reject'ится, а нам нужно дождаться загрузки всех плагинов
          var loadingPlugins = _.where(_plugins, {
            isLoading: true
          }),
              count = loadingPlugins.length;

          count || f();
          loadingPlugins.forEach(function (plugin) {
            plugin.def.always(function () {
              --count || f();
            });
          });
        };
        /**
         Вызывает beforeMap() у всех плагинов
         @memberOf PluginsManager
         @name beforeMap
         @method
        */


        this.beforeMap = _genIterativeFunction('beforeMap');
        /**
         Вызывает preloadMap() у всех плагинов
         @memberOf PluginsManager
         @name preloadMap
         @method
        */

        this.preloadMap = _genIterativeFunction('preloadMap');
        /**
         Вызывает beforeViewer() у всех плагинов
         @memberOf PluginsManager
         @name beforeViewer
         @method
        */

        this.beforeViewer = _genIterativeFunction('beforeViewer');
        /**
         Вызывает afterViewer() у всех плагинов
         @memberOf PluginsManager
         @name afterViewer
         @method
        */

        this.afterViewer = _genIterativeFunction('afterViewer');
        /**
         Добавляет пункты меню всех плагинов к меню upMenu
         Устарело! Используйте непосредственное добавление элемента к меню из afterViewer()
         @method
         @ignore
        */

        this.addMenuItems = function (upMenu) {
          for (var p = 0; p < _plugins.length; p++) {
            if (_plugins[p].isUsed() && _plugins[p].body && _plugins[p].body.addMenuItems) {
              var menuItems = _plugins[p].body.addMenuItems();

              for (var i = 0; i < menuItems.length; i++) {
                upMenu.addChildItem(menuItems[i].item, menuItems[i].parentID);
              }
            }
          }
        };
        /**
         Вызывает callback(plugin) для каждого плагина
         @memberOf PluginsManager
         @name forEachPlugin
         @method
         @param {Function} callback Ф-ция для итерирования. Первый аргумент ф-ции - модуль плагина.
        */


        this.forEachPlugin = function (callback) {
          //if (!_initDone) return;
          for (var p = 0; p < _plugins.length; p++) {
            callback(_plugins[p]);
          }
        };
        /**
         Задаёт, нужно ли в дальнейшем использовать данный плагин
         @memberOf PluginsManager
         @name setUsePlugin
         @method
         @param {String} pluginName Имя плагина
         @param {Bool} isInUse Использовать ли его для карты
        */


        this.setUsePlugin = function (pluginName, isInUse) {
          if (pluginName in _pluginsWithName) _pluginsWithName[pluginName].setUsage(isInUse ? 'used' : 'notused');
        };
        /**
         Получить плагин по имени
         @memberOf PluginsManager
         @name getPluginByName
         @method
         @param {String} pluginName Имя плагина
         @returns {IGeomixerPlugin} Модуль плагина, ничего не возвращает, если плагина нет
        */


        this.getPluginByName = function (pluginName) {
          return _pluginsWithName[pluginName];
        };
        /**
         Проверка публичности плагина (можно ли его показывать в различных списках с перечислением подключенных плагинов)
         @memberOf PluginsManager
         @name isPublic
         @method
         @param {String} pluginName Имя плагина
         @returns {Bool} Является ли плагин публичным
        */


        this.isPublic = function (pluginName) {
          return _pluginsWithName[pluginName] && _pluginsWithName[pluginName].isPublic;
        };
        /**
         Обновление параметров плагина
         @memberOf PluginsManager
         @name updateParams
         @method
         @param {String} pluginName Имя плагина
         @param {Object} newParams Новые параметры плагина. Параметры с совпадающими именами будут перезатёрты
        */


        this.updateParams = function (pluginName, newParams) {
          _pluginsWithName[pluginName] && _pluginsWithName[pluginName].updateParams(newParams);
        };
      };

      var publicInterface = {
        PluginsManager: PluginsManager
      };
      gmxCore$1.addModule('PluginsManager', publicInterface);
    })();

    // Методы:
    //   - isHidden(obj) -> Bool
    //   - isSerializable(obj) -> Bool

    nsGmx$1.DrawingObjectCustomControllers = function () {
      var _delegates = [];
      return {
        addDelegate: function addDelegate(delegate) {
          _delegates.push(delegate);
        },
        isHidden: function isHidden(obj) {
          for (var d = 0; d < _delegates.length; d++) {
            if ('isHidden' in _delegates[d] && _delegates[d].isHidden(obj)) return true;
          }

          return false;
        },
        isSerializable: function isSerializable(obj) {
          for (var d = 0; d < _delegates.length; d++) {
            if ('isSerializable' in _delegates[d] && !_delegates[d].isSerializable(obj)) return false;
          }

          return true;
        }
      };
    }();

    !function (_) {
      var BaseLayersControl = function BaseLayersControl(container, blm) {
        var lang = _translationsHash.getLanguage();

        $(container).append('<table class="group-editor-blm-table">' + '<tr>' + '<td class="group-editor-blm-title">' + _gtxt('Доступные подложки') + '</td>' + '<td class="group-editor-blm-title">' + _gtxt('Подложки карты') + '</td>' + '</tr><tr>' + '<td class="group-editor-blm-available"></td>' + '<td class="group-editor-blm-map"></td>' + '</tr>' + '</table>');
        var availContainer = $('<ul class="group-editor-blm-ul"></ul>').appendTo($('.group-editor-blm-available', container));
        var mapContainer = $('<ul class="group-editor-blm-ul"></ul>').appendTo($('.group-editor-blm-map', container));

        var constructItem = function constructItem(id, title) {
          if (title) {
            return $('<li class="group-editor-blm-item">' + title + '</li>').data('baseLayerID', id);
          } else {
            return $('<li class="group-editor-blm-item group-editor-blm-missing-item">' + id + '</li>').data('baseLayerID', id);
          }
        };

        var activeIDs = blm.getActiveIDs();
        blm.getAll().forEach(function (baseLayer) {
          if (activeIDs.indexOf(baseLayer.id) === -1) {
            var item = constructItem(baseLayer.id, baseLayer.options[lang]);
            availContainer.append(item);
          }
        });
        activeIDs.forEach(function (id) {
          var baseLayer = blm.get(id);
          mapContainer.append(constructItem(id, baseLayer && baseLayer.options[lang]));
        });

        var updateBaseLayers = function updateBaseLayers() {
          var activeIDs = [];
          mapContainer.children('li').each(function (index, elem) {
            activeIDs.push($(elem).data('baseLayerID'));
          });
          blm.setActiveIDs(activeIDs);
        };

        mapContainer.sortable({
          connectWith: '.group-editor-blm-available > ul',
          stop: updateBaseLayers
        });
        availContainer.sortable({
          connectWith: '.group-editor-blm-map > ul',
          stop: updateBaseLayers
        });
      };

      var GroupVisibilityPropertiesModel = Backbone.Model.extend({
        defaults: {
          isChildRadio: false,
          isVisibilityControl: false,
          isExpanded: false
        }
      }); //возвращает массив описания элементов таблицы для использования в mapHelper.createPropertiesTable
      //model {GroupVisibilityPropertiesModel} - ассоциированные параметры видимости
      //showVisibilityCheckbox {bool} - добавлять ли возможность скрывать чекбокс видимости или нет

      var GroupVisibilityPropertiesView = function GroupVisibilityPropertiesView(model, showVisibilityCheckbox, showExpanded) {
        var _model = model;

        var boxSwitch = _checkbox$1(!_model.get('isChildRadio'), 'checkbox'),
            radioSwitch = _checkbox$1(_model.get('isChildRadio'), 'radio');

        var showCheckbox = _checkbox$1(_model.get('isVisibilityControl'), 'checkbox');

        var isExpanded = _checkbox$1(_model.get('isExpanded'), 'checkbox');

        showCheckbox.onclick = function () {
          _model.set('isVisibilityControl', this.checked);
        };

        isExpanded.onclick = function () {
          _model.set('isExpanded', this.checked);
        };

        boxSwitch.onclick = function () {
          this.checked = true;
          radioSwitch.checked = !this.checked;

          _model.set('isChildRadio', !this.checked);
        };

        radioSwitch.onclick = function () {
          this.checked = true;
          boxSwitch.checked = !this.checked;

          _model.set('isChildRadio', this.checked);
        };

        var ret = [{
          name: _gtxt("Вид вложенных элементов"),
          field: 'list',
          elem: _div$1([boxSwitch, radioSwitch])
        }];
        if (showVisibilityCheckbox) ret.push({
          name: _gtxt("Показывать чекбокс видимости"),
          elem: _div$1([showCheckbox])
        });
        if (showExpanded) ret.push({
          name: _gtxt("Разворачивать автоматически"),
          elem: _div$1([isExpanded])
        });
        return ret;
      };
      /** Показывает диалог добавления новой подгруппы
        @param div {HTMLNode} - куда добавлять новую подгруппу (группа или карта)
        @param layersTree {layersTree} - дерево главной карты
      */


      var addSubGroup = function addSubGroup(div, layersTree) {
        var ul = _abstractTree.getChildsUl(div.parentNode),
            newIndex;

        if (!ul) newIndex = 0;else newIndex = ul.childNodes.length + 1;
        var groupVisibilityProperties = new GroupVisibilityPropertiesModel();
        var groupVisibilityPropertiesControls = new GroupVisibilityPropertiesView(groupVisibilityProperties, true, true);

        var elemProperties = div.gmxProperties.content ? div.gmxProperties.content.properties : div.gmxProperties.properties,
            newName = elemProperties.title,
            inputIndex = _input$1(null, [['attr', 'value', newName + ' ' + newIndex], ['dir', 'className', 'inputStyle'], ['css', 'width', '140px']]),
            create = makeButton(_gtxt('Создать')),
            pos = nsGmx$1.Utils.getDialogPos(div, true, 100),
            createSubGroup = function createSubGroup() {
          if (inputIndex.value == '') return;

          var parentProperties = div.gmxProperties,
              newGroupProperties = {
            type: 'group',
            content: {
              properties: {
                title: inputIndex.value,
                list: groupVisibilityProperties.get('isChildRadio'),
                visible: true,
                ShowCheckbox: groupVisibilityProperties.get('isVisibilityControl'),
                expanded: groupVisibilityProperties.get('isExpanded'),
                initExpand: groupVisibilityProperties.get('isExpanded'),
                GroupID: nsGmx$1.Utils.generateUniqueID()
              },
              children: []
            }
          },
              li = _layersTree.getChildsList(newGroupProperties, parentProperties, false, div.getAttribute('MapID') ? true : _layersTree.getLayerVisibility($(div).find('input[type="checkbox"]')[0]));

          _queryMapLayers.addDraggable(li);

          _queryMapLayers.addDroppable(li);

          _queryMapLayers.addSwappable(li);

          layersTree.addTreeElem(div, 0, newGroupProperties);

          var childsUl = _abstractTree.getChildsUl(div.parentNode);

          if (childsUl) {
            _abstractTree.addNode(div.parentNode, li);

            _layersTree.updateListType(li, true);

            if (!childsUl.loaded) li.removeNode(true);
          } else {
            _abstractTree.addNode(div.parentNode, li);

            _layersTree.updateListType(li, true);
          }

          $(dialogDiv).dialog('destroy');
          dialogDiv.removeNode(true);

          _mapHelper.updateUnloadEvent(true);
        };

        create.onclick = createSubGroup;
        $(inputIndex).on('keyup', function (e) {
          if (this.value == '') $(this).addClass('error');else $(this).removeClass('error');

          if (e.keyCode === 13) {
            createSubGroup();
            return false;
          }

          return true;
        });
        create.style.marginTop = '5px';

        var parentDiv = _div$1([inputIndex, _br$1(), create], [['css', 'textAlign', 'center']]);

        var trs = [{
          name: _gtxt("Имя группы"),
          elem: inputIndex
        }].concat(groupVisibilityPropertiesControls);

        var trsControls = _mapHelper.createPropertiesTable(trs, elemProperties, {
          leftWidth: 100
        });

        var propsTable = _div$1([_table$1([_tbody$1(trsControls)], [['dir', 'className', 'propertiesTable']])]);

        _(parentDiv, [propsTable, _br$1(), create]);

        var dialogDiv = showDialog$1(_gtxt("Введите имя группы"), parentDiv, 270, 220, pos.left, pos.top);
      };

      var createGroupEditorProperties = function createGroupEditorProperties(div, isMap, mainLayersTree) {
        var elemProperties = isMap ? div.gmxProperties.properties : div.gmxProperties.content.properties;

        var rawTree = mainLayersTree.treeModel.getRawTree();

        var title = _input$1(null, [['attr', 'value', typeof elemProperties.title != 'undefined' ? elemProperties.title : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '206px']]);

        var visibilityProperties = new GroupVisibilityPropertiesModel({
          isChildRadio: elemProperties.list,
          isVisibilityControl: typeof elemProperties.ShowCheckbox === 'undefined' ? false : elemProperties.ShowCheckbox,
          isExpanded: typeof elemProperties.initExpand === 'undefined' ? false : elemProperties.initExpand
        });
        var visibilityPropertiesView = GroupVisibilityPropertiesView(visibilityProperties, !isMap, !isMap);
        visibilityProperties.on('change', function () {
          elemProperties.list = visibilityProperties.get('isChildRadio');
          elemProperties.ShowCheckbox = visibilityProperties.get('isVisibilityControl');
          elemProperties.expanded = elemProperties.initExpand = visibilityProperties.get('isExpanded');

          _layersTree.treeModel.updateNodeVisibility(mainLayersTree.findTreeElem(div).elem, null);

          var curBox = div.firstChild;

          if (!elemProperties.ShowCheckbox) {
            curBox.checked = true;
            curBox.style.display = 'none';
            curBox.isDummyCheckbox = true;
          } else {
            curBox.style.display = 'block';
            delete curBox.isDummyCheckbox;
          }

          if (isMap) {
            rawTree.properties = div.gmxProperties.properties;
          } else {
            mainLayersTree.findTreeElem(div).elem.content.properties = div.gmxProperties.content.properties;
          }

          var ul = _abstractTree.getChildsUl(div.parentNode);

          $(ul).children('li').each(function () {
            var box = _layersTree.updateListType(this, true);
          });
        });

        title.onkeyup = function () {
          if (title.value == '') {
            $(title).addClass('error');
            return;
          } else $(title).removeClass('error');

          var span = $(div).find(".groupLayer")[0];
          $(span).empty();

          _(span, [_t$1(title.value)]);

          if (isMap) {
            $('.mainmap-title').text(title.value);
            div.gmxProperties.properties.title = title.value;
            rawTree.properties = div.gmxProperties.properties;
          } else {
            div.gmxProperties.content.properties.title = title.value;
            mainLayersTree.findTreeElem(div).elem.content.properties = div.gmxProperties.content.properties;
          }

          return true;
        };

        var addProperties = function addProperties(shownProperties) {
          return _mapHelper.createPropertiesTable(shownProperties, elemProperties, {
            leftWidth: 100
          });
        };

        if (isMap) {
          var useAPI = _checkbox$1(elemProperties.UseKosmosnimkiAPI, 'checkbox'),
              useOSM = _checkbox$1(elemProperties.UseOpenStreetMap, 'checkbox'),
              defLang = $('<span class="defaultMapLangContainer">' + '<label><input type="radio" name="defLang" value="rus">rus</label>' + '<label><input type="radio" name="defLang" value="eng">eng</label>' + '</span>')[0],
              distUnit = $('<span class="defaultMapLangContainer">' + '<label><input type="radio" name="distUnit" value="auto">' + _gtxt('units.auto') + '</label>' + '<label><input type="radio" name="distUnit" value="m">' + _gtxt('units.m') + '</label>' + '<label><input type="radio" name="distUnit" value="km">' + _gtxt('units.km') + '</label>' + '<label><input type="radio" name="distUnit" value="nm">' + _gtxt('units.nm') + '</label>' + '</span>')[0],
              squareUnit = $('<span class="defaultMapLangContainer">' + '<label><input type="radio" name="squareUnit" value="auto">' + _gtxt('units.auto') + '</label>' + '<label><input type="radio" name="squareUnit" value="m2">' + _gtxt('units.m2') + '</label>' + '<label><input type="radio" name="squareUnit" value="ha">' + _gtxt('units.ha') + '</label>' + '<label><input type="radio" name="squareUnit" value="km2">' + _gtxt('units.km2') + '</label>' + '</span>')[0],
              coordinatesFormat = $('<span class="defaultMapLangContainer">' + '<label><input type="radio" name="coordinatesFormat" value="0">' + _gtxt('coords.dd') + '</label>' + '<label><input type="radio" name="coordinatesFormat" value="1">' + _gtxt('coords.dms') + '</label>' + '</span>')[0],
              maxPopupCount = $('<span class="maxPopupCountContainer">' + '<input type="number" min="1" class="inputStyle inputShortWidth">' + '</input>' + '</span>')[0],
              layerOrder = $('<select class="selectStyle">' + '<option value="Native">' + _gtxt('layerOrder.native') + '</label>' + '<option value="VectorOnTop">' + _gtxt('layerOrder.vectorOnTop') + '</label>' + '</select>')[0],
              downloadVectors = _checkbox$1(elemProperties.CanDownloadVectors, 'checkbox'),
              downloadRasters = _checkbox$1(elemProperties.CanDownloadRasters, 'checkbox'),
              WMSLink = _a([_t$1(_gtxt('ссылка'))], [['attr', 'href', serverBase + 'TileService.ashx?map=' + elemProperties.name]]),
              WMSLinks = $(Handlebars.compile('<div>' + '<ul>' + '{{#each this.services}}' + '<li>' + '{{this.upper}}: {{this.url}}rest/ver1/service/{{this.name}}?map={{this.mapName}}{{#if this.site}}&apikey=[APIKEY_VALUE]{{/if}}' + '</li>' + '<br>' + '{{/each}}' + '</ul>' + '</div>')({
            services: [{
              site: window.mapsSite,
              url: window.serverBase,
              mapName: elemProperties.MapID,
              name: 'wms',
              upper: 'WMS'
            }, {
              site: window.mapsSite,
              url: window.serverBase,
              mapName: elemProperties.MapID,
              name: 'wfs',
              upper: 'WFS'
            }]
          }))[0],
              WMSAccess = _checkbox$1(elemProperties.WMSAccess, 'checkbox'),
              defLat = _input$1(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.DefaultLat !== null ? elemProperties.DefaultLat : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              defLong = _input$1(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.DefaultLong !== null ? elemProperties.DefaultLong : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              defPermalink = _input$1(null, [['attr', 'value', elemProperties.ViewUrl != null ? elemProperties.ViewUrl : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '206px']]),
              defZoom = _input$1(null, [['attr', 'placeholder', _gtxt("placeholder zoom")], ['attr', 'value', elemProperties.DefaultZoom != null ? elemProperties.DefaultZoom : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '60px']]),
              onLoad = _textarea(null, [['dir', 'className', 'inputStyle group-editor-onload']]),
              copyright = _input$1(null, [['attr', 'value', elemProperties.Copyright != null ? elemProperties.Copyright : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '206px']]),
              minViewX = _input$1(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.MinViewX != null && elemProperties.MinViewX != 0 ? elemProperties.MinViewX : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              minViewY = _input$1(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.MinViewY != null && elemProperties.MinViewY != 0 ? elemProperties.MinViewY : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              maxViewX = _input$1(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.MaxViewX != null && elemProperties.MaxViewX != 0 ? elemProperties.MaxViewX : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              maxViewY = _input$1(null, [['attr', 'placeholder', _gtxt("placeholder degrees")], ['attr', 'value', elemProperties.MaxViewY != null && elemProperties.MaxViewY != 0 ? elemProperties.MaxViewY : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              minZoom = _input$1(null, [['attr', 'placeholder', _gtxt("placeholder minZoom")], ['attr', 'value', elemProperties.MinZoom != null ? elemProperties.MinZoom : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]),
              maxZoom = _input$1(null, [['attr', 'placeholder', _gtxt("placeholder maxZoom")], ['attr', 'value', elemProperties.MaxZoom != null ? elemProperties.MaxZoom : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '62px']]);

          onLoad.value = nsGmx$1.mappletLoader.get();

          useAPI.onclick = function () {
            div.gmxProperties.properties.UseKosmosnimkiAPI = this.checked;
            rawTree.properties = div.gmxProperties.properties;
          };

          $([useAPI, useOSM]).addClass('propertiesTable-checkbox');
          $('input[value=' + elemProperties.DefaultLanguage + ']', defLang).attr('checked', 'checked');
          $('input[value=' + elemProperties.DistanceUnit + ']', distUnit).attr('checked', 'checked');
          $('input[value=' + elemProperties.SquareUnit + ']', squareUnit).attr('checked', 'checked');
          $('input[value=' + elemProperties.coordinatesFormat + ']', coordinatesFormat).attr('checked', 'checked');
          $('input', maxPopupCount).val(elemProperties.maxPopupContent);
          $('option[value=' + (elemProperties.LayerOrder || 'Native') + ']', layerOrder).attr('selected', 'selected');
          $('input', defLang).change(function () {
            div.gmxProperties.properties.DefaultLanguage = this.value;
            rawTree.properties = div.gmxProperties.properties;
          });
          $('input', distUnit).change(function () {
            div.gmxProperties.properties.DistanceUnit = this.value;
            rawTree.properties = div.gmxProperties.properties;
            nsGmx$1.leafletMap.options.distanceUnit = this.value;
          });
          $('input', squareUnit).change(function () {
            div.gmxProperties.properties.SquareUnit = this.value;
            rawTree.properties = div.gmxProperties.properties;
            nsGmx$1.leafletMap.options.squareUnit = this.value;
          });
          $('input', coordinatesFormat).change(function () {
            var num = Number(this.value),
                locationControl = nsGmx$1.leafletMap.gmxControlsManager.get('location');

            if (locationControl) {
              locationControl.setCoordinatesFormat(num);
            }

            nsGmx$1.leafletMap.options.coordinatesFormat = num;
            div.gmxProperties.properties.coordinatesFormat = num;
          });
          $('input', maxPopupCount).change(function () {
            if (Number(this.value) > 0) {
              div.gmxProperties.properties.maxPopupContent = this.value;
              rawTree.properties = div.gmxProperties.properties;
              nsGmx$1.leafletMap.options.maxPopupCount = this.value;
            }
          });
          $(layerOrder).change(function () {
            div.gmxProperties.properties.LayerOrder = this.value;
            rawTree.properties = div.gmxProperties.properties;
          });

          useOSM.onclick = function () {
            div.gmxProperties.properties.UseOpenStreetMap = this.checked;
            rawTree.properties = div.gmxProperties.properties;
          };

          downloadVectors.onclick = function () {
            div.gmxProperties.properties.CanDownloadVectors = this.checked;
            rawTree.properties = div.gmxProperties.properties;
          };

          downloadRasters.onclick = function () {
            div.gmxProperties.properties.CanDownloadRasters = this.checked;
            rawTree.properties = div.gmxProperties.properties;
          };

          WMSAccess.onclick = function () {
            div.gmxProperties.properties.WMSAccess = this.checked;
            rawTree.properties = div.gmxProperties.properties;
            $(WMSLinks).toggle(this.checked);
          };

          defLat.onkeyup = function () {
            div.gmxProperties.properties.DefaultLat = this.value === '' || isNaN(Number(this.value)) ? null : Number(this.value);
            rawTree.properties = div.gmxProperties.properties;
            return true;
          };

          defLong.onkeyup = function () {
            div.gmxProperties.properties.DefaultLong = this.value === '' || isNaN(Number(this.value)) ? null : Number(this.value);
            rawTree.properties = div.gmxProperties.properties;
            return true;
          };

          defPermalink.onkeyup = function () {
            div.gmxProperties.properties.ViewUrl = this.value;
            rawTree.properties = div.gmxProperties.properties;
            return true;
          };

          defZoom.onkeyup = function () {
            div.gmxProperties.properties.DefaultZoom = this.value === '' || isNaN(Number(this.value)) ? null : Number(this.value);
            rawTree.properties = div.gmxProperties.properties;
            return true;
          };

          onLoad.onkeyup = function () {
            nsGmx$1.mappletLoader.set(this.value);
            return true;
          };

          copyright.onkeyup = function () {
            div.gmxProperties.properties.Copyright = this.value;
            rawTree.properties = div.gmxProperties.properties;
            return true;
          };

          minViewX.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MinViewX = Number(this.value);
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          minViewY.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MinViewY = Number(this.value);
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          maxViewX.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MaxViewX = Number(this.value);
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          maxViewY.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MaxViewY = Number(this.value);
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          minZoom.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MinZoom = Number(this.value) || null;
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          maxZoom.onkeyup = function () {
            if (!isNaN(Number(this.value))) {
              div.gmxProperties.properties.MaxZoom = Number(this.value) || null;
              rawTree.properties = div.gmxProperties.properties;
            }

            return true;
          };

          WMSAccess.style.verticalAlign = "middle";
          $(WMSLinks).toggle(elemProperties.WMSAccess);
          var shownCommonProperties = [{
            name: _gtxt("Имя"),
            field: 'title',
            elem: title
          }, {
            name: _gtxt("ID"),
            field: 'name'
          }, {
            name: _gtxt("Копирайт"),
            field: 'Copyright',
            elem: copyright
          }].concat([{
            name: _gtxt("Использовать KosmosnimkiAPI"),
            elem: useAPI
          }, {
            name: _gtxt("Язык по умолчанию"),
            elem: defLang
          }, {
            name: _gtxt("Единицы длины"),
            elem: distUnit
          }, {
            name: _gtxt("Единицы площади"),
            elem: squareUnit
          }, {
            name: _gtxt("Формат координат"),
            elem: coordinatesFormat
          }, {
            name: _gtxt("Количество информационных окошек"),
            elem: maxPopupCount
          }, {
            name: _gtxt("layerOrder.title"),
            elem: layerOrder
          }, {
            name: _gtxt("Ссылка (permalink)"),
            elem: defPermalink
          }]),
              shownPolicyProperties = [{
            name: _gtxt("Разрешить скачивание"),
            elem: _table$1([_tbody$1([_tr$1([_td$1([_t$1(_gtxt('Векторных слоев'))], [['css', 'width', '100px'], ['css', 'height', '20px'], ['css', 'paddingLeft', '3px']]), _td$1([downloadVectors])]), _tr$1([_td$1([_t$1(_gtxt('Растровых слоев'))], [['css', 'width', '100px'], ['css', 'height', '20px'], ['css', 'paddingLeft', '3px']]), _td$1([downloadRasters])])])])
          }, {
            name: _gtxt("WMS доступ"),
            elem: _div$1([WMSAccess
            /*, WMSLinks*/
            ])
          }],
              shownViewProperties = [{
            name: _gtxt("Начальная позиция"),
            elem: _table$1([_tbody$1([_tr$1([_td$1([_span$1([_t$1(_gtxt('Широта'))], [['css', 'marginLeft', '3px']]), _br$1(), defLat], [['css', 'width', '70px']]), _td$1([_span$1([_t$1(_gtxt('Долгота'))], [['css', 'marginLeft', '3px']]), _br$1(), defLong], [['css', 'width', '70px']]), _td$1([_span$1([_t$1(_gtxt('Зум'))], [['css', 'marginLeft', '3px']]), _br$1(), defZoom], [['css', 'width', '68px']])])])], [['css', 'borderCollapse', 'collapse']])
          }, {
            name: _gtxt("Зум"),
            elem: _table$1([_tbody$1([_tr$1([_td$1([_span$1([_t$1(_gtxt('Мин'))], [['css', 'marginLeft', '3px']]), _br$1(), minZoom], [['css', 'width', '70px']]), _td$1([_span$1([_t$1(_gtxt('Макс'))], [['css', 'marginLeft', '3px']]), _br$1(), maxZoom], [['css', 'width', '70px'], ['css', 'rowspan', '2']])])])], [['css', 'borderCollapse', 'collapse']])
          }, {
            name: _gtxt("Граница обрезки"),
            elem: _table$1([_tbody$1([_tr$1([_td$1([_span$1(null, [['css', 'marginLeft', '3px']]), _br$1()], [['css', 'width', '73px']]), _td$1([_span$1([_t$1(_gtxt('Широта'))], [['css', 'marginLeft', '3px']])], [['css', 'width', '70px']]), _td$1([_span$1([_t$1(_gtxt('Долгота'))], [['css', 'marginLeft', '3px']])], [['css', 'width', '68px']])]), _tr$1([_td$1([_span$1([_t$1(_gtxt('Мин'))], [['css', 'marginLeft', '3px']])]), _td$1([minViewY]), _td$1([minViewX])]), _tr$1([_td$1([_span$1([_t$1(_gtxt('Макс'))], [['css', 'marginLeft', '3px']])]), _td$1([maxViewY]), _td$1([maxViewX])])])], [['css', 'borderCollapse', 'collapse']])
          }];

          var id = 'mapProperties' + String(Math.random()).substring(2, 12),
              tabMenu = _div$1([_ul$1([_li$1([_a([_t$1(_gtxt("Общие"))], [['attr', 'href', '#common' + id]])]), _li$1([_a([_t$1(_gtxt("Подложки"))], [['attr', 'href', '#baselayers' + id]])]), _li$1([_a([_t$1(_gtxt("Доступ"))], [['attr', 'href', '#policy' + id]])]), _li$1([_a([_t$1(_gtxt("Поиск"))], [['attr', 'href', '#search' + id]])]), _li$1([_a([_t$1(_gtxt("Окно карты"))], [['attr', 'href', '#view' + id]])]), _li$1([_a([_t$1(_gtxt("Загрузка"))], [['attr', 'href', '#onload' + id]])]), _li$1([_a([_t$1(_gtxt("Плагины"))], [['attr', 'href', '#plugins' + id]])])])]),
              divCommon = _div$1(null, [['attr', 'id', 'common' + id], ['css', 'width', '320px']]),
              divBaseLayers = _div$1(null, [['attr', 'id', 'baselayers' + id], ['dir', 'className', 'group-editor-tab-container'], ['css', 'overflowY', 'auto']]),
              divPolicy = _div$1(null, [['attr', 'id', 'policy' + id], ['css', 'width', '320px']]),
              divSearch = _div$1(null, [['attr', 'id', 'search' + id], ['dir', 'className', 'group-editor-tab-container']]),
              divView = _div$1(null, [['attr', 'id', 'view' + id], ['css', 'width', '320px']]),
              divOnload = _div$1(null, [['attr', 'id', 'onload' + id], ['dir', 'className', 'group-editor-tab-container']]),
              divPlugins = _div$1(null, [['attr', 'id', 'plugins' + id], ['dir', 'className', 'group-editor-tab-container']]);

          _(tabMenu, [divCommon, divBaseLayers, divPolicy, divSearch, divView, divOnload, divPlugins]);

          var baseLayersControl = new BaseLayersControl(divBaseLayers, nsGmx$1.leafletMap.gmxBaseLayersManager);

          _(divCommon, [_table$1([_tbody$1(addProperties(shownCommonProperties))], [['css', 'width', '100%'], ['dir', 'className', 'propertiesTable']])]);

          _(divPolicy, [_table$1([_tbody$1(addProperties(shownPolicyProperties))], [['css', 'width', '100%'], ['dir', 'className', 'propertiesTable']]), WMSLinks]);

          _(divView, [_table$1([_tbody$1(addProperties(shownViewProperties))], [['css', 'width', '100%'], ['dir', 'className', 'propertiesTable']])]);

          _(divOnload, [onLoad]);

          var pluginsEditor = nsGmx$1.createPluginsEditor(divPlugins, _mapHelper.mapPlugins);
          var mapLayersTree = new layersTree({
            showVisibilityCheckbox: false,
            allowActive: false,
            allowDblClick: false,
            showStyle: false,
            visibilityFunc: function visibilityFunc(props, isVisible) {
              var origTreeNode = mainLayersTree.treeModel.findElem('LayerID', props.LayerID).elem;
              origTreeNode.content.properties.AllowSearch = isVisible;
            }
          }); //формируем новое дерево - без не-векторных слоёв и пустых папок,
          //в котором видимость слоя отражает возможность его скачивания

          var searchRawTree = mainLayersTree.treeModel.cloneRawTree(function (node) {
            if (node.type === 'layer') {
              var props = node.content.properties;

              if (props.type !== 'Vector') {
                return null;
              }

              props.visible = !!props.AllowSearch;
              return node;
            }

            if (node.type === 'group') {
              var children = node.content.children;

              if (!children.length) {
                return null;
              }

              var isVisible = false;

              for (var i = 0; i < children.length; i++) {
                isVisible = isVisible || children[i].content.properties.visible;
              }

              node.content.properties.visible = isVisible;
              return node;
            }
          });
          var mapLayersDOM = mapLayersTree.drawTree(searchRawTree, 2);
          $('<div class="group-editor-search-title"/>').text(_gtxt('Выберите слои для поиска по атрибутам')).appendTo(divSearch);
          $(mapLayersDOM).treeview().appendTo(divSearch);

          tabMenu.updateFunc = function () {
            var props = div.gmxProperties.properties;
            props.UseKosmosnimkiAPI = useAPI.checked;
            props.UseOpenStreetMap = useOSM.checked;
            props.CanDownloadVectors = downloadVectors.checked;
            props.CanDownloadRasters = downloadRasters.checked;
            props.WMSAccess = WMSAccess.checked;
            props.DefaultLat = isNaN(Number(defLat.value)) || defLat.value === '' ? null : Number(defLat.value);
            props.DefaultLong = isNaN(Number(defLong.value)) || defLong.value === '' ? null : Number(defLong.value);
            props.ViewUrl = defPermalink.checked;
            props.DefaultZoom = isNaN(Number(defZoom.value)) || defZoom.value === '' ? null : Number(defZoom.value);
            props.onLoad = onLoad.value;
            props.Copyright = copyright.value;
            props.MinViewX = isNaN(Number(minViewX.value)) ? null : Number(minViewX.value);
            props.MinViewY = isNaN(Number(minViewY.value)) ? null : Number(minViewY.value);
            props.MaxViewX = isNaN(Number(maxViewX.value)) ? null : Number(maxViewX.value);
            props.MaxViewY = isNaN(Number(maxViewY.value)) ? null : Number(maxViewY.value);
            props.MaxZoom = isNaN(Number(maxZoom.value)) ? null : Number(maxZoom.value) || null;
            props.MinZoom = isNaN(Number(minZoom.value)) ? null : Number(minZoom.value) || null;
            rawTree.properties = props;
            pluginsEditor.update();
          };

          tabMenu.closeFunc = function () {
            pluginsEditor.closeParamsDialogs();
          };

          return tabMenu;
        } else {
          var shownProperties = [{
            name: _gtxt("Имя"),
            field: 'title',
            elem: title
          }, {
            name: _gtxt("ID"),
            field: 'GroupID'
          }].concat(visibilityPropertiesView);
          return _div$1([_table$1([_tbody$1(addProperties(shownProperties))], [['css', 'width', '100%']])], [['css', 'width', '320px'], ['dir', 'className', 'propertiesTable']]);
        }
      };

      var _groupEditorsHash = {};
      /** Создаёт диалог редактирование свойств группы. Есть проверка на создание дублирующих диалогов
       @param div {HTMLHNode} - элемент дерева, соответствующий редактируемой группе
      */

      var createGroupEditor = function createGroupEditor(div) {
        var elemProperties = div.gmxProperties.content.properties;
        if (_groupEditorsHash[elemProperties.GroupID]) return;

        var pos = nsGmx$1.Utils.getDialogPos(div, true, 140),
            closeFunc = function closeFunc() {
          delete _groupEditorsHash[elemProperties.GroupID];
          return false;
        };

        var canvas = createGroupEditorProperties(div, false, _layersTree);
        showDialog$1(_gtxt('Группа [value0]', elemProperties.title), canvas, 340, 230, pos.left, pos.top, null, closeFunc);
        _groupEditorsHash[elemProperties.GroupID] = true;
        canvas.parentNode.style.width = canvas.clientWidth + 'px';
      };

      window._mapEditorsHash = {};
      /** Создаёт диалог редактирование свойств группы. Есть проверка на создание дублирующих диалогов
       @param div {HTMLHNode} - элемент дерева, соответствующий редактируемой карте
      */

      var createMapEditor = function createMapEditor(div, activePage) {
        var elemProperties = div.gmxProperties.properties;

        if (_mapEditorsHash[elemProperties.MapID]) return;

        var pos = nsGmx$1.Utils.getDialogPos(div, true, 530),
            closeFunc = function closeFunc() {
          delete _mapEditorsHash[elemProperties.MapID];
          canvas.updateFunc();
          canvas.closeFunc();
          return false;
        };

        var canvas = createGroupEditorProperties(div, true, _layersTree);
        showDialog$1(_gtxt('Карта [value0]', elemProperties.title), canvas, 450, 410, pos.left, pos.top, null, closeFunc);
        _mapEditorsHash[elemProperties.MapID] = {
          update: canvas.updateFunc
        };
        $(canvas).tabs({
          active: activePage || 0
        });
        canvas.parentNode.style.width = canvas.clientWidth + 'px';
      };

      gmxCore.addModule('GroupEditor', {
        addSubGroup: addSubGroup,
        createGroupEditor: createGroupEditor,
        createMapEditor: createMapEditor
      });
    }(nsGmx$1.Utils._);

    (function (_) {
      /** Разнообразные вспомогательные контролы (базовые элементы GUI)
          @namespace nsGmx.Controls
      */
      nsGmx$1.Controls = {
        /** Создаёт контрол выбора цвета */
        createColorPicker: function createColorPicker(color, showFunc, hideFunc, changeFunc) {
          var colorPicker = _div$1(null, [['dir', 'className', 'colorSelector'], ['css', 'backgroundColor', nsGmx$1.Utils.convertColor(color)]]);

          $(colorPicker).ColorPicker({
            color: nsGmx$1.Utils.convertColor(color),
            onShow: showFunc,
            onHide: hideFunc,
            onChange: changeFunc
          });

          _title$1(colorPicker, _gtxt("Цвет"));

          return colorPicker;
        },

        /** Создаёт иконку по описанию стиля слоя и типа геометрии
           */
        createGeometryIcon: function createGeometryIcon(parentStyle, type) {
          var icon = _div$1(null, [['css', 'display', 'inline-block'], ['dir', 'className', 'colorIcon'], ['attr', 'styleType', 'color']]);

          if (window.newStyles) {
            if (type.indexOf('linestring') < 0) {
              if (parentStyle.fill && parentStyle.fill.pattern) {
                var opaqueStyle = L.gmxUtil.fromServerStyle($.extend(true, {}, parentStyle, {
                  fill: {
                    opacity: 100
                  }
                })),
                    patternData = L.gmxUtil.getPatternIcon(null, opaqueStyle);
                icon = patternData ? patternData.canvas : document.createElement('canvas');

                _(icon, [], [['dir', 'className', 'icon'], ['attr', 'styleType', 'icon'], ['css', 'width', '13px'], ['css', 'height', '13px']]);
              } else {
                var fill = _div$1(null, [['dir', 'className', 'fillIcon'], ['css', 'backgroundColor', parentStyle.fillColor ? color2Hex(parentStyle.fillColor) : "#FFFFFF"]]),
                    fillOpacity = typeof parentStyle.fillOpacity !== 'undefined' ? parentStyle.fillOpacity : 1,
                    border = _div$1(null, [['dir', 'className', 'borderIcon'], ['attr', 'styleType', 'color'], ['css', 'borderColor', parentStyle.color ? color2Hex(parentStyle.color) : "#0000FF"]]),
                    borderOpacity = typeof parentStyle.opacity !== 'undefined' ? parentStyle.opacity : 1;

                fill.style.opacity = fillOpacity;
                border.style.opacity = borderOpacity;

                if (type.indexOf('point') > -1) {
                  border.style.height = '5px';
                  fill.style.height = '5px';
                  border.style.width = '5px';
                  fill.style.width = '5px';
                  border.style.top = '3px';
                  fill.style.top = '4px';
                  border.style.left = '1px';
                  fill.style.left = '2px';
                }

                _(icon, [border, fill]);
              }
            } else {
              var _border = _div$1(null, [['dir', 'className', 'borderIcon'], ['attr', 'styleType', 'color'], ['css', 'borderColor', parentStyle.color ? color2Hex(parentStyle.color) : "#0000FF"]]),
                  _borderOpacity = parentStyle.opacity !== 'undefined' ? parentStyle.opacity : 1;

              _border.style.opacity = _borderOpacity;
              _border.style.width = '4px';
              _border.style.height = '13px';
              _border.style.borderTop = 'none';
              _border.style.borderBottom = 'none';
              _border.style.borderLeft = 'none';

              _(icon, [_border]);
            }
          } else {
            if (type.indexOf('linestring') < 0) {
              if (parentStyle.fill && parentStyle.fill.pattern) {
                var _opaqueStyle = L.gmxUtil.fromServerStyle($.extend(true, {}, parentStyle, {
                  fill: {
                    opacity: 100
                  }
                })),
                    _patternData = L.gmxUtil.getPatternIcon(null, _opaqueStyle);

                icon = _patternData ? _patternData.canvas : document.createElement('canvas');

                _(icon, [], [['dir', 'className', 'icon'], ['attr', 'styleType', 'icon'], ['css', 'width', '13px'], ['css', 'height', '13px']]);
              } else {
                var _fill = _div$1(null, [['dir', 'className', 'fillIcon'], ['css', 'backgroundColor', parentStyle.fill && typeof parentStyle.fill.color != 'undefined' ? nsGmx$1.Utils.convertColor(parentStyle.fill.color) : "#FFFFFF"]]),
                    _border2 = _div$1(null, [['dir', 'className', 'borderIcon'], ['attr', 'styleType', 'color'], ['css', 'borderColor', parentStyle.outline && typeof parentStyle.outline.color != 'undefined' ? nsGmx$1.Utils.convertColor(parentStyle.outline.color) : "#0000FF"]]),
                    _fillOpacity = parentStyle.fill && typeof parentStyle.fill.opacity != 'undefined' ? parentStyle.fill.opacity : 100,
                    _borderOpacity2 = parentStyle.outline && typeof parentStyle.outline.opacity != 'undefined' ? parentStyle.outline.opacity : 100;

                _fill.style.opacity = _fillOpacity / 100;
                _border2.style.opacity = _borderOpacity2 / 100;

                if (type.indexOf('point') > -1) {
                  _border2.style.height = '5px';
                  _fill.style.height = '5px';
                  _border2.style.width = '5px';
                  _fill.style.width = '5px';
                  _border2.style.top = '3px';
                  _fill.style.top = '4px';
                  _border2.style.left = '1px';
                  _fill.style.left = '2px';
                }

                _(icon, [_border2, _fill]);
              }
            } else {
              var _border3 = _div$1(null, [['dir', 'className', 'borderIcon'], ['attr', 'styleType', 'color'], ['css', 'borderColor', parentStyle.outline && typeof parentStyle.outline.color != 'undefined' ? nsGmx$1.Utils.convertColor(parentStyle.outline.color) : "#0000FF"]]),
                  _borderOpacity3 = parentStyle.outline && typeof parentStyle.outline.opacity != 'undefined' ? parentStyle.outline.opacity : 100;

              _border3.style.opacity = _borderOpacity3 / 100;
              _border3.style.width = '4px';
              _border3.style.height = '13px';
              _border3.style.borderTop = 'none';
              _border3.style.borderBottom = 'none';
              _border3.style.borderLeft = 'none';

              _(icon, [_border3]);
            }
          }

          icon.oncontextmenu = function (e) {
            return false;
          };

          return icon;

          function color2Hex(color) {
            if (typeof color === 'number') {
              return nsGmx$1.Utils.convertColor(color);
            } else if (typeof color === 'string') {
              if (color.indexOf('#') === -1) {
                return color2Hex(Number(color));
              } else {
                return color;
              }
            }
          }
        },

        /** Создаёт контрол "слайдер".
           */
        createSlider: function createSlider(opacity, changeFunc) {
          var divSlider = _div$1(null, [['css', 'width', '86px'], ['css', 'height', '8px'], ['css', 'border', '1px solid #cdcdcd']]);

          $(divSlider).slider({
            min: 0,
            max: 100,
            step: 1,
            value: opacity,
            slide: function slide(event, ui) {
              changeFunc(event, ui);

              _title$1(divSlider.firstChild, ui.value);
            }
          });
          divSlider.firstChild.style.zIndex = 1;
          divSlider.style.width = '100px';
          divSlider.style.border = 'none';
          divSlider.style.backgroundImage = 'url(img/slider.png)';
          divSlider.firstChild.style.border = 'none';
          divSlider.firstChild.style.width = '12px';
          divSlider.firstChild.style.height = '14px';
          divSlider.firstChild.style.marginLeft = '-6px';
          divSlider.firstChild.style.top = '-3px';
          divSlider.firstChild.style.background = 'transparent url(img/sliderIcon.png) no-repeat';

          divSlider.firstChild.onmouseover = function () {
            divSlider.firstChild.style.backgroundImage = 'url(img/sliderIcon_a.png)';
          };

          divSlider.firstChild.onmouseout = function () {
            divSlider.firstChild.style.backgroundImage = 'url(img/sliderIcon.png)';
          };

          _title$1(divSlider.firstChild, opacity);

          _title$1(divSlider, _gtxt("Прозрачность"));

          return divSlider;
        },
        createInput: function createInput(value, changeFunc) {
          var input = _input$1(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '30px'], ['attr', 'value', value]]);

          input.onkeyup = changeFunc;
          return input;
        },

        /** Создаёт диалог, позволяющий выбрать пользователю один из нарисованных на карте объектов
         * @param {String} name Уникальный идентификатор диалога
         * @param {function(gmxAPI.DrawingObject)} callback Ф-ция, которая вызовется при выборе пользователем одного из объектов
         * @param {Object} [params] Дополнительные параметры диалога
         * @param {String} [params.title] Заголовок диалога
         * @param {String} [params.geomType=null] Ограничения на тип геометрии (POINT, LINESTRING, POLYGON). null - без ограничений
         * @param {String} [params.errorTitle] Заголовок диалога с ошибками (например, если нет объектов)
         * @param {String} [params.errorMessage] Текст диалога с ошибками (например, если нет объектов)
         * @param {Number} [params.width=250] Ширина диалога в пикселях
        */
        chooseDrawingBorderDialog: function chooseDrawingBorderDialog(name, callback, params) {
          var TYPE_CONVERT_DICT = {
            Polyline: 'linestring',
            MultiPolyline: 'linestring',
            Rectangle: 'polygon',
            Polygon: 'polygon',
            MultiPolygon: 'polygon',
            Point: 'point'
          };

          var _params = $.extend({
            title: _gtxt("Выбор контура"),
            geomType: null,
            errorTitle: _gtxt("$$phrase$$_12"),
            errorMessage: _gtxt("$$phrase$$_12"),
            width: 250
          }, params);

          if ($('#drawingBorderDialog' + name).length) return;

          var drawingObjs = [];

          nsGmx$1.leafletMap.gmxDrawing.getFeatures().forEach(function (obj) {
            if (!_params.geomType || TYPE_CONVERT_DICT[obj.getType()] === _params.geomType.toLowerCase()) {
              drawingObjs.push(obj);
            }
          });
          if (!drawingObjs.length) showErrorMessage$1(_params.errorMessage, true, _params.errorTitle);else {
            gmxCore.loadModule('DrawingObjects').done(function (drawing) {
              var canvas = _div$1();

              var collection = new drawing.DrawingObjectCollection(nsGmx$1.leafletMap);

              for (var i = 0; i < drawingObjs.length; i++) {
                collection.Add(drawingObjs[i]);
              }

              var list = new drawing.DrawingObjectList(nsGmx$1.leafletMap, canvas, collection, {
                allowDelete: false,
                editStyle: false,
                showButtons: false,
                click: function click(drawingObject) {
                  callback && callback(drawingObject);
                  removeDialog$1(jDialog);
                }
              });
              var jDialog = nsGmx$1.Utils.showDialog(_params.title, _div$1([canvas], [['attr', 'id', 'drawingBorderDialog' + name], ['dir', 'className', 'drawingObjectsCanvas']]), {
                width: _params.width,
                height: 180
              });
            });
          }
        },

        /**
         Создаёт виджет для управления видимостью (скрытия/показа) других элементов
         Сам виджет представляет из себя изменяющуюся иконку с текстом заголовка рядом с ней
         @class
         @param {String} title - текст заголовка
         @param {DOMElement} titleElem - элемент для размещения самого виджета
         @param {DOMElement|Array[]} managedElems - элементы, видимостью которых будем
         @param {Bool} isCollapsed - начальное состояние виджета
        */
        CollapsibleWidget: function CollapsibleWidget(title, titleElem, managedElems, isCollapsed) {
          //let contentTr = _tr([_td([layerTagsParent], [['dir', 'colSpan', '2']])]);
          var collapseTagIcon = $('<div/>').addClass('collabsible-icon');

          var _isCollapsed = !!isCollapsed;

          managedElems = managedElems || [];
          if (!$.isArray(managedElems)) managedElems = [managedElems];

          var updateElems = function updateElems() {
            for (var iE = 0; iE < managedElems.length; iE++) {
              $(managedElems[iE]).toggle(!_isCollapsed);
            }
          };

          var updateView = function updateView() {
            collapseTagIcon.toggleClass('collabsible-icon-hidden', _isCollapsed).toggleClass('collabsible-icon-shown', !_isCollapsed);
            updateElems();
          };

          updateView();
          $(titleElem).empty().append(collapseTagIcon, $('<div/>').addClass('collabsible-title').text(title)).click(function () {
            _isCollapsed = !_isCollapsed;
            updateView();
          });

          this.addManagedElements = function (elems) {
            managedElems = managedElems.concat(elems);
            updateElems();
          };

          this.isCollapsed = function () {
            return _isCollapsed;
          };
        },

        /** Показывает аттрибутивную информацию объекта в виде таблички в отдельном диалоге */
        showLayerInfo: function showLayerInfo(layer, obj) {
          var trs = [];
          var typeSpans = {};

          for (var key in obj.properties) {
            var content = _div$1(),
                contentText = String(obj.properties[key]);

            if (contentText.indexOf("http://") == 0 || contentText.indexOf("https://") == 0 || contentText.indexOf("www.") == 0) contentText = "<a href=\"" + contentText + "\" target=\"_blank\">" + contentText + "</a>";
            content.innerHTML = contentText;

            var typeSpan = _span$1([_t$1(key)]);

            typeSpans[key] = typeSpan;
            trs.push(_tr$1([_td$1([typeSpan], [['css', 'width', '30%']]), _td$1([content], [['css', 'width', '70%']])]));
          }

          var title = _span$1(null, [['dir', 'className', 'title'], ['css', 'cursor', 'default']]),
              summary = _span$1(null, [['dir', 'className', 'summary']]),
              div;

          if ($('#layerPropertiesInfo').length) {
            div = $('#layerPropertiesInfo')[0];

            if (!trs.length && !layer.properties.Legend) {
              $(div.parentNode).dialog('close');
              return;
            }

            $(div).empty();

            _(div, [_table$1([_tbody$1(trs)], [['dir', 'className', 'vectorInfoParams']])]);

            if (layer.properties.Legend) {
              var legend = _div$1();

              legend.innerHTML = layer.properties.Legend;

              _(div, [legend]);
            }

            var dialogTitle = div.parentNode.parentNode.firstChild.firstChild;
            $(dialogTitle).empty();

            _(dialogTitle, [_t$1(_gtxt("Слой [value0]", layer.properties.title))]);

            $(div.parentNode).dialog('open');
          } else {
            if (!trs.length && !layer.properties.Legend) return;
            div = _div$1([_table$1([_tbody$1(trs)], [['dir', 'className', 'vectorInfoParams']])], [['attr', 'id', 'layerPropertiesInfo']]);

            if (layer.properties.Legend) {
              var _legend = _div$1();

              _legend.innerHTML = layer.properties.Legend;

              _(div, [_legend]);
            }

            showDialog$1(_gtxt("Слой [value0]", layer.properties.title), div, 360, 'auto', false, false, null, function () {
              return true;
            });
          } //подстраиваем ширину


          setTimeout(function () {
            var dialogDiv = $('#layerPropertiesInfo')[0].parentNode;
            var width = $(div).find('.vectorInfoParams').width();

            if (width > 340) {
              $(dialogDiv).dialog('option', 'width', width + 18);
            }
          }, 100);
          nsGmx$1.TagMetaInfo.loadFromServer(function (tagInfo) {
            for (var _key in typeSpans) {
              if (tagInfo.isTag(_key)) $(typeSpans[_key]).attr('title', tagInfo.getTagDescription(_key));
            }
          });
        }
      };
      gmxCore.addModule('Controls', nsGmx$1.Controls);
    })(nsGmx$1.Utils._);

    //Создание интерфейса редактирования стилей слоя
    !function (_) {
      //явно прописывает все свойства балунов в стиле.
      var applyBalloonDefaultStyle = function applyBalloonDefaultStyle(style) {
        //слой только что создали - всё по умолчанию!
        if (typeof style.BalloonEnable === 'undefined') {
          style.BalloonEnable = true;
          style.DisableBalloonOnClick = false;
          style.DisableBalloonOnMouseMove = true;
        } else {
          //поддержка совместимости - если слой уже был, но новых параметров нет
          if (typeof style.DisableBalloonOnClick === 'undefined') style.DisableBalloonOnClick = false;
          if (typeof style.DisableBalloonOnMouseMove === 'undefined') style.DisableBalloonOnMouseMove = false;
        }

        return style;
      };

      var FillStyleControl = function FillStyleControl(initStyle, params) {
        var _params = $.extend({
          showSelectors: true
        }, params);

        var _fillStyle = $.extend(true, {
          fill: {
            color: 0xFFFFFF,
            opacity: 50,
            image: "",
            pattern: {
              width: 8,
              step: 0,
              colors: [0x000000, 0xFFFFFF],
              style: 'diagonal1'
            }
          }
        }, initStyle).fill;

        var _this = this;

        var selectorDiv = $("<div/>", {
          'class': "fillStyleSelectorDiv"
        });
        var colorContainer = $("<div/>");
        var patternContainer = $("<div/>");
        var imagePatternContainer = $("<div/>");
        var colorIcon = $("<img/>", {
          src: 'img/styles/color.png',
          title: _gtxt("Заливка цветом")
        }).data('type', 'color');
        var patternIcon = $("<img/>", {
          src: 'img/styles/pattern.png',
          title: _gtxt("Заливка штриховкой")
        }).data('type', 'pattern');
        var patternURLIcon = $("<img/>", {
          src: 'img/styles/globe.gif',
          title: _gtxt("Заливка рисунком")
        }).data('type', 'bitmapPattern');
        var controls = {
          "color": {
            icon: colorIcon,
            control: colorContainer
          },
          "pattern": {
            icon: patternIcon,
            control: patternContainer
          },
          "bitmapPattern": {
            icon: patternURLIcon,
            control: imagePatternContainer
          }
        };
        var initFillStyle = initStyle.fill || {};
        var activeFillType = null;
        if ('image' in initFillStyle) activeFillType = 'bitmapPattern';else if ('pattern' in initFillStyle) activeFillType = 'pattern';else //if ('color' in initFillStyle)
          activeFillType = 'color';

        for (var c in controls) {
          if (c == activeFillType) controls[c].icon.addClass('selectedType');else controls[c].control.hide();
        }

        var selectorIconsDiv = $('<div/>').append(colorIcon).append(patternIcon).append(patternURLIcon);
        selectorDiv.append($("<span/>").text(_gtxt("Заливка"))).append($("<br/>"));
        if (_params.showSelectors) selectorDiv.append(selectorIconsDiv);
        $("img", selectorDiv).click(function () {
          activeFillType = $(this).data('type');

          for (var k in controls) {
            if (k === activeFillType) $(controls[k].control).show(500);else $(controls[k].control).hide(500);
          }

          $("img", selectorDiv).removeClass('selectedType');
          $(this).addClass('selectedType');
          $(_this).change();
        });
        var fillColor = _fillStyle.color;
        var fillOpacity = _fillStyle.opacity; //выбор цвета

        var fillColorPicker = nsGmx.Controls.createColorPicker(fillColor, function (colpkr) {
          $(colpkr).fadeIn(500);
          return false;
        }, function (colpkr) {
          $(colpkr).fadeOut(500);
          $(_this).change();
          return false;
        }, function (hsb, hex, rgb) {
          fillColorPicker.style.backgroundColor = '#' + hex;
          fillColor = parseInt("0x" + hex);
          $(_this).change();
        }),
            fillOpacitySlider = nsGmx.Controls.createSlider(fillOpacity, function (event, ui) {
          fillOpacity = ui.value;
          $(_this).change();
        });
        colorContainer.append($("<table/>").append($("<tr/>").append($("<td/>").append(fillColorPicker)).append($("<td/>", {
          'class': 'fillColorOpacity'
        }).append(fillOpacitySlider))));
        var patternURL = new mapHelper.ImageInputControl(_fillStyle.image);
        $(patternURL).change(function () {
          $(_this).change();
        });
        imagePatternContainer.append(patternURL.getControl()); //выбор втроенных паттернов

        var patternTypeIcons = [['horizontal', 'img/styles/horisontal.png'], ['vertical', 'img/styles/vertical.png'], ['diagonal1', 'img/styles/diagonal1.png'], ['diagonal2', 'img/styles/diagonal2.png'], ['circle', 'img/styles/circle.png'], ['cross', 'img/styles/cross.png']];
        var patternStyleSelector = $("<div/>", {
          id: "patternStyleSelector"
        });

        for (var i = 0; i < patternTypeIcons.length; i++) {
          var icon = $('<img/>', {
            src: patternTypeIcons[i][1]
          }).data("style", patternTypeIcons[i][0]);
          patternStyleSelector.append(icon);
          if (patternTypeIcons[i][0] === _fillStyle.pattern.style) icon.addClass('activePatternType');
        }

        $("img", patternStyleSelector).click(function () {
          $("img", patternStyleSelector).removeClass('activePatternType');
          $(this).addClass('activePatternType');
          _fillStyle.pattern.style = $(this).data("style");
          $(_this).change();
        });
        var patternOpacity = _fillStyle.opacity;
        var patternOpacitySlider = nsGmx.Controls.createSlider(_fillStyle.opacity, function (event, ui) {
          patternOpacity = ui.value;
          $(_this).change();
        });
        $(patternOpacitySlider).attr({
          id: "patternOpacitySlider"
        });
        var patternOpacityContainer = $('<div/>', {
          'class': 'patternOpacityContainer'
        }).append($('<table/>').append($('<tr/>').append($('<td/>').append($('<img/>', {
          src: 'img/styles/pattern-opacity.PNG',
          'class': 'opacityIcon'
        }))).append($('<td/>').append(patternOpacitySlider))));
        var widthIcon = $("<img/>", {
          src: 'img/styles/pattern-width.PNG'
        });
        var stepIcon = $("<img/>", {
          src: 'img/styles/pattern-step.PNG',
          'class': 'stepIcon'
        });
        var widthInput = $("<input/>", {
          'class': 'widthInput',
          title: _gtxt("Ширина паттерна")
        }).val(_fillStyle.pattern.width).change(function () {
          $(_this).change();
        });
        var stepInput = $("<input/>", {
          title: _gtxt("Ширина отступа")
        }).val(_fillStyle.pattern.step).change(function () {
          $(_this).change();
        });
        var widthStepInputs = $("<table/>", {
          'class': "widthStepTable"
        }).append($("<tr/>").append($("<td/>").append(widthIcon).append(widthInput)).append($("<td/>").append(stepIcon).append(stepInput)));

        var PatternColorControl = function PatternColorControl(parentDiv, initColors) {
          var _parentDiv = $(parentDiv);

          var _colors = initColors;

          var _this = this;

          var _redraw = function _redraw() {
            _parentDiv.empty();

            var table = $('<table/>', {
              'class': 'patternColorControl'
            });

            for (var k = 0; k < _colors.length; k++) {
              (function (k) {
                if (_colors[k] === null) return;
                var colorPicker = nsGmx.Controls.createColorPicker(_colors[k], function (colpkr) {
                  $(colpkr).fadeIn(500);
                  return false;
                }, function (colpkr) {
                  $(colpkr).fadeOut(500);
                  $(_this).change();
                  return false;
                }, function (hsb, hex, rgb) {
                  colorPicker.style.backgroundColor = '#' + hex;
                  _colors[k] = parseInt('0x' + hex);
                  $(_this).change();
                });
                colorPicker.style.width = '100%';
                var deleteIcon = makeImageButton('img/close.png', 'img/close_orange.png');

                deleteIcon.onclick = function () {
                  _colors[k] = null;

                  _redraw();

                  $(_this).change();
                };

                table.append($("<tr/>").append($("<td/>", {
                  'class': 'patternColorPicker'
                }).append(colorPicker)).append($("<td/>", {
                  'class': 'patternColorDelete'
                }).append(deleteIcon)));
              })(k);
            }

            var addIcon = makeImageButton('img/zoom_plus.png', 'img/zoom_plus_a.png');

            addIcon.onclick = function () {
              var initColor = 0x00FF00;

              for (var c = 0; c < _colors.length; c++) {
                if (_colors[c] !== null) initColor = _colors[c];
              }

              _colors.push(initColor);

              _redraw();

              $(_this).change();
            };

            table.append($("<tr/>").append($("<td/>", {
              'class': 'patternColorPicker'
            })).append($("<td/>").append(addIcon)));

            _parentDiv.append(table);
          };

          _redraw();

          this.getColors = function () {
            var res = [];

            for (var c = 0; c < _colors.length; c++) {
              if (_colors[c] !== null) res.push(_colors[c]);
            }

            return res;
          };
        };

        var patternColorSelector = $("<div/>");
        var patternColorControl = new PatternColorControl(patternColorSelector, _fillStyle.pattern.colors);
        $(patternColorControl).change(function () {
          $(_this).change();
        });
        patternContainer.append(patternStyleSelector).append(patternOpacityContainer).append(widthStepInputs).append(patternColorSelector);
        var fillControlsDiv = $("<div/>", {
          'class': 'fillStyleControls'
        }).append(colorContainer).append(imagePatternContainer).append(patternContainer); //public interface

        this.getSelector = function () {
          return selectorDiv;
        };

        this.getControls = function () {
          return fillControlsDiv;
        };

        this.getFillStyle = function () {
          var fillStyle = {};

          if (activeFillType === 'color') {
            fillStyle.color = fillColor;
            fillStyle.opacity = fillOpacity;
          } else if (activeFillType === 'bitmapPattern') {
            fillStyle.image = patternURL.value();
          } else if (activeFillType === 'pattern') {
            fillStyle.pattern = {
              style: _fillStyle.pattern.style,
              width: parseInt(widthInput.val()),
              step: parseInt(stepInput.val()),
              colors: patternColorControl.getColors()
            };
            fillStyle.opacity = patternOpacity;
          }

          return fillStyle;
        };

        this.setVisibleSelectors = function (isVisible) {
          if (isVisible) selectorIconsDiv.show();else selectorIconsDiv.hide();
        };
      };

      var createFilterEditorInner = function createFilterEditorInner(filter, attrs, elemCanvas) {
        var filterText = _textarea(null, [['dir', 'className', 'inputStyle'], ['css', 'overflow', 'auto'], ['css', 'width', '250px'], ['css', 'height', '50px']]),
            setFilter = function setFilter() {
          var filterNum = getOwnChildNumber(filterText.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode),
              layer = nsGmx.gmxMap.layersByID[elemCanvas.parentNode.gmxProperties.content.properties.name],
              filter = layer.getStyle(filterNum);
          var newStyle = $.extend(true, {}, filter);
          newStyle.Filter = filterText.value;
          layer.setStyle(newStyle, filterNum);
        };

        filterText.value = filter;

        filterText.onkeyup = function () {
          setFilter();
          return true;
        };

        var mapName = elemCanvas.parentNode.gmxProperties.content.properties.mapName,
            layerName = elemCanvas.parentNode.gmxProperties.content.properties.name,
            attrSuggestWidget = new nsGmx.AttrSuggestWidget([filterText], attrs || [], _mapHelper.attrValues[mapName][layerName], setFilter, ['attrs', 'operators']);
        var suggestCanvas = attrSuggestWidget.el[0];

        var div = _div([filterText, suggestCanvas], [['attr', 'filterTable', true]]);

        div.getFilter = function () {
          return filterText.value;
        };

        div.setFilter = function () {
          setFilter();
        };

        return div;
      };

      var createFilterEditor = function createFilterEditor(filterParam, attrs, elemCanvas) {
        var filter = typeof filterParam == 'undefined' ? '' : filterParam,
            props = elemCanvas.parentNode.gmxProperties.content.properties,
            mapName = props.mapName;
        _mapHelper.attrValues[mapName] = _mapHelper.attrValues[mapName] || {};

        if (!_mapHelper.attrValues[mapName][props.name]) {
          var div = _div([_t(_gtxt("Авторизуйтесь для редактирования фильтров"))], [['css', 'padding', '5px 0px 5px 5px'], ['css', 'color', 'red']]);

          div.getFilter = function () {
            return filter;
          };

          div.setFilter = function () {};

          div.setAttribute('filterTable', true);
          return div;
        } else return createFilterEditorInner(filter, attrs, elemCanvas);
      };

      var _balloonEditorId = 0; //identityField - будем исключать из списка аттрибутов, показываемых в балуне, так как это внутренняя техническая информация

      var createBalloonEditor = function createBalloonEditor(balloonParams, attrs, elemCanvas, identityField) {
        applyBalloonDefaultStyle(balloonParams);

        var layerName = elemCanvas.parentNode.gmxProperties.content.properties.name,
            textareaID = 'ballooneditor' + layerName + _balloonEditorId++,
            balloonText = _textarea(null, [['dir', 'className', 'inputStyle balloonEditor'], ['css', 'overflow', 'auto'], ['css', 'width', '251px'], ['css', 'height', '80px'], ['dir', 'id', textareaID]]),
            setBalloon = function setBalloon() {
          var filterNum = getOwnChildNumber(balloonText.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode),
              layer = nsGmx.gmxMap.layersByID[layerName],
              style = layer.getStyle(filterNum);
          var newStyle = $.extend(true, {}, style, div.getBalloonState());
          layer.setStyle(newStyle, filterNum);
        },
            defaultBalloonText = function defaultBalloonText() {
          var sortAttrs = attrs.slice(0),
              text = "";

          for (var i = 0; i < sortAttrs.length; ++i) {
            var key = sortAttrs[i];
            if (key !== identityField) text += "<b>" + key + ":</b> [" + key + "]<br />" + br;
          }

          text += "<br />" + br + "[SUMMARY]";
          return text;
        },
            boxClick = _checkbox(!balloonParams.DisableBalloonOnClick && balloonParams.BalloonEnable, 'checkbox'),
            boxMove = _checkbox(!balloonParams.DisableBalloonOnMouseMove && balloonParams.BalloonEnable, 'checkbox'),
            br = "\n";

        gmxCore.loadModule('TinyMCELoader', window.location.protocol + '//' + window.location.host + window.location.pathname.replace('index.html', '') + 'TinyMCELoader.js', function () {
          tinyMCE.onAddEditor.add(function (mgr, ed) {
            if (ed.id === textareaID) {
              ed.onKeyUp.add(setBalloon);
              ed.onChange.add(setBalloon);
              ed.onClick.add(function () {
                $(suggestWidget.el).fadeOut(300);
              });
            }
          });
        });
        boxClick.className = 'box';

        boxClick.onclick = function () {
          setBalloon();
        };

        boxMove.className = 'box';

        boxMove.onclick = function () {
          setBalloon();
        };

        balloonText.value = balloonParams.Balloon ? balloonParams.Balloon : defaultBalloonText();
        var suggestWidget = new nsGmx.SuggestWidget(attrs ? attrs : [], [balloonText], '[suggest]', setBalloon);

        var divAttr = _div([_t(_gtxt("Атрибут >")), suggestWidget.el], [['dir', 'className', 'suggest-link-container']]);

        divAttr.onclick = function () {
          if (suggestWidget.el.style.display == 'none') $(suggestWidget.el).fadeIn(300);
          return true;
        };

        var setDefaultBalloonText = nsGmx.Utils.makeLinkButton(_gtxt('По умолчанию'));

        setDefaultBalloonText.onclick = function () {
          window.tinyMCE.get(textareaID).setContent(defaultBalloonText());
          setBalloon();
        };

        var suggestCanvas = _table([_tbody([_tr([_td([_div([divAttr], [['css', 'position', 'relative']])]), _td([_div([setDefaultBalloonText], [['css', 'float', 'right']])])])])], [['css', 'margin', '0px 3px'], ['css', 'width', '249px']]);

        var div = _div([_div([boxClick, _span([_t(_gtxt("Показывать при клике"))], [['css', 'marginLeft', '5px']])], [['css', 'margin', '2px 0px 4px 3px']]), _div([boxMove, _span([_t(_gtxt("Показывать при наведении"))], [['css', 'marginLeft', '5px']])], [['css', 'margin', '2px 0px 4px 3px']]), balloonText, suggestCanvas], [['attr', 'balloonTable', true]]);

        div.getBalloon = function () {
          var value = window.tinyMCE && window.tinyMCE.get(textareaID) ? window.tinyMCE.get(textareaID).getContent() : balloonText.value;
          return value == defaultBalloonText() ? '' : value;
        };

        div.getBalloonEnable = function () {
          return boxClick.checked || boxMove.checked;
        };

        div.getBalloonDisableOnClick = function () {
          return boxClick.checked;
        };

        div.getDisableBalloonOnMouseMove = function () {
          return boxMove.checked;
        };

        div.getBalloonState = function () {
          var state = {
            BalloonEnable: boxClick.checked || boxMove.checked,
            DisableBalloonOnClick: !boxClick.checked,
            DisableBalloonOnMouseMove: !boxMove.checked
          };
          var value = window.tinyMCE && window.tinyMCE.get(textareaID) ? window.tinyMCE.get(textareaID).getContent() : balloonText.value;
          if (value !== defaultBalloonText()) state.Balloon = value;
          return state;
        };

        return div;
      };

      var _labelEditorId = 0;

      var createFilter = function createFilter(layer, styleIndex, parentStyle, geometryType, attrs, elemCanvas, ulParent, treeviewFlag) {
        var templateStyle = {};
        $.extend(true, templateStyle, _mapHelper.makeStyle(parentStyle));
        var zoomPropertiesControl = new nsGmx.ZoomPropertiesControl(parentStyle.MinZoom, parentStyle.MaxZoom);

        var filterInput = _textarea([_t(parentStyle.Filter || '')], [['dir', 'className', 'inputStyle'], ['css', 'overflow', 'auto'], ['css', 'margin', '1px 0px'], ['css', 'width', '260px'], ['css', 'height', '40px']]),
            liMinZoom = zoomPropertiesControl.getMinLi(),
            liMaxZoom = zoomPropertiesControl.getMaxLi(),
            ulfilterExpr = _ul([_li([_div()], [['css', 'paddingLeft', '0px'], ['css', 'background', 'none']])]),
            liLabel = _li([_div()], [['css', 'paddingLeft', '0px'], ['css', 'background', 'none']]),
            ulLabel = _ul([liLabel]),
            liBalloon = _li([_div()], [['css', 'paddingLeft', '0px'], ['css', 'background', 'none']]),
            ulBalloon = _ul([liBalloon]),
            liStyle = _li([_div()], [['css', 'paddingLeft', '0px'], ['css', 'background', 'none']]),
            ulStyle = _ul([liStyle]),
            liClusters = _li([_div()], [['css', 'paddingLeft', '0px'], ['css', 'background', 'none']]),
            ulClusters = _ul([liClusters]);
     // currently we don't support clustring

        /*if (geometryType == 'point')
        {
            clusterControl = new nsGmx.ClusterParamsControl(liClusters, parentStyle.clusters);
            $(clusterControl).change(function()
            {
                var filterNum = getOwnChildNumber(ulParent.parentNode.parentNode.parentNode),
                        filter = globalFlashMap.layers[elemCanvas.parentNode.gmxProperties.content.properties.name].filters[filterNum];
                  if (clusterControl.isApplyCluster())
                {
                    filter.setClusters(clusterControl.getClusterStyle());
                }
                else
                {
                    filter.delClusters();
                }
            })
              clusterCheckbox = _checkbox(clusterControl.isApplyCluster(), 'checkbox');
            clusterCheckbox.style.marginTop = '2px';
            clusterCheckbox.onchange = function()
            {
                clusterControl.applyClusters(this.checked);
            }
              if (!clusterControl.isApplyCluster())
            {
                ulClusters.style.display = 'none';
                ulClusters.className = 'hiddenTree';
            }
        }*/
        // zoom


        $(zoomPropertiesControl).change(function () {
          var filterNum = getOwnChildNumber(ulParent.parentNode.parentNode.parentNode),
              layer = nsGmx.gmxMap.layersByID[elemCanvas.parentNode.gmxProperties.content.properties.name],
              style = layer.getStyle(filterNum);
          var newStyle = $.extend(true, {}, style, {
            MinZoom: this.getMinZoom(),
            MaxZoom: this.getMaxZoom()
          });
          layer.setStyle(newStyle, filterNum);
        }); // label

        var fontSizeInput = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'labelParamName', 'FontSize'], ['css', 'width', '26px'], ['attr', 'value', templateStyle.label && templateStyle.label.size || '12']]),
            xShiftInput = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'labelParamName', 'XSfift'], ['css', 'width', '26px'], ['attr', 'value', templateStyle.labelAnchor && templateStyle.labelAnchor[0] || '0']]),
            yShiftInput = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'labelParamName', 'FontSize'], ['css', 'width', '26px'], ['attr', 'value', templateStyle.labelAnchor && -templateStyle.labelAnchor[1] || '0']]),
            checkedLabelColor = typeof templateStyle.label != 'undefined' && typeof templateStyle.label.color != 'undefined' ? templateStyle.label.color : 0x000000,
            checkedLabelHaloColor = typeof templateStyle.label != 'undefined' && typeof templateStyle.label.haloColor != 'undefined' ? templateStyle.label.haloColor : 0xFFFFFF,
            checkedFontSize = typeof templateStyle.label != 'undefined' && typeof templateStyle.label.size != 'undefined' ? templateStyle.label.size : 12,
            checkedXShift = typeof templateStyle.labelAnchor != 'undefined' && _typeof(templateStyle.labelAnchor[0]) ? templateStyle.labelAnchor[0] : 0,
            checkedYShift = typeof templateStyle.labelAnchor != 'undefined' && _typeof(templateStyle.labelAnchor[1]) ? templateStyle.labelAnchor[1] : 0,
            backupLabel = {
          color: checkedLabelColor,
          haloColor: checkedLabelHaloColor,
          size: checkedFontSize,
          dx: checkedXShift,
          dy: checkedYShift
        },
            labelColor = nsGmx.Controls.createColorPicker(checkedLabelColor, function (colpkr) {
          $(colpkr).fadeIn(500);
          return false;
        }, function (colpkr) {
          $(colpkr).fadeOut(500);
          return false;
        }, function (hsb, hex, rgb) {
          labelColor.style.backgroundColor = '#' + hex;

          if (typeof templateStyle.label == 'undefined') {
            templateStyle.label = backupLabel;
          }

          templateStyle.label.color = labelColor.hex = parseInt('0x' + hex);
          checkedLabelColor = labelColor.hex = parseInt('0x' + hex);
          nsGmx.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
        }),
            labelHaloColor = nsGmx.Controls.createColorPicker(checkedLabelHaloColor, function (colpkr) {
          $(colpkr).fadeIn(500);
          return false;
        }, function (colpkr) {
          $(colpkr).fadeOut(500);
          return false;
        }, function (hsb, hex, rgb) {
          labelHaloColor.style.backgroundColor = '#' + hex;

          if (typeof templateStyle.label == 'undefined') {
            templateStyle.label = backupLabel;
          }

          templateStyle.label.haloColor = labelHaloColor.hex = parseInt('0x' + hex);
          checkedLabelHaloColor = labelHaloColor.hex = parseInt('0x' + hex);
          nsGmx.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
        }),
            layerName = elemCanvas.parentNode.gmxProperties.content.properties.name,
            textareaID = 'labeleditor' + layerName + _labelEditorId++,
            labelText = _textarea(null, [['dir', 'className', 'inputStyle labelEditor'], ['attr', 'placeholder', _gtxt("Пример выражения")], ['css', 'overflow', 'auto'], ['css', 'width', '251px'], ['css', 'height', '80px'], ['dir', 'id', textareaID]]);

        _title(labelColor, _gtxt("Цвет шрифта"));

        _title(labelHaloColor, _gtxt("Цвет обводки"));

        _title(fontSizeInput, _gtxt("Размер шрифта"));

        _title(xShiftInput, _gtxt("Смещение по x"));

        _title(yShiftInput, _gtxt("Смещение по y")); // при загрузке выставим в инпуты значения либо template, либо label


        if (templateStyle.labelTemplate) {
          $(labelText).val(templateStyle.labelTemplate);
        } else if (templateStyle.label && templateStyle.label.field) {
          $(labelText).val('[' + templateStyle.label.field + ']');
        }

        if (attrs) {
          var keys = {};
          attrs.forEach(function (attr) {
            keys[attr] = true;
          });
        } // при изменении значения текстового поля меняется labelTemplate
        // если оно равно какому-либо атрибуту, он утанавливается в значение field
        // если же как-то отличается, то перечень атрибутов устанавливается на '';


        var updateLabelText = function updateLabelText() {
          // соберем все значения в квадратных скобках
          var matches = this.value.match(/\[([^\]]+)\]/ig);
          var str = this.value;

          if (matches) {
            for (var i = 0, len = matches.length; i < len; i++) {
              var key1 = matches[i],
                  key = key1.substr(1, key1.length - 2); // отсеиваем случаи, когда в textArea содержится единственный [атрибут]

              if (matches.length === 1 && matches[0] === str && key in keys) {
                // в label передается templateStyle.label.field
                delete templateStyle.labelTemplate;

                if (typeof templateStyle.label == 'undefined') {
                  templateStyle.label = backupLabel;
                  templateStyle.label.field = key;
                } else {
                  templateStyle.label.field = key;
                }

                nsGmx.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
                return;
              } // в других случаях в label передается templateStyle.labelTemplate
              // если внтутри квадратных скобок оказывается какой-то произвольный текст


              if (!(key in keys)) {
                str = str.replace(key1, '');
              }
            }
          }

          if (!str) {
            if (!this.value) {
              delete templateStyle.labelTemplate;
              delete templateStyle.label;
            } else {
              templateStyle.labelTemplate = this.value;
            }
          } else {
            if (typeof templateStyle.label == 'undefined') {
              templateStyle.label = backupLabel;
            }

            templateStyle.labelTemplate = str;
          }

          nsGmx.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
        };

        labelText.onkeyup = updateLabelText;

        fontSizeInput.onkeyup = function () {
          if (typeof templateStyle.label == 'undefined') {
            templateStyle.label = backupLabel;
          }

          templateStyle.label.size = Number(this.value);
          checkedFontSize = Number(this.value);
          nsGmx.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
        };

        xShiftInput.onkeyup = function () {
          if (typeof templateStyle.labelAnchor == 'undefined') {
            templateStyle.labelAnchor = [backupLabel.dx, backupLabel.dy];
          }

          templateStyle.labelAnchor[0] = Number(this.value);
          checkedXShift = Number(this.value);
          nsGmx.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
          layer.setStyle(templateStyle);
        };

        yShiftInput.onkeyup = function () {
          if (typeof templateStyle.labelAnchor == 'undefined') {
            templateStyle.labelAnchor = [backupLabel.dx, backupLabel.dy];
          }

          templateStyle.labelAnchor[1] = -Number(this.value);
          checkedYShift = -Number(this.value);
          nsGmx.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
        };

        var suggestWidget = new nsGmx.SuggestWidget(attrs ? attrs : [], [labelText], '[suggest]', updateLabelText.bind(labelText));

        var divAttr = _div([_t(_gtxt("Атрибут >")), suggestWidget.el], [['dir', 'className', 'suggest-link-container']]);

        divAttr.onclick = function () {
          if (suggestWidget.el.style.display == 'none') $(suggestWidget.el).fadeIn(300);
          return true;
        };

        var suggestCanvas = _table([_tbody([_tr([_td([_div([divAttr], [['css', 'position', 'relative']])])])])], [['css', 'margin', '0px 3px']]);

        _(liLabel.lastChild, [_table([_tbody([_tr([_td([_t(_gtxt("Цвет шрифта"))], [['css', 'width', '100px']]), _td([labelColor])]), _tr([_td([_t(_gtxt("Цвет обводки"))], [['css', 'width', '100px']]), _td([labelHaloColor])]), _tr([_td([_t(_gtxt("Размер шрифта"))], [['css', 'width', '100px']]), _td([fontSizeInput])]), _tr([_td([_t(_gtxt("Смещение по x"))], [['css', 'width', '100px']]), _td([xShiftInput])]), _tr([_td([_t(_gtxt("Смещение по y"))], [['css', 'width', '100px']]), _td([yShiftInput])]), _tr([_td([labelText], [['attr', 'colspan', 4]])]), _tr([_td([divAttr])])])])]);

        if (typeof templateStyle.label == 'undefined') {
          ulLabel.style.display = 'none';
          ulLabel.className = 'hiddenTree';
        } // filter


        var filterEditor = createFilterEditor(parentStyle.Filter, attrs, elemCanvas);

        _(ulfilterExpr.lastChild.lastChild, [filterEditor]);

        if (typeof parentStyle.Filter == 'undefined' || filterEditor.childNodes.length == 1) {
          ulfilterExpr.style.display = 'none';
          ulfilterExpr.className = 'hiddenTree';
        } // balloon


        var balloonEditor = createBalloonEditor(parentStyle, attrs, elemCanvas, elemCanvas.parentNode.gmxProperties.content.properties.identityField);

        _(liBalloon.lastChild, [balloonEditor]);

        if (typeof parentStyle.Balloon == 'undefined') {
          ulBalloon.style.display = 'none';
          ulBalloon.className = 'hiddenTree';
        }

        var bindChangeEvent = function bindChangeEvent() {
          $(resObject).change(function () {
            nsGmx.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
          });
        }; // common


        var symbolsTitle = _div();

        if (nsGmx.AuthManager.isRole(nsGmx.ROLE_ADMIN)) {
          var styleLibIcon = makeImageButton('img/stylelib-main.png', 'img/stylelib-main.png');
          styleLibIcon.style.verticalAlign = 'middle';
          styleLibIcon.style.marginLeft = '5px';
          styleLibIcon.title = _gtxt('Библиотека стилей');

          _(symbolsTitle, [_span([_t(_gtxt("Символика"))], [['css', 'fontSize', '12px']]), styleLibIcon]);

          styleLibIcon.onclick = function () {
            nsGmx.showStyleLibraryDialog('select', geometryType.toUpperCase()).done(function (activeStyleManager) {
              $(activeStyleManager).change(function () {
                var styleFromLib = this.getActiveStyle();

                if (styleFromLib) {
                  templateStyle = styleFromLib;
                  $(liStyle.lastChild).empty();
                  resObject = createStyleEditor(liStyle.lastChild, templateStyle, geometryType, isWindLayer);
                  bindChangeEvent();
                  nsGmx.Utils.setMapObjectStyle(layer, styleIndex, templateStyle);
                }
              });
            });
          };
        } else {
          _(symbolsTitle, [_span([_t(_gtxt("Символика"))], [['css', 'fontSize', '12px']])]);
        }

        _(ulParent, [liMinZoom, liMaxZoom, _li([_div([_span([_t(_gtxt("Фильтр"))], [['css', 'fontSize', '12px']])]), ulfilterExpr]), _li([_div([_span([_t(_gtxt("Подпись"))], [['css', 'fontSize', '12px']])]), ulLabel]), _li([_div([_span([_t(_gtxt("Балун"))], [['css', 'fontSize', '12px']])]), ulBalloon]), _li([symbolsTitle, ulStyle])]);
        /*if (geometryType == 'point')
        {
            _(ulParent, [_li([
                _div([clusterCheckbox,
                _span([_t(_gtxt("Кластеризация"))],[['css','fontSize','12px'], ['css', 'marginLeft', '4px']])]),
                ulClusters
            ])])
        }*/


        if (treeviewFlag) $(ulParent).treeview(); // styles

        var isWindLayer = typeof elemCanvas.parentNode.gmxProperties != 'undefined' && elemCanvas.parentNode.gmxProperties.content.properties.description && String(elemCanvas.parentNode.gmxProperties.content.properties.description).toLowerCase().indexOf('карта ветра') == 0;
        var resObject = createStyleEditor(liStyle.lastChild, templateStyle, geometryType, isWindLayer);
        bindChangeEvent();

        ulParent.parentNode.parentNode.parentNode.getStyle = function () {
          return templateStyle;
        };

        ulParent.parentNode.parentNode.parentNode.getClusterStyle = function () {
          return null;
        };

        ulParent.parentNode.parentNode.parentNode.removeColorPickers = function () {
          $(liStyle.lastChild).find(".colorSelector").each(function () {
            $('#' + $(this).data("colorpickerId")).remove();
          });
          $('#' + $(labelColor).data("colorpickerId")).remove();
        };
      };

      var updateFilterMoveButtons = function updateFilterMoveButtons(filter) {
        var num = getOwnChildNumber(filter),
            upButton = $(filter).find("[filterMoveButton='up']")[0],
            downButton = $(filter).find("[filterMoveButton='down']")[0],
            removeButton = $(filter).find("[filterMoveButton='remove']")[0];
        if (num == 0 || filter.parentNode.childNodes.length == 1) upButton.style.visibility = 'hidden';else upButton.style.visibility = 'visible';
        if (num == filter.parentNode.childNodes.length - 1) downButton.style.visibility = 'hidden';else downButton.style.visibility = 'visible';
        if (num == 0) removeButton.style.visibility = 'hidden';else removeButton.style.visibility = 'visible';
      };

      var attachLoadingFilterEvent = function attachLoadingFilterEvent(filterCanvas, layer, styleIndex, parentStyle, geometryType, attrs, elemCanvas) {
        $(filterCanvas.firstChild.firstChild.firstChild).bind('click', function () {
          var ulFilterParams = _abstractTree.getChildsUl(filterCanvas.firstChild.firstChild);

          if (!ulFilterParams.loaded) {
            ulFilterParams.loaded = true;
            createFilter(layer, styleIndex, parentStyle, geometryType, attrs, elemCanvas, ulFilterParams, true);

            _mapHelper.updateTinyMCE(filterCanvas);
          }
        });
      };

      var createFilterHeader = function createFilterHeader(filtersCanvas, elem, elemCanvas) {
        var addButton = makeLinkButton(_gtxt('Добавить стиль'));

        addButton.onclick = function () {
          if (!_layersTree.getLayerVisibility($(elemCanvas.parentNode).find('input[type="checkbox"]')[0])) {
            _layersTree.treeModel.setNodeVisibility(elemCanvas.parentNode.gmxProperties, true);
          }

          var lastStyle = elemCanvas.parentNode.gmxProperties.content.properties.styles[elemCanvas.parentNode.gmxProperties.content.properties.styles.length - 1],
              newStyle = {},
              defaultStyle = {
            fill: {
              color: 0x0FFFFFF,
              opacity: 20
            },
            outline: {
              color: 255,
              thickness: 1
            }
          },
              layer = nsGmx.gmxMap.layersByID[elem.name];
          lastStyle = lastStyle || {}; //копируем состояние балунов с последнего стиля

          newStyle.Balloon = lastStyle.Balloon || '';
          newStyle.BalloonEnable = !!lastStyle.BalloonEnable;
          newStyle.DisableBalloonOnClick = !!lastStyle.DisableBalloonOnClick;
          newStyle.DisableBalloonOnMouseMove = !!lastStyle.DisableBalloonOnMouseMove; //TODO: вернуть правильные начальные параметры
          //globalFlashMap.balloonClassObject.setBalloonFromParams(newFilter, newStyle);

          newStyle.MinZoom = lastStyle.MinZoom || 1;
          newStyle.MaxZoom = lastStyle.MaxZoom || 21;
          newStyle.RenderStyle = defaultStyle;
          layer.setStyles(layer.getStyles().concat(newStyle));
          var filter = createLoadingFilter(layer, layer.getStyles().length - 1, newStyle, elem.GeometryType.toLowerCase(), elem.attributes, elemCanvas, false);

          _(filtersCanvas, [filter]);

          updateFilterMoveButtons(filter);

          if (filtersCanvas.childNodes.length >= 2) {
            updateFilterMoveButtons(filtersCanvas.childNodes[filtersCanvas.childNodes.length - 2]);
          }

          $(filter.firstChild).treeview();
          attachLoadingFilterEvent(filter, layer, layer.getStyles().length - 1, newStyle, elem.GeometryType.toLowerCase(), elem.attributes, elemCanvas, false);
        };

        addButton.style.marginLeft = '10px';
        return _div([addButton], [['css', 'height', '20px'], ['css', 'padding', '5px']]);
      };

      var swapFilters = function swapFilters(div, firstNum, filterCanvas) {
        var layerName = div.gmxProperties.content.properties.name,
            layer = nsGmx.gmxMap.layersByID[layerName],
            filters = layer.getStyles(),
            newFilters = [];

        for (var i = 0; i < filters.length; i++) {
          if (i < firstNum || i > firstNum + 1) newFilters.push(filters[i]);else if (i == firstNum) newFilters.push(filters[i + 1]);else if (i == firstNum + 1) newFilters.push(filters[i - 1]);
        }

        layer.setStyles(newFilters);
        $(filterCanvas.childNodes[firstNum]).before(filterCanvas.childNodes[firstNum + 1]);
        updateFilterMoveButtons(filterCanvas.childNodes[firstNum]);
        updateFilterMoveButtons(filterCanvas.childNodes[firstNum + 1]);
      };

      var createLoadingFilter = function createLoadingFilter(layer, styleIndex, parentStyle, geometryType, attrs, elemCanvas, openedFlag) {
        var templateStyle = {},
            nameInput = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'paramName', 'Name'], ['css', 'width', '210px'], ['attr', 'value', parentStyle.Name || '']]),
            ulFilterParams = _ul(),
            liFilter = _li([_div([nameInput]), ulFilterParams]),
            ulFilter = _ul([liFilter]),
            filterCanvas = _div([ulFilter], [['dir', 'className', 'filterCanvas']]);

        $.extend(true, templateStyle, _mapHelper.makeStyle(parentStyle));

        _title(nameInput, _gtxt("Имя фильтра"));

        filterCanvas.getStyle = function () {
          return templateStyle;
        };

        filterCanvas.getClusterStyle = function () {
          return parentStyle.clusters;
        };

        filterCanvas.getFilter = function () {
          return parentStyle.Filter;
        };

        filterCanvas.getBalloon = function () {
          return parentStyle.Balloon;
        };

        filterCanvas.getBalloonEnable = function () {
          return typeof parentStyle.BalloonEnable != 'undefined' ? parentStyle.BalloonEnable : true;
        };

        filterCanvas.getBalloonDisableOnClick = function () {
          return parentStyle.DisableBalloonOnClick;
        };

        filterCanvas.getDisableBalloonOnMouseMove = function () {
          return parentStyle.DisableBalloonOnMouseMove;
        };

        filterCanvas.getBalloonState = function () {
          var state = {
            BalloonEnable: !parentStyle.DisableBalloonOnMouseMove || !parentStyle.DisableBalloonOnClick,
            DisableBalloonOnClick: parentStyle.DisableBalloonOnClick,
            DisableBalloonOnMouseMove: parentStyle.DisableBalloonOnMouseMove,
            Balloon: parentStyle.Balloon
          };
          return state;
        };

        filterCanvas.addFilterParams = function (filterParams) {
          filterParams.Name = nameInput.value;
          filterParams.MinZoom = parentStyle.MinZoom;
          filterParams.MaxZoom = parentStyle.MaxZoom;
        };

        filterCanvas.removeColorPickers = function () {};

        if (!openedFlag) {
          ulFilterParams.loaded = false;
          ulFilterParams.style.display = 'none';
          ulFilterParams.className = 'hiddenTree';
        } else {
          ulFilterParams.loaded = true;
          createFilter(layer, styleIndex, parentStyle, geometryType, attrs, elemCanvas, ulFilterParams, false);
        }

        var moveUp = makeImageButton('img/up.png', 'img/up_a.png'),
            moveDown = makeImageButton('img/down.png', 'img/down_a.png');

        moveUp.onclick = function () {
          this.src = 'img/up.png';
          var firstNum = getOwnChildNumber(this.parentNode.parentNode.parentNode.parentNode) - 1;
          swapFilters(elemCanvas.parentNode, firstNum, this.parentNode.parentNode.parentNode.parentNode.parentNode);
        };

        moveDown.onclick = function () {
          this.src = 'img/down.png';
          var firstNum = getOwnChildNumber(this.parentNode.parentNode.parentNode.parentNode);
          swapFilters(elemCanvas.parentNode, firstNum, this.parentNode.parentNode.parentNode.parentNode.parentNode);
        };

        moveUp.style.margin = '0px 1px -3px 2px';
        moveDown.style.margin = '0px 1px -3px 2px';
        moveUp.setAttribute('filterMoveButton', 'up');
        moveDown.setAttribute('filterMoveButton', 'down');

        _title(moveUp, _gtxt("Переместить фильтр вверх"));

        _title(moveDown, _gtxt("Переместить фильтр вниз"));

        _(liFilter.firstChild, [moveDown, moveUp]);

        var remove = makeImageButton('img/closemin.png', 'img/close_orange.png');

        remove.onclick = function () {
          var num = getOwnChildNumber(filterCanvas);
          var filtersParent = filterCanvas.parentNode;
          filterCanvas.removeNode(true);
          updateFilterMoveButtons(filtersParent.childNodes[num - 1]);
          var styles = layer.getStyles().slice();
          styles.splice(styleIndex, 1);
          layer.setStyles(styles);
        };

        remove.setAttribute('filterMoveButton', 'remove');
        remove.style.width = '16px';
        remove.style.height = '16px';
        remove.style.margin = '0px 1px -3px 2px';

        _title(remove, _gtxt("Удалить фильтр"));

        _(liFilter.firstChild, [remove]);

        return filterCanvas;
      };

      var showStyle = function showStyle(elem) {
        var div = $(elem).find("[fade]")[0];
        $(div).fadeIn(300);
      };

      var hideStyle = function hideStyle(elem) {
        var div = $(elem).find("[fade]")[0];
        $(div).fadeOut(300);
      }; //возвращает стили, которые в данный момент введены в DOM-элементе filterCanvas
      //использует структуру DOM-дерева


      var updateStyles = function updateStyles(filterCanvas) {
        var styles = [];

        for (var i = 0; i < filterCanvas.childNodes.length; i++) {
          var filter = filterCanvas.childNodes[i],
              newFilterStyle = {};
          if (!_abstractTree.getChildsUl(filter.firstChild.firstChild).childNodes.length) filter.addFilterParams(newFilterStyle);else {
            $(filter).find("[paramName]").each(function () {
              newFilterStyle[this.getAttribute('paramName')] = this.value;
            });
          }
          var filterValueElem = $(filter).find("[filterTable]").length > 0 ? $(filter).find("[filterTable]")[0] : filter,
              filterValue = filterValueElem.getFilter();
          if (filterValue != '' && filterValue != null) newFilterStyle.Filter = filterValue;
          var balloonValueElem = $(filter).find("[balloonTable]").length > 0 ? $(filter).find("[balloonTable]")[0] : filter,
              balloonValue = balloonValueElem.getBalloon();
          $.extend(newFilterStyle, balloonValueElem.getBalloonState());
          if (newFilterStyle.Filter == '') delete newFilterStyle.Filter;
          if (newFilterStyle.Name == '') delete newFilterStyle.Name;
          newFilterStyle.MinZoom = Number(newFilterStyle.MinZoom);
          newFilterStyle.MaxZoom = Number(newFilterStyle.MaxZoom);
          if (isNaN(newFilterStyle.MinZoom)) newFilterStyle.MinZoom = 1;
          if (isNaN(newFilterStyle.MinZoom)) newFilterStyle.MinZoom = 21;
          newFilterStyle.RenderStyle = filter.getStyle();
          var clusterStyle = filter.getClusterStyle();
          if (clusterStyle) newFilterStyle.clusters = clusterStyle;
          styles.push(newFilterStyle);
        }

        return styles;
      };

      var createStyleEditor = function createStyleEditor(parent, templateStyle, geometryType, isWindLayer) {
        var markerSizeParent = _tr(),
            outlineParent = _tr(),
            fillParent = _tr(),
            iconParent = _tr(),
            outlineTitleTds = [],
            fillTitleTds = [],
            iconTitleTds = [],
            outlineTds = [],
            fillTds = [],
            iconTds = [],
            inputUrl,
            fillToggle,
            outlineToggle,
            iconToggle,
            showIcon,
            showMarker,
            angle,
            scale,
            resObject = {};

        _(parent, [_table([_tbody([outlineParent, markerSizeParent, fillParent, iconParent])])]);

        var fillStyleControl = new FillStyleControl(templateStyle, {
          showSelectors: geometryType !== 'point'
        });
        fillStyleControl.setVisibleSelectors(typeof templateStyle.fill != 'undefined');
        $(fillStyleControl).change(function () {
          var fillStyle = fillStyleControl.getFillStyle();
          templateStyle.fill = fillStyle;
          $(resObject).change();
        });

        showIcon = function showIcon() {
          hideStyle(outlineParent);
          hideStyle(fillParent);
          fillStyleControl.setVisibleSelectors(false);
          fillParent.style.display = 'none';
          showStyle(iconParent);
          templateStyle.marker = {};
          templateStyle.marker.image = inputUrl.value();
          templateStyle.marker.center = true;
          delete templateStyle.outline;
          delete templateStyle.fill;

          if (geometryType == "point") {
            if (isWindLayer) {
              if (angle.value != '') templateStyle.marker.angle = angle.value;
              if (scale.value != '') templateStyle.marker.scale = scale.value;
              templateStyle.marker.color = $(iconParent).find(".colorSelector")[0].hex;
            }

            hideStyle(markerSizeParent);
            markerSizeParent.style.display = 'none';
          }

          if (geometryType != "linestring") {
            fillToggle.disabled = true;
          }

          $(resObject).change();
        };

        showMarker = function showMarker() {
          showStyle(outlineParent);
          showStyle(markerSizeParent);
          markerSizeParent.style.display = '';
          hideStyle(iconParent);

          if (geometryType != "linestring") {
            fillParent.style.display = '';

            if (fillToggle.checked) {
              showStyle(fillParent);
              fillStyleControl.setVisibleSelectors(true);
            }

            if (geometryType == "point") {
              templateStyle.marker = {};
              templateStyle.marker.size = Number($(markerSizeParent).find(".inputStyle").val());
            }

            templateStyle.fill = fillStyleControl.getFillStyle();
            fillToggle.disabled = false;
          }

          if (geometryType != "point" && typeof templateStyle.marker != 'undefined') delete templateStyle.marker;
          templateStyle.outline = {};
          templateStyle.outline.thickness = Number($(outlineParent).find(".inputStyle")[0].value);
          templateStyle.outline.color = $(outlineParent).find(".colorSelector")[0].hex;
          templateStyle.outline.opacity = $($(outlineParent).find(".ui-slider")[0]).slider('option', 'value');
          $(resObject).change();
        };

        outlineToggle = _checkbox(geometryType == "point" && typeof templateStyle.marker != 'undefined' && typeof templateStyle.marker.image == 'undefined' || geometryType != "point" && (typeof templateStyle.marker == 'undefined' || typeof templateStyle.marker != 'undefined' && typeof templateStyle.marker.image == 'undefined'), 'radio');

        outlineToggle.onclick = function () {
          showMarker();
          iconToggle.checked = false;
          this.checked = true;
        };

        outlineTitleTds.push(_td([outlineToggle], [['css', 'width', '20px'], ['css', 'height', '24px']]));
        outlineTitleTds.push(_td([_t(_gtxt("Граница"))], [['css', 'width', '70px']]));
        var outlineColor = nsGmx.Controls.createColorPicker(templateStyle.outline && typeof templateStyle.outline.color != 'undefined' ? templateStyle.outline.color : 0x0000FF, function (colpkr) {
          $(colpkr).fadeIn(500);
          return false;
        }, function (colpkr) {
          $(colpkr).fadeOut(500);
          return false;
        }, function (hsb, hex, rgb) {
          outlineColor.style.backgroundColor = '#' + hex;
          templateStyle.outline = templateStyle.outline || {};
          templateStyle.outline.color = outlineColor.hex = parseInt('0x' + hex);
          $(resObject).change();
        });
        if (templateStyle.outline && typeof templateStyle.outline.color != 'undefined') outlineColor.hex = templateStyle.outline.color;else outlineColor.hex = 0x0000FF;
        outlineTds.push(_td([outlineColor], [['css', 'width', '40px']]));
        var divSlider = nsGmx.Controls.createSlider(templateStyle.outline && typeof templateStyle.outline.opacity != 'undefined' ? templateStyle.outline.opacity : 100, function (event, ui) {
          templateStyle.outline = templateStyle.outline || {};
          templateStyle.outline.opacity = ui.value;
          $(resObject).change();
        });
        outlineTds.push(_td([divSlider], [['css', 'width', '100px'], ['css', 'padding', '4px 5px 3px 5px']]));
        var outlineThick = nsGmx.Controls.createInput(templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined' ? templateStyle.outline.thickness : 2, function () {
          templateStyle.outline = templateStyle.outline || {};
          templateStyle.outline.thickness = Number(this.value);
          $(resObject).change();
          return true;
        });

        _title(outlineThick, _gtxt("Толщина линии"));

        outlineTds.push(_td([outlineThick], [['css', 'width', '30px']]));

        var dashInput = _input(null, [['attr', 'value', templateStyle.outline && typeof templateStyle.outline.dashes != 'undefined' ? templateStyle.outline.dashes : ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '140px']]),
            dashSelect = nsGmx.Utils._select(null, [['dir', 'className', 'selectStyle'], ['css', 'width', '50px'], ['css', 'fontSize', '12px'], ['css', 'fontWeight', 'bold']]),
            borderValues = {
          "1": "",
          "2": "4,4",
          "3": "2,2",
          "4": "6,3,2,3",
          "5": "6,3,2,3,2,3",
          "6": "2,4",
          "7": "6,6",
          "8": "7,6,2,6",
          "9": "8,4,8,4,2,4"
        },
            dashSelector = _div(null, [['dir', 'className', 'colorSelector']]),
            dashTable = _table(null, [['css', 'position', 'absolute'], ['css', 'left', '-1px'], ['css', 'top', '-57px'], ['css', 'zIndex', 2]]),
            dashedTds = [],
            dashFunc = function dashFunc() {
          var arr = dashInput.value.split(","),
              correct = true;

          if (arr.length % 2 == 0) {
            for (var i = 0; i < arr.length; i++) {
              arr[i] = Number(arr[i]);

              if (isNaN(arr[i]) || arr[i] <= 0) {
                correct = false;
                break;
              }
            }
          } else correct = false;

          templateStyle.outline = templateStyle.outline || {};
          if (correct) templateStyle.outline.dashes = arr;else {
            if (templateStyle.outline.dashes) delete templateStyle.outline.dashes;
          }
          $(resObject).change();
        };

        if (geometryType != "point") {
          var dashTrs = [];

          for (var i = 1; i <= 7; i += 3) {
            var dashTds = [];

            for (var j = i; j <= i + 2; j++) {
              var dashTd = _td([_img(null, [['attr', 'src', 'img/dash' + j + '.png']])], [['css', 'border', '1px solid #000000'], ['css', 'cursor', 'pointer']]);

              (function (j) {
                dashTd.onclick = function (e) {
                  dashSelector.style.backgroundImage = 'url(img/dash' + j + '.png)';
                  dashInput.value = borderValues[String(j)];
                  dashFunc();
                  $(dashTable).fadeOut(500);
                  stopEvent(e);
                };
              })(j);

              dashTds.push(dashTd);
            }

            dashTrs.push(_tr(dashTds));
          }

          _(dashTable, [_tbody(dashTrs)]);

          _(dashSelector, [dashTable]);

          dashSelector.onclick = function () {
            $(dashTable).fadeIn(500);
          };

          dashInput.onfocus = dashSelector.onblur = function () {
            $(dashTable).fadeOut(500);
          };

          dashTable.style.display = 'none';
          dashedTds.push(_td([dashSelector]));
          dashedTds.push(_td([dashInput], [['attr', 'colSpan', 2]]));

          for (var borderValue in borderValues) {
            if (borderValues[borderValue] == dashInput.value) {
              dashSelector.style.backgroundImage = 'url(img/dash' + borderValue + '.png)';
              break;
            }
          }

          dashSelect.style.marginLeft = '2px';

          dashInput.onkeyup = function () {
            dashFunc();
            return true;
          };
        } else dashedTds = [_td(), _td(), _td()];

        if (geometryType != "linestring") {
          fillToggle = _checkbox(typeof templateStyle.fill != 'undefined', 'checkbox');

          fillToggle.onclick = function () {
            fillStyleControl.setVisibleSelectors(this.checked);

            if (this.checked) {
              templateStyle.fill = fillStyleControl.getFillStyle();
              showStyle(fillParent);
              $(resObject).change();
            } else {
              hideStyle(fillParent);
              delete templateStyle.fill; // if (elemCanvas.nodeName == 'DIV')
              // $(elemCanvas).find(".fillIcon")[0].style.backgroundColor = "#FFFFFF";

              $(resObject).change();
            }
          };

          fillTitleTds.push(_td([fillToggle], [['css', 'width', '20px'], ['css', 'height', '24px']])); //fillTitleTds.push(_td([_t(_gtxt("Заливка"))],[['css','width','70px']]));

          fillTitleTds.push(_td([fillStyleControl.getSelector()[0]], [['css', 'width', '70px']]));
          var checkedFillColor = typeof templateStyle.fill != 'undefined' && typeof templateStyle.fill.color != 'undefined' ? templateStyle.fill.color : 0xFFFFFF,
              checkedFillOpacity = typeof templateStyle.fill != 'undefined' && typeof templateStyle.fill.opacity != 'undefined' ? templateStyle.fill.opacity : 0,
              fillColor = nsGmx.Controls.createColorPicker(checkedFillColor, function (colpkr) {
            $(colpkr).fadeIn(500);
            return false;
          }, function (colpkr) {
            $(colpkr).fadeOut(500);
            return false;
          }, function (hsb, hex, rgb) {
            fillColor.style.backgroundColor = '#' + hex;
            templateStyle.fill.color = fillColor.hex = parseInt('0x' + hex); // if (elemCanvas.nodeName == 'DIV')
            // $(elemCanvas).find(".fillIcon")[0].style.backgroundColor = '#' + hex;

            $(resObject).change();
          }),
              fillSlider = nsGmx.Controls.createSlider(checkedFillOpacity, function (event, ui) {
            templateStyle.fill.opacity = ui.value;
            $(resObject).change();
          });
          fillColor.hex = checkedFillColor;
          fillTds.push(_td([fillColor], [['css', 'width', '40px']]));
          fillTds.push(_td([fillSlider], [['css', 'width', '100px'], ['css', 'padding', '4px 5px 3px 5px']]));
        }

        iconToggle = _checkbox(templateStyle.marker && typeof templateStyle.marker.image != 'undefined', 'radio');

        iconToggle.onclick = function () {
          showIcon();
          outlineToggle.checked = false;
          this.checked = true;
        };

        iconTitleTds.push(_td([iconToggle], [['css', 'width', '20px'], ['css', 'height', '24px'], ['attr', 'vAlign', 'top'], ['css', 'paddingTop', '5px']]));
        iconTitleTds.push(_td([_t(_gtxt("Маркер URL"))], [['css', 'width', '70px'], ['attr', 'vAlign', 'top'], ['css', 'paddingTop', '5px']]));
        var inputUrl = new mapHelper.ImageInputControl(typeof templateStyle.marker != 'undefined' && templateStyle.marker.image ? templateStyle.marker.image : '');
        $(inputUrl).change(function () {
          if (inputUrl.value() != '') {
            showIcon();
            outlineToggle.checked = false;
            iconToggle.checked = true;
          }

          if (typeof templateStyle.marker == 'undefined') templateStyle.marker = {};
          templateStyle.marker.image = inputUrl.value();
          $(resObject).change();
        });

        if (geometryType == "point") {
          var markerSizeInput = nsGmx.Controls.createInput(templateStyle.marker && templateStyle.marker.size || 3, function () {
            templateStyle.marker = templateStyle.marker || {};
            templateStyle.marker.size = Number(this.value);
            $(resObject).change();
            return true;
          });

          _title(markerSizeInput, _gtxt("Размер точек"));

          var markerSizeTds = [_td(), _td([_t(_gtxt("Размер"))]), _td([markerSizeInput], [['attr', 'fade', true]])];

          _(markerSizeParent, markerSizeTds, [['attr', 'fade', true]]);

          if (isWindLayer) {
            var markerColor = nsGmx.Controls.createColorPicker(templateStyle.marker && typeof templateStyle.marker.color != 'undefined' ? templateStyle.marker.color : 0xFF00FF, function (colpkr) {
              $(colpkr).fadeIn(500);
              return false;
            }, function (colpkr) {
              $(colpkr).fadeOut(500);
              return false;
            }, function (hsb, hex, rgb) {
              markerColor.style.backgroundColor = '#' + hex;
              templateStyle.marker = templateStyle.marker || {};
              templateStyle.marker.color = markerColor.hex = parseInt('0x' + hex);
              $(resObject).change();
            });
            if (templateStyle.marker && typeof templateStyle.marker.color != 'undefined') markerColor.hex = templateStyle.marker.color;else markerColor.hex = 0xFF00FF;
            scale = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'value', templateStyle.marker && templateStyle.marker.scale ? templateStyle.marker.scale : ''], ['css', 'width', '68px']]);

            scale.onkeyup = function () {
              templateStyle.marker = templateStyle.marker || {};
              if (this.value != '') templateStyle.marker.scale = this.value;else delete templateStyle.marker.scale;
              $(resObject).change();
            };

            _title(scale, _gtxt("Масштаб"));

            angle = _input(null, [['dir', 'className', 'inputStyle'], ['attr', 'value', templateStyle.marker && templateStyle.marker.angle ? templateStyle.marker.angle : ''], ['css', 'width', '68px']]);

            angle.onkeyup = function () {
              templateStyle.marker = templateStyle.marker || {};
              if (this.value != '') templateStyle.marker.angle = this.value;else delete templateStyle.marker.angle;
              $(resObject).change();
            };

            _title(angle, _gtxt("Угол поворота"));

            iconTds.push(_td([_table([_tbody([_tr([_td([inputUrl.getControl()], [['attr', 'colSpan', 3]])]), _tr([_td([markerColor], [['css', 'paddingLeft', '1px']]), _td([angle]), _td([scale], [['css', 'paddingRight', '3px']])])])])]));
          } else iconTds.push(_td([inputUrl.getControl()]));
        } else if (geometryType == "polygon" || geometryType == "linestring") {
          //	hide(iconParent);
          iconTds.push(_td([inputUrl.getControl()]));
          if (geometryType == "linestring") hide(fillParent);
        }

        _(outlineParent, outlineTitleTds.concat(_td([_div([_table([_tbody([_tr(outlineTds), _tr(dashedTds)])])], [['attr', 'fade', true]])]))); //_(fillParent, fillTitleTds.concat(_td([_div([_table([_tbody([_tr(fillTds)])])],[['attr','fade',true]])])));


        var topPadding = geometryType === "point" ? "0px" : "10px";
        fillTitleTds = fillTitleTds.concat(_td([fillStyleControl.getControls()[0]], [['attr', 'fade', true], ['css', 'paddingTop', topPadding]]));

        _(fillParent, fillTitleTds);

        _(iconParent, iconTitleTds.concat(_td([_div([_table([_tbody([_tr(iconTds)])])], [['attr', 'fade', true]])])));

        if (templateStyle.marker && typeof templateStyle.marker.image != 'undefined') {
          $(outlineParent).find("[fade]")[0].style.display = 'none';
          $(fillParent).find("[fade]")[0].style.display = 'none';
          $(iconParent).find("[fade]")[0].style.display = '';
        } else {
          $(outlineParent).find("[fade]")[0].lastChild.style.display = '';
          $(fillParent).find("[fade]")[0].style.display = '';
          $(iconParent).find("[fade]")[0].style.display = 'none';
        }

        if (geometryType != "linestring" && typeof templateStyle.fill == 'undefined') $(fillParent).find("[fade]")[0].style.display = 'none';
        return resObject;
      };

      var LayerStylesEditor = function LayerStylesEditor(div, divStyles, openedStyleIndex) {
        var elemProperties = div.gmxProperties.content.properties,
            parentIcon = $(div).children("[styleType]")[0],
            filtersCanvas = _div(null, [['css', 'marginLeft', '10px']]),
            filterHeader = createFilterHeader(filtersCanvas, elemProperties, parentIcon),
            layer = nsGmx.gmxMap.layersByID[elemProperties.name],
            layerStyles = layer.getStyles();

        for (var i = 0; i < layerStyles.length; i++) {
          var filter = createLoadingFilter(layer, i, elemProperties.styles[i], elemProperties.GeometryType, elemProperties.attributes, parentIcon, i == openedStyleIndex);

          _(filtersCanvas, [filter]);

          $(filter.firstChild).treeview();
          attachLoadingFilterEvent(filter, layer, i, elemProperties.styles[i], elemProperties.GeometryType, elemProperties.attributes, parentIcon);
        }

        for (var i = 0; i < filtersCanvas.childNodes.length; i++) {
          updateFilterMoveButtons(filtersCanvas.childNodes[i]);
        }

        _(divStyles, [filterHeader, filtersCanvas]);

        this.getUpdatedStyles = function () {
          return updateStyles(filtersCanvas);
        };

        this.removeColorPickers = function () {
          for (var i = 0; i < filtersCanvas.childNodes.length; i++) {
            filtersCanvas.childNodes[i].removeColorPickers();
          }
        };

        this.getStyleCount = function () {
          return filtersCanvas.childNodes.length;
        };

        this.setAllFilters = function () {
          $(filtersCanvas).find("[filterTable]").each(function () {
            this.setFilter();
          });
        };
      };

      var createStylesDialog = function createStylesDialog(elem, treeView, openedStyleIndex) {
        var div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + elem.LayerID + "']")[0],
            elemProperties = div.gmxProperties.content.properties,
            mapName = elemProperties.mapName,
            layerName = elemProperties.name;

        if (typeof window._mapHelper.layerStylesHash[layerName] !== 'undefined') {
          return;
        }

        window._mapHelper.layerStylesHash[layerName] = true;
        var pos = nsGmx.Utils.getDialogPos(div, true, 390);

        var updateFunc = function updateFunc() {
          var _styles = elemProperties.styles;
          elemProperties.styles = styleEditor.getUpdatedStyles();

          for (var i = 0; i < elemProperties.styles.length; i++) {
            if (_styles[i] && _styles[i]._MinZoom) {
              elemProperties.styles[i]._MinZoom = _styles[i]._MinZoom;
            }
          }

          treeView.findTreeElem(div).elem.content.properties = elemProperties;
        };

        var attributesHash = {};

        for (var i = 0; i < elemProperties.attributes.length; i++) {
          attributesHash[elemProperties.attributes[i]] = [];
        }

        _mapHelper.attrValues[mapName] = _mapHelper.attrValues[mapName] || {};
        _mapHelper.attrValues[mapName][layerName] = new nsGmx.LazyAttributeValuesProviderFromServer(attributesHash, layerName);

        var closeFunc = function closeFunc() {
          updateFunc();
          var newStyles = styleEditor.getUpdatedStyles();
          multiStyleParent = $(div).children('[multiStyle]')[0], parentIcon = $(div).children("[styleType]")[0];
          delete window._mapHelper.layerStylesHash[layerName];
          styleEditor.removeColorPickers();
          var multiFiltersFlag = parentIcon.getAttribute('styleType') == 'multi' && styleEditor.getStyleCount() > 1,
              // было много стилей и осталось
          colorIconFlag = parentIcon.getAttribute('styleType') == 'color' && styleEditor.getStyleCount() == 1 && typeof newStyles[0].RenderStyle.marker != 'undefined' && typeof newStyles[0].RenderStyle.marker.image == 'undefined'; // была не иконка и осталась

          if (multiFiltersFlag) ; else if (colorIconFlag) ; else {
            var newIcon = _mapHelper.createStylesEditorIcon(newStyles, elemProperties.GeometryType.toLowerCase());

            $(parentIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));
          }

          $(multiStyleParent).empty();

          _mapHelper.createMultiStyle(elemProperties, treeView, multiStyleParent);

          gmxCore.loadModule('TinyMCELoader', 'http://' + window.location.host + window.location.pathname.replace('index.html', '') + 'TinyMCELoader.js', function () {
            $('.balloonEditor', divDialog).each(function () {
              tinyMCE.execCommand("mceRemoveControl", true, $(this).attr('id'));
            });
          });
          return false;
        };

        if (div.gmxProperties.content.properties.styles.length == 1) {
          openedStyleIndex = 0;
        } else if (typeof openedStyleIndex === 'undefined') {
          openedStyleIndex = -1;
        }

        var styleContainer = _div();

        var styleEditor = new LayerStylesEditor(div, styleContainer, openedStyleIndex);
        styleEditor.setAllFilters();
        var divDialog = showDialog(_gtxt('Стили слоя [value0]', elem.title), styleContainer, 350, 470, pos.left, pos.top, null, function () {
          closeFunc();
          delete styleDialogs[elemProperties.name];
        });
        styleDialogs[elemProperties.name] = {
          updateFunc: updateFunc
        };
        if (openedStyleIndex > 0) styleContainer.parentNode.scrollTop = 58 + openedStyleIndex * 32;

        _mapHelper.updateTinyMCE(styleContainer);
      };

      var styleDialogs = {};

      var updateAllStyles = function updateAllStyles() {
        for (var name in styleDialogs) {
          styleDialogs[name].updateFunc();
        }
      };

      gmxCore.addModule('LayerStylesEditor', {
        LayerStylesEditor: LayerStylesEditor,
        createStyleEditor: createStyleEditor,
        createStylesDialog: createStylesDialog,
        updateAllStyles: updateAllStyles
      });
    }(nsGmx.Utils._);

    /** Менеджер дополнительных данных карты. Данные собираются и используются набором сборщиков данных, каждый из которых имеет свой уникальный id.
    @class userObjectsManager
    @memberOf nsGmx 
    */
    nsGmx$1.userObjectsManager = {
      _data: {},
      _collectors: {},

      /**
       Устанавливает данные, которые потом могут быть использованы поставщиками данных
      @method
      */
      setData: function setData(data) {
        this._data = data;
      },

      /**
       Возвращает собранные данные
      @method
      */
      getData: function getData() {
        return this._data;
      },

      /**
       Собирает данные со всех сборщиков данных. Собранные данные доступны через метод getData
       @method
      */
      collect: function collect() {
        for (var id in this._collectors) {
          if ('collect' in this._collectors[id]) {
            var data = this._collectors[id].collect();

            if (data !== null) {
              this._data[id] = data;
            }
          }
        }
      },

      /**
      Вызывает метод load() у всех поставщиков данных, для которых есть данные.
       После вызова метода данные для данного загрузчика будут удалены (чтобы предотвратить множественную загрузку)
      @method
      */
      load: function load(dataCollectorNames) {
        var collectors = {};

        if (dataCollectorNames) {
          if (typeof dataCollectorNames === 'string') dataCollectorNames = [dataCollectorNames];

          for (var dc = 0; dc < dataCollectorNames.length; dc++) {
            var name = dataCollectorNames[dc];
            if (name in this._collectors) collectors[name] = this._collectors[name];
          }
        } else collectors = this._collectors;

        for (var id in collectors) {
          if (id in this._data && 'load' in collectors[id]) {
            collectors[id].load(this._data[id]);
            delete this._data[id];
          }
        }
      },

      /**
      Добавляет новый сборщик данных. Если в момент добавления есть какие-нибудь данные для загрузчика, они будут ему сразу же переданы
      @method
       @param collectorId {String} - уникальный идентификатор сборщика данных
       @param collector {Object} - сборщик данных. Должен иметь следующие методы:<br/>
           collect()->Object - возвращает собранные данные. Если данных нет, нужно вернуть null
           load(data)->void - передаёт существующие данные загрузчику
      */
      addDataCollector: function addDataCollector(collectorId, collector) {
        this._collectors[collectorId] = collector;

        if (collectorId in this._data && 'load' in collector) {
          collector.load(this._data[collectorId]);
          delete this._data[collectorId];
        }
      }
    };

    //Отображение закладок карты в левой панели

    nsGmx$1.Controls = nsGmx$1.Controls || {};

    nsGmx$1.Controls.LanguageSelector = function (container, defLang) {
      var LANGUAGES = [{
        lang: 'rus',
        title: 'rus'
      }, {
        lang: 'eng',
        title: 'eng'
      }],
          lang = null,
          _this = this;

      var template = Handlebars.compile('<div class = "language-container">' + '{{#langs}}' + '<span data-lang = "{{lang}}" class="language-item">{{title}}</span>' + '{{/langs}}' + '</div>');
      $(container).empty().append($(template({
        langs: LANGUAGES
      })));

      var update = function update() {
        var newLang = $(this).data('lang'),
            prevLang = lang;

        if (newLang !== prevLang) {
          lang = newLang;
          $(this).addClass('language-selected').siblings().removeClass('language-selected');
          $(_this).trigger('change', [prevLang, newLang]);
        }
      };

      $(container).find('span').click(update);
      update.bind($(container).find('span')[0])();

      this.getLang = function () {
        return lang;
      };
    };

    var queryTabs = function queryTabs() {
      this.builded = false;
      this.tabsCanvas = null;
      this.tabs = [];
    };

    queryTabs.prototype = new leftMenu$1();

    queryTabs.prototype.load = function () {
      if (!this.builded) {
        var _this = this;

        this.tabsCanvas = _div(null, [['dir', 'className', 'tabsCanvas']]);
        this.workCanvas.appendChild(this.tabsCanvas);

        for (var i = 0; i < this.tabs.length; i++) {
          this.draw(this.tabs[i]);
        }

        this.builded = true;
        $(this.tabsCanvas).sortable({
          axis: 'y',
          tolerance: 'pointer',
          containment: 'parent'
        });
        $(this.tabsCanvas).bind('sortupdate', function (event, ui) {
          var orderedTabs = [];
          $(_this.tabsCanvas).children().each(function () {
            orderedTabs.push(this.tabInfo);
          });
          _this.tabs = orderedTabs;
        });
        this.leftPanelItem.hide();
      }
    };

    queryTabs.prototype.add = function (tabInfo, tabIndex) {
      var isNew = typeof tabIndex === 'undefined';
      tabInfo = tabInfo || {
        name_rus: '',
        description_rus: '',
        name_eng: '',
        description_eng: ''
      };

      if (typeof tabInfo.name_rus === 'undefined') {
        tabInfo.name_rus = tabInfo.name;
      }

      if (typeof tabInfo.description_rus === 'undefined') {
        tabInfo.description_rus = tabInfo.description;
      }

      var uiTemplate = Handlebars.compile('<div class = "addtabs-container">' + '<div class = "addtabs-info">{{i "Название"}}</div>' + '<input class = "addtabs-title-input inputStyle" value="{{title}}"><br>' + '<div class = "addtabs-info">{{i "Описание"}}</div>' + '<textarea class = "addtabs-title-description inputStyle">{{description}}</textarea><br>' + '<button class = "addtabs-create">{{buttonTitle}}</button>' + '<div class = "addtabs-lang-placeholder"></div>' + '</div>');
      var titleLoc = {
        rus: tabInfo.name_rus,
        eng: tabInfo.name_eng
      };
      var descrLoc = {
        rus: tabInfo.description_rus,
        eng: tabInfo.description_eng
      };
      var ui = $(uiTemplate({
        title: titleLoc.rus,
        description: descrLoc.rus,
        buttonTitle: isNew ? _gtxt('Создать') : _gtxt('Изменить')
      })),
          titleInput = $('.addtabs-title-input', ui);

      var updateDataLoc = function updateDataLoc(lang) {
        titleLoc[lang] = titleInput.val();
        descrLoc[lang] = $('.addtabs-title-description', ui).val();
      };

      var langControl = new nsGmx$1.Controls.LanguageSelector(ui.find('.addtabs-lang-placeholder'));
      $(langControl).change(function (event, prevLang, newLang) {
        updateDataLoc(prevLang);
        titleInput.val(titleLoc[newLang]);
        $('.addtabs-title-description', ui).val(descrLoc[newLang]);
      });
      titleInput.keyup(function (e) {
        $(this).toggleClass('error', this.value == '');

        if (e.keyCode == 13) {
          createTab();
          return false;
        }

        return true;
      });
      titleInput.focus();

      var createTab = function createTab() {
        updateDataLoc(langControl.getLang());

        var mapState = _mapHelper.getMapState(),
            tab = {
          name: titleLoc.rus || titleLoc.eng,
          description: descrLoc.rus || descrLoc.eng,
          name_rus: titleLoc.rus,
          description_rus: descrLoc.rus,
          name_eng: titleLoc.eng,
          description_eng: descrLoc.eng,
          state: mapState
        };

        if (isNew) {
          _this.tabs.push(tab);
        } else {
          _this.tabs[tabIndex] = tab;
        }

        _this.draw(tab, tabIndex);

        removeDialog(dialogDiv);
      },
          _this = this;

      $('.addtabs-create', ui).click(createTab);
      var dialogDiv = showDialog$1(_gtxt("Имя закладки"), ui[0], 280, 230, false, false);
    };

    queryTabs.prototype.draw = function (tabInfo, tabIndex) {
      var selectValLoc = function selectValLoc(paramName) {
        var lang = nsGmx$1.Translations.getLanguage();
        return tabInfo[paramName + '_' + lang] || tabInfo[paramName];
      };

      var tmpl = Handlebars.compile('<div class="canvas">' + '<div class="buttonLink tabName" title="{{description}}">{{name}}</div>' + '<div class="gmx-icon-edit"></div>' + '<div class="gmx-icon-close"></div>' + '</div>');
      var canvas = $(tmpl({
        name: selectValLoc('name'),
        description: selectValLoc('description')
      }))[0];

      var _this = this;

      canvas.tabInfo = tabInfo;
      $('.tabName', canvas).click(this.show.bind(this, tabInfo.state));
      $('.gmx-icon-close', canvas).click(function () {
        var index = getOwnChildNumber(canvas);

        _this.tabs.splice(index, 1);

        canvas.removeNode(true);
      });
      $('.gmx-icon-edit', canvas).click(function () {
        var index = getOwnChildNumber(canvas);

        _this.add(_this.tabs[index], index);
      }).toggle(_queryMapLayers.currentMapRights() === "edit");

      if (typeof tabIndex === 'undefined') {
        $(this.tabsCanvas).append(canvas);
      } else {
        $(this.tabsCanvas).find('.canvas').eq(tabIndex).replaceWith(canvas);
      }
    };

    queryTabs.prototype.show = function (state) {
      var parsedState = {},
          lmap = nsGmx$1.leafletMap,
          gmxDrawing = lmap.gmxDrawing;
      $.extend(true, parsedState, state);
      var pos = parsedState.position;
      lmap.setView(L.Projection.Mercator.unproject(L.point(pos.x, pos.y)), 17 - pos.z);

      for (var i = 0; i < state.drawnObjects.length; i++) {
        parsedState.drawnObjects[i].geometry = L.gmxUtil.geometryToGeoJSON(state.drawnObjects[i].geometry, true);
      }

      lmap.gmxBaseLayersManager.setCurrentID(lmap.gmxBaseLayersManager.getIDByAlias(parsedState.mode)); //удаляем все фичи

      gmxDrawing.getFeatures().slice(0).forEach(gmxDrawing.remove.bind(gmxDrawing));

      for (var i = 0; i < parsedState.drawnObjects.length; i++) {
        //старый формат - число, новый - строка
        var rawColor = parsedState.drawnObjects[i].color,
            color = (typeof rawColor === 'number' ? '#' + L.gmxUtil.dec2hex(rawColor) : rawColor) || '#0000FF',
            thickness = parsedState.drawnObjects[i].thickness || 2,
            opacity = parsedState.drawnObjects[i].opacity || 80;
        gmxDrawing.addGeoJSON(parsedState.drawnObjects[i].geometry, {
          lineStyle: {
            color: color,
            weight: thickness,
            opacity: opacity / 100
          }
        });
      }

      _queryMapLayers.applyState(parsedState.condition, parsedState.mapStyles);

      if (typeof parsedState.customParamsCollection !== 'undefined') _mapHelper.customParamsManager.loadParams(parsedState.customParamsCollection);

      if (parsedState.openPopups) {
        for (var l in parsedState.openPopups) {
          var layer = nsGmx$1.gmxMap.layersByID[l];

          if (layer && layer.addPopup) {
            parsedState.openPopups[l].forEach(layer.addPopup.bind(layer));
          }
        }
      }
    };

    var _queryTabs = new queryTabs();

    nsGmx$1.userObjectsManager.addDataCollector('tabs', {
      collect: function collect() {
        if (!_queryTabs.tabs.length) return null;
        var tabs = [];

        for (var i = 0; i < _queryTabs.tabs.length; i++) {
          var tab = {};
          $.extend(tab, _queryTabs.tabs[i]);
          tabs.push(tab);
        }

        return tabs;
      },
      load: function load(data) {
        if (!data || !data.length) return;
        $('#left_mapTabs').remove();
        _queryTabs.builded = false;
        _queryTabs.tabs = data;
        mapHelp.tabs.load('mapTabs');
      }
    });

    var _$2 = nsGmx$1.Utils._;
    /** Вспомогательные ф-ции ГеоМиксера
    @namespace _mapHelper
    */

    nsGmx$1.mapHelper = {};
    var mapHelp$1 = {
      mapHelp: {},
      serviceHelp: {},
      tabs: {},
      externalMaps: {}
    };

    var mapHelper$1 = function mapHelper() {
      this.builded = false; //this._treeView = false;

      this.defaultStyles = {
        'point': {
          outline: {
            color: 0x0000FF,
            thickness: 1
          },
          marker: {
            size: 8
          },
          fill: {
            color: 0xFFFFFF,
            opacity: 20
          }
        },
        'linestring': {
          outline: {
            color: 0x0000FF,
            thickness: 1
          }
        },
        'polygon': {
          outline: {
            color: 0x0000FF,
            thickness: 1
          },
          fill: {
            color: 0xFFFFFF,
            opacity: 20
          }
        }
      };
      this.defaultPhotoIconStyles = {
        'point': {
          marker: {
            image: 'api/img/camera18.png',
            center: true
          }
        }
      };
      this.stylesDialogsHash = {};
      this.drawingDialogsHash = {};
      this.layerEditorsHash = {};
      this.layerStylesHash = {};
      this.attrValues = {};
      this.customErrorsHash = {
        "Unable to locate EXIF content": "Unable to locate EXIF content" // контролирует пользовательские объекты, которые являются редактируемыми контурами растровых слоёв.
        // все такие объекты не будут сериализоваться

      };

      this.drawingBorders = function () {
        var _borders = {}; //не будем сериализовать все пользовательские объекты, являющиеся контурами слоёв, так как это временные объекты

        nsGmx$1.DrawingObjectCustomControllers.addDelegate({
          isSerializable: function isSerializable(obj) {
            for (var name in _borders) {
              if (_borders[name] === obj) return false;
            }

            return true;
          }
        });
        return {
          set: function set(name, obj) {
            if (name in _borders) {
              _borders[name].drawingFeature.off('edit', _borders[name].editListener);
            }

            var editListener = function editListener() {
              _borders[name].isChanged = true;
            };

            obj.on('edit', editListener);
            _borders[name] = {
              isChanged: !!_borders[name],
              drawingFeature: obj,
              editListener: editListener
            };
          },
          get: function get(name) {
            return _borders[name] && _borders[name].drawingFeature;
          },
          length: function length() {
            return objLength$1(_borders);
          },
          //callback(name, obj)
          forEach: function forEach(callback) {
            for (var name in _borders) {
              callback(name, _borders[name].drawingFeature);
            }
          },
          isChanged: function isChanged(name) {
            return !!_borders[name] && _borders[name].isChanged;
          },
          updateBorder: function updateBorder(name, span) {
            if (!_borders[name]) return;

            var geom = _borders[name].drawingFeature.toGeoJSON().geometry,
                areaStr = L.gmxUtil.prettifyArea(L.gmxUtil.geoArea(geom, false));

            if (span) {
              _$2(span, [_t$1(areaStr)]);

              return;
            }

            if (!$('#drawingBorderDescr' + name).length) return;
            $('#drawingBorderDescr' + name).empty();

            _$2($('#drawingBorderDescr' + name)[0], [_t$1(areaStr)]);
          },
          //Удаляет объект из списка контуров слоя
          //?removeDrawring {bool, default: false} - удалять ли сам пользовательский объект
          removeRoute: function removeRoute(name, removeDrawing) {
            if (!(name in _borders)) return;

            _borders[name].drawingFeature.off('edit', _borders[name].editListener);

            if (removeDrawing) {
              nsGmx$1.leafletMap.gmxDrawing.remove(_borders[name].drawingFeature);
            }

            delete _borders[name];
            $('#drawingBorderDescr' + name).empty();
          }
        };
      }();

      this.unsavedChanges = false;
    };

    mapHelper$1.prototype = new leftMenu$1();
    /** Менеджер кастомных параметров карты.
     * Содержит набор провайдеров доп. параметров, которые могут сохранять и загружать данные из хранилища параметров
     * Данные загружаются один раз. Возможна асинхронная загрузка данных/добавление провайдеров.
     * Порядок вызова провайдеров не определён.
     *
     * @memberOf _mapHelper
     * @name customParamsManager
     */

    mapHelper$1.prototype.customParamsManager = function () {
      var _providers = [];
      var _params = []; //хранит параметры, которые не были загружены провайдерами

      var loadProviderState = function loadProviderState(provider) {
        if (provider.name in _params && typeof provider.loadState !== 'undefined') {
          provider.loadState(_params[provider.name]);
          delete _params[provider.name];
        }
      };

      return {
        saveParams: function saveParams() {
          if (!_providers.length) return;
          var params = {};

          for (var p = 0; p < _providers.length; p++) {
            if (typeof _providers[p].saveState !== 'undefined') params[_providers[p].name] = _providers[p].saveState();
          }

          return params;
        },
        loadParams: function loadParams(params) {
          _params = params;

          for (var p = 0; p < _providers.length; p++) {
            loadProviderState(_providers[p]);
          }
        },
        //интерфейс провайдера: name, saveState(), loadState(state)
        addProvider: function addProvider(provider) {
          _providers.push(provider);

          loadProviderState(provider);
        },
        isProvider: function isProvider(providerName) {
          return !!nsGmx$1._.findWhere(_providers, {
            name: providerName
          });
        },
        removeProvider: function removeProvider(providerName) {
          _providers = nsGmx$1._.filter(_providers, function (provider) {
            return provider.name !== providerName;
          });
        }
      };
    }();

    mapHelper$1.prototype.makeStyle = function (style) {
      style = style || {};
      var givenStyle = {};
      if (typeof style.RenderStyle != 'undefined') givenStyle = style.RenderStyle;else if (style.outline || style.marker) givenStyle = style;else {
        if (style.PointSize) givenStyle.marker = {
          size: parseInt(style.PointSize)
        };

        if (style.Icon) {
          var src = style.Icon.indexOf("http://") != -1 || style.Icon.indexOf("https://") != -1 ? style.Icon : baseAddress + "/" + style.Icon;
          givenStyle.marker = {
            image: src,
            center: true
          };
        }

        if (style.BorderColor || style.BorderWidth) givenStyle.outline = {
          color: parseColor(style.BorderColor),
          thickness: parseInt(style.BorderWidth || "1")
        };
        if (style.FillColor) givenStyle.fill = {
          color: parseColor(style.FillColor),
          opacity: 100 - parseInt(style.Transparency || "0")
        };
        var label = style.label || style.Label;
        if (label) givenStyle.label = {
          field: label.FieldName,
          color: parseColor(label.FontColor),
          size: parseInt(label.FontSize || "12")
        };
      }
      return givenStyle;
    };

    mapHelper$1.prototype.getMapStateAsPermalink = function (callback) {
      // сохраняем состояние карты
      var mapState = _mapHelper$1.getMapState(); // туда же сохраним созданные объекты


      nsGmx$1.userObjectsManager.collect();
      mapState.userObjects = JSON.stringify(nsGmx$1.userObjectsManager.getData());
      nsGmx$1.Utils.TinyReference.create(mapState, true).then(callback);
    };

    mapHelper$1.prototype.reloadMap = function () {
      if (!nsGmx$1.gmxMap) {
        window.location.reload();
      }

      _mapHelper$1.getMapStateAsPermalink(function (permalinkID) {
        createCookie("TempPermalink", permalinkID);
        window.location.replace(window.location.href.split("?")[0] + "?permalink=" + permalinkID + (window.defaultMapID == globalMapName ? "" : "&" + globalMapName));
      });
    };

    mapHelper$1.prototype.updateUnloadEvent = function (flag) {
      if (typeof flag != 'undefined') this.unsavedChanges = flag;

      if (this.unsavedChanges) {
        window.onbeforeunload = function (e) {
          return _gtxt("В дереве слоев остались несохраненные изменения!");
        };
      } else window.onbeforeunload = null;
    };

    mapHelper$1.prototype.setBalloon = function (filter, template) {
      filter.enableHoverBalloon(function (o) {
        return template.replace(/\[([a-zA-Z0-9_а-яА-Я ]+)\]/g, function () {
          var key = arguments[1];
          if (key == "SUMMARY") return o.getGeometrySummary();else return o.properties[key];
        });
      });
    };

    mapHelper$1.prototype.updateMapStyles = function (newStyles, name) {
      var layer = nsGmx$1.gmxMap.layersByID[name],
          styles = newStyles.map(nsGmx$1.Utils.prepareGmxLayerStyle);
      layer.setStyles(styles);
    }; //TODO: remove isEditableStyles


    mapHelper$1.prototype.updateTreeStyles = function (newStyles, div, treeView, isEditableStyles) {
      isEditableStyles = typeof isEditableStyles === 'undefined' || isEditableStyles;

      if (window.newStyles) {
        div.gmxProperties.content.properties.gmxStyles.styles = newStyles;
      } else {
        div.gmxProperties.content.properties.styles = newStyles;
      }

      var multiStyleParent = $(div).children('[multiStyle]')[0];

      var parentIcon = $(div).children("[styleType]")[0],
          newIcon = _mapHelper$1.createStylesEditorIcon(newStyles, div.gmxProperties.content.properties.GeometryType.toLowerCase(), {
        addTitle: isEditableStyles
      });

      $(parentIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));
      $(multiStyleParent).empty();

      _mapHelper$1.createMultiStyle(div.gmxProperties.content.properties, treeView, multiStyleParent);
    };

    mapHelper$1.prototype.restoreTinyReference = function (id, callbackSuccess, errorCallback) {
      window.suppressDefaultPermalink = true;
      nsGmx$1.Utils.TinyReference.get(id).then(function (obj) {
        if (obj.position) {
          var latLngPos = L.Projection.Mercator.unproject(obj.position);
          obj.position.x = latLngPos.lng;
          obj.position.y = latLngPos.lat;
          obj.position.z = 17 - obj.position.z;

          if (obj.drawnObjects) {
            for (var i in obj.drawnObjects) {
              //эта двойная конвертация в действительности просто перевод координат из Меркатора в LatLng
              obj.drawnObjects[i].geometry = L.gmxUtil.geoJSONtoGeometry(L.gmxUtil.geometryToGeoJSON(obj.drawnObjects[i].geometry, true));
            }
          }
        }

        obj.originalReference = id;
        callbackSuccess(obj);
      }, errorCallback);
    };

    mapHelper$1.prototype.getMapState = function () {
      var lmap = nsGmx$1.leafletMap;

      if (!lmap) {
        return {};
      }

      var drawnObjects = [],
          drawings = lmap.gmxDrawing.saveState(),
          features = drawings.featureCollection.features,
          openPopups = {},
          condition = {
        expanded: {},
        visible: {}
      },
          LayersTreePermalinkParams = {},
          mercCenter = L.Projection.Mercator.project(lmap.getCenter());

      for (var i = 0; i < features.length; i++) {
        if (features[i].properties.exportRect) {
          features.splice(i, 1);
        }
      }

      lmap.gmxDrawing.getFeatures().forEach(function (feature) {
        if (!nsGmx$1.DrawingObjectCustomControllers.isSerializable(feature) || feature.options.exportRect) {
          return;
        }

        var geoJSON = feature.toGeoJSON();
        var elem = {
          properties: geoJSON.properties,
          geometry: L.gmxUtil.geoJSONtoGeometry(geoJSON, true)
        };

        if (elem.geometry.type !== "POINT") {
          var style = feature.getOptions().lineStyle;

          if (style) {
            elem.thickness = style.weight || 2;
            elem.color = style.color;
            elem.opacity = (style.opacity || 0.8) * 100;
          }
        }

        if (lmap.hasLayer(feature.getPopup())) {
          elem.isBalloonVisible = true;
        }

        drawnObjects.push(elem);
      });

      for (var l in nsGmx$1.gmxMap.layersByID) {
        var layer = nsGmx$1.gmxMap.layersByID[l];

        if (layer.getPopups) {
          var popups = layer.getPopups();

          if (popups.length) {
            openPopups[l] = popups;
          }
        }
      }

      this.findTreeElems(_layersTree.treeModel.getRawTree(), function (elem) {
        var props = elem.content.properties;

        if (elem.type == 'group') {
          var groupId = props.GroupID;
          if (!$("div[GroupID='" + groupId + "']").length && !props.changedByViewer) return;
          condition.visible[groupId] = props.visible;
          condition.expanded[groupId] = props.expanded;
        } else {
          if (props.changedByViewer) {
            condition.visible[props.name] = props.visible;
          }
        }
      }); // layers tree permalink params (without server)

      this.findTreeElems(_layersTree.treeModel.getRawTree(), function (elem) {
        var props = elem.content.properties,
            id = elem.type == 'group' ? props.GroupID : props.LayerID;

        if (props.permalinkParams) {
          LayersTreePermalinkParams[id] = props.permalinkParams;
        }
      });
      var dateIntervals = {};

      for (var l in nsGmx$1.gmxMap.layersByID) {
        var layer = nsGmx$1.gmxMap.layersByID[l],
            props = layer.getGmxProperties(),
            isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.setDateInterval;

        if (isTemporalLayer && layer.getDateInterval) {
          dateIntervals[props.LayerID] = layer.getDateInterval();
        }
      }

      return {
        mode: lmap.gmxBaseLayersManager.getCurrentID(),
        mapName: globalMapName,
        position: {
          x: mercCenter.x,
          y: mercCenter.y,
          z: 17 - lmap.getZoom()
        },
        mapStyles: this.getMapStyles(),
        drawings: drawings,
        drawnObjects: drawnObjects,
        isFullScreen: window.layersShown ? "false" : "true",
        condition: condition,
        LayersTreePermalinkParams: LayersTreePermalinkParams,
        language: window.language,
        customParamsCollection: this.customParamsManager.saveParams(),
        dateIntervals: dateIntervals,
        openPopups: openPopups
      };
    };

    mapHelper$1.prototype.getMapStyles = function () {
      var styles = {};
      this.findChilds(_layersTree.treeModel.getRawTree(), function (child) {
        if (child.content.properties.type == "Vector" && $("div[LayerID='" + child.content.properties.LayerID + "']").length) styles[child.content.properties.name] = child.content.properties.styles;
      }, true);
      return styles;
    };

    mapHelper$1.prototype.showPermalink = function () {
      this.createPermalink(function (id) {
        var url = window.location.protocol + "//" + window.location.host + window.location.pathname + "?permalink=" + id + (window.defaultMapID == globalMapName ? "" : "&" + globalMapName);

        var input = _input$1(null, [['dir', 'className', 'inputStyle inputFullWidth'], ['attr', 'value', url]]);

        showDialog$1(_gtxt("Ссылка на текущее состояние карты"), _div$1([input]), 311, 80, false, false);
        input.select();
      });
    };

    mapHelper$1.prototype.createExportPermalink = function (params, callback) {
      var mapState = $.extend(this.getMapState(), params),
          def = nsGmx$1.Utils.TinyReference.create(mapState, false);
      def.then(callback);
      return def;
    };

    mapHelper$1.prototype.createPermalink = function (callback) {
      var mapState = this.getMapState(),
          def = nsGmx$1.Utils.TinyReference.create(mapState, false);
      def.then(callback);
      return def;
    };

    mapHelper$1.prototype.updateTinyMCE = function (container) {
      gmxCore$1.loadModule('TinyMCELoader', window.location + '//' + window.location.host + window.location.pathname.replace('index.html', '') + 'TinyMCELoader.js', function () {
        $('.balloonEditor', container).each(function () {
          var id = $(this).attr('id');

          if (!tinyMCE.get(id)) {
            tinyMCE.execCommand("mceAddControl", true, id);
          }
        });
      });
    }; //event: selected(url)


    mapHelper$1.ImageSelectionWidget = Backbone.View.extend({
      tagName: 'span',
      className: 'gmx-icon-choose',
      events: {
        'click': function click() {
          var imagesDir = nsGmx$1.AuthManager.getUserFolder() + 'images';
          _this = this;
          sendCrossDomainJSONRequest$2(serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(imagesDir), function (response) {
            if (!parseResponse(response)) return;

            _fileBrowser.createBrowser(_gtxt("Изображение"), ['jpg', 'jpeg', 'png', 'gif', 'swf'], function (path) {
              var relativePath = path.substring(imagesDir.length);

              if (relativePath[0] == '\\') {
                relativePath = relativePath.substring(1);
              }

              var url = serverBase + "GetImage.ashx?usr=" + encodeURIComponent(nsGmx$1.AuthManager.getLogin()) + "&img=" + encodeURIComponent(relativePath);

              _this.trigger('selected', url);
            }, {
              startDir: imagesDir,
              restrictDir: imagesDir
            });
          });
        }
      }
    });

    mapHelper$1.ImageInputControl = function (initURL) {
      var prevValue = initURL || '';

      var inputUrl = _input$1(null, [['dir', 'className', 'inputStyle'], ['attr', 'value', prevValue], ['css', 'width', '170px']]);

      _title$1(inputUrl, _gtxt('URL изображения'));

      var _this = this;

      var update = function update() {
        if (inputUrl.value != prevValue) {
          prevValue = inputUrl.value;
          $(_this).change();
        }
      };

      var mainDiv = $('<div/>').append(inputUrl);
      inputUrl.onkeyup = inputUrl.change = update;

      if (nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_UPLOAD_FILES)) {
        var imageSelectionWidget = new mapHelper$1.ImageSelectionWidget();
        imageSelectionWidget.on('selected', function (url) {
          inputUrl.value = url;
          update();
        });
        mainDiv.append(imageSelectionWidget.el);
      }

      this.getControl = function () {
        return mainDiv[0];
      };

      this.value = function () {
        return inputUrl.value;
      };
    }; //params:
    //  * addTitle {bool, default: true}


    mapHelper$1.prototype.createStylesEditorIcon = function (parentStyles, type, params) {
      var _params = $.extend({
        addTitle: true
      }, params);

      var icon;

      if ($.isArray(parentStyles) && parentStyles.length > 1) {
        icon = _img$1(null, [['attr', 'src', 'img/misc.png'], ['css', 'margin', '0px 2px -3px 4px'], ['css', 'cursor', 'pointer'], ['attr', 'styleType', 'multi']]);
      } else {
        var parentStyle = _mapHelper$1.makeStyle(parentStyles[0]);

        var iconUrlProp = window.newStyles ? parentStyle.iconUrl : parentStyle.marker && parentStyle.marker.image;

        if (iconUrlProp) {
          icon = _img$1(null, [['dir', 'className', 'icon'], ['attr', 'styleType', 'icon']]);

          var fixFunc = function fixFunc() {
            var width = this.width,
                height = this.height,
                scale;

            if (width && height) {
              var scaleX = 14.0 / width;
              var scaleY = 14.0 / height;
              scale = Math.min(scaleX, scaleY);
            } else {
              scale = 1;
              width = height = 14;
            }

            setTimeout(function () {
              icon.style.width = Math.round(width * scale) + 'px';
              icon.style.height = Math.round(height * scale) + 'px';
            }, 10);
          };

          icon.onload = fixFunc;
          icon.src = iconUrlProp;
        } else {
          icon = nsGmx$1.Controls.createGeometryIcon(parentStyle, type);
        }
      }

      if (_params.addTitle) _title$1(icon, _gtxt("Редактировать стили"));
      icon.geometryType = type;
      return icon;
    };

    mapHelper$1.prototype.createLoadingLayerEditorProperties = function (div, parent, layerProperties, params) {
      var elemProperties = div.gmxProperties.content.properties,
          loading = _div$1([_img$1(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), _t$1(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px']]),
          type = elemProperties.type;

      if (type == "Vector") {
        nsGmx$1.createLayerEditor(div, type, parent, layerProperties, params);
        return;
      } else {
        if (elemProperties.name) {
          _$2(parent, [loading]);

          sendCrossDomainJSONRequest$2(serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&LayerName=" + elemProperties.name, function (response) {
            if (!parseResponse(response)) return;
            loading.removeNode(true);
            nsGmx$1.createLayerEditor(div, type, parent, response.Result, params);
          });
        }
      }
    };

    mapHelper$1.prototype.createNewLayer = function (type) {
      if ($('#new' + type + 'Layer').length) return;

      var parent = _div$1(null, [['attr', 'id', 'new' + type + 'Layer'], ['css', 'height', '100%']]),
          height = type == 'Vector' ? 340 : 360;

      if (type !== 'Multi') {
        var properties = {
          Title: '',
          Description: '',
          Date: '',
          TilePath: {
            Path: ''
          },
          ShapePath: {
            Path: ''
          }
        };
        var dialogDiv = showDialog$1(type != 'Vector' ? _gtxt('Создать растровый слой') : _gtxt('Создать векторный слой'), parent, 340, height, false, false);
        nsGmx$1.createLayerEditor(false, type, parent, properties, {
          doneCallback: function doneCallback() {
            removeDialog$1(dialogDiv);
          }
        });
      } else {

        nsGmx$1.createMultiLayerEditorNew(_layersTree);
      }
    }; // перенос clipLayer из маплетов карты


    mapHelper$1.prototype.clipLayer = function (layer, props) {
      var sw = L.latLng([props.MinViewY, props.MinViewX]),
          nw = L.latLng([props.MaxViewY, props.MinViewX]),
          ne = L.latLng([props.MaxViewY, props.MaxViewX]),
          se = L.latLng([props.MinViewY, props.MaxViewX]),
          clip = L.polygon([sw, nw, ne, se, sw]);
      layer.addClipPolygon(clip);
    }; // Формирует набор элементов tr используя контролы из shownProperties.
    // Параметры:
    // - shownProperties: массив со следующими свойствами:
    //   * tr - если есть это свойство, то оно помещается в tr, все остальные игнорируются
    //   * name - названия свойства, которое будет писаться в левой колонке
    //   * elem - если есть, то в правую колонку помещается этот элемент
    //   * field - если нет "elem", в правый столбец подставляется layerProperties[field]
    //   * trid - id для DOM элементов. Не применяется, если прямо указано tr
    //   * trclass - class для DOM элементов. Не применяется, если прямо указано tr
    // - layerProperties - просто хеш строк для подстановки в правую колонку
    // - style:
    //   * leftWidth - ширина левой колонки в пикселях
    //   * leftcolumnclass - class для td элементов первого столбца. Не применяется, если прямо указано tr
    //   * rightcolumnclass - class для td элементов второго столбца. Не применяется, если прямо указано tr


    mapHelper$1.prototype.createPropertiesTable = function (shownProperties, layerProperties, style) {
      var _styles = $.extend({
        leftWidth: 100
      }, style);

      var trs = [];

      for (var i = 0; i < shownProperties.length; i++) {
        var td;

        if (typeof shownProperties[i].tr !== 'undefined') {
          trs.push(shownProperties[i].tr);
          continue;
        }

        if (typeof shownProperties[i].elem !== 'undefined') td = _td$1([shownProperties[i].elem]);else td = _td$1([_t$1(layerProperties[shownProperties[i].field] != null ? layerProperties[shownProperties[i].field] : '')], [['css', 'padding', '0px 3px']]);

        var tdTitle = _td$1([_t$1(shownProperties[i].name)], [['css', 'width', _styles.leftWidth + 'px']]);

        var tr = _tr$1([tdTitle, td]);

        _$2(tdTitle, [], [['dir', 'className', 'propertiesTable-title ' + (_styles.leftcolumnclass || '')]]);

        if (_styles.rightcolumnclass) _$2(td, [], [['dir', 'className', _styles.rightcolumnclass]]);
        if (shownProperties[i].trid) _$2(tr, [], [['attr', 'id', shownProperties[i].trid]]);
        if (shownProperties[i].trclass) _$2(tr, [], [['dir', 'className', shownProperties[i].trclass]]);
        trs.push(tr);
      }

      return trs;
    };

    mapHelper$1.prototype.createLayerEditor = function (div, treeView, selected, openedStyleIndex) {
      var elemProperties = div.gmxProperties.content.properties,
          layerName = elemProperties.name,
          _this = this;

      if (elemProperties.type == "Vector") {
        if (typeof this.layerEditorsHash[layerName] != 'undefined') {
          if (this.layerEditorsHash[layerName] != false) {
            this.layerEditorsHash[layerName].selectTab(selected);
          }

          return;
        }

        this.layerEditorsHash[layerName] = false;

        var mapName = elemProperties.mapName,
            createTabs = function createTabs(layerProperties) {
          var id = 'layertabs' + layerName,
              divProperties = _div$1(null, [['attr', 'id', 'properties' + id], ['css', 'height', '100%']]),
              additionalTabs = [];

          var pos = nsGmx$1.Utils.getDialogPos(div, true, 390),
              updateFunc = function updateFunc() {},
              closeFunc = function closeFunc() {
            return false;
          };

          _this.createLoadingLayerEditorProperties(div, divProperties, layerProperties, {
            doneCallback: function doneCallback() {
              $(divDialog).dialog('close');
            },
            additionalTabs: additionalTabs,
            selected: selected,
            createdCallback: function createdCallback(layerEditor) {
              _this.layerEditorsHash[layerName] = layerEditor;
              _this.layerEditorsHash[layerName].closeFunc = closeFunc;
              _this.layerEditorsHash[layerName].updateFunc = updateFunc;
            }
          });

          var divDialog = showDialog$1(_gtxt('Слой [value0]', elemProperties.title), divProperties, 350, 470, pos.left, pos.top, null, function () {
            delete _this.layerEditorsHash[layerName];
          }); // при сохранении карты сбросим все временные стили в json карты

          divProperties.closeFunc = closeFunc;
          divProperties.updateFunc = updateFunc;
        };

        if (!this.attrValues[mapName]) this.attrValues[mapName] = {};
        sendCrossDomainJSONRequest$2(serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + layerName, function (response) {
          if (!parseResponse(response)) return;
          var columns = response.Result.Columns;
          var attributesHash = {};

          for (var i = 0; i < columns.length; i++) {
            attributesHash[columns[i].Name] = [];
          }

          _this.attrValues[mapName][layerName] = new nsGmx$1.LazyAttributeValuesProviderFromServer(attributesHash, layerName);
          createTabs(response.Result);
        });
      } else if (elemProperties.type == "Raster") {
        if (elemProperties.LayerID) {
          if (this.layerEditorsHash[layerName]) return;
          this.layerEditorsHash[layerName] = true;

          var id = 'layertabs' + layerName,
              divProperties = _div$1(null, [['attr', 'id', 'properties' + id], ['css', 'height', '100%']]),
              divStyles = _div$1(null, [['attr', 'id', 'styles' + id], ['css', 'height', '100%'], ['css', 'overflowY', 'auto']]);

          var layer = nsGmx$1.gmxMap.layersByID[layerName],
              parentStyle = elemProperties.styles && elemProperties.styles[0] || elemProperties;
          var zoomPropertiesControl = new nsGmx$1.ZoomPropertiesControl(parentStyle.MinZoom, parentStyle.MaxZoom),
              liMinZoom = zoomPropertiesControl.getMinLi(),
              liMaxZoom = zoomPropertiesControl.getMaxLi();
          $(zoomPropertiesControl).change(function () {
            layer.setZoomBounds(this.getMinZoom(), this.getMaxZoom());
          });

          _$2(divStyles, [_ul$1([liMinZoom, liMaxZoom])]);

          this.createLoadingLayerEditorProperties(div, divProperties, null, {
            doneCallback: function doneCallback() {
              $(divDialog).dialog('close');
            },
            additionalTabs: [{
              title: _gtxt("Стили"),
              name: 'styles',
              container: divStyles
            }]
          });

          var pos = nsGmx$1.Utils.getDialogPos(div, true, 330),
              closeFunc = function closeFunc() {
            elemProperties.styles = elemProperties.styles || [];
            elemProperties.styles[0] = elemProperties.styles[0] || {};
            elemProperties.styles[0].MinZoom = zoomPropertiesControl.getMinZoom();
            elemProperties.styles[0].MaxZoom = zoomPropertiesControl.getMaxZoom();
            delete _this.layerEditorsHash[layerName];
            treeView.findTreeElem(div).elem.content.properties = elemProperties;

            _this.drawingBorders.removeRoute(layerName, true);

            if ($('#drawingBorderDialog' + layerName).length) removeDialog$1($('#drawingBorderDialog' + layerName)[0].parentNode);
            return false;
          };

          var divDialog = showDialog$1(_gtxt('Слой [value0]', elemProperties.title), divProperties, 330, 410, pos.left, pos.top, null, closeFunc);
        } else {
          nsGmx$1.createMultiLayerEditorServer(elemProperties, div, treeView);
        }
      } else if (elemProperties.type == "Virtual") {
        var divProperties = _div$1(null, [['attr', 'id', 'properties' + id], ['css', 'height', '100%']]);

        this.createLoadingLayerEditorProperties(div, divProperties, null, {
          doneCallback: function doneCallback() {
            $(divDialog).dialog('close');
          }
        });

        var closeFunc = function closeFunc() {
          delete _this.layerEditorsHash[layerName];
        };

        var pos = nsGmx$1.Utils.getDialogPos(div, true, 330);
        var divDialog = showDialog$1(_gtxt('Слой [value0]', elemProperties.title), divProperties, 330, 410, pos.left, pos.top, null);
      }
    };

    mapHelper$1.prototype.createWFSStylesEditor = function (parentObject, style, geometryType, divCanvas) {
      var _this = this,
          templateStyle = {};

      $.extend(true, templateStyle, style);

      var elemCanvas = _mapHelper$1.createStylesEditorIcon([{
        MinZoom: 1,
        MaxZoom: 21,
        RenderStyle: style.regularStyle
      }], geometryType);

      var spanIcon = _span$1([elemCanvas]);

      spanIcon.onclick = function () {
        var listenerId = parentObject.addListener('onSetStyle', function (style) {
          var newIcon = _this.createStylesEditorIcon([{
            MinZoom: 1,
            MaxZoom: 21,
            RenderStyle: style.regularStyle
          }], geometryType);

          $(spanIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));
        });

        var canvasStyles = _div$1(null, [['css', 'marginTop', '10px']]),
            canvasCharts = _div$1(null, [['css', 'marginTop', '10px']]),
            closeFunc = function closeFunc() {
          $(canvasStyles).find(".colorSelector").each(function () {
            $('#' + $(this).data("colorpickerId")).remove();
          });
          var layerElemCanvas = $(divCanvas).find("[geometryType='" + geometryType.toUpperCase() + "']")[0];
          layerElemCanvas.graphDataType = $(canvasCharts).find("select")[0].value;
          layerElemCanvas.graphDataProperties = $(canvasCharts).find("input")[0].value;
          parentObject.removeMapStateListener('onSetStyle', listenerId);
        };

        var id = 'wfstabs' + String(Math.random()).substring(2, 9),
            tabMenu = _div$1([_ul$1([_li$1([_a([_t$1(_gtxt("Стили"))], [['attr', 'href', '#styles' + id]])]), _li$1([_a([_t$1(_gtxt("Диаграммы"))], [['attr', 'href', '#graph' + id]])])])]),
            divStyles = _div$1(null, [['attr', 'id', 'styles' + id]]),
            divGraph = _div$1(null, [['attr', 'id', 'graph' + id]]);

        _$2(tabMenu, [divStyles, divGraph]);

        gmxCore$1.loadModule('LayerStylesEditor').done(function (module) {
          var resObject = module.createStyleEditor(canvasStyles, templateStyle, geometryType, false);
          $(resObject).change(function () {
            nsGmx$1.Utils.setMapObjectStyle(parentObject, templateStyle);
          });
        });
        canvasStyles.firstChild.style.marginLeft = '0px';

        _$2(divStyles, [canvasStyles]);

        _mapHelper$1.createChartsEditor(canvasCharts, $(divCanvas).find("[geometryType='" + geometryType.toUpperCase() + "']")[0]);

        canvasCharts.firstChild.style.marginLeft = '0px';

        _$2(divGraph, [canvasCharts]);

        var pos = nsGmx$1.Utils.getDialogPos(spanIcon, false, 160);
        showDialog$1(_gtxt('Редактирование стилей объекта'), tabMenu, 330, 180, pos.left, pos.top, false, closeFunc);
        $(tabMenu).tabs({
          active: 0
        });
      };

      spanIcon.getStyle = function () {
        return templateStyle;
      };

      return spanIcon;
    };

    mapHelper$1.prototype.createChartsEditor = function (parent, elemCanvas) {
      var graphTypeSel = nsGmx$1.Utils._select([_option$1([_t$1(_gtxt("График по времени"))], [['attr', 'value', 'func']]), _option$1([_t$1(_gtxt("Круговая"))], [['attr', 'value', 'pie']])], [['dir', 'className', 'selectStyle'], ['css', 'width', '180px']]),
          propertiesMask = _input$1(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '180px']]);

      switchSelect(graphTypeSel, elemCanvas.graphDataType);
      propertiesMask.value = elemCanvas.graphDataProperties;

      _$2(parent, [_table$1([_tbody$1([_tr$1([_td$1([_t$1(_gtxt("Тип"))], [['css', 'width', '100px']]), _td$1([graphTypeSel])]), _tr$1([_td$1([_t$1(_gtxt("Маска атрибутов"))]), _td$1([propertiesMask])])])])]);
    };

    mapHelper$1.prototype.createMultiStyle = function (elem, treeView, multiStyleParent, treeviewFlag, layerManagerFlag) {
      var filters = window.newStyles ? elem.gmxStyles.styles : elem.styles;

      if (filters.length < 2) {
        multiStyleParent.style.display = 'none';
        return;
      }

      multiStyleParent.style.display = '';

      var ulFilters = _ul$1();

      for (var i = 0; i < filters.length; i++) {
        var checkbox = $('<input type="checkbox" class="multistlye-visibility-checkbox">'),
            // var eye = $('<span class="multistyle-visibility-icon"><svg><use xlink:href="#transparency-eye"></use></svg></span>'),
        icon = this.createStylesEditorIcon([filters[i]], elem.GeometryType.toLowerCase(), {
          addTitle: !layerManagerFlag
        }),
            name = filters[i].Name || filters[i].Filter || 'Без имени ' + (i + 1),
            iconSpan = _span$1([icon]),
            li = _li$1([_div$1([$(checkbox)[0], iconSpan, _span$1([_t$1(name)], [['css', 'marginLeft', '3px']])])]);

        $(iconSpan).attr('styleType', $(icon).attr('styleType'));
        $(checkbox).prop('checked', filters[i].MinZoom !== 25);
        bindCheckboxHandler(checkbox, i);

        if (!layerManagerFlag) {
          (function (i) {
            iconSpan.onclick = function () {
              nsGmx$1.createStylesDialog(elem, treeView, i); //_mapHelper.createLayerEditor(multiStyleParent.parentNode, treeView, 'styles', i);
            };
          })(i);
        }

        _$2(ulFilters, [li]);
      }

      function bindCheckboxHandler(checkbox, index) {
        $(checkbox).on('change', function (e) {
          var styleVisibilityProps = {
            elem: elem,
            styleIndex: index,
            show: e.target.checked
          };
          $(_layersTree).triggerHandler('styleVisibilityChange', [styleVisibilityProps]);
        });
      }

      ulFilters.style.display = 'none';
      ulFilters.className = 'hiddenTree';

      _$2(multiStyleParent, [_ul$1([_li$1([_div$1([_t$1(_gtxt("Стили слоя"))]), ulFilters])])]);

      if (typeof treeviewFlag == 'undefined') $(multiStyleParent.firstChild).treeview();
    };

    mapHelper$1.prototype.load = function () {
      var _this = this;

      if (!this.builded) {
        var fileName;
        if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.usageFilePrefix !== 'undefined') fileName = window.gmxViewerUI.usageFilePrefix;else fileName = window.gmxJSHost ? window.gmxJSHost + "usageHelp" : "usageHelp";
        fileName += _gtxt("helpPostfix");

        _mapHelper$1._loadHelpTextFromFile(fileName, function (text) {
          var div = _div$1(null, [['dir', 'className', 'help']]);

          div.innerHTML = text;

          _$2(_this.workCanvas, [div]);
        });

        this.builded = true;
      }
    };

    mapHelper$1.prototype._loadHelpTextFromFile = function (fileName, callback, num, data) {
      var proceess = function proceess(text) {
        callback(Handlebars.compile(text)({
          gmxVersion: num,
          gmxData: data
        }));
      };

      if (fileName.indexOf("http://") !== 0 || fileName.indexOf("https://") !== 0) $.ajax({
        url: fileName,
        success: proceess
      });else sendCrossDomainJSONRequest$2(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(fileName), function (response) {
        proceess(response.Result);
      });
    };

    mapHelper$1.prototype.version = function () {
      var div = $("<div class='gmx-about'></div>");
      var fileName;
      if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.helpFilePrefix !== 'undefined') fileName = window.gmxViewerUI.helpFilePrefix;else fileName = window.gmxJSHost ? window.gmxJSHost + "help" : "help";
      fileName += _gtxt("helpPostfix");

      _mapHelper$1._loadHelpTextFromFile(fileName, function (text) {
        div.html(text);
        showDialog$1(_gtxt("О проекте"), div[0], 500, 300, false, false);
      }, window.nsGmx.GeomixerFrameworkVersion, '');
    };

    mapHelper$1.prototype.print = function () {
      var centerControl = nsGmx$1.leafletMap.gmxControlsManager.get('center'),
          map = nsGmx$1.leafletMap,
          toggleMode = function toggleMode(isPreviewMode) {
        map.gmxControlsManager.get('hide').setActive(!isPreviewMode);
        window.printMode = isPreviewMode;
        $('#header, #leftMenu, #leftCollapser, #bottomContent, #tooltip, .ui-datepicker-div').toggleClass('print-preview-hide', isPreviewMode);
        $('#all').toggleClass('print-preview-all', isPreviewMode);
        $('.ui-dialog').toggle();
        $('.leaflet-gmx-iconSvg-hide').toggle();
        $('.leaflet-control-container').toggle();
      };

      toggleMode(true);
      centerControl.removeFrom ? centerControl.removeFrom(map) : centerControl.remove();
      var ui = $(Handlebars.compile('<div class="print-ui"><span class="print-ui-inner">' + '<button class="print-ui-close">Закрыть</button>' + '<button class="print-ui-print">Печать</button>' + '<span class="layoutContainer">' + '<label><input type="radio" name="layout" value="portrait" checked="true">' + _gtxt('портретная') + '</label>' + '<label><input type="radio" name="layout" value="layout">' + _gtxt('альбомная') + '</label>' + '</span>' + '</span>' + '</div>')());
      var BIG = 1150,
          SMALL = BIG / 1.4142;
      var layout = {
        width: SMALL + 'px',
        height: BIG + 'px'
      };
      ui.find('input[value="portrait"]').click(function () {
        this.checked = true;
        layout.width = SMALL + 'px';
        layout.height = BIG + 'px';
        $('#flash').css({
          width: layout.width,
          height: layout.height
        });
        map.invalidateSize();
      });
      ui.find('input[value="layout"]').click(function () {
        this.checked = true;
        layout.width = BIG + 'px';
        layout.height = SMALL + 'px';
        $('#flash').css({
          width: layout.width,
          height: layout.height
        });
        map.invalidateSize();
      });
      ui.find('.print-ui-print').click(function () {
        window.print();
      });
      ui.find('.print-ui-close').click(function () {
        toggleMode(false);
        centerControl.addTo(map);
        $('#flash').css({
          marginLeft: '0px',
          marginTop: '0px'
        });
        window.resizeAll();
        ui.remove();
      });
      $('body').append(ui);
      $('#flash').css({
        top: '0px',
        left: '0px',
        width: layout.width,
        height: layout.height
      });
      map.invalidateSize();
    }; // экспортный режим редактора


    mapHelper$1.prototype.exportMap = function (params) {
      var map = nsGmx$1.leafletMap,
          hide = map.gmxControlsManager.get('hide'),
          center = map.gmxControlsManager.get('center');
      hide.setActive(false);
      center.removeFrom ? center.removeFrom(map) : center.remove();
      window.exportMode = true;

      if (params.grid) {
        if (!nsGmx$1.gridManager.gridControl) {
          nsGmx$1.gridManager.setState({
            isActive: true
          });
        }

        var grid = nsGmx$1.gridManager.gridControl;
        params.exportBounds && grid.setFixBounds(L.latLngBounds(params.exportBounds._southWest, params.exportBounds._northEast));
      } else {
        nsGmx$1.gridManager.setState(false);
      }

      $('#header, #leftMenu, #leftCollapser, #bottomContent, #tooltip, .ui-datepicker-div').toggleClass('print-preview-hide', true);
      $('#all').toggleClass('print-preview-all', true);

      if (params.controls) {
        $('.gmx-slider-control').hide();
        var cs = nsGmx$1.leafletMap.gmxControlsManager.getAll();

        for (var key in cs) {
          if (!(key in params.controls)) {
            nsGmx$1.leafletMap.removeControl(cs[key]);
          }
        }
      } else {
        $('.leaflet-control-container').hide();
      } // $('#leftContent').mCustomScrollbar({live:"off"});


      var exportCssParams = {
        top: '0px',
        left: '0px',
        width: '100%',
        height: '100%'
      };
      $('#flash').css(exportCssParams);
      map.invalidateSize();
    }; //вызывает callback для всех слоёв поддерева treeElem. Параметры: callback(layerInfo, visibilityFlag)


    mapHelper$1.prototype.findChilds = function (treeElem, callback, flag) {
      var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;

      if (childsArr) {
        for (var i = 0; i < childsArr.length; i++) {
          var child = childsArr[i];
          if (child.type == 'group') this.findChilds(child, callback, flag && child.content.properties.visible);else callback(child, flag && child.content.properties.visible);
        }
      }
    };

    mapHelper$1.prototype.findTreeElems = function (treeElem, callback, flag, list) {
      var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;

      for (var i = 0; i < childsArr.length; i++) {
        var child = childsArr[i];

        if (child.type == 'group') {
          callback(child, flag, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list, i);
          this.findTreeElems(child, callback, flag && child.content.properties.visible, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list);
        } else callback(child, flag, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list, i);
      }
    };
    /**
     *  Модифицирует объекты внутри векторного слоя, отправляя изменения на сервер и информируя об этом API
     *
     * @memberOf _mapHelper
     * @name modifyObjectLayer
     * @function
     * @param {String} layerName Имя слоя
     * @param {Object[]} objs Массив описания объектов. Каждое описание представляет из себя объект:
     *
     *  * id {String} ID объекта слоя, над которым производятся изменения (только для модификации и удаления)
     *  * geometry Описание геометрии (вставка и изменение). GeoJSON
     *  * source: {rc: <name КР-источника>, rcobj: <id объекта внутри КР>}
     *  * properties Свойства объекта (вставка и изменение)
     *  * action {'delete'|'insert'|'update'} Производимое действие. Если не указано, то вычисляется следующим образом:
     *    * Если не указан id, то вставка
     *    * Если указан id, то модифицируем
     *    * Для удаления объекта нужно явно прописать параметр
     * @param {String} [crs='EPSG:3395'] Название системы координат геометрии объектов. Поддерживаются 3395, 4326, 3857
     * @return {jQuery.Deferred} Ресолвится в соответствии с ответом сервера
    */


    mapHelper$1.prototype.modifyObjectLayer = function (layerName, objs, crs) {
      var def = $.Deferred();
      $.each(objs, function (i, obj) {
        obj.action = obj.action || (obj.id ? 'update' : 'insert');
      });
      var params = {
        WrapStyle: 'window',
        LayerName: layerName,
        objects: JSON.stringify(objs)
      };

      if (crs) {
        params.geometry_cs = crs;
      }

      sendCrossDomainPostRequest(serverBase + "VectorLayer/ModifyVectorObjects.ashx", params, function (addResponse) {
        if (!parseResponse(addResponse)) {
          def.reject();
          return;
        }

        var mapLayer = nsGmx$1.gmxMap.layersByID[layerName];

        if (mapLayer) {
          L.gmx.layersVersion.chkVersion(mapLayer);
        }

        def.resolve();
      });
      return def.promise();
    };
    /** Запросить с сервера объекты векторного слоя
     * @memberOf _mapHelper
     * @name searchObjectLayer
     * @function
     * @param {String} layerName ID векторного слоя
     * @param {Object} options Параметры запроса
     * @param {String} [options.query] SQL-подобное выражение для выборки объектов
     * @param {Boolean} [options.includeGeometry=false] Возвращать ли геометрию с сервера или нет
     * @param {Object} [options.border=null] GeoJSON для ограничения выборки по геометрии
     * @param {Number} [options.page=0] номер страницы результатов (0 - результаты с самого первого)
     * @param {Number} [options.pagesize=100000] максимальное кол-во объектов в ответе
     * @return {jQuery.Deferred} Promise, который ресолвится массивом найденных объектов. Каждый объект имеет свойства properties и, возможно, geometry
    */


    mapHelper$1.prototype.searchObjectLayer = function (layerName, options) {
      options = options || {};
      var def = $.Deferred();
      var requestParams = {
        WrapStyle: 'message',
        layer: layerName
      };

      if (options.query) {
        requestParams.query = options.query;
      }

      if (options.includeGeometry) {
        requestParams.geometry = true;
      }

      if (options.border) {
        requestParams.border = JSON.stringify(options.border);
      }

      requestParams.page = options.page || 0;
      requestParams.pagesize = options.pagesize || 100000;
      sendCrossDomainPostRequest(serverBase + "VectorLayer/Search.ashx", requestParams, function (response) {
        if (!parseResponse(response)) {
          def.reject(response);
          return;
        }

        var values = response.Result.values;
        var fields = response.Result.fields;
        var objects = [];

        for (var i = 0; i < values.length; i++) {
          var obj = {
            properties: {}
          };

          for (var p = 0; p < values[i].length; p++) {
            if (fields[p] === 'geomixergeojson') {
              obj.geometry = values[i][p];
            } else {
              obj.properties[fields[p]] = values[i][p];
            }
          }

          objects.push(obj);
        }

        def.resolve(objects);
      });
      return def.promise();
    };
    /** Скачать векторный слой с сервера
     * @memberOf _mapHelper
     * @name downloadVectorLayer
     * @function
     * @param {Object} params Параметры запроса
     * @param {String} params.name ID векторного слоя, который нужно скачать
     * @param {String} params.host хост, с которого будем скачивать слой
     * @param {String} [params.format=Shape] В каком формате хотим получить (Shape, Tab, gpx, csv, csv_wkt, excel, kml или несколько через запятую)
     * @param {String} [params.query] SQL запрос для сохранения выборки данных вместо всех данных слоя
     * @param {Array} [params.columns] Атрибуты, которые нужно скачать. Массив объектов с ключами {Value, Alias}
    */


    mapHelper$1.prototype.downloadVectorLayer = function (params) {
      var requestParams = {
        t: params.name
      };

      if (params.format) {
        requestParams.format = params.format;
      }

      if (params.query) {
        requestParams.query = params.query;
      }

      if (params.columns) {
        requestParams.columns = JSON.stringify(params.columns);
      }

      sendCrossDomainPostRequest(window.location.protocol + "//" + params.host + "/" + "DownloadLayer.ashx", requestParams); // if (window.FormData) {
      //
      // 	var form = document.createElement("form");
      // 	form.style.display = 'none';
      // 	form.setAttribute('enctype', 'multipart/form-data');
      // 	form.name = 'uploadFile';
      //
      // 	var hiddenParamsDiv = document.createElement("div");
      // 	hiddenParamsDiv.style.display = 'none';
      //
      // 	for (var paramName in requestParams) {
      // 		var input = document.createElement("input");
      // 		var value = typeof requestParams[paramName] !== 'undefined' ? requestParams[paramName] : '';
      //
      // 		input.setAttribute('type', 'hidden');
      // 		input.setAttribute('name', paramName);
      // 		input.setAttribute('value', value);
      //
      // 		hiddenParamsDiv.appendChild(input)
      // 	}
      //
      //     form.appendChild(hiddenParamsDiv);
      //
      // 	var formData = new FormData(form);
      //
      //
      // 	var xhr = new XMLHttpRequest();
      // 	// :attachment; filename="suda_15062017_Sentinel_poly.zip";
      // 	xhr.open('POST', /*"http://" + /*params.host*/ window.serverBase + /*"/" + */"DownloadLayer.ashx");
      //
      // 	// xhr.setRequestHeader('Content-Disposition', 'attachment');
      // 	xhr.onload = function () {
      // 		if (xhr.status === 200) {
      // 			// var blob = new Blob([xhr.response], {type: "application/zip"});
      // 			var blob = xhr.response;
      // 			console.log(xhr);
      // 			console.log(blob);
      // 			saveData(blob, params.name);
      // 		}
      // 	}
      //
      // 	xhr.withCredentials = true;
      // 	xhr.responseType = "blob";
      // 	xhr.send(formData);
      //
      // 	function saveData(blob, name) {
      // 		var url = window.URL.createObjectURL(blob),
      // 		a = document.createElement("a");
      // 		console.log(url);
      // 		document.body.appendChild(a);
      // 		a.style = "display: none";
      // 		a.href = url;
      // 		a.download = name;
      // 		// a.click();
      // 		window.URL.revokeObjectURL(url);
      // 	};
      // }
    };

    var _mapHelper$1 = new mapHelper$1();

    window._mapHelper = _mapHelper$1;
    window.mapHelper = mapHelper$1;

    mapHelp$1.mapHelp.load = function () {
      var alreadyLoaded = _mapHelper$1.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _mapHelper$1.load();
    };

    mapHelp$1.mapHelp.unload = function () {};

    mapHelp$1.serviceHelp.load = function () {
      var alreadyLoaded = _serviceHelper.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _serviceHelper.load();
    };

    mapHelp$1.serviceHelp.unload = function () {};

    var serviceHelper = function serviceHelper() {
      this.builded = false;
    };

    serviceHelper.prototype = new leftMenu$1();

    serviceHelper.prototype.load = function () {
      var _this = this;

      if (!this.builded) {
        var fileName;
        if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.servicesFilePrefix !== 'undefined') fileName = window.gmxViewerUI.servicesFilePrefix;else fileName = window.gmxJSHost ? window.gmxJSHost + "servicesHelp" : "servicesHelp";
        fileName += _gtxt("helpPostfix");

        _mapHelper$1._loadHelpTextFromFile(fileName, function (text) {
          var div = _div$1(null, [['dir', 'className', 'help']]);

          div.innerHTML = text;

          _$2(_this.workCanvas, [div]);
        });

        this.builded = true;
      }
    };

    var _serviceHelper = new serviceHelper();

    window._serviceHelper = _serviceHelper;

    mapHelp$1.tabs.load = function () {
      var alreadyLoaded = _queryTabs.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _queryTabs.load();
    };

    mapHelp$1.tabs.unload = function () {};

    mapHelp$1.externalMaps.load = function () {
      var alreadyLoaded = _queryExternalMaps.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _queryExternalMaps.load();
    };

    mapHelp$1.externalMaps.unload = function () {}; //Динамически подгружаемые части вьюера
    //Редактирование мультислоя


    nsGmx$1.createMultiLayerEditorServer = gmxCore$1.createDeferredFunction('MultiLayerEditor', 'createMultiLayerEditorServer');
    nsGmx$1.createMultiLayerEditorNew = gmxCore$1.createDeferredFunction('MultiLayerEditor', 'createMultiLayerEditorNew'); //Редактирование карты и группы

    nsGmx$1.addSubGroup = gmxCore$1.createDeferredFunction('GroupEditor', 'addSubGroup');
    nsGmx$1.createGroupEditor = gmxCore$1.createDeferredFunction('GroupEditor', 'createGroupEditor');
    nsGmx$1.createMapEditor = gmxCore$1.createDeferredFunction('GroupEditor', 'createMapEditor'); //Редактирование свойств слоя

    nsGmx$1.createLayerEditor = gmxCore$1.createDeferredFunction('LayerEditor', 'createLayerEditor'); //Редактирование стилей векторного слоя

    nsGmx$1.createStylesDialog = gmxCore$1.createDeferredFunction('LayerStylesEditor', 'createStylesDialog'); //Библиотека стилей

    nsGmx$1.showStyleLibraryDialog = gmxCore$1.createDeferredFunction('StyleLibrary', 'showStyleLibraryDialog');

    (function ($) {
      $.extend(nsGmx$1, {
        ROLE_ADMIN: 'admin',
        ROLE_USER: 'user',
        ROLE_GUEST: 'guest',
        ROLE_UNAUTHORIZED: undefined,
        ACTION_CREATE_LAYERS: 'createData',
        // Создавать новые слои (векторные и растровые)
        ACTION_CREATE_MAP: 'createMap',
        // Cоздавать новые карты
        ACTION_SAVE_MAP: 'saveMap',
        // Сохранять карту (нужны права редактирования на карту)
        ACTION_CHANGE_MAP_TYPE: 'changeType',
        // Менять тип карты (публичная/открытая/закрытая и т.п.)
        ACTION_SEE_OPEN_MAP_LIST: 'openMap',
        // Видеть список публичных карт
        ACTION_SEE_PRIVATE_MAP_LIST: 'privateMap',
        // Видеть спискок всех карт
        ACTION_SEE_MAP_RIGHTS: 'seeRights',
        // Видеть и редактировать права пользователей (для объектов, владельцем которых является)
        ACTION_SEE_FILE_STRUCTURE: 'seeFiles',
        // Видеть всю файловую структуру сервера, а не только свою дом. директорию
        ACTION_SEE_ALL_USERS: 'seeUsers',
        // Видеть список всех пользователей
        ACTION_SEE_USER_FULLNAME: 'seeUserFullname',
        // Видеть полные имена и логины пользователей (а не только псевдонимы)
        ACTION_UPLOAD_FILES: 'uploadFiles' // Загружать файлы на сервер через web-интерфейс

      });
      var _actions = {};
      _actions[nsGmx$1.ROLE_ADMIN] = {};
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_CREATE_LAYERS] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_CREATE_MAP] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SAVE_MAP] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_OPEN_MAP_LIST] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_PRIVATE_MAP_LIST] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_CHANGE_MAP_TYPE] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_MAP_RIGHTS] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_FILE_STRUCTURE] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_ALL_USERS] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_USER_FULLNAME] = true;
      _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_UPLOAD_FILES] = true;
      _actions[nsGmx$1.ROLE_USER] = {};
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_CREATE_LAYERS] = true;
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_CREATE_MAP] = true;
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_SAVE_MAP] = true;
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_SEE_OPEN_MAP_LIST] = true;
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_SEE_MAP_RIGHTS] = true;
      _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_UPLOAD_FILES] = true;
      _actions[nsGmx$1.ROLE_GUEST] = {};
      _actions[nsGmx$1.ROLE_GUEST][nsGmx$1.ACTION_SEE_OPEN_MAP_LIST] = true;
      _actions[nsGmx$1.ROLE_GUEST][nsGmx$1.ACTION_SAVE_MAP] = true;
      nsGmx$1.AuthManager = new function () {
        var _userInfo = null;

        var _this = this;

        this.getLogin = function () {
          if (!_userInfo) return null;
          return _userInfo.Login || null;
        };

        this.getNickname = function () {
          if (!_userInfo) return null;
          return _userInfo.Nickname || null;
        };

        this.getFullname = function () {
          if (!_userInfo) return null;
          return _userInfo.FullName || null;
        };

        this.getUserFolder = function () {
          if (!_userInfo) return null;
          return _userInfo.Folder;
        };

        this.isRole = function (role) {
          return _userInfo && _userInfo.Role === role;
        };

        this.canDoAction = function (action) {
          return _userInfo && _userInfo.Role in _actions && action in _actions[_userInfo.Role];
        };

        this.isAccounts = function () {
          return _userInfo && _userInfo.IsAccounts;
        };

        this.isLogin = function () {
          return _userInfo && _userInfo.Login !== false && _userInfo.Role !== this.ROLE_UNAUTHORIZED;
        };

        this.setUserInfo = function (userInfo) {
          _userInfo = $.extend({}, {
            IsAccounts: false,
            Role: this.ROLE_UNAUTHORIZED
          }, userInfo);
          $(this).triggerHandler('change');
        };

        this.checkUserInfo = function (callback, errorCallback) {
          //var isTokenUsed = false;
          var _processResponse = function _processResponse(response) {
            var resOk = parseResponse(response);
            !resOk && errorCallback && errorCallback();

            if (response.Result == null || !resOk) {
              // юзер не авторизован
              _this.setUserInfo({
                Login: false
              });
            } else {
              _this.setUserInfo(response.Result);
            }

            resOk && callback && callback();
          };

          for (var iProvider = 0; iProvider < checkProviders.length; iProvider++) {
            if (checkProviders[iProvider].canAuth()) {
              checkProviders[iProvider].doAuth(callback, errorCallback);
              return;
            }
          }

          sendCrossDomainJSONRequest$2(serverBase + 'User/GetUserInfo.ashx?WrapStyle=func', function (response) {
            if (response.Status === 'ok' && !response.Result && window.mapsSite && window.gmxAuthServer) {
              var callbackPath = location.href.match(/(.*)\//)[0] + 'oAuthCallback.html';
              nsGmx$1.Utils.login(callbackPath, serverBase + 'oAuth/', function (userInfo) {
                _processResponse({
                  Status: 'ok',
                  Result: userInfo || null
                });
              }, null, true);
            } else {
              doAuthServerLogin(response.Result && response.Result.Token);

              _processResponse(response);
            }
          });
        };

        this.login = function (login, password, callback, errorCallback) {
          sendCrossDomainPostRequest(serverBase + "Login.ashx", {
            WrapStyle: 'message',
            login: login,
            pass: password
          }, function (response) {
            if (response.Status == 'ok' && response.Result) {
              _this.setUserInfo(response.Result);

              doAuthServerLogin(response.Result && response.Result.Token);
              callback && callback();
            } else {
              if (response.Status === 'auth' && 'Result' in response && _typeof(response.Result) === 'object' && 'ExceptionType' in response.Result && response.Result.ExceptionType.indexOf('System.ArgumentException') == 0) {
                errorCallback && errorCallback({
                  emailWarning: true,
                  message: response.Result.Message
                });
              }

              errorCallback && errorCallback({
                emailWarning: false
              });
            }
          });
        };

        this.logout = function (callback) {
          sendCrossDomainJSONRequest$2(serverBase + "Logout.ashx?WrapStyle=func&WithoutRedirection=1", function (response) {
            if (!parseResponse(response)) return;

            if (_this.isAccounts() && window.gmxAuthServer) {
              sendCrossDomainJSONRequest$2(window.gmxAuthServer + "Handler/Logout", function (response) {
                //TODO: check result
                _this.setUserInfo({
                  Login: false
                });

                callback && callback();
              }, 'callback');
            } else {
              _this.setUserInfo({
                Login: false
              });

              callback && callback();
            }
          });
        };

        this.changePassword = function (oldPass, newPass, callback, errorCallback) {
          sendCrossDomainJSONRequest$2(serverBase + "ChangePassword.ashx?WrapStyle=func&old=" + encodeURIComponent(oldPass) + "&new=" + encodeURIComponent(newPass), function (response) {
            if (response.Status == 'ok' && response.Result) callback && callback();else {
              var msg = response.ErrorInfo && typeof response.ErrorInfo.ErrorMessage != 'undefined' ? response.ErrorInfo.ErrorMessage : null;
              errorCallback && errorCallback(msg);
            }
          });
        };
      }();
      var checkProviders = [];

      var doAuthServerLogin = function doAuthServerLogin(token) {
        if (token && window.mapsSite && window.gmxAuthServer) {
          sendCrossDomainJSONRequest$2(gmxAuthServer + 'Handler/Me?token=' + encodeURIComponent(token), function (response) {//console.log(response);
          }, 'callback');
        }
      }; //canAuth() -> bool
      //doAuth(callbackSuccess, callbackError)


      nsGmx$1.AuthManager.addCheckUserMethod = function (provider) {
        checkProviders.push(provider);
      };
    })(jQuery);

    nsGmx$1.GmxWidgetMixin = {
      getContainer: function getContainer() {
        return this.el || this._container;
      },
      appendTo: function appendTo(el) {
        el = el[0] || el;
        el.appendChild(this.getContainer());
      },
      show: function show() {
        var el = this.getContainer();
        el.style.display = this._previousStyleDisplayValue !== 'none' && this._previousStyleDisplayValue || 'block';
        delete this._previousStyleDisplayValue;
      },
      hide: function hide() {
        var el = this.getContainer();
        this._previousStyleDisplayValue = el.style.display;
        el.style.display = 'none';
      },
      _terminateMouseEvents: function _terminateMouseEvents(el) {
        el = el || this.getContainer();
        L.DomEvent.disableClickPropagation(el);
        el.addEventListener('mousewheel', L.DomEvent.stopPropagation);
        el.addEventListener('mousemove', L.DomEvent.stopPropagation);
      }
    };
    nsGmx$1.GmxWidget = Backbone.View.extend(nsGmx$1.GmxWidgetMixin);

    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.DropdownMenuWidget = {};
    nsGmx$1.Templates.DropdownMenuWidget["dropdownMenuWidget"] = "<div class=\"dropdownMenuWidget ui-widget\">\n" + "    {{#each items}}\n" + "    <div class=\"dropdownMenuWidget-item{{#if className}} {{className}}{{/if}}\">\n" + "        <a\n" + "            {{#if id}}id=\"{{id}}\"{{/if}}\n" + "            {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" + "            {{#if newWindow}}{{#if link}}target=\"_blank\"{{/if}}{{/if}}\n" + "            class=\"dropdownMenuWidget-itemAnchor{{#if newWindow}} dropdownMenuWidget-itemAnchor_newWindow{{/if}}\"\n" + "        >\n" + "            {{#if icon}}\n" + "                <img src=\"{{icon}}\" />\n" + "            {{/if}}\n" + "            {{#if fonticon}}\n" + "                <i class=\"{{fonticon}}\"></i>\n" + "            {{/if}}\n" + "            {{#if title}}\n" + "                <span>{{title}}</span>\n" + "                {{#if dropdown}}<i class=\"icon-angle-down\"></i>{{/if}}\n" + "            {{/if}}\n" + "        </a>\n" + "        {{#if dropdown}}\n" + "            <div class=\"dropdownMenuWidget-itemDropdown\">\n" + "                <ul class=\"dropdownMenuWidget-dropdownMenu\">\n" + "                    {{#each dropdown}}\n" + "                        <li class=\"dropdownMenuWidget-dropdownMenuItem{{#if className}} {{className}}{{/if}}\">\n" + "                            {{#if newWindow}}<div class=\"ui-icon ui-icon-newwin dropdownMenuWidget-dropdownMenuIcon\"></div>{{/if}}\n" + "                            <a\n" + "                                {{#if id}}id=\"{{id}}\"{{/if}}\n" + "                                {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" + "                                {{#if newWindow}}{{#if link}}target=\"_blank\"{{/if}}{{/if}}\n" + "                                class=\"dropdownMenuWidget-dropdownItemAnchor{{#if newWindow}} dropdownMenuWidget-dropdownItemAnchor_newWindow{{/if}}\"\n" + "                            >\n" + "                                {{#if icon}}\n" + "                                    <img src=\"{{icon}}\" />\n" + "                                {{/if}}\n" + "                                {{#if title}}\n" + "                                    <span>{{title}}</span>\n" + "                                {{/if}}\n" + "                            </a>\n" + "                        </li>\n" + "                    {{/each}}\n" + "                </ul>\n" + "            </div>\n" + "        {{/if}}\n" + "    </div>\n" + "    {{/each}}\n" + "</div>\n" + "";
    nsGmx$1.Templates.DropdownMenuWidget["anchor"] = "<a \n" + "    {{#if id}}id=\"{{id}}\"{{/if}}\n" + "    {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" + "    {{#if newWindow}}target=\"_blank\" class=\"dropdownMenuWidget-anchor_newWindow\"{{/if}}\n" + ">\n" + "    {{#if icon}}\n" + "        <img src=\"{{icon}}\" />\n" + "    {{/if}}\n" + "    {{#if title}}\n" + "        <span>{{title}}</span>\n" + "    {{/if}}\n" + "</a>";
    nsGmx$1.PlainTextWidget = nsGmx$1.GmxWidget.extend({
      initialize: function initialize(txt) {
        this.setText(txt);
        this.$el.on('click', function () {
          this.trigger('click');
        }.bind(this));
      },
      getText: function getText() {
        return this.$el.html();
      },
      setText: function setText(txt) {
        this.$el.html(txt);
      }
    }); // <String>options.title
    // <String>options.className
    // <String>options.trigger (hover|click|manual)
    // <String>options.direction (down|up)
    // <Boolean>options.adjustWidth
    // <Boolean>options.showTopItem

    nsGmx$1.DropdownWidget = nsGmx$1.GmxWidget.extend({
      className: 'dropdownWidget dropdownWidget-item',
      options: {
        title: '',
        trigger: 'hover',
        direction: 'down',
        adjustWidth: true,
        showTopItem: true,
        titleClassName: ''
      },
      initialize: function initialize(options) {
        this.options = _.extend(this.options, options);
        this.$titleContainer = $('<div>').addClass('dropdownWidget-dropdownTitle').addClass(options.titleClassName).html(this.options.title).appendTo(this.$el);
        this.$dropdownContainer = $('<div>').addClass('dropdownWidget-dropdown').hide().appendTo(this.$el);
        this.$dropdownTitle = $('<div>').addClass('dropdownWidget-item dropdownWidget-dropdownTitle').addClass(options.titleClassName).html(this.options.title).appendTo(this.$dropdownContainer);

        if (!this.options.showTopItem) {
          this.$dropdownTitle.hide();
        }

        if (this.options.trigger === 'hover') {
          this.$dropdownTitle.addClass('ui-state-disabled');
          this.$titleContainer.on('mouseover', function (je) {
            this.expand();
          }.bind(this));
          this.$dropdownContainer.on('mouseleave', function (je) {
            this.collapse();
          }.bind(this));
        } else if (this.options.trigger === 'click') {
          this.$titleContainer.on('click', function (je) {
            this.expand();
          }.bind(this));
          this.$dropdownTitle.on('click', function (je) {
            this.collapse();
          }.bind(this));
        }

        if (this.options.direction === 'up') {
          this.$el.addClass('dropdownWidget_direction-up');
        } else {
          this.$el.addClass('dropdownWidget_direction-down');
        }

        this._items = {};
      },
      addItem: function addItem(id, inst, position) {
        this._items[id] = inst;
        var $container = $('<div>').addClass('dropdownWidget-item dropdownWidget-dropdownItem').attr('data-id', id).attr('data-position', position).on('click', function (je) {
          this.trigger('item', $(je.currentTarget).attr('data-id'));
          this.trigger('item:' + $(je.currentTarget).attr('data-id'));

          if (this.options.trigger === 'click') {
            this.collapse();
          }
        }.bind(this));
        $container.append(inst.el);
        this.$dropdownContainer.append($container);

        this._sortItems();
      },
      setTitle: function setTitle(title) {
        this.$titleContainer.html(title);
        this.$dropdownTitle.html(title);
      },
      toggle: function toggle() {
        this._expanded ? this.collapse() : this.expand();
        this._expanded = !this._expanded;
      },
      expand: function expand() {
        this.$dropdownContainer.css('min-width', this.$el.width());
        this.$dropdownContainer.show();
        this.trigger('expand');
      },
      collapse: function collapse() {
        this.$dropdownContainer.hide();
        this.trigger('collapse');
      },
      reset: function reset() {
        this.collapse();
      },
      _sortItems: function _sortItems() {
        var containerEl = this.$dropdownContainer[0];
        var items = Array.prototype.slice.call(containerEl.children);
        var titleEl = items.splice(items.indexOf($(containerEl).find('.dropdownWidget-dropdownTitle')[0]), 1);

        while (items.length) {
          var maxPositionIndex = items.indexOf(_.max(items, function (el) {
            return el.getAttribute('data-position') / 1;
          }));
          $(containerEl).prepend(items.splice(maxPositionIndex, 1)[0]);
        }

        if (this.options.direction === 'up') {
          $(containerEl).append(titleEl);
        } else {
          $(containerEl).prepend(titleEl);
        }
      }
    });

    nsGmx$1.DropdownMenuWidget = function () {
      var DropdownMenuWidget = function DropdownMenuWidget(options) {
        var h = Handlebars.create();
        h.registerPartial('anchor', nsGmx$1.Templates.DropdownMenuWidget.anchor);
        this._view = $(h.compile(nsGmx$1.Templates.DropdownMenuWidget.dropdownMenuWidget)({
          items: options.items
        }));

        this._view.find('.dropdownMenuWidget-itemDropdown').hide();

        var mouseTimeout = options.mouseTimeout || 100;

        this._view.find('.dropdownMenuWidget-item').each(function (index) {
          var mouseIsOver = false;
          $(this).on('mouseenter', function (je) {
            mouseIsOver = true;
            setTimeout(function () {
              if (mouseIsOver) {
                $(je.currentTarget).find('.dropdownMenuWidget-itemDropdown').show();
              }
            }, 100);
          });
          $(this).on('mouseleave', function (je) {
            mouseIsOver = false;
            $(je.currentTarget).find('.dropdownMenuWidget-itemDropdown').hide();
          });
        });
      };

      DropdownMenuWidget.prototype.appendTo = function (placeholder) {
        $(placeholder).append(this._view);
      };

      return DropdownMenuWidget;
    }();

    nsGmx$1.HeaderWidget = function () {

      var SocialShareWidget = function SocialShareWidget(socials) {
        this._view = Handlebars.compile(nsGmx$1.Templates.HeaderWidget.socials)(socials);
      };

      SocialShareWidget.prototype.appendTo = function (placeholder) {
        $(placeholder).append(this._view);
      };

      var HeaderWidget = function HeaderWidget(options) {
        var addDots = function addDots(item) {
          if (!item.icon && !item.className) {
            item.className = item.className + ' headerWidget-menuDot';
          }

          return item;
        };

        var h = Handlebars.create();
        this._view = $(h.compile(nsGmx$1.Templates.HeaderWidget.layout)(options));

        if (nsGmx$1.DropdownMenuWidget) {
          new nsGmx$1.DropdownMenuWidget({
            items: options.leftLinks && options.leftLinks.map(addDots)
          }).appendTo(this._view.find('.headerWidget-leftLinksContainer'));
          new nsGmx$1.DropdownMenuWidget({
            items: options.rightLinks && options.rightLinks.map(addDots)
          }).appendTo(this._view.find('.headerWidget-rightLinksContainer'));
        } else {
          console.warn('DropdownMenuWidget not found');
        }

        new SocialShareWidget(options.socials).appendTo(this._view.find('.headerWidget-socialsContainer'));

        this._view.find(".headerWidget-authContainer").hide();

        this._view.find(".headerWidget-menuContainer").hide();

        this._view.find(".headerWidget-searchContainer").hide();

        this._view.find(".headerWidget-languageContainer").hide();

        if (!options.socials) {
          this._view.find(".headerWidget-socialsContainer").hide();
        }
      };

      HeaderWidget.prototype.appendTo = function (placeholder) {
        $(placeholder).append(this._view);
      };

      HeaderWidget.prototype.getAuthPlaceholder = function () {
        return this._view.find(".headerWidget-authContainer").show();
      };

      HeaderWidget.prototype.getMenuPlaceholder = function () {
        return this._view.find(".headerWidget-menuContainer").show();
      };

      HeaderWidget.prototype.getSearchPlaceholder = function () {
        return this._view.find(".headerWidget-searchContainer").show();
      };

      HeaderWidget.prototype.getLanguagePlaceholder = function () {
        return this._view.find(".headerWidget-languageContainer").show();
      };

      HeaderWidget.prototype.getSocialsPlaceholder = function (first_argument) {
        return this._view.find(".headerWidget-socialsContainer");
      };

      return HeaderWidget;
    }();
    nsGmx$1.Translations.addText('rus', {
      header: {
        'langRu': 'Ru',
        'langEn': 'En'
      }
    });
    nsGmx$1.Translations.addText('eng', {
      header: {
        'langRu': 'Ru',
        'langEn': 'En'
      }
    });
    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.HeaderWidget = {};
    nsGmx$1.Templates.HeaderWidget["layout"] = "<div class=\"headerWidget\">\n" + "    <div class=\"headerWidget-left\">\n" + "        <div class=\"headerWidget-logoContainer\">\n" + "            <img class=\"headerWidget-logo\" src=\"{{logo}}\" />\n" + "        </div>\n" + "    </div>\n" + "    <div class=\"headerWidget-right\">\n" + "        <div class=\"headerWidget-bar headerWidget-controlsBar\">\n" + "            <div class=\"headerWidget-barTable headerWidget-controlsBarTable\">\n" + "                <div class=\"headerWidget-barCell headerWidget-menuContainer\"></div>\n" + "                <div class=\"headerWidget-barCell headerWidget-authContainer\"></div>\n" + "                <div class=\"headerWidget-barCell headerWidget-languageContainer\"></div>\n" + "            </div>\n" + "        </div>\n" + "    </div>\n" + "</div>\n" + "";
    nsGmx$1.Templates.HeaderWidget["socials"] = "<div class=\"headerWidget-socialIcons\">\n" + "    {{#if vk}}\n" + "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{vk}}\" target=\"_blank\"><i class=\"icon-vk\"></i></a></div>\n" + "    {{/if}}\n" + "    {{#if facebook}}\n" + "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{facebook}}\" target=\"_blank\"><i class=\"icon-facebook\"></i></a></div>\n" + "    {{/if}}\n" + "    {{#if twitter}}\n" + "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{twitter}}\" target=\"_blank\"><i class=\"icon-twitter\"></i></a></div>\n" + "    {{/if}}\n" + "</div>";

    nsGmx$1.LanguageWidget = function () {
      var LanguageWidget = function LanguageWidget(options) {
        this._view = $(Handlebars.compile(nsGmx$1.Templates.LanguageWidget.layout)({
          eng: nsGmx$1.Translations.getLanguage() === 'eng',
          rus: nsGmx$1.Translations.getLanguage() === 'rus'
        }));

        if (nsGmx$1.Translations.getLanguage() !== 'eng') {
          this._view.find('.languageWidget-item_eng').click(function () {
            nsGmx$1.Translations.updateLanguageCookies('eng'); // присвоение url не работает, если есть #

            window.location.reload(false);
          });
        }

        if (nsGmx$1.Translations.getLanguage() !== 'rus') {
          this._view.find('.languageWidget-item_rus').click(function () {
            nsGmx$1.Translations.updateLanguageCookies('rus');
            window.location.reload(false);
          });
        }
      };

      LanguageWidget.prototype.appendTo = function (placeholder) {
        $(placeholder).append(this._view);
      };

      return LanguageWidget;
    }();
    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.LanguageWidget = {};
    nsGmx$1.Templates.LanguageWidget["layout"] = "<div class=\"languageWidget ui-widget\">\n" + "    <div class=\"languageWidget-item languageWidget-item_rus\"><span class=\"{{^rus}}link languageWidget-link{{/rus}}{{#rus}}languageWidget-disabled{{/rus}}\">Ru</span></div>\n" + "    <div class=\"languageWidget-item languageWidget-item_eng\"><span class=\"{{^eng}}link languageWidget-link{{/eng}}{{#eng}}languageWidget-disabled{{/eng}}\">En</span></div>\n" + "</div>";

    function each(o, cb) {
      for (var p in o) {
        if (o.hasOwnProperty(p)) {
          cb(o[p], p, o);
        }
      }
    }

    function find(ar, cb) {
      if (ar.length) {
        for (var i = 0; i < ar.length; i++) {
          if (cb(ar[i])) {
            return ar[i];
          }
        }
      } else {
        for (var p in ar) {
          if (ar.hasOwnProperty(p) && cb(ar[p])) {
            return ar[p];
          }
        }
      }
    }

    function first(o) {
      for (var p in o) {
        if (o.hasOwnProperty(p)) {
          return o[p];
        }
      }
    }

    function length(o) {
      var length = 0;

      for (var p in o) {
        if (o.hasOwnProperty(p)) {
          length++;
        }
      }

      return length;
    }

    function prepend(parent, el) {
      if (parent.children.length) {
        parent.insertBefore(el, parent.children[0]);
      } else {
        parent.appendChild(el);
      }
    }

    var IconLayers = L.Control.extend({
      includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,
      _getActiveLayer: function _getActiveLayer() {
        if (this._activeLayerId) {
          return this._layers[this._activeLayerId];
        } else if (length(this._layers)) {
          return first(this._layers);
        } else {
          return null;
        }
      },
      _getPreviousLayer: function _getPreviousLayer() {
        var activeLayer = this._getActiveLayer();

        if (!activeLayer) {
          return null;
        } else if (this._previousLayerId) {
          return this._layers[this._previousLayerId];
        } else {
          return find(this._layers, function (l) {
            return l.id !== activeLayer.id;
          }.bind(this)) || null;
        }
      },
      _getInactiveLayers: function _getInactiveLayers() {
        var ar = [];
        var activeLayerId = this._getActiveLayer() ? this._getActiveLayer().id : null;
        var previousLayerId = this._getPreviousLayer() ? this._getPreviousLayer().id : null;
        each(this._layers, function (l) {
          if (l.id !== activeLayerId && l.id !== previousLayerId) {
            ar.push(l);
          }
        });
        return ar;
      },
      _arrangeLayers: function _arrangeLayers() {
        var behaviors = {};

        behaviors.previous = function () {
          var layers = this._getInactiveLayers();

          if (this._getActiveLayer()) {
            layers.unshift(this._getActiveLayer());
          }

          if (this._getPreviousLayer()) {
            layers.unshift(this._getPreviousLayer());
          }

          return layers;
        };

        return behaviors[this.options.behavior].apply(this, arguments);
      },
      _getLayerCellByLayerId: function _getLayerCellByLayerId(id) {
        var els = this._container.getElementsByClassName('leaflet-iconLayers-layerCell');

        for (var i = 0; i < els.length; i++) {
          if (els[i].getAttribute('data-layerid') == id) {
            return els[i];
          }
        }
      },
      _createLayerElement: function _createLayerElement(layerObj) {
        var el = L.DomUtil.create('div', 'leaflet-iconLayers-layer');

        if (layerObj.title) {
          var titleContainerEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitleContainer');
          var titleEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitle');
          var checkIconEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerCheckIcon');
          titleEl.innerHTML = layerObj.title;
          titleContainerEl.appendChild(titleEl);
          el.appendChild(titleContainerEl);
          el.appendChild(checkIconEl);
        }

        if (layerObj.icon) {
          el.setAttribute('style', 'background-image: url(\'' + layerObj.icon + '\')');
        }

        return el;
      },
      _createLayerElements: function _createLayerElements() {
        var currentRow, layerCell;

        var layers = this._arrangeLayers();

        var activeLayerId = this._getActiveLayer() && this._getActiveLayer().id;

        for (var i = 0; i < layers.length; i++) {
          if (i % this.options.maxLayersInRow === 0) {
            currentRow = L.DomUtil.create('div', 'leaflet-iconLayers-layersRow');

            if (this.options.position.indexOf('bottom') === -1) {
              this._container.appendChild(currentRow);
            } else {
              prepend(this._container, currentRow);
            }
          }

          layerCell = L.DomUtil.create('div', 'leaflet-iconLayers-layerCell');
          layerCell.setAttribute('data-layerid', layers[i].id);

          if (i !== 0) {
            L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_hidden');
          }

          if (layers[i].id === activeLayerId) {
            L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_active');
          }

          if (this._expandDirection === 'left') {
            L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandLeft');
          } else {
            L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandRight');
          }

          layerCell.appendChild(this._createLayerElement(layers[i]));

          if (this.options.position.indexOf('right') === -1) {
            currentRow.appendChild(layerCell);
          } else {
            prepend(currentRow, layerCell);
          }
        }
      },
      _onLayerClick: function _onLayerClick(e) {
        e.stopPropagation();
        var layerId = e.currentTarget.getAttribute('data-layerid');
        var layer = this._layers[layerId];
        this.setActiveLayer(layer.layer);
        this.expand();
      },
      _attachEvents: function _attachEvents() {
        each(this._layers, function (l) {
          var e = this._getLayerCellByLayerId(l.id);

          if (e) {
            e.addEventListener('click', this._onLayerClick.bind(this));
          }
        }.bind(this));

        var layersRowCollection = this._container.getElementsByClassName('leaflet-iconLayers-layersRow');

        var onMouseEnter = function (e) {
          e.stopPropagation();
          this.expand();
        }.bind(this);

        var onMouseLeave = function (e) {
          e.stopPropagation();
          this.collapse();
        }.bind(this);

        var stopPropagation = function stopPropagation(e) {
          e.stopPropagation();
        }; //TODO Don't make functions within a loop.


        for (var i = 0; i < layersRowCollection.length; i++) {
          var el = layersRowCollection[i];
          el.addEventListener('mouseenter', onMouseEnter);
          el.addEventListener('mouseleave', onMouseLeave);
          el.addEventListener('mousemove', stopPropagation);
        }
      },
      _render: function _render() {
        this._container.innerHTML = '';

        this._createLayerElements();

        this._attachEvents();
      },
      _switchMapLayers: function _switchMapLayers() {
        if (!this._map) {
          return;
        }

        var activeLayer = this._getActiveLayer();

        var previousLayer = this._getPreviousLayer();

        if (previousLayer) {
          this._map.removeLayer(previousLayer.layer);
        } else {
          each(this._layers, function (layerObject) {
            var layer = layerObject.layer;

            this._map.removeLayer(layer);
          }.bind(this));
        }

        if (activeLayer) {
          this._map.addLayer(activeLayer.layer);
        }
      },
      options: {
        position: 'bottomleft',
        // one of expanding directions depends on this
        behavior: 'previous',
        // may be 'previous', 'expanded' or 'first'
        expand: 'horizontal',
        // or 'vertical'
        autoZIndex: true,
        // from L.Control.Layers
        maxLayersInRow: 5,
        manageLayers: true
      },
      initialize: function initialize(layers, options) {
        if (!L.Util.isArray(arguments[0])) {
          // first argument is options
          options = layers;
          layers = [];
        }

        L.setOptions(this, options);
        this._expandDirection = this.options.position.indexOf('left') != -1 ? 'right' : 'left';

        if (this.options.manageLayers) {
          this.on('activelayerchange', this._switchMapLayers, this);
        }

        this.setLayers(layers);
      },
      onAdd: function onAdd(map) {
        this._container = L.DomUtil.create('div', 'leaflet-iconLayers');
        L.DomUtil.addClass(this._container, 'leaflet-iconLayers_' + this.options.position);

        this._render();

        map.on('click', this.collapse, this);

        if (this.options.manageLayers) {
          this._switchMapLayers();
        }

        return this._container;
      },
      onRemove: function onRemove(map) {
        map.off('click', this.collapse, this);
      },
      setLayers: function setLayers(layers) {
        this._layers = {};
        layers.map(function (layer) {
          var id = L.stamp(layer.layer);
          this._layers[id] = L.extend(layer, {
            id: id
          });
        }.bind(this));

        if (this._container) {
          this._render();
        }
      },
      setActiveLayer: function setActiveLayer(layer) {
        var l = layer && this._layers[L.stamp(layer)];

        if (!l || l.id === this._activeLayerId) {
          return;
        }

        this._previousLayerId = this._activeLayerId;
        this._activeLayerId = l.id;

        if (this._container) {
          this._render();
        }

        this.fire('activelayerchange', {
          layer: layer
        });
      },
      expand: function expand() {
        this._arrangeLayers().slice(1).map(function (l) {
          var el = this._getLayerCellByLayerId(l.id);

          L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_hidden');
        }.bind(this));
      },
      collapse: function collapse() {
        this._arrangeLayers().slice(1).map(function (l) {
          var el = this._getLayerCellByLayerId(l.id);

          L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_hidden');
        }.bind(this));
      }
    }); // var iconLayers = function(layers, options) {
    //     return new IconLayers(layers, options);
    // };
    // iconLayers.Constructor = IconLayers;
    // window.L.control.iconLayers = iconLayers;
    // window.L.Control.IconLayers = window.L.control.iconLayers.Constructor;

    window.L.Control.IconLayers = IconLayers;

    /* ========================================================================
     * Bootstrap: tooltip.js v3.3.1
     * http://getbootstrap.com/javascript/#tooltip
     * Inspired by the original jQuery.tipsy by Jason Frame
     * ========================================================================
     * Copyright 2011-2014 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */
    +function ($) {
      // ===============================

      var Tooltip = function Tooltip(element, options) {
        this.type = this.options = this.enabled = this.timeout = this.hoverState = this.$element = null;
        this.init('tooltip', element, options);
      };

      Tooltip.VERSION = '3.3.1';
      Tooltip.TRANSITION_DURATION = 150;
      Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
          selector: 'body',
          padding: 0
        }
      };

      Tooltip.prototype.init = function (type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport);
        var triggers = this.options.trigger.split(' ');

        for (var i = triggers.length; i--;) {
          var trigger = triggers[i];

          if (trigger == 'click') {
            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
          } else if (trigger != 'manual') {
            var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';
            this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
          }
        }

        this.options.selector ? this._options = $.extend({}, this.options, {
          trigger: 'manual',
          selector: ''
        }) : this.fixTitle();
      };

      Tooltip.prototype.getDefaults = function () {
        return Tooltip.DEFAULTS;
      };

      Tooltip.prototype.getOptions = function (options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);

        if (options.delay && typeof options.delay == 'number') {
          options.delay = {
            show: options.delay,
            hide: options.delay
          };
        }

        return options;
      };

      Tooltip.prototype.getDelegateOptions = function () {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function (key, value) {
          if (defaults[key] != value) options[key] = value;
        });
        return options;
      };

      Tooltip.prototype.enter = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

        if (self && self.$tip && self.$tip.is(':visible')) {
          self.hoverState = 'in';
          return;
        }

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        clearTimeout(self.timeout);
        self.hoverState = 'in';
        if (!self.options.delay || !self.options.delay.show) return self.show();
        self.timeout = setTimeout(function () {
          if (self.hoverState == 'in') self.show();
        }, self.options.delay.show);
      };

      Tooltip.prototype.leave = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        clearTimeout(self.timeout);
        self.hoverState = 'out';
        if (!self.options.delay || !self.options.delay.hide) return self.hide();
        self.timeout = setTimeout(function () {
          if (self.hoverState == 'out') self.hide();
        }, self.options.delay.hide);
      };

      Tooltip.prototype.show = function () {
        var that = this;

        if (this.hasContent() && this.enabled) {
          this._toBeShown = true;

          this._preloadImages().then(function () {
            if (that._toBeShown) {
              that.doShow();
            }
          });
        }
      };

      Tooltip.prototype._preloadImages = function () {
        var that = this;
        var $images = $('<div>').html(that.getContent()).find('img');
        var srcs = Array.prototype.slice.apply($images).map(function (el) {
          return el.src;
        });
        var promises = srcs.map(function (src) {
          return $.Deferred(function (def) {
            var img = new Image();
            img.addEventListener('load', function () {
              def.resolve();
            });
            img.addEventListener('error', function () {
              def.reject();
            });
            img.src = src;
          }).promise();
        });
        return $.when.apply(null, promises);
      };

      Tooltip.prototype.doShow = function () {
        var e = $.Event('show.bs.' + this.type);
        this.$element.trigger(e);
        var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
        if (e.isDefaultPrevented() || !inDom) return;
        var that = this;
        var $tip = this.tip();
        var tipId = this.getUID(this.type);
        this.setContent();
        $tip.attr('id', tipId);
        this.$element.attr('aria-describedby', tipId);
        if (this.options.animation) $tip.addClass('fade');
        var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
        var autoToken = /\s?auto?\s?/i;
        var autoPlace = autoToken.test(placement);
        if (autoPlace) placement = placement.replace(autoToken, '') || 'top';
        $tip.detach().css({
          top: 0,
          left: 0,
          display: 'block'
        }).addClass(placement).data('bs.' + this.type, this);
        this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
        var pos = this.getPosition();
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;

        if (autoPlace) {
          var orgPlacement = placement;
          var $container = this.options.container ? $(this.options.container) : this.$element.parent();
          var containerDim = this.getPosition($container);
          placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < containerDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > containerDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < containerDim.left ? 'right' : placement;
          $tip.removeClass(orgPlacement).addClass(placement);
        }

        var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
        this.applyPlacement(calculatedOffset, placement);

        var complete = function complete() {
          var prevHoverState = that.hoverState;
          that.$element.trigger('shown.bs.' + that.type);
          that.hoverState = null;
          if (prevHoverState == 'out') that.leave(that);
        };

        $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
      };

      Tooltip.prototype.applyPlacement = function (offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight; // manually read margins because getBoundingClientRect includes difference

        var marginTop = parseInt($tip.css('margin-top'), 10);
        var marginLeft = parseInt($tip.css('margin-left'), 10); // we must check for NaN for ie 8/9

        if (isNaN(marginTop)) marginTop = 0;
        if (isNaN(marginLeft)) marginLeft = 0;
        offset.top = offset.top + marginTop;
        offset.left = offset.left + marginLeft; // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0

        $.offset.setOffset($tip[0], $.extend({
          using: function using(props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left)
            });
          }
        }, offset), 0);
        $tip.addClass('in'); // check to see if placing tip in new offset caused the tip to resize itself

        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;

        if (placement == 'top' && actualHeight != height) {
          offset.top = offset.top + height - actualHeight;
        }

        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left) offset.left += delta.left;else offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
      };

      Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
        this.arrow().css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isHorizontal ? 'top' : 'left', '');
      };

      Tooltip.prototype.setContent = function () {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
        $tip.removeClass('fade in top bottom left right');
      };

      Tooltip.prototype.hide = function (callback) {
        var that = this;
        var $tip = this.tip();
        var e = $.Event('hide.bs.' + this.type);
        this._toBeShown = false;

        function complete() {
          if (that.hoverState != 'in') $tip.detach();
          that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
          callback && callback();
        }

        this.$element.trigger(e);
        if (e.isDefaultPrevented()) return;
        $tip.removeClass('in');
        $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
      };

      Tooltip.prototype.fixTitle = function () {
        var $e = this.$element;

        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
        }
      };

      Tooltip.prototype.hasContent = function () {
        return this.getTitle();
      };

      Tooltip.prototype.getPosition = function ($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == 'BODY';
        var elRect = el.getBoundingClientRect();

        if (elRect.width == null) {
          // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
          elRect = $.extend({}, elRect, {
            width: elRect.right - elRect.left,
            height: elRect.bottom - elRect.top
          });
        }

        var elOffset = isBody ? {
          top: 0,
          left: 0
        } : $element.offset();
        var scroll = {
          scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        };
        var outerDims = isBody ? {
          width: $(window).width(),
          height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
      };

      Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? {
          top: pos.top + pos.height,
          left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'top' ? {
          top: pos.top - actualHeight,
          left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'left' ? {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left - actualWidth
        } :
        /* placement == 'right' */
        {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left + pos.width
        };
      };

      Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
        var delta = {
          top: 0,
          left: 0
        };
        if (!this.$viewport) return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);

        if (/right|left/.test(placement)) {
          var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;

          if (topEdgeOffset < viewportDimensions.top) {
            // top overflow
            delta.top = viewportDimensions.top - topEdgeOffset;
          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
            // bottom overflow
            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
          }
        } else {
          var leftEdgeOffset = pos.left - viewportPadding;
          var rightEdgeOffset = pos.left + viewportPadding + actualWidth;

          if (leftEdgeOffset < viewportDimensions.left) {
            // left overflow
            delta.left = viewportDimensions.left - leftEdgeOffset;
          } else if (rightEdgeOffset > viewportDimensions.width) {
            // right overflow
            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
          }
        }

        return delta;
      };

      Tooltip.prototype.getTitle = function () {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);
        return title;
      };

      Tooltip.prototype.getUID = function (prefix) {
        do {
          prefix += ~~(Math.random() * 1000000);
        } while (document.getElementById(prefix));

        return prefix;
      };

      Tooltip.prototype.tip = function () {
        return this.$tip = this.$tip || $(this.options.template);
      };

      Tooltip.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');
      };

      Tooltip.prototype.enable = function () {
        this.enabled = true;
      };

      Tooltip.prototype.disable = function () {
        this.enabled = false;
      };

      Tooltip.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled;
      };

      Tooltip.prototype.toggle = function (e) {
        var self = this;

        if (e) {
          self = $(e.currentTarget).data('bs.' + this.type);

          if (!self) {
            self = new this.constructor(e.currentTarget, this.getDelegateOptions());
            $(e.currentTarget).data('bs.' + this.type, self);
          }
        }

        self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
      };

      Tooltip.prototype.destroy = function () {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function () {
          that.$element.off('.' + that.type).removeData('bs.' + that.type);
        });
      }; // TOOLTIP PLUGIN DEFINITION
      // =========================


      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.tooltip');
          var options = _typeof(option) == 'object' && option;
          var selector = options && options.selector;
          if (!data && option == 'destroy') return;

          if (selector) {
            if (!data) $this.data('bs.tooltip', data = {});
            if (!data[selector]) data[selector] = new Tooltip(this, options);
          } else {
            if (!data) $this.data('bs.tooltip', data = new Tooltip(this, options));
          }

          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.tooltip;
      $.fn.tooltip = Plugin;
      $.fn.tooltip.Constructor = Tooltip; // TOOLTIP NO CONFLICT
      // ===================

      $.fn.tooltip.noConflict = function () {
        $.fn.tooltip = old;
        return this;
      };
    }(jQuery);
    /* ========================================================================
     * Bootstrap: popover.js v3.3.1
     * http://getbootstrap.com/javascript/#popovers
     * ========================================================================
     * Copyright 2011-2014 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */

    +function ($) {
      // ===============================

      var Popover = function Popover(element, options) {
        this.init('popover', element, options);
      };

      if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');
      Popover.VERSION = '3.3.1';
      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      }); // NOTE: POPOVER EXTENDS tooltip.js
      // ================================

      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
      Popover.prototype.constructor = Popover;

      Popover.prototype.getDefaults = function () {
        return Popover.DEFAULTS;
      };

      Popover.prototype.setContent = function () {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
        $tip.find('.popover-content').children().detach().end()[// we use append for html objects to maintain js events
        this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);
        $tip.removeClass('fade top bottom left right in'); // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.

        if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();
      };

      Popover.prototype.hasContent = function () {
        return this.getTitle() || this.getContent();
      };

      Popover.prototype.getContent = function () {
        var $e = this.$element;
        var o = this.options;
        return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
      };

      Popover.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find('.arrow');
      };

      Popover.prototype.tip = function () {
        if (!this.$tip) this.$tip = $(this.options.template);
        return this.$tip;
      }; // POPOVER PLUGIN DEFINITION
      // =========================


      function Plugin(option) {
        return this.each(function () {
          var $this = $(this);
          var data = $this.data('bs.popover');
          var options = _typeof(option) == 'object' && option;
          var selector = options && options.selector;
          if (!data && option == 'destroy') return;

          if (selector) {
            if (!data) $this.data('bs.popover', data = {});
            if (!data[selector]) data[selector] = new Popover(this, options);
          } else {
            if (!data) $this.data('bs.popover', data = new Popover(this, options));
          }

          if (typeof option == 'string') data[option]();
        });
      }

      var old = $.fn.popover;
      $.fn.popover = Plugin;
      $.fn.popover.Constructor = Popover; // POPOVER NO CONFLICT
      // ===================

      $.fn.popover.noConflict = function () {
        $.fn.popover = old;
        return this;
      };
    }(jQuery);

    nsGmx$1.Translations.addText('rus', {
      gmxIconLayers: {
        zoominpls: 'Приблизьте карту, чтобы активировать слой',
        zoomoutpls: 'Отдалите карту, чтобы активировать слой'
      }
    });
    nsGmx$1.Translations.addText('eng', {
      gmxIconLayers: {
        zoominpls: 'Zoom in to enable layer',
        zoomoutpls: 'Zoom out to enable layer'
      }
    });
    window.L.Control.GmxIconLayers = window.L.Control.IconLayers.extend({
      _updateLayers: function _updateLayers() {
        var lang = nsGmx$1.Translations.getLanguage();
        lang = lang || 'rus';
        var blm = this._baseLayersManager;
        var layers = blm.getActiveIDs().map(function (id) {
          var layer = blm.get(id);

          if (!layer) {
            return null;
          } else {
            return {
              layer: layer,
              icon: layer.options.icon,
              title: layer.options[lang]
            };
          }
        }).filter(function (e) {
          return e;
        });
        this.setLayers(layers);
        this.setActiveLayer(blm.get(blm.getCurrentID()));

        this._updateDisabledLayers();
      },
      _updateDisabledLayers: function _updateDisabledLayers() {
        this._disabledLayerIds = this._map ? this._baseLayersManager.getActiveIDs().map(function (id) {
          return this._baseLayersManager.get(id);
        }.bind(this)).filter(function (l) {
          return !!l && (this._map.getZoom() < l.options.minZoom || this._map.getZoom() > l.options.maxZoom);
        }.bind(this)).map(function (l) {
          return L.stamp(l) + '';
        }) : [];

        this._updateDisabledLayersStyle();
      },
      _updateDisabledLayersStyle: function _updateDisabledLayersStyle() {
        var els = this._container ? this._container.getElementsByClassName('leaflet-iconLayers-layerCell') : [];
        Array.prototype.slice.call(els).map(function (el) {
          var elId = el.getAttribute('data-layerid');

          if (this._disabledLayerIds.indexOf(elId) + 1) {
            L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_disabled');
          } else {
            L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_disabled');
          }
        }.bind(this));
      },
      _updatePopoversContent: function _updatePopoversContent() {
        var els = this._container ? this._container.getElementsByClassName('leaflet-iconLayers-layerCell') : [];
        var defaultTemplate = new $.fn.popover.Constructor().getDefaults().template;

        function createPopover(el, text) {
          $(el).popover({
            viewport: {
              selector: this._map && this._map.getContainer(),
              padding: 10
            },
            container: this._map && this._map.getContainer(),
            content: text,
            trigger: 'manual',
            placement: this.options.position.indexOf('bottom') != -1 ? 'top' : 'bottom',
            html: true,
            template: $(defaultTemplate).css('pointer-events', 'none')[0].outerHTML
          });

          if (el.mouseIsOver) {
            $(el).popover('show');
          }
        }

        Array.prototype.slice.call(els).map(function (el) {
          var elId = el.getAttribute('data-layerid');
          var layerEl = el.getElementsByClassName('leaflet-iconLayers-layer')[0];
          var layer = this._layers[elId].layer;

          if (layer.options.maxZoom && this._map && this._map.getZoom() > layer.options.maxZoom) {
            $(layerEl).popover('destroy');
            createPopover.call(this, layerEl, nsGmx$1.Translations.getText('gmxIconLayers.zoomoutpls'));
          } else if (layer.options.minZoom && this._map && this._map.getZoom() < layer.options.minZoom) {
            $(layerEl).popover('destroy');
            createPopover.call(this, layerEl, nsGmx$1.Translations.getText('gmxIconLayers.zoominpls'));
          } else if (layer.options.description) {
            $(layerEl).popover('destroy');
            createPopover.call(this, layerEl, layer.options.description);
          } else {
            $(layerEl).popover('destroy');
          }
        }.bind(this));
      },
      _createLayerElement: function _createLayerElement(layerObj) {
        var layer = layerObj.layer;

        var el = L.Control.IconLayers.prototype._createLayerElement.call(this, layerObj);

        var shutterEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerShutter');
        $(el).prepend(shutterEl);
        el.addEventListener('mouseover', function (e) {
          e.currentTarget.mouseIsOver = true;
          $(e.currentTarget).popover('show');
        });
        el.addEventListener('mouseout', function (e) {
          e.currentTarget.mouseIsOver = false;
          $(e.currentTarget).popover('hide');
        });
        return el;
      },
      _render: function _render() {
        L.Control.IconLayers.prototype._render.apply(this, arguments);

        this._updateDisabledLayers();

        this._updatePopoversContent();
      },
      _onLayerClick: function _onLayerClick(e) {
        e.stopPropagation();
        $(e.currentTarget).find('.leaflet-iconLayers-layer').popover('hide');
        var layerId = e.currentTarget.getAttribute('data-layerid');

        if (this._disabledLayerIds.indexOf(layerId) === -1) {
          var layer = this._layers[layerId];
          this.setActiveLayer(layer.layer);
        }

        this.expand();
      },
      initialize: function initialize(gmxBaseLayersManager, options) {
        L.Control.IconLayers.prototype.initialize.call(this, [], L.extend(options || {}, {
          manageLayers: false
        }));
        this._baseLayersManager = gmxBaseLayersManager;

        this._updateLayers();

        this.on('activelayerchange', function (le) {
          this._baseLayersManager.setCurrentID(le.layer.id);
        }.bind(this));

        this._baseLayersManager.on('baselayeradd', this._updateLayers.bind(this));

        this._baseLayersManager.on('baselayerremove', this._updateLayers.bind(this));

        this._baseLayersManager.on('baselayeractiveids', this._updateLayers.bind(this));

        this._baseLayersManager.on('baselayerchange', this._updateLayers.bind(this));

        this._baseLayersManager.on('baselayerlayerschange', this._updateLayers.bind(this));
      },
      onAdd: function onAdd() {
        var container = L.Control.IconLayers.prototype.onAdd.apply(this, arguments);

        this._map.on('zoomend', function () {
          this._updateDisabledLayers();

          this._updatePopoversContent();
        }.bind(this));

        return container;
      }
    });

    var DateInterval = Backbone.Model.extend({
      initialize: function initialize() {
        if (!('dateBegin' in this.attributes) && !('dateEnd' in this.attributes)) {
          this.set(DateInterval.getUTCDayBoundary());
        }
      },
      saveState: function saveState() {
        return {
          version: '1.1.0',
          dateBegin: +this.attributes.dateBegin,
          dateEnd: +this.attributes.dateEnd
        };
      },
      loadState: function loadState(state) {
        if (!state.version || state.version === '1.1.0' || state.version === '1.0.0') {
          this.set({
            dateBegin: new Date(state.dateBegin),
            dateEnd: new Date(state.dateEnd)
          });
        } else {
          throw 'Unknown state version';
        }
      }
    }, {
      //number of milliseconds in one day
      MS_IN_DAY: 24 * 3600 * 1000,
      //set time to UTC midnight
      toMidnight: function toMidnight(date) {
        return new Date(date - date % DateInterval.MS_IN_DAY);
      },
      getUTCDayBoundary: function getUTCDayBoundary(date) {
        date = date || new Date();
        var midnight = DateInterval.toMidnight(date);
        return {
          dateBegin: midnight,
          dateEnd: new Date(midnight.valueOf() + DateInterval.MS_IN_DAY)
        };
      },
      // 24+n interval
      defaultFireDateInterval: function defaultFireDateInterval() {
        var now = new Date(),
            lastMidnight = DateInterval.toMidnight(now),
            dateEnd = new Date(now - 1 - (now - 1) % (3600 * 1000) + 3600 * 1000),
            //round to the nearest hour greater then 'now'
        isTooSmall = dateEnd - lastMidnight < 12 * 3600 * 1000,
            dateBegin = new Date(isTooSmall ? lastMidnight - nsGmx$1.DateInterval.MS_IN_DAY : lastMidnight.valueOf());
        return {
          dateBegin: dateBegin,
          dateEnd: dateEnd
        };
      }
    });
    nsGmx$1.DateInterval = DateInterval;

    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.CalendarWidget = {};
    nsGmx$1.Templates.CalendarWidget["CalendarWidget"] = "<table>\n" + "    <tr>\n" + "        <td><div class = \"CalendarWidget-iconScrollLeft ui-helper-noselect icon-left-open\"></div></td>\n" + "        <td class = \"CalendarWidget-inputCell\"><input class = \"gmx-input-text CalendarWidget-dateBegin\"></td>\n" + "        <td class = \"CalendarWidget-inputCell CalendarWidget-onlyMaxVersion\"><input class = \"gmx-input-text CalendarWidget-dateEnd\"></td>\n" + "        <td><div class = \"CalendarWidget-iconScrollRight ui-helper-noselect icon-right-open\" ></div></td>\n" + "        <td><div class = \"CalendarWidget-iconMore {{moreIconClass}}\" title = \"{{moreIconTitle}}\"></div></td>\n" + "        <td><div class = \"CalendarWidget-forecast\" hidden>{{forecast}}</div></td>\n" + "    </tr><tr>\n" + "        <td></td>\n" + "        <td class = \"CalendarWidget-dateBeginInfo\"></td>\n" + "        <td class = \"CalendarWidget-dateEndInfo\"></td>\n" + "        <td></td>\n" + "        <td></td>\n" + "    </tr>\n" + "</table>\n" + "<div class=\"CalendarWidget-footer\"></div>\n" + "";

    (function ($) {

      var _gtxt = nsGmx$1.Translations.getText.bind(nsGmx$1.Translations),
          toMidnight = nsGmx$1.DateInterval.toMidnight;
      /** Параметры календаря
       * @typedef nsGmx.CalendarWidget~Parameters
       * @property {nsGmx.DateInterval} dateInterval Временной интервал, который нужно менять
       * @property {Date} [dateMin] минимальная граничная дата для календарей, null - без ограничений
       * @property {Date} [dateMax] максимальная граничная дата для календарей, null - без ограничений
       * @property {String} [dateFormat='dd.mm.yy'] формат даты
       * @property {bool} [minimized=true] показывать ли минимизированный или развёрнутый виджет в начале
       * @property {bool} [showSwitcher=true] показывать ли иконку для разворачивания/сворачивания периода
       * @property {Date} [dateBegin=<текущая дата>] начальная дата интервала
       * @property {Date} [dateEnd=<текущая дата>] конечная дата интервала
       * @property {String|DOMNode} [container] куда добавлять календарик
       * @property {String} [buttonImage] URL иконки для активации календариков
       */

      /** Контрол для задания диапазона дат. Даты календарика всегда в UTC, а не в текущем поясе.
       @description Виджет для выбора интервала дат. Пользователь при помощи datepicker'ов выбирает два дня (год, месяц, число),
                    затем выбранные значения при помощи ф-ции `_updateModel()` переводятся в интервал дат ({@link nsGmx.DateInterval}).
                    Так же виджет реагирует на изменения модели (с использованием ф-ции `_updateWidget()`)
       @alias nsGmx.CalendarWidget
       @extends nsGmx.GmxWidget
       @class
       @param {nsGmx.CalendarWidget~Parameters} options Параметры календаря
      */


      var Calendar = nsGmx$1.GmxWidget.extend({
        tagName: 'div',
        className: 'CalendarWidget ui-widget',
        template: Handlebars.compile(nsGmx$1.Templates.CalendarWidget.CalendarWidget),
        events: {
          'click .CalendarWidget-iconMore': 'toggleMode',
          'click .CalendarWidget-iconScrollLeft': function clickCalendarWidgetIconScrollLeft() {
            this._shiftDates(-1);
          },
          'click .CalendarWidget-iconScrollRight': function clickCalendarWidgetIconScrollRight() {
            this._shiftDates(1);
          }
        },
        initialize: function initialize(options) {
          options = $.extend({
            minimized: true,
            showSwitcher: true,
            dateMax: null,
            dateMin: null,
            dateFormat: 'dd.mm.yy',
            name: null
          }, options);
          this._dateMin = options.dateMin;
          this._dateMax = options.dateMax;
          this._dateInterval = options.dateInterval;
          this.$el.html(this.template({
            moreIconClass: options.minimized ? 'icon-calendar' : 'icon-calendar-empty',
            moreIconTitle: options.minimized ? _gtxt('CalendarWidget.ExtendedViewTitle') : _gtxt('CalendarWidget.MinimalViewTitle'),
            forecast: _gtxt('CalendarWidget.forecast')
          }));
          this._moreIcon = this.$('.CalendarWidget-iconMore').toggle(!!options.showSwitcher);
          this._dateBegin = this.$('.CalendarWidget-dateBegin');
          this._dateEnd = this.$('.CalendarWidget-dateEnd');
          this._dateInputs = this._dateBegin.add(this._dateEnd);

          this._dateInputs.datepicker({
            onSelect: function (dateText, inst) {
              this._selectFunc(inst.input);

              this._updateModel();
            }.bind(this),
            showAnim: 'fadeIn',
            changeMonth: true,
            changeYear: true,
            minDate: this._dateMin ? Calendar.toUTC(this._dateMin) : null,
            maxDate: this._dateMax ? Calendar.toUTC(this._dateMax) : null,
            dateFormat: options.dateFormat,
            defaultDate: Calendar.toUTC(this._dateMax || new Date()),
            showOn: options.buttonImage ? 'both' : 'focus',
            buttonImageOnly: true
          }); //устанавливаем опцию после того, как добавили календарик в canvas


          if (options.buttonImage) {
            this._dateInputs.datepicker('option', 'buttonImage', options.buttonImage);
          }

          this.$('.CalendarWidget-onlyMaxVersion').toggle(!options.minimized);
          options.dateBegin && this._dateBegin.datepicker('setDate', Calendar.toUTC(options.dateBegin));
          options.dateEnd && this._dateEnd.datepicker('setDate', Calendar.toUTC(options.dateEnd));

          if (options.container) {
            if (typeof options.container === 'string') $('#' + options.container).append(this.$el);else $(options.container).append(this.$el);
          }

          this.setMode(options.minimized ? Calendar.SIMPLE_MODE : Calendar.ADVANCED_MODE);

          this._updateWidget();

          this._dateInterval.on('change', this._updateWidget, this); //for backward compatibility


          this.canvas = this.$el;
        },
        _shiftDates: function _shiftDates(delta) {
          var dateBegin = this.getDateBegin(),
              dateEnd = this.getDateEnd();

          if (!dateBegin || !dateEnd) {
            return;
          }

          var shift = (dateEnd - dateBegin + nsGmx$1.DateInterval.MS_IN_DAY) * delta,
              newDateBegin = new Date(dateBegin.valueOf() + shift),
              newDateEnd = new Date(dateEnd.valueOf() + shift);

          if ((!this._dateMin || toMidnight(this._dateMin) <= toMidnight(newDateBegin)) && (!this._dateMax || toMidnight(this._dateMax) >= toMidnight(newDateEnd))) {
            this._dateBegin.datepicker('setDate', Calendar.toUTC(newDateBegin));

            this._dateEnd.datepicker('setDate', Calendar.toUTC(newDateEnd));

            this._updateModel();
          }
        },
        _selectFunc: function _selectFunc(activeInput) {
          var begin = this._dateBegin.datepicker('getDate');

          var end = this._dateEnd.datepicker('getDate');

          if (end && begin && begin > end) {
            var dateToFix = activeInput[0] == this._dateEnd[0] ? this._dateBegin : this._dateEnd;
            dateToFix.datepicker('setDate', $(activeInput[0]).datepicker('getDate'));
          } else if (this._curMode === Calendar.SIMPLE_MODE) {
            //либо установлена только одна дата, либо две, но отличающиеся
            if (!begin != !end || begin && begin.valueOf() !== end.valueOf()) {
              this._dateEnd.datepicker('setDate', this._dateBegin.datepicker('getDate'));
            }
          }
        },
        _updateModel: function _updateModel() {
          var dateBegin = this.getDateBegin(),
              dateEnd = this.getDateEnd();

          this._dateInterval.set({
            dateBegin: dateBegin ? toMidnight(dateBegin) : null,
            dateEnd: dateEnd ? toMidnight(dateEnd.valueOf() + nsGmx$1.DateInterval.MS_IN_DAY) : null
          });
        },
        _updateWidget: function _updateWidget() {
          var dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              dayms = nsGmx$1.DateInterval.MS_IN_DAY;

          if (!dateBegin || !dateEnd) {
            return;
          }
          var isValid = !(dateBegin % dayms) && !(dateEnd % dayms);
          var newDateBegin = Calendar.toUTC(dateBegin),
              newDateEnd;

          if (isValid) {
            newDateEnd = Calendar.toUTC(new Date(dateEnd - dayms));

            if (dateEnd - dateBegin > dayms) {
              this.setMode(Calendar.ADVANCED_MODE);
            }
          } else {
            newDateEnd = Calendar.toUTC(dateEnd);
            this.setMode(Calendar.ADVANCED_MODE);
          } //если мы сюда пришли после выбора интервала в самом виджете, вызов setDate сохраняет фокус на input-поле
          //возможно, это какая-то проблема jQueryUI.datepicker'ов.
          //чтобы этого избежать, явно проверяем, нужно ли изменять дату


          var prevDateBegin = this._dateBegin.datepicker('getDate'),
              prevDateEnd = this._dateEnd.datepicker('getDate');

          if (!prevDateBegin || prevDateBegin.valueOf() !== newDateBegin.valueOf()) {
            this._dateBegin.datepicker('setDate', newDateBegin);
          }

          if (!prevDateEnd || prevDateEnd.valueOf() !== newDateEnd.valueOf()) {
            this._dateEnd.datepicker('setDate', newDateEnd);
          }
        },
        //public interface

        /** Закрыть все открытые datepicker'ы.
         * @return {nsGmx.CalendarWidget} this
         */
        reset: function reset() {
          this._dateInputs.datepicker('hide');

          return this;
        },

        /** Сериализация состояния виджета
         * @return {Object} Сериализованное состояние
         */
        saveState: function saveState() {
          return {
            version: '1.1.0',
            vismode: this.getMode()
          };
        },

        /** Восстановить состояние виджета по сериализованным данным
         * @param {Object} data Сериализованное состояние календарика
         */
        loadState: function loadState(data) {
          this.setMode(data.vismode);
        },

        /** Получить начальную дату
         * @return {Date} начальная дата
         */
        getDateBegin: function getDateBegin() {
          return Calendar.fromUTC(this._dateBegin.datepicker('getDate'));
        },

        /** Получить конечную дату
         * @return {Date} конечная дата
         */
        getDateEnd: function getDateEnd() {
          return Calendar.fromUTC(this._dateEnd.datepicker('getDate'));
        },

        /** Получить верхнюю границу возможных дат периода
         * @return {Date} верхняя граница возможных периодов
         */
        getDateMax: function getDateMax() {
          return this._dateMax;
        },

        /** Получить нижнуюю границу возможных дат периода
         * @return {Date} нижняя граница возможных периодов
         */
        getDateMin: function getDateMin() {
          return this._dateMin;
        },

        /** Установить нижнуюю границу возможных дат периода
         * @param {Date} dateMin нижняя граница возможных периодов
         */
        setDateMin: function setDateMin(dateMin) {
          this._dateMin = dateMin;

          this._dateInputs.datepicker('option', 'minDate', dateMin ? Calendar.toUTC(dateMin) : null);
        },

        /** Установить верхнюю границу возможных дат периода
         * @param {Date} dateMax верхняя граница возможных периодов
         */
        setDateMax: function setDateMax(dateMax) {
          var titleContainer = this.$('.CalendarWidget-forecast');
          this._dateMax = dateMax;

          if (dateMax) {
            var utcDate = Calendar.toUTC(dateMax);

            this._dateInputs.datepicker('option', 'maxDate', utcDate);

            if (dateMax > new Date()) {
              $(titleContainer).attr('title', _gtxt('CalendarWidget.tooltip') + ' ' + ('0' + dateMax.getDate()).slice(-2) + '.' + ('0' + (dateMax.getMonth() + 1)).slice(-2) + '.' + dateMax.getFullYear());
              $(titleContainer).show();
            } else {
              $(titleContainer).hide();
            }
          } else {
            this._dateInputs.datepicker('option', 'maxDate', null);
          }
        },
        setSwitcherVisibility: function setSwitcherVisibility(isVisible) {
          this._moreIcon && this._moreIcon.toggle(isVisible);
        },
        getDateInterval: function getDateInterval() {
          return this._dateInterval;
        },
        getMode: function getMode() {
          return this._curMode;
        },
        setMode: function setMode(mode) {
          if (this._curMode === mode) {
            return this;
          }

          this.reset();
          this._curMode = mode;
          var isSimple = mode === Calendar.SIMPLE_MODE;
          this.$('.CalendarWidget-onlyMaxVersion').toggle(!isSimple);

          this._moreIcon.toggleClass('icon-calendar', isSimple).toggleClass('icon-calendar-empty', !isSimple).attr('title', isSimple ? _gtxt('CalendarWidget.ExtendedViewTitle') : _gtxt('CalendarWidget.MinimalViewTitle'));

          var dateBegin = this._dateBegin.datepicker('getDate'),
              dateEnd = this._dateEnd.datepicker('getDate');

          if (isSimple && dateBegin && dateEnd && dateBegin.valueOf() !== dateEnd.valueOf()) {
            this._selectFunc(this._dateEnd);

            this._updateModel();
          }

          this.trigger('modechange');
          return this;
        },
        toggleMode: function toggleMode() {
          this.setMode(this._curMode === Calendar.SIMPLE_MODE ? Calendar.ADVANCED_MODE : Calendar.SIMPLE_MODE);
        }
      }, {
        /* static methods */
        fromUTC: function fromUTC(date) {
          if (!date) return null;
          var timeOffset = date.getTimezoneOffset() * 60 * 1000;
          return new Date(date.valueOf() - timeOffset);
        },
        toUTC: function toUTC(date) {
          if (!date) return null;
          var timeOffset = date.getTimezoneOffset() * 60 * 1000;
          return new Date(date.valueOf() + timeOffset);
        },
        SIMPLE_MODE: 1,
        ADVANCED_MODE: 2
      });
      nsGmx$1.CalendarWidget = Calendar;
    })(jQuery);
    nsGmx$1.Translations.addText("rus", {
      CalendarWidget: {
        ExtendedViewTitle: "Выбор периода",
        MinimalViewTitle: "Свернуть",
        UTC: "Всемирное координированное время",
        forecast: "прогноз",
        tooltip: "доступны прогнозные данные до"
      }
    });
    nsGmx$1.Translations.addText("eng", {
      CalendarWidget: {
        ExtendedViewTitle: "Period selection",
        MinimalViewTitle: "Minimize",
        UTC: "Coordinated Universal Time",
        forecast: "forecast",
        tooltip: "forecast data is available up to"
      }
    });
    /** Контрол для задания диапазона дат с логикой работы, взятой с сайта fires.ru.
     @description Основное отличае в логине формировании интервала на основе выбранных в календариках дат.
                  Работает так же, как и обычный виджет ({@link nsGmx.CalendarWidget}) за исключением ситуации, когда dateEnd попадает в текущие UTC сутки.
                  В этом случае, dateEnd устанавливается равном началу следующего часа. Далее, если длина выбранного интервала меньше 12 часов, начало интервала смещается на сутки назад.
                  Кроме формирования интервала, этот виджет показывает пользователю дополнительную информацию о выбранном интервале.
     @alias nsGmx.FireCalendarWidget
     @class
     @param {nsGmx.CalendarWidget~Parameters} params Параметры календаря
    */

    (function ($) {

      var toMidnight = nsGmx$1.DateInterval.toMidnight;
      nsGmx$1.Translations.addText("rus", {
        FireCalendarWidget: {
          timeTitlePrefix: 'За ',
          timeTitleLastPrefix: 'За последние ',
          timeTitlePostfix: 'ч (UTC)'
        }
      });
      nsGmx$1.Translations.addText("eng", {
        FireCalendarWidget: {
          timeTitlePrefix: 'For ',
          timeTitleLastPrefix: 'For last ',
          timeTitlePostfix: 'h (UTC)'
        }
      });

      function f(n) {
        return n < 10 ? '0' + n : n;
      }

      function getStr(hours, minutes) {
        return f(hours) + ":" + f(minutes);
        /*+ ":" + f(time.seconds)*/
      }
      var FireCalendarWidget = nsGmx$1.CalendarWidget.extend({
        initialize: function initialize(options) {
          options = $.extend({
            dateMax: new Date()
          }, options);
          nsGmx$1.CalendarWidget.prototype.initialize.call(this, options);

          this._dateInterval.on('change', this._updateInfo, this);

          this.on('modechange', this._updateInfo, this);
          this.on('modechange', this._updateModel, this);

          this._updateInfo();
        },
        _updateModel: function _updateModel() {
          var dateBegin = this.getDateBegin(),
              origDateEnd = this.getDateEnd(),
              now = new Date(),
              lastMidnight = toMidnight(now),
              dateEnd;

          if (lastMidnight <= origDateEnd) {
            //last day
            dateEnd = new Date(now - 1 - (now - 1) % (3600 * 1000) + 3600 * 1000); //round to the nearest hour greater then 'now'

            if (dateEnd - toMidnight(dateBegin) < 12 * 3600 * 1000 && this.getMode() === nsGmx$1.CalendarWidget.SIMPLE_MODE) {
              dateBegin = new Date(dateBegin - nsGmx$1.DateInterval.MS_IN_DAY);
            }
          } else {
            //previous days
            dateEnd = new Date(origDateEnd.valueOf() + nsGmx$1.DateInterval.MS_IN_DAY);
          }

          this._dateInterval.set({
            dateBegin: toMidnight(dateBegin),
            dateEnd: dateEnd
          });
        },
        _updateWidget: function _updateWidget() {
          var dateBegin = +this._dateInterval.get('dateBegin'),
              dateEnd = +this._dateInterval.get('dateEnd');

          if (!dateBegin || !dateEnd) {
            return;
          }
          var currentDayMode = toMidnight(new Date()) < dateEnd;

          if (currentDayMode && this.getMode() === nsGmx$1.CalendarWidget.SIMPLE_MODE && dateEnd - dateBegin < 2 * nsGmx$1.DateInterval.MS_IN_DAY) {
            this._dateBegin.datepicker("setDate", nsGmx$1.CalendarWidget.toUTC(new Date()));

            this._dateEnd.datepicker("setDate", nsGmx$1.CalendarWidget.toUTC(new Date()));
          } else if (nsGmx$1.CalendarWidget1) {
            nsGmx$1.CalendarWidget1.prototype._updateWidget.call(this);
          } else {
            nsGmx$1.CalendarWidget.prototype._updateWidget.call(this);
          }
        },
        _updateInfo: function _updateInfo() {
          var isSimpleMode = this.getMode() === nsGmx$1.CalendarWidget.SIMPLE_MODE;
          this.$('.CalendarWidget-footer').toggle(isSimpleMode);
          this.$('.CalendarWidget-dateBeginInfo, .CalendarWidget-dateEndInfo').toggle(!isSimpleMode);

          var dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd');

          if (!dateBegin || !dateEnd) {
            return;
          }

          var hours = Math.ceil((dateEnd - dateBegin) / 3600000);

          if (isSimpleMode) {
            var hoursStr = hours > 24 ? "24+" + (hours - 24) : hours;
            var prefix = hours === 24 ? _gtxt("FireCalendarWidget.timeTitlePrefix") : _gtxt("FireCalendarWidget.timeTitleLastPrefix");
            this.$('.CalendarWidget-footer').html(prefix + hoursStr + _gtxt("FireCalendarWidget.timeTitlePostfix"));
          } else {
            var dateEndToShow = hours % 24 === 0 ? new Date(+dateEnd - 1) : dateEnd; //hack to show 23:59 instead of 00:00

            this.$('.CalendarWidget-dateBeginInfo').text(getStr(dateBegin.getUTCHours(), dateBegin.getUTCMinutes()) + " (UTC)").attr('title', _gtxt('CalendarWidget.UTC'));
            this.$('.CalendarWidget-dateEndInfo').text(getStr(dateEndToShow.getUTCHours(), dateEndToShow.getUTCMinutes()) + " (UTC)").attr('title', _gtxt('CalendarWidget.UTC'));
          }
        }
      }, {
        defaultFireDateInterval: function defaultFireDateInterval() {
          var now = new Date(),
              lastMidnight = toMidnight(now),
              dateEnd = new Date(now - 1 - (now - 1) % (3600 * 1000) + 3600 * 1000),
              //round to the nearest hour greater then 'now'
          isTooSmall = dateEnd - lastMidnight < 12 * 3600 * 1000,
              dateBegin = new Date(isTooSmall ? lastMidnight - nsGmx$1.DateInterval.MS_IN_DAY : lastMidnight.valueOf());
          return {
            dateBegin: dateBegin,
            dateEnd: dateEnd
          };
        }
      });
      nsGmx$1.FireCalendarWidget = FireCalendarWidget;
    })(jQuery);

    (function ($) {

      var _gtxt = nsGmx$1.Translations.getText.bind(nsGmx$1.Translations),
          toMidnight = nsGmx$1.DateInterval.toMidnight;

      nsGmx$1.Translations.addText("rus", {
        CalendarWidget: {
          ShowIconTitle: "Выбрать дату",
          createDateInterval: "Задать интервал",
          resetDateInterval: "Сбросить интервал",
          selectDateInterval: "Применить",
          hour: "ч.",
          from: "с",
          to: "до"
        }
      });
      nsGmx$1.Translations.addText("eng", {
        CalendarWidget: {
          ShowIconTitle: "Select date",
          createDateInterval: "Create date interval",
          resetDateInterval: "Reset date interval",
          selectDateInterval: "Select date interval",
          hour: "h.",
          from: "from",
          to: "to"
        }
      });
      var template = '' + '<div>' + '<div class = "CalendarWidget-row CalendarWidget-dates">' + // dates block
      '<span class = "CalendarWidget-iconScrollLeft icon-left-open"></span>' + '<span class = "CalendarWidget-dates-outside">' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputBegin">' + '<input class = "CalendarWidget-dateBegin">' + '</span>' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputMiddle">-</span>' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputEnd">' + '<input class = "CalendarWidget-dateEnd">' + '</span>' + '</span>' + '<span class = "CalendarWidget-iconScrollRight ui-helper-noselect icon-right-open"></span>' + // space between dates and time
      '<span class = "CalendarWidget-space"></span>' + // times block
      '<span class = "CalendarWidget-timeicon"><img src="img/time-icon-01.svg"></img></span>' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputTimeBegin"><input class = "CalendarWidget-timeInput CalendarWidget-timeBegin" value={{hourBegin}} ></span>' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputMiddle CalendarWidget-inputCell-inputTimeMiddle">-</span>' + '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputTimeEnd"><input class = "CalendarWidget-timeInput CalendarWidget-timeEnd" value={{hourEnd}}></span>' + '</div>' + '</div>';
      /** Параметры календаря
       * @typedef nsGmx.CalendarWidget~Parameters
       * @property {nsGmx.DateInterval} dateInterval Временной интервал, который нужно менять
       * @property {Date} [dateMin] минимальная граничная дата для календарей, null - без ограничений
       * @property {Date} [dateMax] максимальная граничная дата для календарей, null - без ограничений
       * @property {String} [dateFormat='dd.mm.yy'] формат даты
       * @property {bool} [minimized=true] показывать ли минимизированный или развёрнутый виджет в начале
       * @property {bool} [showSwitcher=true] показывать ли иконку для разворачивания/сворачивания периода
       * @property {Date} [dateBegin=<текущая дата>] начальная дата интервала
       * @property {Date} [dateEnd=<текущая дата>] конечная дата интервала
       * @property {String|DOMNode} [container] куда добавлять календарик
       * @property {String} [buttonImage] URL иконки для активации календариков
       */

      /** Контрол для задания диапазона дат. Даты календарика всегда в UTC, а не в текущем поясе.
       @description Виджет для выбора интервала дат. Пользователь при помощи datepicker'ов выбирает два дня (год, месяц, число),
                    затем выбранные значения при помощи ф-ции `_updateModel()` переводятся в интервал дат ({@link nsGmx.DateInterval}).
                    Так же виджет реагирует на изменения модели (с использованием ф-ции `_updateWidget()`)
       @alias nsGmx.CalendarWidget
       @extends nsGmx.GmxWidget
       @class
       @param {nsGmx.CalendarWidget~Parameters} options Параметры календаря
      */

      var CalendarModel = window.Backbone.Model.extend({
        defaults: {
          dailyFilter: true
        }
      });
      var Calendar1 = window.Backbone.View.extend({
        tagName: 'div',
        model: new CalendarModel(),
        className: 'CalendarWidget ui-widget',
        template: Handlebars.compile(template),
        events: {
          'click .CalendarWidget-dates-outside .CalendarWidget-inputCell': function clickCalendarWidgetDatesOutsideCalendarWidgetInputCell(e) {
            e.stopPropagation();
            this.showCalendar(e);
            $(e.target).focus();
          },
          'keydown .CalendarWidget-dateBegin': function keydownCalendarWidgetDateBegin(e) {
            this.manuallyChangeDateInterval(e, 'begin');
          },
          'keydown .CalendarWidget-dateEnd': function keydownCalendarWidgetDateEnd(e) {
            this.manuallyChangeDateInterval(e, 'end');
          },
          'click .CalendarWidget-iconScrollLeft': function clickCalendarWidgetIconScrollLeft() {
            this._shiftDates(-1);
          },
          'click .CalendarWidget-iconScrollRight': function clickCalendarWidgetIconScrollRight() {
            this._shiftDates(1);
          },
          'keydown .CalendarWidget-inputCell-inputTimeBegin': function keydownCalendarWidgetInputCellInputTimeBegin(e) {
            this.jumpByArrow(e, 'left');
          },
          'keydown .CalendarWidget-inputCell-inputTimeEnd': function keydownCalendarWidgetInputCellInputTimeEnd(e) {
            this.jumpByArrow(e, 'right');
          }
        },
        initialize: function initialize(options) {
          var _this = this;

          options = $.extend({
            minimized: true,
            showSwitcher: true,
            dateMax: null,
            dateMin: null,
            dateFormat: 'dd.mm.yy',
            name: null
          }, options);
          this._dateMin = options.dateMin;
          this._dateMax = options.dateMax;
          this._dateInterval = options.dateInterval;
          this._opened = false;
          $.datepicker.setDefaults({
            onSelect: function (dateText, inst) {
              this._selectFunc(inst.input);
            }.bind(this),
            minDate: this._dateMin ? Calendar1.toUTC(this._dateMin) : null,
            maxDate: this._dateMax ? Calendar1.toUTC(this._dateMax) : null,
            changeMonth: true,
            changeYear: true,
            dateFormat: 'dd.mm.yy',
            defaultDate: Calendar1.toUTC(this._dateMax || new Date()),
            buttonImageOnly: true,
            constrainInput: true
          });
          this.calendarTemplates = {
            beginTemplate: Handlebars.compile('' + '<div class="outside-calendar-container">' + '<div class="begin-outside-calendar">' + '</div>' + '<div class="time-container begin-time-container">' + '</div>' + '<div class="time-placeholder begin-time-placeholder" hidden>' + '</div>' + '<span class="calendar-button createdateinterval-button">' + '{{i "CalendarWidget.createDateInterval"}}' + '</span>' + '<span class="calendar-button resetdateinterval-button" hidden>' + '{{i "CalendarWidget.resetDateInterval"}}' + '</span>' + '</div>'),
            endTemplate: Handlebars.compile('' + '<div class="outside-calendar-container">' + '<div class="end-outside-calendar">' + '</div>' + '<div class="time-container end-time-container">' + '</div>' + '<div class="time-placeholder end-time-placeholder" hidden>' + '</div>' + '<span class="calendar-button selectdateinterval-button disabled">' + '{{i "CalendarWidget.selectDateInterval"}}' + '</span>' + '</div>')
          };

          var dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              hourBegin = Calendar1.getTime(dateBegin, 'begin'),
              hourEnd = Calendar1.getTime(dateEnd, 'end');

          this.$el.html(this.template({
            showCalendarIconClass: 'icon-calendar-empty',
            showCalendarIconTitle: _gtxt('CalendarWidget.ShowIconTitle'),
            hourBegin: hourBegin,
            hourEnd: hourEnd
          })); // если есть контейнер, куда прикреплять виджет календаря

          if (options.container) {
            if (typeof options.container === 'string') $('#' + options.container).append(this.$el);else $(options.container).append(this.$el);
          }

          this._updateWidget();

          this._dateInterval.on('change', this._updateWidget, this);

          this.listenTo(this.model, 'change:dailyFilter', this.enableDailyFilter);
          $('#leftMenu').on('click', function (e) {
            if (e.target.className !== 'CalendarWidget-show-calendar-icon icon-calendar-empty' && e.target.className !== 'layers-before' && !(e.target.className instanceof SVGAnimatedString) && e.target.className.indexOf('CalendarWidget-timeInput') === -1 && e.target.className !== 'calendar-container') {
              $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
              _this._opened = false;
            }
          });
          this.$('.CalendarWidget-timeInput').on('blur', this._selectTime.bind(this)); //for backward compatibility

          this.canvas = this.$el;
        },
        manuallyChangeDateInterval: function manuallyChangeDateInterval(e, type) {
          if (e.keyCode !== 13) return;
          e.preventDefault();
          e.stopPropagation();

          var value = $(e.target).val(),
              beginInput = this.$('.CalendarWidget-dateBegin')[0],
              endInput = this.$('.CalendarWidget-dateEnd')[0],
              dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              endMidnight = dateEnd.valueOf() === toMidnight(dateEnd).valueOf(),
              oneDayPeriod,
              parsed;

          try {
            parsed = $.datepicker.parseDate('dd.mm.yy', value);
          } catch (e) {
            return;
          } // handle errors and too large values


          if (!parsed || parsed < this._dateMin || parsed > this._dateMax) {
            return;
          }

          parsed = nsGmx$1.CalendarWidget1.fromUTC(parsed);
          oneDayPeriod = parsed.valueOf() === dateBegin.valueOf();
          oneDayPeriod ? this.setMode(Calendar1.SIMPLE_MODE) : this.setMode(Calendar1.ADVANCED_MODE);

          if (type === 'begin') {
            this._dateBegin.datepicker('setDate', parsed);

            if (parsed > new Date(dateEnd.valueOf() - dayms)) {
              this._dateEnd.datepicker('setDate', parsed);

              $(endInput).val(e.target.value);

              this._selectFunc(endInput);
            }

            this._dateInterval.set({
              dateBegin: new Date(parsed.valueOf()),
              dateEnd: new Date(parsed.valueOf() + dayms)
            });
          } else {
            this._dateEnd.datepicker('setDate', parsed);

            if (parsed < dateBegin) {
              this._dateBegin.datepicker('setDate', parsed);

              $(beginInput).val(e.target.value);

              this._selectFunc(beginInput);

              this._dateInterval.set({
                dateBegin: new Date(parsed.valueOf()),
                dateEnd: new Date(parsed.valueOf() + dayms)
              });
            } else if (parsed > dateBegin) {
              this._dateInterval.set({
                dateEnd: new Date(parsed.valueOf() + dayms)
              });
            }
          }

          this._selectFunc(e.target);

          this.showCalendar(e);
        },
        enableDailyFilter: function enableDailyFilter() {
          var dailyFilter = this.model.get('dailyFilter'),
              timeBeginValue = this.$('.CalendarWidget-timeBegin').val(),
              timeEndValue = this.$('.CalendarWidget-timeEnd').val();

          if (dailyFilter) {
            if (Number(timeBeginValue) >= Number(timeEndValue)) {
              this.$('.CalendarWidget-timeBegin').addClass('error');
              this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
              this.$('.CalendarWidget-timeEnd').addClass('error');
            } else {
              this.$('.CalendarWidget-timeBegin').removeClass('error');
              this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
              this.$('.CalendarWidget-timeEnd').removeClass('error');
            }
          } else {
            this.$('.CalendarWidget-timeBegin').removeClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
            this.$('.CalendarWidget-timeEnd').removeClass('error');
          }

          this.$('.CalendarWidget-timeBegin').trigger('blur');
          this.$('.CalendarWidget-timeEnd').trigger('blur');
        },
        _selectTime: function _selectTime(e) {
          var match = this._checkValue(e.target.value);

          if (!match) {
            this.$('.CalendarWidget-timeBegin').addClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
            this.$('.CalendarWidget-timeEnd').addClass('error');
            return;
          } // $(e.target).removeClass('error');


          var isBegin = $(e.target).hasClass('CalendarWidget-timeBegin'),
              dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              dailyFilter = this.model.get('dailyFilter'),
              timeBeginValue = this.$('.CalendarWidget-timeBegin').val(),
              timeEndValue = this.$('.CalendarWidget-timeEnd').val(),
              msBeginInputValue = Calendar1.convertTimeValueToMs(timeBeginValue),
              msEndInputValue = Calendar1.convertTimeValueToMs(timeEndValue),
              dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              hourBegin = Calendar1.getTime(dateBegin, 'begin'),
              hourEnd = Calendar1.getTime(dateEnd, 'end'),
              msBegin = Calendar1.convertTimeValueToMs(hourBegin),
              msEnd = Calendar1.convertTimeValueToMs(hourEnd),
              newDateBegin = new Date(dateBegin.valueOf() + (msBeginInputValue - msBegin)),
              newDateEnd = new Date(dateEnd.valueOf() + (msEndInputValue - msEnd));

          if (dailyFilter && Number(timeBeginValue) >= Number(timeEndValue)) {
            this.$('.CalendarWidget-timeBegin').addClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
            this.$('.CalendarWidget-timeEnd').addClass('error');
            return;
          }

          if (newDateBegin.valueOf() >= newDateEnd.valueOf()) {
            this.$('.CalendarWidget-timeBegin').addClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
            this.$('.CalendarWidget-timeEnd').addClass('error');
            return;
          } else {
            this.$('.CalendarWidget-timeBegin').removeClass('error');
            this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
            this.$('.CalendarWidget-timeEnd').removeClass('error');
          }

          this._dateInterval.set({
            dateBegin: newDateBegin,
            dateEnd: newDateEnd
          });
        },
        _checkValue: function _checkValue(value) {
          var hours = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24'],
              match = false;

          for (var i = 0; i < hours.length; i++) {
            if (value === hours[i]) {
              match = true;
            }
          }

          return match;
        },
        showCalendar: function showCalendar(e) {
          var _this = this,
              beginInput = this.$('.CalendarWidget-dateBegin')[0],
              endInput = this.$('.CalendarWidget-dateEnd')[0],
              dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              oneDayPeriod = dateEnd.valueOf() - dateBegin.valueOf() === dayms,
              endMidnight = dateEnd.valueOf() === toMidnight(dateEnd).valueOf();

          this.beginCalendar = $(this.calendarTemplates.beginTemplate({
            oneDayPeriod: oneDayPeriod
          }));
          this.endCalendar = $(this.calendarTemplates.endTemplate({}));
          var createIntervalButton = $('.createdateinterval-button', this.beginCalendar),
              resetIntervalButton = $('.resetdateinterval-button', this.beginCalendar),
              selectIntervalButton = $('.selectdateinterval-button', this.endCalendar),
              beginDialogOptions = {
            dialogClass: "calendar-outside begin-calendar",
            draggable: false,
            resizable: false,
            width: 224.8,
            height: 280,
            position: [372, 105],
            resizeFunc: function resizeFunc() {
              return false;
            },
            closeFunc: function closeFunc() {
              _this._dateBegin.datepicker("destroy");
            }
          },
              endDialogOptions = {
            dialogClass: "calendar-outside end-calendar",
            draggable: false,
            resizable: false,
            width: 224.8,
            height: 280,
            position: [610, 105],
            resizeFunc: function resizeFunc() {
              return false;
            },
            closeFunc: function closeFunc() {
              _this._dateEnd.datepicker("destroy");
            }
          };

          if (this._opened) {
            $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
            this._opened = false;
          }

          oneDayPeriod ? this.setMode(Calendar1.SIMPLE_MODE) : this.setMode(Calendar1.ADVANCED_MODE);
          this._dateBegin = $('.begin-outside-calendar', this.beginCalendar);
          this._dateEnd = $('.end-outside-calendar', this.endCalendar);
          this._dateInputs = this._dateBegin.add(this._dateEnd);

          this._dateInputs.datepicker();

          this._dateInputs.datepicker('option', 'minDate', Calendar1.toUTC(this._dateMin));

          this._dateInputs.datepicker('option', 'maxDate', Calendar1.toUTC(this._dateMax));

          this._dateBegin.datepicker('setDate', Calendar1.toUTC(dateBegin));

          this._dateEnd.datepicker('setDate', oneDayPeriod || endMidnight ? Calendar1.toUTC(new Date(dateEnd.valueOf() - dayms)) : Calendar1.toUTC(dateEnd));

          $(this.beginCalendar).dialog(beginDialogOptions);
          this._opened = true;

          if (this.getMode() === Calendar1.ADVANCED_MODE) {
            $(createIntervalButton).toggle(false);
            $(resetIntervalButton).toggle(true);
            $(this.endCalendar).dialog(endDialogOptions);
            this._opened = true;
          } // кнопки в первом календаре


          $(createIntervalButton).on('click', function () {
            var begin = _this._dateInterval.get('dateBegin'),
                end = _this._dateInterval.get('dateEnd');

            _this.setMode(Calendar1.ADVANCED_MODE);

            $(_this.endCalendar).dialog(endDialogOptions);
            _this._opened = true;
            $(this).toggle(false);
            $(resetIntervalButton).toggle(true);
          });
          $(resetIntervalButton).on('click', function () {
            var dateBegin = toMidnight(_this._dateInterval.get('dateBegin'));

            _this.setMode(Calendar1.SIMPLE_MODE);

            _this._dateBegin.datepicker('setDate', Calendar1.toUTC(dateBegin));

            _this._dateEnd.datepicker('setDate', Calendar1.toUTC(dateBegin));

            $(".calendar-outside.end-calendar .ui-dialog-titlebar-close").trigger('click');
            _this._opened = false;
            $(this).toggle(false);
            $(createIntervalButton).toggle(true);

            _this._dateInterval.set({
              dateBegin: dateBegin,
              dateEnd: new Date(dateBegin.valueOf() + dayms)
            });
          }); // кнопка во втором календаре

          $(selectIntervalButton).on('click', function () {
            _this._updateModel();

            _this.setActive(true);

            _this._enableCreateIntervalButton();

            $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
            _this._opened = false;
          });
        },
        _enableCreateIntervalButton: function _enableCreateIntervalButton(e) {
          var dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              selectIntervalButton = $('.selectdateinterval-button'),
              dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              beginTimeValue = Calendar1.convertTimeValueToMs(e && e.target === $('CalendarWidget-timeBegin', this)[0] ? $(e.target).val() : $('.CalendarWidget-timeBegin').val()),
              endTimeValue = Calendar1.convertTimeValueToMs(e && e.target === $('CalendarWidget-timeEnd', this)[0] ? $(e.target).val() : $('.CalendarWidget-timeEnd').val()),
              calendarDateBegin = this.getDateBegin(),
              calendarDateEnd = this.getDateEnd(),
              newDateBegin = new Date(calendarDateBegin.valueOf() + beginTimeValue),
              newDateEnd = new Date(calendarDateEnd.valueOf() + endTimeValue); // если даты в итоге не поменялись или вторая дата больше первой


          if (newDateBegin.valueOf() === dateBegin.valueOf() && newDateEnd.valueOf() === dateEnd.valueOf() || newDateBegin.valueOf() >= newDateEnd.valueOf()) {
            $(selectIntervalButton).addClass('disabled');
          } else {
            $(selectIntervalButton).removeClass('disabled');
          }
        },
        _shiftDates: function _shiftDates(delta) {
          var dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              dailyFilter = this.model.get('dailyFilter'),
              shift;

          if (!dateBegin || !dateEnd) {
            return;
          }

          if (dailyFilter) {
            var diff = toMidnight(dateEnd) - toMidnight(dateBegin);
            shift = diff ? diff * delta : dayms * delta;
          } else {
            shift = (dateEnd - dateBegin) * delta;
          }

          var newDateBegin = new Date(dateBegin.valueOf() + shift),
              newDateEnd = new Date(dateEnd.valueOf() + shift);

          if ((!this._dateMin || toMidnight(this._dateMin) <= toMidnight(newDateBegin)) && (!this._dateMax || toMidnight(this._dateMax) >= toMidnight(newDateEnd))) {
            this._dateInterval.set({
              dateBegin: newDateBegin ? newDateBegin : null,
              dateEnd: newDateEnd ? newDateEnd : null
            });
          }
        },
        _selectFunc: function _selectFunc(activeInput) {
          var begin = this.getDateBegin(),
              end = this.getDateEnd(),
              dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              selectIntervalButton = $('.selectdateinterval-button');

          if (end && begin && begin > end) {
            var dateToFix = activeInput[0] == this._dateEnd[0] ? this._dateBegin : this._dateEnd;
            dateToFix.datepicker('setDate', $(activeInput[0]).datepicker('getDate'));
          }

          if (this._curMode === Calendar1.SIMPLE_MODE) {
            if (!begin != !end || begin && begin.valueOf() !== end.valueOf()) {
              this._dateEnd.datepicker('setDate', this._dateBegin.datepicker('getDate'));
            }

            this._dateInterval.set({
              dateBegin: begin ? begin : null,
              dateEnd: end ? new Date(begin.valueOf() + nsGmx$1.DateInterval.MS_IN_DAY) : null
            });
          } else if (this._curMode === Calendar1.ADVANCED_MODE) {
            this._enableCreateIntervalButton();
          }
        },
        _updateModel: function _updateModel() {
          // получаем значения с дейтпикеров и переводим их в локальное время
          var dateBegin = this.getDateBegin(),
              dateEnd = this.getDateEnd(),
              // значение часов
          beginTimeValue = Calendar1.convertTimeValueToMs($('.CalendarWidget-timeBegin').val()),
              endTimeValue = Calendar1.convertTimeValueToMs($('.CalendarWidget-timeEnd').val()),
              dayms = nsGmx$1.DateInterval.MS_IN_DAY;
     // добавим время к часам (в локальном времени)

          dateBegin = new Date(dateBegin.valueOf() + beginTimeValue);
          dateEnd = new Date(dateEnd.valueOf() + endTimeValue);

          this._dateInterval.set({
            dateBegin: dateBegin ? dateBegin : null,
            dateEnd: dateEnd ? dateEnd : null
          });
        },
        _updateWidget: function _updateWidget() {
          var dateBegin = this._dateInterval.get('dateBegin'),
              dateEnd = this._dateInterval.get('dateEnd'),
              hourBegin = Calendar1.getTime(dateBegin, 'begin'),
              hourEnd = Calendar1.getTime(dateEnd, 'end'),
              beginInput = this.$('.CalendarWidget-dateBegin')[0],
              endInput = this.$('.CalendarWidget-dateEnd')[0],
              timeBegin = this.$('.CalendarWidget-timeBegin')[0],
              timeEnd = this.$('.CalendarWidget-timeEnd')[0],
              dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              newDateEnd;

          if (!dateBegin || !dateEnd) {
            return;
          }
          var newDateBegin = Calendar1.toUTC(dateBegin),
              newDateEnd = Calendar1.toUTC(new Date(dateEnd)); // если календарь показывает ровно один день,
          // прибавляем 24 часа к первой дате, чтобы получить сутки

          if (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()) {
            newDateEnd = Calendar1.toUTC(new Date(dateEnd - dayms));
          }

          $(beginInput).val(Calendar1.formatDate(newDateBegin));
          $(endInput).val(Calendar1.formatDate(newDateEnd));
          $(timeBegin).val(Calendar1.prefixTimeValue(hourBegin));
          $(timeEnd).val(Calendar1.prefixTimeValue(hourEnd));
          this.enableDailyFilter && this.enableDailyFilter();
        },
        setActive: function setActive(value) {
          var active = this.active;

          if (value !== active) {
            this.active = value;
          }

          if (this.active) {
            this.$el.removeClass('gmx-disabled');
          } else {
            this.$el.addClass('gmx-disabled');
          }
        },
        jumpByArrow: function jumpByArrow(e, type) {
          var target = type === 'left' ? this.$('.CalendarWidget-inputCell-inputTimeBegin').find('input') : this.$('.CalendarWidget-inputCell-inputTimeEnd').find('input'),
              source = type === 'left' ? this.$('.CalendarWidget-inputCell-inputTimeEnd').find('input') : this.$('.CalendarWidget-inputCell-inputTimeBegin').find('input'),
              sourceElem = $(source).get(0),
              strEnd;

          switch (type) {
            case 'left':
              if (e.key === 'ArrowRight' && e.target.value.length === e.target.selectionEnd) {
                $(target).blur();
                $(source).focus();
                strEnd = sourceElem.value.length || 0;
                setTimeout(function () {
                  sourceElem.setSelectionRange(strEnd, strEnd);
                }, 0);
              }

              break;

            case 'right':
              if (e.key === 'ArrowLeft' && e.target.selectionStart === 0) {
                $(target).blur();
                $(source).focus();
                strEnd = sourceElem.value.length || 0;
                setTimeout(function () {
                  sourceElem.setSelectionRange(strEnd, strEnd);
                }, 0);
              }

              break;

            default:
              return;
          }
        },
        //public interface

        /** Закрыть все открытые datepicker'ы.
         * @return {nsGmx.CalendarWidget} this
         */
        reset: function reset() {
          this._dateInputs.datepicker('hide');

          return this;
        },

        /** Сериализация состояния виджета
         * @return {Object} Сериализованное состояние
         */
        saveState: function saveState() {
          return {
            version: '1.1.0',
            vismode: this.getMode()
          };
        },

        /** Восстановить состояние виджета по сериализованным данным
         * @param {Object} data Сериализованное состояние календарика
         */
        loadState: function loadState(data) {
          this.setMode(data.vismode);
        },

        /** Получить начальную дату
         * @return {Date} начальная дата
         */
        getDateBegin: function getDateBegin() {
          return this._dateBegin ? Calendar1.fromUTC(this._dateBegin.datepicker('getDate')) : this.getDateInterval().get('dateBegin');
        },

        /** Получить конечную дату
         * @return {Date} конечная дата
         */
        getDateEnd: function getDateEnd() {
          return this._dateEnd ? Calendar1.fromUTC(this._dateEnd.datepicker('getDate')) : this.getDateInterval().get('dateEnd');
        },

        /** Получить верхнюю границу возможных дат периода
         * @return {Date} верхняя граница возможных периодов
         */
        getDateMax: function getDateMax() {
          return this._dateMax;
        },

        /** Получить нижнуюю границу возможных дат периода
         * @return {Date} нижняя граница возможных периодов
         */
        getDateMin: function getDateMin() {
          return this._dateMin;
        },

        /** Установить нижнуюю границу возможных дат периода
         * @param {Date} dateMin нижняя граница возможных периодов
         */
        setDateMin: function setDateMin(dateMin) {
          this._dateMin = dateMin;

          this._dateInputs.datepicker('option', 'minDate', dateMin ? Calendar1.toUTC(dateMin) : null);
        },

        /** Установить верхнюю границу возможных дат периода
         * @param {Date} dateMax верхняя граница возможных периодов
         */
        setDateMax: function setDateMax(dateMax) {
          // var titleContainer = this.$('.CalendarWidget-forecast');
          this._dateMax = dateMax;

          if (dateMax) {
            var utcDate = Calendar1.toUTC(dateMax);

            if (this._dateInputs) {
              this._dateInputs.datepicker('option', 'maxDate', utcDate);
            }
          } else {
            if (this._dateInputs) {
              this._dateInputs.datepicker('option', 'maxDate', null);
            }
          }
        },
        setSwitcherVisibility: function setSwitcherVisibility(isVisible) {
          this._showCalendarIcon && this._showCalendarIcon.toggle(isVisible);
        },
        getDateInterval: function getDateInterval() {
          return this._dateInterval;
        },
        getMode: function getMode() {
          return this._curMode;
        },
        setMode: function setMode(mode) {
          if (this._curMode === mode) {
            return this;
          }

          this._curMode = mode;
        }
      }, {
        /* static methods */
        // date показывает в utc
        // нужно вычесть отрицательную разницу
        // utc 13:00
        // 13:00 - (-3 часа) = 16:00
        // locale 16:00
        // return locale date
        fromUTC: function fromUTC(date) {
          if (!date) return null;
          var timeOffset = date.getTimezoneOffset() * 60 * 1000;
          return new Date(date.valueOf() - timeOffset);
        },
        toUTC: function toUTC(date) {
          if (!date) return null;
          var timeOffset = date.getTimezoneOffset() * 60 * 1000;
          return new Date(date.valueOf() + timeOffset);
        },
        formatDate: function formatDate(date) {
          var d = new Date(date),
              month = '' + (d.getMonth() + 1),
              day = '' + d.getDate(),
              year = d.getFullYear();
          if (month.length < 2) month = '0' + month;
          if (day.length < 2) day = '0' + day;
          return [day, month, year].join('.');
        },
        convertTimeValueToMs: function convertTimeValueToMs(value) {
          var ms = Number(value) * 1000 * 3600;
          return ms;
        },
        getTime: function getTime(date, position) {
          var dayms = nsGmx$1.DateInterval.MS_IN_DAY,
              offset,
              hours;

          if (position === 'begin') {
            offset = date.valueOf() - toMidnight(date).valueOf();
          } else {
            if (date.valueOf() === toMidnight(date).valueOf()) {
              offset = dayms;
            } else {
              offset = date.valueOf() - toMidnight(date).valueOf();
            }
          }
          hours = offset / (3600 * 1000);
          return hours;
        },
        prefixTimeValue: function prefixTimeValue(value) {
          value = Number(value);
          return value < 10 ? '0' + value : String(value);
        },
        SIMPLE_MODE: 1,
        ADVANCED_MODE: 2
      });
      nsGmx$1.CalendarWidget1 = Calendar1;
    })(jQuery);

    // COMMON CalendarWidget

    (function ($) {
      nsGmx$1.Translations.addText("rus", {
        CommonCalendarWidget: {
          Timeline: "Таймлайн",
          select: "Выберите мультивременной слой",
          sync: "Единый интервал для слоев",
          daily: "посуточно",
          on: "Включить синхронизацию слоев",
          off: "Выключить синхронизацию слоев",
          all: "Интервал для всех слоев"
        }
      });
      nsGmx$1.Translations.addText("eng", {
        CommonCalendarWidget: {
          Timeline: "Timeline",
          select: "Select temporal layer",
          sync: "Single date interval",
          daily: "daily",
          on: "Layers sync on",
          off: "Layers sync off",
          all: "Интервал для всех слоев"
        }
      });
      var toMidnight = nsGmx$1.DateInterval.toMidnight,
          dayms = nsGmx$1.DateInterval.MS_IN_DAY;
      var calendarWidgetTemplate = '' + '<div class="commoncalendar-container">' + '<div class="calendar-layers-container">' + '<div class="calendar-container">' + '<div class="calendar-widget-container"></div>' + '</div>' + '</div>' + '<div class="sync-switch-container switch-container">' + '<label class="sync-switch switch">' + '<input type="checkbox"' + '{{#if synchronyzed}}checked{{/if}}' + '>' + '<div class="sync-switch-slider switch-slider round"></div>' + '</label>' + '<span class="sync-switch-slider-description">{{i "CommonCalendarWidget.sync"}}</span>' + '<label class="daily-switch">' + '<input type="checkbox"' + '{{#if dailyFilter}}checked{{/if}}' + '>' + '{{i "CommonCalendarWidget.daily"}}' + '</label>' + '</div>' + '<div class="unsync-layers-container" style="display: none">' + '<select class="layersList">' + '{{#each this.layers}}' + '<option value="{{this.layer}}"' + '{{#if this.current}} selected="selected"{{/if}}>' + '{{this.layer}}' + '</option>' + '{{/each}}' + '</select>' + '</div>' + '</div>';

      var _gtxt = nsGmx$1.Translations.getText.bind(nsGmx$1.Translations);

      var CommonCalendarModel = Backbone.Model.extend({
        defaults: {
          active: true,
          currentLayer: null,
          calendar: null,
          isAppended: false,
          unbindedTemporalLayers: {},
          dailyFiltersHash: {},
          dailyFilter: true,
          synchronyzed: true
        }
      });
      var CommonCalendar = Backbone.View.extend({
        tagName: 'div',
        model: new CommonCalendarModel(),
        className: 'CommonCalendarWidget ui-widget',
        template: Handlebars.compile(calendarWidgetTemplate),
        events: {
          'change .sync-switch': 'toggleSync',
          'change .daily-switch': 'toggleDailyFilter',
          'change .layersList': 'changeCurrentLayer'
        },
        initialize: function initialize(options) {
          var _this = this;

          this.$el.html(this.template({
            synchronyzed: _this.model.get('synchronyzed'),
            layers: _this.model.get('visibleTemporalLayers'),
            dailyFilter: _this.model.get('dailyFilter')
          })); //for backward compatibility

          this.canvas = this.$el;
          this.dateInterval = new nsGmx$1.DateInterval();
          this.listenTo(this.model, 'change:synchronyzed', this.updateSync);
          this.listenTo(this.model, 'change:dailyFilter', function () {
            this.handleFiltersHash();
            this.applyDailyFilter();
          }.bind(this));
          this.dateInterval.on('change', function () {
            _this.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);

            if (_this.model.get('dailyFilter')) {
              _this.applyDailyFilter();
            }
          });

          this._fillFiltersHash();
        },
        _fillFiltersHash: function _fillFiltersHash(layers) {
          layers = layers || nsGmx$1.gmxMap.layers;
          var dailyFiltersHash = {};

          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i],
                props = layer.getGmxProperties(),
                layerID = props.LayerID,
                isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

            if (isTemporalLayer) {
              dailyFiltersHash[layerID] = true;
            }

            this.model.set('dailyFiltersHash', dailyFiltersHash);
          }
        },
        _clearFiltersHash: function _clearFiltersHash(layers) {
          layers = layers || nsGmx$1.gmxMap.layers;
          var dailyFiltersHash = {};

          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i],
                props = layer.getGmxProperties(),
                layerID = props.LayerID,
                isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

            if (isTemporalLayer) {
              dailyFiltersHash[layerID] = false;
            }

            this.model.set('dailyFiltersHash', dailyFiltersHash);
          }
        },
        setDateInterval: function setDateInterval(dateBegin, dateEnd, layer) {
          if (layer) {
            this.setCurrentLayer(layer);
          }

          var oldBegin = this.dateInterval.get('dateBegin').valueOf(),
              oldEnd = this.dateInterval.get('dateEnd').valueOf();

          if (oldBegin === dateBegin.valueOf() && oldEnd === dateEnd.valueOf()) {
            this.updateTemporalLayers();
            this.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);

            if (this.model.get('dailyFilter')) {
              this.applyDailyFilter();
            }

            this.trigger('change:dateInterval');
          } else {
            this.dateInterval.set({
              dateBegin: dateBegin,
              dateEnd: dateEnd
            });
          }

          if (this.dateInterval.get('dailyFilter')) {
            this.applyDailyFilter();
          }
        },
        setCurrentLayer: function setCurrentLayer(layer) {
          var props = layer.getGmxProperties();
          this.model.set('currentLayer', props.LayerID);
        },
        changeCurrentLayer: function changeCurrentLayer(e) {
          var _this = this,
              layerID = e.target.value;

          _this.model.set('currentLayer', layerID);
        },
        log: function log() {
          var f = function f(list) {
            var layers = nsGmx$1.gmxMap.layers;

            for (var i = 0; i < layers.length; i++) {
              var layer = layers[i],
                  props = layer.getGmxProperties(),
                  t = props.title,
                  isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;
              int = layer.getDateInterval();

              if (isTemporalLayer && int) {
                var b = int.beginDate.toString(),
                    e = int.endDate.toString();
                list.push({
                  title: t,
                  beginDate: b,
                  endDate: e
                });
              }
            }

            console.table(list);
          };

          f([]);
        },
        getDateInterval: function getDateInterval() {
          return this.dateInterval;
        },
        get: function get() {
          var attrs = this.model.toJSON(),
              _this = this,
              calendar;

          if (!attrs.calendar) {
            calendar = new nsGmx$1.CalendarWidget1({
              minimized: false,
              dateMin: new Date(2000, 1, 1),
              dateMax: new Date(Date.now() + dayms) > _this.dateInterval.get('dateEnd') ? new Date(Date.now() + dayms) : _this.dateInterval.get('dateEnd'),
              dateInterval: _this.dateInterval
            });
            this.dateInterval.on('change', this.updateTemporalLayers.bind(this, null));
            this.model.set('calendar', calendar);
            this.updateTemporalLayers();
          }

          return this.model.get('calendar');
        },
        replaceCalendarWidget: function replaceCalendarWidget(newCalendar) {
          this._calendar = newCalendar; //заменим виджет перед деревом слоёв

          if (this._isAppended) {
            var doChange = function doChange() {
              var calendarDiv = $('<div class="commoncalendar-container"></div>').append(newCalendar.canvas); // special for steppe project

              if (nsGmx$1.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                _queryMapLayers.getContainerAfter().find('.commoncalendar-container').replaceWith(calendarDiv);
              } else {
                _queryMapLayers.getContainerBefore().findcommoncalendar - container('.commoncalendar-container').replaceWith(calendarDiv);
              }
            }; //явная проверка, так как хочется быть максимально синхронными в этом методе


            if (_queryMapLayers.loadDeferred.state() === 'resolved') {
              doChange();
            } else {
              _queryMapLayers.loadDeferred.then(doChange);
            }
          }
        },
        show: function show() {
          var calendarDiv = this.$('.calendar-widget-container'),
              calendarCanvas = this.get().canvas;
          $(_queryMapLayers.getContainerBefore()).append(calendarCanvas[0]);

          var doAdd = function () {
            calendarDiv.append(calendarCanvas);
            var commonCanvas = this.canvas; // special for steppe Project

            if (nsGmx$1.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
              _queryMapLayers.getContainerAfter().append(commonCanvas);
            } else {
              _queryMapLayers.getContainerBefore().append(commonCanvas);
            }

            this.model.set('isAppended', true);
          }.bind(this);

          if (!this.model.get('isAppended')) {
            //явная проверка, так как хочется быть максимально синхронными в этом методе
            if (_queryMapLayers.loadDeferred.state() === 'resolved') {
              doAdd();
            } else {
              _queryMapLayers.loadDeferred.then(doAdd);
            }
          }

          return this;
        },
        hide: function hide() {
          var attrs = this.model.toJSON();
          attrs._isAppended && $(this.get().canvas).hide();
          this.model.set('isAppended', true);
          return this;
        },
        bindLayer: function bindLayer(layerName) {
          var attrs = this.model.toJSON(),
              unbindedTemporalLayers = attrs.unbindedTemporalLayers,
              clone = {}; // clone object

          for (var variable in unbindedTemporalLayers) {
            if (unbindedTemporalLayers.hasOwnProperty(variable)) {
              clone[variable] = unbindedTemporalLayers[variable];
            }
          }
          delete clone[layerName];
          this.model.set('unbindedTemporalLayers', clone);
          this.updateTemporalLayers();
        },
        unbindLayer: function unbindLayer(layerName) {
          var attrs = this.model.toJSON(),
              layer = nsGmx$1.gmxMap.layersByID[layerName];

          if (!layer) {
            return;
          }

          var props = layer.getGmxProperties(),
              unbindedTemporalLayers = attrs.unbindedTemporalLayers,
              clone = {};
          layer.removeLayerFilter({
            id: 'dailyFilter'
          }); // clone object

          for (var variable in unbindedTemporalLayers) {
            if (unbindedTemporalLayers.hasOwnProperty(variable)) {
              clone[variable] = unbindedTemporalLayers[variable];
            }
          }
          clone[layerName] = true;
          this.model.set('unbindedTemporalLayers', clone);
          this.updateTemporalLayers([layer]);
        },
        _updateOneLayer: function _updateOneLayer(layer, dateBegin, dateEnd) {
          var props = layer.getGmxProperties();

          if (props.maxShownPeriod) {
            var msecPeriod = props.maxShownPeriod * 24 * 3600 * 1000;
            var newDateBegin = new Date(Math.max(dateBegin.valueOf(), dateEnd.valueOf() - msecPeriod));
            layer.setDateInterval(newDateBegin, dateEnd);
          } else {
            layer.setDateInterval(dateBegin, dateEnd);
          }
        },
        updateTemporalLayers: function updateTemporalLayers(layers) {
          layers = layers || nsGmx$1.gmxMap.layers;
          var attrs = this.model.toJSON(),
              synchronyzed = attrs.synchronyzed,
              dateBegin = this.dateInterval.get('dateBegin'),
              dateEnd = this.dateInterval.get('dateEnd'),
              currentLayer = attrs.currentLayer,
              layersMaxDates = [],
              maxDate = null,
              localeDate;

          if (!attrs.calendar) {
            return;
          }

          if (synchronyzed) {
            for (var i = 0, len = layers.length; i < len; i++) {
              var layer = layers[i],
                  props = layer.getGmxProperties(),
                  isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.setDateInterval;

              if (isTemporalLayer && !(props.name in attrs.unbindedTemporalLayers)) {
                if (props.DateEnd) {
                  if (typeof props.DateEnd === "string") {
                    localeDate = $.datepicker.parseDate('dd.mm.yy', props.DateEnd);
                  } else if (typeof props.DateEnd === "number") {
                    localeDate = new Date(props.DateEnd);
                  }

                  layersMaxDates.push(localeDate);
                }

                this._updateOneLayer(layer, dateBegin, dateEnd);
              }
            }
          } else {
            if (currentLayer && !(currentLayer in attrs.unbindedTemporalLayers)) {
              currentLayer = nsGmx$1.gmxMap.layersByID[currentLayer];

              this._updateOneLayer(currentLayer, dateBegin, dateEnd);
            } else {
              return;
            }
          }

          if (layersMaxDates.length > 0) {
            layersMaxDates.sort(function (a, b) {
              return b - a;
            });
            maxDate = new Date(layersMaxDates[0]);

            if (maxDate > attrs.calendar.getDateMax()) {
              attrs.calendar.setDateMax(nsGmx$1.CalendarWidget.fromUTC(new Date(maxDate.valueOf() + dayms)));
            }

            this.model.set('calendar', attrs.calendar);
          }
        },
        onDateIntervalChanged: function onDateIntervalChanged(e) {
          var attrs = this.model.toJSON(),
              currentLayer = attrs.currentLayer,
              layer = e.target,
              props,
              dateInterval,
              dateBegin,
              dateEnd;

          if (!currentLayer) {
            return;
          }

          props = layer.getGmxProperties(), layerID = props.LayerID;

          if (layerID in attrs.unbindedTemporalLayers) {
            return;
          }

          if (layerID === currentLayer) {
            if (props.maxShownPeriod) {
              return;
            }

            dateInterval = layer.getDateInterval(), dateBegin = dateInterval.beginDate, dateEnd = dateInterval.endDate;
            this.setDateInterval(dateBegin, dateEnd, layer);
          }
        },
        updateVisibleTemporalLayers: function updateVisibleTemporalLayers(layers) {
          var _this = this,
              attrs = this.model.toJSON(),
              currentLayer = attrs.currentLayer,
              layersList = this.$('.layersList'),
              temporalLayers = [],
              str = '';

          $.widget("ui.temporallayersmenu", $.ui.selectmenu, {
            _renderItem: function _renderItem(ul, item) {
              var li = $("<li>");

              if (item.value) {
                var l = nsGmx$1.gmxMap.layersByID[item.value],
                    props = l.getGmxProperties(),
                    di = l.getDateInterval && l.getDateInterval(),
                    dateBegin,
                    dateEnd,
                    hourBegin,
                    hourEnd,
                    newDateBegin,
                    newDateEnd,
                    str = '';

                if (di) {
                  var now = new Date(),
                      dateBeginToMidnight = new Date(now - now % dayms); // dateBegin = di.beginDate;
                  // dateEnd = di.endDate);

                  dateBegin = di.beginDate || dateBeginToMidnight;
                  dateEnd = di.endDate || new Date(dateBeginToMidnight.valueOf() + dayms);
                  hourBegin = nsGmx$1.CalendarWidget1.prefixTimeValue(nsGmx$1.CalendarWidget1.getTime(dateBegin, 'begin'));
                  hourEnd = nsGmx$1.CalendarWidget1.prefixTimeValue(nsGmx$1.CalendarWidget1.getTime(dateEnd, 'end'));
                  newDateBegin = nsGmx$1.CalendarWidget1.toUTC(dateBegin);
                  newDateEnd = nsGmx$1.CalendarWidget1.toUTC(dateEnd); // если календарь показывает ровно один день,
                  // прибавляем 24 часа к первой дате, чтобы получить сутки

                  if (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()) {
                    newDateEnd = nsGmx$1.CalendarWidget1.toUTC(new Date(dateEnd - dayms));
                  }

                  str = '<span class=\'layerslist-title\'>' + props.title + '</span>' + ' ' + '<span class=\'layerslist-dates-times\'>' + nsGmx$1.CalendarWidget1.formatDate(newDateBegin) + ' - ' + nsGmx$1.CalendarWidget1.formatDate(newDateEnd) + ' | ' + hourBegin + '-' + hourEnd + '</span>';
                }

                $(li).html(str);
                $(li).prop('layerID', item.value);
                return li.appendTo(ul);
              }
            },
            _renderMenu: function _renderMenu(ul, items) {
              var that = this;
              $.each(items, function (index, item) {
                that._renderItemData(ul, item);
              });
            }
          });

          if ($(layersList).temporallayersmenu("instance")) {
            $(layersList).temporallayersmenu("destroy");
          }

          for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];

            if (layer.getGmxProperties) {
              var props = layer.getGmxProperties(),
                  isVisible = props.visible,
                  isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

              if (isTemporalLayer && isVisible) {
                temporalLayers.push(layer);
              }
            }
          }

          for (var i = 0; i < temporalLayers.length; i++) {
            var layer = temporalLayers[i],
                props = layer.getGmxProperties(),
                layerID = props.LayerID;
            str += '<option value=' + layerID + '>' + props.title + '</option>';
          }
          $(layersList).html(str);

          if (currentLayer) {
            var l = nsGmx$1.gmxMap.layersByID[currentLayer];
            this.$('.layersList option').each(function () {
              if ($(this).val() === currentLayer) {
                $(this).prop("selected", true);
              }
            }); // установим текщим первый слой из списка
          } else if (!currentLayer && temporalLayers.length) {
            var props = temporalLayers[0].getGmxProperties(),
                layerID = props.LayerID;
            this.$('.layersList option[value="' + layerID + '"]').prop("selected", true);
          }

          $(layersList).temporallayersmenu({
            change: function change(e) {
              var layerID = $(e.currentTarget).prop('layerID'),
                  layer = nsGmx$1.gmxMap.layersByID[layerID],
                  filters = layer._gmx.dataManager._filtersView,
                  layerFilters = filters[layerID],
                  dateBegin,
                  dateEnd;
              dateInterval = layer.getDateInterval();

              if (dateInterval.beginDate && dateInterval.endDate) {
                dateBegin = dateInterval.beginDate;
                dateEnd = dateInterval.endDate;
              } else {
                dateInterval = new nsGmx$1.DateInterval();
                dateBegin = dateInterval.get('dateBegin');
                dateEnd = dateInterval.get('dateEnd');
              }

              if (layerFilters) {
                if ('screen_dailyFilter' in layerFilters) {
                  _this.$('.daily-switch input').prop("checked", true);
                } else {
                  _this.$('.daily-switch input').prop("checked", false);
                }
              }

              _this.$('.layersList option[value="' + layerID + '"]').prop("selected", true);

              _this.setDateInterval(dateBegin, dateEnd, layer);
            }
          });
        },
        toggleSync: function toggleSync() {
          this.model.set('synchronyzed', !this.model.get('synchronyzed'));
        },
        setSyncMode: function setSyncMode(value) {
          this.model.set('synchronyzed', Boolean(value));
        },
        updateSync: function updateSync() {
          var _this = this,
              layers = nsGmx$1.gmxMap.layers,
              attrs = this.model.toJSON(),
              synchronyzed = attrs.synchronyzed,
              currentLayer = attrs.currentLayer,
              listContainer = this.$('.unsync-layers-container'),
              layersList = this.$('.layersList'),
              dateBegin,
              dateEnd;

          if (synchronyzed) {
            dateBegin = _this.dateInterval.get('dateBegin'), dateEnd = _this.dateInterval.get('dateEnd'), _this.setDateInterval(dateBegin, dateEnd);
            this.model.set('currentLayer', null);
            this.model.set('currentLayer', null);
            this.$('.sync-switch input').prop("checked", true);
            $(listContainer).hide();
          } else {
            if (currentLayer) {
              return;
            } else {
              var temporalLayers = [];
              this.$('.sync-switch input').prop("checked", false);
              $(listContainer).show();
              this.updateVisibleTemporalLayers(layers);

              for (var i = 0; i < layers.length; i++) {
                var layer = layers[i];

                if (layer.getGmxProperties) {
                  var props = layer.getGmxProperties(),
                      isVisible = props.visible,
                      isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

                  if (isTemporalLayer && isVisible) {
                    temporalLayers.push(layer);
                  }
                }
              }

              if (!temporalLayers.length) {
                this.model.set('currentLayer', null);
              } else {
                var props = temporalLayers[0].getGmxProperties(),
                    layerID = props.LayerID;
                this.model.set('currentLayer', layerID);
              }
            }
          }
        },
        toggleDailyFilter: function toggleDailyFilter() {
          var attrs = this.model.toJSON(),
              calendar = attrs.calendar;
          calendar.model.set('dailyFilter', !this.model.get('dailyFilter'));
          this.model.set('dailyFilter', !this.model.get('dailyFilter'));
        },
        setDailyFilter: function setDailyFilter(active) {
          var attrs = this.model.toJSON(),
              calendar = attrs.calendar;
          calendar.model.set('dailyFilter', active);
          this.model.set('dailyFilter', active);
        },
        handleFiltersHash: function handleFiltersHash() {
          var attrs = this.model.toJSON(),
              synchronyzed = attrs.synchronyzed,
              currentLayer = attrs.currentLayer,
              dateInterval = this.dateInterval,
              calendar = attrs.calendar,
              dailyFilter = attrs.dailyFilter,
              dailyFiltersHash = attrs.dailyFiltersHash;

          if (dailyFilter) {
            if (currentLayer) {
              dailyFiltersHash[currentLayer] = true;
            } else {
              this._fillFiltersHash();
            }
          } else {
            if (currentLayer) {
              dailyFiltersHash[currentLayer] = false;
            } else {
              this._clearFiltersHash();
            }
          }
        },
        applyDailyFilter: function applyDailyFilter(layers) {
          var temporalLayers = layers || nsGmx$1.gmxMap.layers,
              _this = this,
              attrs = this.model.toJSON(),
              dailyFilter = attrs.dailyFilter,
              dailyFiltersHash = attrs.dailyFiltersHash,
              synchronyzed = attrs.synchronyzed,
              currentLayer = attrs.currentLayer,
              dateInterval = this.dateInterval,
              calendar = attrs.calendar,
              dateBegin = this.dateInterval.get('dateBegin'),
              dateEnd = this.dateInterval.get('dateEnd'),
              hourBegin = Number(nsGmx$1.CalendarWidget1.getTime(dateBegin, 'begin')) * 1000 * 3600,
              hourEnd = Number(nsGmx$1.CalendarWidget1.getTime(dateEnd, 'end')) * 1000 * 3600;

          if (synchronyzed) {
            temporalLayers = nsGmx$1.gmxMap.layers;
          }

          if (!synchronyzed && !currentLayer) {
            return;
          }

          for (var i = 0; i < temporalLayers.length; i++) {
            var l = temporalLayers[i],
                p = l.getGmxProperties && l.getGmxProperties(),
                layerName;

            if (!p) {
              continue;
            }

            layerName = p.name;

            if (layerName in attrs.unbindedTemporalLayers) {
              continue;
            }

            (function (x) {
              var layer = temporalLayers[x];

              if (layer.getGmxProperties) {
                var props = layer.getGmxProperties(),
                    isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

                if (isTemporalLayer && layer.getDataManager) {
                  if (layer.getGmxProperties().name === '509762F05B0044D8A7CCC9D3C2383365') ;

                  if (!synchronyzed && layer.getDateInterval()) {
                    dateInterval = layer.getDateInterval();

                    if (dateInterval.beginDate && dateInterval.endDate) {
                      dateBegin = dateInterval.beginDate;
                      dateEnd = dateInterval.endDate;
                      hourBegin = Number(nsGmx$1.CalendarWidget1.getTime(dateBegin, 'begin')) * 1000 * 3600, hourEnd = Number(nsGmx$1.CalendarWidget1.getTime(dateEnd, 'end')) * 1000 * 3600;
                    }
                  }

                  var dm = layer.getDataManager(),
                      dmOpt = dm.options,
                      fullDays,
                      intervals = [];

                  if (dmOpt.Temporal) {
                    var tmpKeyNum = dm.tileAttributeIndexes[dmOpt.TemporalColumnName];
                  }

                  if (hourEnd < dayms) {
                    fullDays = toMidnight(dateEnd).valueOf() - toMidnight(dateBegin).valueOf() + dayms;
                  } else if (hourEnd === dayms) {
                    fullDays = toMidnight(dateEnd).valueOf() - toMidnight(dateBegin).valueOf();
                  }

                  for (var i = 0; i < fullDays; i += dayms) {
                    intervals.push({
                      begin: toMidnight(dateBegin).valueOf() + hourBegin + i,
                      end: toMidnight(dateBegin).valueOf() + hourEnd + i
                    });
                  }

                  if (dailyFilter && dailyFiltersHash[props.LayerID]) {
                    layer.addLayerFilter(function (item) {
                      var itemDate = item.properties[tmpKeyNum] * 1000,
                          inside = false;

                      for (var j = 0; j < intervals.length; j++) {
                        if (intervals[j].begin <= itemDate && itemDate <= intervals[j].end) {
                          inside = true;
                          break;
                        }
                      } //
                      // if (inside) {
                      //     console.log(layer.getGmxProperties().title + ' / ' + 'loaded');
                      // } else {
                      //     console.log(layer.getGmxProperties().title + ' / ' + 'filtered');
                      // }


                      return inside;
                    }, {
                      id: 'dailyFilter'
                    });

                    _this.$('.daily-switch input').prop("checked", true);
                  } else {
                    layer.removeLayerFilter({
                      id: 'dailyFilter'
                    });

                    _this.$('.daily-switch input').prop("checked", false);
                  }
                }
              }
            })(i);
          }
        }
      });
      nsGmx$1.CommonCalendarWidget = CommonCalendar;
    })(jQuery);

    /** 
    * Контроллёр глобального буфера обмена
    * @memberOf nsGmx
    * @class Синглетон. Позволяет хранить массивы объектов разного типа. Тип объектов - строка. В рамках одного типа объекты упорядочены.
    */

    nsGmx$1.ClipboardController = function () {
      var _clipboard = {};
      return {
        addItem: function addItem(type, item) {
          _clipboard[type] = _clipboard[type] || [];

          _clipboard[type].push(item);
        },
        popItem: function popItem(type) {
          if (typeof _clipboard[type] === 'undefined' || _clipboard[type].length == 0) return null;
          return _clipboard[type].pop();
        },
        //количество объектов данного типа
        getCount: function getCount(type) {
          if (typeof _clipboard[type] === 'undefined') return 0;
          return _clipboard[type].length;
        },
        //получить объект типа type с индексом index. Если index < 0, то индексация с конца (-1 - последний элемент)
        get: function get(type, index) {
          if (typeof _clipboard[type] === 'undefined') return null;
          if (index < 0) index += _clipboard[type].length;
          if (index < 0 || _clipboard[type].length <= index) return null;
          return _clipboard[type][index];
        }
      };
    }();

    var UPDATE_INTERVAL = 2000;

    var sendGmxRequest = function sendGmxRequest(requestType, url, params) {
      var def = $.Deferred();

      var processResponse = function processResponse(response) {
        if (!response.Result || !response.Result.TaskID) {
          if (response.Status === 'ok' && !response.ErrorInfo) {
            def.resolve(response);
          } else {
            parseResponse$1(response);
            def.reject(response);
          }

          return;
        }

        def.notify(response.Result);
        var taskID = response.Result.TaskID;
        var interval = setInterval(function () {
          sendCrossDomainJSONRequest$2(window.serverBase + "AsyncTask.ashx?WrapStyle=func&TaskID=" + taskID, function (response) {
            var res = response.Result;

            if (response.Status !== 'ok' || res.ErrorInfo) {
              res.Status = 'error';
              parseResponse$1(res);
              clearInterval(interval);
              def.reject(res);
            } else if (res.Completed) {
              clearInterval(interval);
              def.resolve(res);
            } else {
              def.notify(res);
            }
          }, null, function () {
            clearInterval(interval);
            def.reject();
          });
        }, UPDATE_INTERVAL);
      };

      if (requestType === 'get') {
        params = params || {};
        var paramStrItems = [];

        for (var p in params) {
          paramStrItems.push(p + '=' + encodeURIComponent(params[p]));
        }

        var sepSym = url.indexOf('?') == -1 ? '?' : '&';
        sendCrossDomainJSONRequest$2(url + sepSym + paramStrItems.join('&'), processResponse, null, def.reject.bind(def));
      } else if (requestType === 'post') {
        var localParams = $.extend({
          WrapStyle: 'message'
        }, params);
        sendCrossDomainPostRequest$1(url, localParams, processResponse);
      } else {
        throw 'Wrong request type';
      }

      return def.promise();
    };

    nsGmx$1.asyncTaskManager = {
      sendGmxJSONPRequest: sendGmxRequest.bind(null, 'get'),
      sendGmxPostRequest: sendGmxRequest.bind(null, 'post')
    };

    !function () {
      //Контроллёр контектных меню и соответствующие пункты всех меню...

      /**
      * Контроллёр контекстных меню.
      * @class
      * @name ContextMenuController
      * @memberOf nsGmx
      *
      * @description Позволяет добавлять элементы контектсного меню разного типа и привязывать меню к отдельным DOM элементам.
      * Возможно динамическое создание меню при клике на объекте. Элементам меню передаётся контекст,
      * указанный при привязке меню к элементу (он так же может создаваться в момент клика на элементе)
      * Каждый элемент меню - отдельный объект, они независимо добавляются в контроллер.
      * При создании меню определённого типа из этого набора выбираются нужные элементы.
      */
      nsGmx$1.ContextMenuController = function () {
        var _menuItems = {};
        var SUGGEST_TIMEOUT = 700; // Показывает контектное меню для конкретного элемента.
        // В Opera меню показывается при наведении на элемент в течении некоторого времени, во всех остальных браузерах - по правому клику.
        // Меню исчезает при потере фокуса
        // Параметры:
        // * elem {DOMElement} - элемент, на который навешивается меню
        // * menuFunc {Function, menuFunc()->DomElement} - функция, создающая меню
        // * checkFunc {Function, checkFunc()->Bool} - если возвращает false, то ничего не показывается...

        var _context = function _context(elem, menuFunc, checkFunc) {
          var menu = null;

          elem.oncontextmenu = function (e) {
            if (typeof checkFunc != 'undefined' && !checkFunc()) return false;
            if (menu && menu.parentNode) menu.parentNode.removeChild(menu);
            menu = menuFunc();
            if (!menu) return false;

            var contextMenu = _div([menu], [['dir', 'className', 'contextMenu'], ['attr', 'id', 'contextMenuCanvas']]);

            var evt = e || window.event;
            hidden(contextMenu);
            document.body.appendChild(contextMenu); // определение координат курсора для ie

            if (evt.pageX == null && evt.clientX != null) {
              var html = document.documentElement;
              var body = document.body;
              evt.pageX = evt.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0);
              evt.pageY = evt.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0);
            }

            if (evt.pageX + contextMenu.clientWidth < getWindowWidth()) contextMenu.style.left = evt.pageX - 5 + 'px';else contextMenu.style.left = evt.pageX - contextMenu.clientWidth + 5 + 'px';
            if (evt.pageY + contextMenu.clientHeight < getWindowHeight()) contextMenu.style.top = evt.pageY - 5 + 'px';else contextMenu.style.top = evt.pageY - contextMenu.clientHeight + 5 + 'px';
            visible(contextMenu);
            var menuArea = contextMenu.getBoundingClientRect();

            contextMenu.onmouseout = function (e) {
              var evt = e || window.event; // определение координат курсора для ie

              if (evt.pageX == null && evt.clientX != null) {
                var html = document.documentElement;
                var body = document.body;
                evt.pageX = evt.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0);
                evt.pageY = evt.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0);
              }

              if (evt.pageX <= menuArea.left || evt.pageX >= menuArea.right || evt.clientY <= menuArea.top || evt.clientY >= menuArea.bottom) {
                menu = null;
                contextMenu.removeNode(true);
              }
            };

            return false;
          };
        };

        var _contextClose = function _contextClose() {
          $('#contextMenuCanvas').remove();
        };

        var _generateMenuDiv = function _generateMenuDiv(type, context) {
          var uiTemplate = Handlebars.compile('<div>' + '{{#menuItems}}' + '{{#if separator}}<div class = "contextMenuSeparator"></div>{{/if}}' + '<div class = "contextMenuItem" data-itemIndex="{{index}}">{{title}}</div>' + '{{/menuItems}}' + '</div>');
          var items = _menuItems[type],
              visibleItems = [];

          for (var e = 0; e < items.length; e++) {
            var menuElem = items[e];

            if (menuElem.isVisible && !menuElem.isVisible(context)) {
              continue;
            }

            visibleItems.push({
              index: e,
              title: typeof menuElem.title === 'function' ? menuElem.title() : menuElem.title,
              separator: menuElem.isSeparatorBefore && menuElem.isSeparatorBefore(context)
            });
          }

          if (visibleItems.length) {
            var ui = $(uiTemplate({
              menuItems: visibleItems
            }));
            ui.find('.contextMenuItem').click(function () {
              var itemIndex = Number($(this).data('itemindex'));
              context.contentMenuArea = getOffsetRect$1(this);
              context.contentMenuType = type;

              _contextClose();

              _menuItems[type][itemIndex].clickCallback(context);
            });
            return ui[0];
          }

          return null;
        }; //public interface


        return {
          /**
           * Добавляет новый пункт меню
                 * @memberOf nsGmx.ContextMenuController
           * @function
           * @param {nsGmx.ContextMenuController.IContextMenuElem} menuItem Элемент контекстного меню
           * @param {String | String[]} menuType Тип меню (например: "Layer", "Map", "Group"). Если массив, то данный элемент применяется в нескольких типах меню
           */
          addContextMenuElem: function addContextMenuElem(menuItem, menuType) {
            if (typeof menuType === 'string') menuType = [menuType];

            for (var i = 0; i < menuType.length; i++) {
              _menuItems[menuType[i]] = _menuItems[menuType[i]] || [];

              _menuItems[menuType[i]].push(menuItem);
            }
          },

          /**
           * Добавляет к DOM элементу контекстное меню
           * @function
                 * @memberOf nsGmx.ContextMenuController
           * @param {DOMElement} elem Целевой DOM-элемент
           * @param {String} type Тип меню
           * @param {function():Boolean} checkFunc Проверка, показывать ли сейчас меню. Если ф-ция возвращает false, меню не показывается
           * @param {Object|function(context):Object} context Контекст, который будет передан в элемент меню при клике на DOM-элементе.
           *        Если контект - ф-ция, она будет вызвана непосредственно при клике. В контекст при клике будут добавлены элементы contentMenuArea и contentMenuType.
           */
          bindMenuToElem: function bindMenuToElem(elem, type, checkFunc, context) {
            _context(elem, function () {
              if (typeof context === 'function') context = context(); //

              return _generateMenuDiv(type, context);
            }, checkFunc, SUGGEST_TIMEOUT);
          }
        };
      }();
      /** Интерфейс для задания контекстного меню пользователей
      * @class
      * @name nsGmx.ContextMenuController.IContextMenuElem
      */

      /** Нужно ли отображать данный пункт меню для данного элемента и типа дерева. Необязательная (по умолчанию отображается)
      @function
      @name isVisible
      @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
      @param {Object} context - контекст, специфический для конкретного типа меню
      */

      /** Нужно ли рисовать перед данным пунктом разделитель (гориз. черту). Необязательная (по умолчанию не рисуется)
      @function
      @name isSeparatorBefore
      @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
      @param {Object} context - контекст, специфический для конкретного типа меню
      */

      /** Вызывается при клике по соответствующему пункту меню
      * @function
      * @name clickCallback
      * @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
      * @param {object} context - контекст, который был передан при привязке меню к DOM-элементу. В контекст будут добавлены поля:
      *
      *  * contentMenuArea {Object} - координаты верхнего левого угла пункта меню, на которое было нажатие. {left: int, top: int}. Если нужно привязаться к месту текущего клика
      *  * contentMenuType {String}- тип вызванного контекстного меню. Актуально, если элемент меню используется в нескольких типах меню.
      */

      /** Строка или ф-ция, которую нужно отображать в контекстном меню. Если ф-ция, то она будет вызываться при каждом формировании меню и должна возвращать строку.
      @name title
      @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
      */
      //Все заголовки элементов меню заданы как ф-ции, так как на момент выполенения этого кода неизвестен выбранный язык системы
      ///////////////////////////////////////////////////////////////////////////////
      /////////////////////////// Контекстное меню слоёв ////////////////////////////
      ///////////////////////////////////////////////////////////////////////////////

      /*
      В контексте типа "Layer" присутствуют следующие атрибуты:
       * layerManagerFlag {int} Тип дерева
       * elem Элемент (слой), для которого стротся меню
       * tree {layersTree} Текущее дерево, внутри которого находится слой
      */


      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Свойства");
        },
        isVisible: function isVisible(context) {
          return !context.layerManagerFlag && nsGmx$1.AuthManager.isLogin();
        },
        clickCallback: function clickCallback(context) {
          var div;
          if (context.elem.MultiLayerID) div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];else div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];

          _mapHelper.createLayerEditor(div, context.tree, 'main', div.gmxProperties.content.properties.styles.length > 1 ? -1 : 0);
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Стили");
        },
        isVisible: function isVisible(context) {
          return !context.layerManagerFlag && context.elem.type === "Vector" && _queryMapLayers.currentMapRights() === "edit";
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.createStylesDialog(context.elem, context.tree);
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Таблица атрибутов");
        },
        isVisible: function isVisible(context) {
          return !nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_UNAUTHORIZED) && !context.layerManagerFlag && (_queryMapLayers.currentMapRights() === "edit" || _queryMapLayers.layerRights(context.elem.name) == 'view' || _queryMapLayers.layerRights(context.elem.name) == 'edit' || _queryMapLayers.layerRights(context.elem.name) === 'editrows') && context.elem.type === "Vector";
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.createAttributesTable(context.elem.name);
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Права доступа");
        },
        isVisible: function isVisible(context) {
          return !context.layerManagerFlag && nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_MAP_RIGHTS) && _queryMapLayers.layerRights(context.elem.name) === 'edit';
        },
        clickCallback: function clickCallback(context) {
          if (context.elem.MultiLayerID) {
            var securityDialog = new nsGmx$1.multiLayerSecurity();
            securityDialog.getRights(context.elem.MultiLayerID, context.elem.title);
          } else {
            var securityDialog = new nsGmx$1.layerSecurity(context.elem.name);
            securityDialog.getRights(context.elem.name, context.elem.title);
          }
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Скачать");
        },
        isVisible: function isVisible(context) {
          return !context.layerManagerFlag && (_queryMapLayers.currentMapRights() === "edit" || _queryMapLayers.currentMapRights() == "view" && nsGmx$1.AuthManager.isLogin()) && context.elem.type == "Vector" && context.tree.treeModel.getMapProperties().CanDownloadVectors;
        },
        clickCallback: function clickCallback(context) {
          _mapHelper.downloadVectorLayer({
            name: context.elem.name,
            host: context.elem.hostName
          });
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Удалить");
        },
        isVisible: function isVisible(context) {
          return !context.layerManagerFlag && _queryMapLayers.currentMapRights() === "edit";
        },
        clickCallback: function clickCallback(context) {
          _queryMapLayers.removeLayer(context.elem.name);

          var div;
          if (context.elem.MultiLayerID) div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];else div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];

          var treeElem = _layersTree.findTreeElem(div).elem,
              node = div.parentNode,
              parentTree = node.parentNode;

          _layersTree.removeTreeElem(div);

          node.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);

          _mapHelper.updateUnloadEvent(true);
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Добавить снимки");
        },
        isVisible: function isVisible(context) {
          var layerRights = _queryMapLayers.layerRights(context.elem.name);

          return !context.layerManagerFlag && (layerRights === 'edit' || layerRights === 'editrows') && context.elem.type == "Vector" && context.elem.IsRasterCatalog;
        },
        clickCallback: function clickCallback(context) {
          new nsGmx$1.RCAddLayerControl(nsGmx$1.gmxMap, context.elem.name);
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Копировать стиль");
        },
        isVisible: function isVisible(context) {
          return context.elem.type == "Vector" && (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
        },
        isSeparatorBefore: function isSeparatorBefore(context) {
          return !context.layerManagerFlag;
        },
        clickCallback: function clickCallback(context) {
          var rawTree = context.tree.treeModel,
              elem;
          if (context.elem.MultiLayerID) elem = rawTree.findElem("MultiLayerID", context.elem.MultiLayerID).elem;else elem = rawTree.findElem("LayerID", context.elem.name).elem;
          nsGmx$1.ClipboardController.addItem('LayerStyle', {
            type: context.elem.GeometryType,
            style: elem.content.properties.styles
          });
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Создать копию слоя");
        },
        isVisible: function isVisible(context) {
          return context.elem.type == "Vector" && (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
        },
        isSeparatorBefore: function isSeparatorBefore(context) {
          return false;
        },
        clickCallback: function clickCallback(context) {
          sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + context.elem.name, function (response) {
            if (!parseResponse(response)) {
              return;
            }

            createEditorFromSelection(response.Result);

            function createEditorFromSelection(props) {
              var query = '';

              var parent = nsGmx$1.Utils._div(null, [['attr', 'id', 'new' + 'Vector' + 'Layer'], ['css', 'height', '100%']]),
                  properties = {
                Title: props.Title + ' ' + _gtxt('копия'),
                Copyright: props.Copyright,
                Description: props.Description,
                Date: props.Date,
                MetaProperties: props.MetaProperties,
                TilePath: {
                  Path: ''
                },
                ShapePath: props.ShapePath,
                Columns: props.Columns,
                IsRasterCatalog: props.IsRasterCatalog,
                SourceType: "sql",
                Quicklook: props.Quicklook
              },
                  dialogDiv = nsGmx$1.Utils.showDialog(_gtxt('Создать векторный слой'), parent, 340, 340, false, false),
                  params = {
                copy: true,
                sourceLayerName: context.elem.name,
                query: query,
                doneCallback: function doneCallback(res) {
                  nsGmx$1.Utils.removeDialog(dialogDiv);
                }
              };

              nsGmx$1.createLayerEditor(false, 'Vector', parent, properties, params);
            }
          });
        }
      }, 'Layer');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Вставить объекты");
        },
        isVisible: function isVisible(context) {
          return context.elem.type == "Vector" && (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
        },
        isSeparatorBefore: function isSeparatorBefore(context) {
          return false;
        },
        clickCallback: function clickCallback(context) {
          var copyLayerParams = nsGmx$1.ClipboardController.get('CopyObjects', -1),
              copyLayerName = copyLayerParams.layerName,
              copyLayerQuery = copyLayerParams.query,
              list = copyLayerParams.list || '';
          var url = window.serverBase + "VectorLayer/Append?LayerName=" + context.elem.name + "&FromLayer=" + copyLayerName + "&Query=" + copyLayerQuery;
          var def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(url);
          def.done(function (taskInfo) {
            showErrorMessage(list, true, window._gtxt('Объекты добавлены'));
          }).fail(function (taskInfo) {
            showErrorMessage(window._gtxt('Вставить объекты не удалось'), true); // console.log(taskInfo);
          }).progress(function (taskInfo) {// console.log(taskInfo);
          });
        }
      }, 'Layer');
      var applyStyleContentMenuItem = {
        title: function title() {
          return _gtxt("Применить стиль");
        },
        isVisible: function isVisible(context) {
          if (context.layerManagerFlag || _queryMapLayers.currentMapRights() !== "edit" || nsGmx$1.ClipboardController.getCount('LayerStyle') === 0) {
            return false;
          }

          if (context.contentMenuType === 'Layer') {
            return context.elem.type == "Vector" && nsGmx$1.ClipboardController.get('LayerStyle', -1).type === context.elem.GeometryType;
          } else {
            //группы
            return true;
          }
        },
        clickCallback: function clickCallback(context) {
          var newStyles = nsGmx$1.ClipboardController.get('LayerStyle', -1).style,
              stylesType = nsGmx$1.ClipboardController.get('LayerStyle', -1).type;

          if (context.contentMenuType === 'Layer') {
            var div;
            if (context.elem.MultiLayerID) div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];else div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];
            div.gmxProperties.content.properties.styles = newStyles;

            _mapHelper.updateMapStyles(newStyles, context.elem.name);

            _mapHelper.updateTreeStyles(newStyles, div, context.tree, true);
          } else {
            //группа
            var tree = context.tree.treeModel,
                node = tree.findElemByGmxProperties(context.div.gmxProperties).elem;
            tree.forEachLayer(function (layerContent) {
              if (layerContent.properties.type !== "Vector" || layerContent.properties.GeometryType !== stylesType) {
                return;
              }
              layerContent.properties.styles = newStyles;

              _mapHelper.updateMapStyles(newStyles, layerContent.properties.name);

              var div = context.tree.findUITreeElem({
                content: layerContent
              });

              if (div) {
                // div.gmxProperties.content.properties.styles = newStyles;
                _mapHelper.updateTreeStyles(newStyles, div, context.tree, true);
              }
            }, node);
          }
        }
      };
      nsGmx$1.ContextMenuController.addContextMenuElem(applyStyleContentMenuItem, 'Layer'); ///////////////////////////////////////////////////////////////////////////////
      /////////////////////////// Контекстное меню групп ////////////////////////////
      ///////////////////////////////////////////////////////////////////////////////

      /*
      В контексте типа "Group" присутствуют следующие атрибуты:
       * div {DOMElement} Элемент дерева, для которого стротся меню
       * tree {layersTree} Текущее дерево карты
      */

      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Свойства");
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.createGroupEditor(context.div);
        }
      }, 'Group');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Добавить подгруппу");
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.addSubGroup(context.div, context.tree);
        }
      }, 'Group');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Удалить");
        },
        clickCallback: function clickCallback(context) {
          context.tree.removeGroup(context.div);

          _mapHelper.updateUnloadEvent(true);
        }
      }, 'Group');
      nsGmx$1.ContextMenuController.addContextMenuElem(applyStyleContentMenuItem, 'Group'); ///////////////////////////////////////////////////////////////////////////////
      /////////////////////////// Контекстное меню карты ////////////////////////////
      ///////////////////////////////////////////////////////////////////////////////

      /*
      В контексте типа "Map" присутствуют следующие атрибуты:
       * div {DOMElement} Элемент дерева, для которого стротся меню
       * tree {layersTree} Текущее дерево карты
      */

      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Свойства");
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.createMapEditor(context.div);
        }
      }, 'Map');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Добавить подгруппу");
        },
        clickCallback: function clickCallback(context) {
          nsGmx$1.addSubGroup(context.div, context.tree);
        }
      }, 'Map');
      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Права доступа");
        },
        clickCallback: function clickCallback(context) {
          var securityDialog = new nsGmx$1.mapSecurity();
          securityDialog.getRights(context.tree.treeModel.getMapProperties().MapID, context.tree.treeModel.getMapProperties().title);
        },
        isVisible: function isVisible(context) {
          return nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_MAP_RIGHTS) && (_queryMapLayers.currentMapRights() === "edit" || nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN));
        }
      }, 'Map'); //групповое редактирование слоев

      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return _gtxt("Права доступа к слоям");
        },
        isVisible: function isVisible(context) {
          var treeModel = context.tree.treeModel,
              layersFlag = false,
              layersRights = false;
          treeModel.forEachNode(function (node) {
            if (node.type !== 'group') {
              layersFlag = true;

              if (_queryMapLayers.layerRights(node.content.properties.LayerID) === 'edit') {
                layersRights = true;
              }
            }
          });
          return nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_MAP_RIGHTS) && layersFlag && layersRights;
        },
        clickCallback: function clickCallback(context) {
          var securityDialog = new nsGmx$1.layersGroupSecurity(),
              props = _layersTree.treeModel.getMapProperties();

          securityDialog.getRights(props.MapID, props.title);
        }
      }, 'Map');
    }();

    nsGmx$1.GeomixerFrameworkVersion = '05.12.2018';

    !function ($, _) {
      var modulePath = ""; //TODO: вынести переключалку страниц в отдельный модуль

      var appendTranslations = function appendTranslations() {
        _translationsHash.addtext("rus", {
          "Следующие [value0] страниц": "Следующие [value0] страниц",
          "Предыдущие [value0] страниц": "Предыдущие [value0] страниц",
          "Первая страница": "Первая страница",
          "Последняя страница": "Последняя страница"
        });

        _translationsHash.addtext("eng", {
          "Следующие [value0] страниц": "Next [value0] pages",
          "Предыдущие [value0] страниц": "Previous [value0] pages",
          "Первая страница": "First page",
          "Последняя страница": "Last page"
        });
      };
      /** Интерфейс провайдера данных таблицы {@link nsGmx.ScrollTable}
       * @class nsGmx.ScrollTable.IDataProvider
       * @abstract
       */

      /** Получить общее количество объектов
        @method nsGmx.ScrollTable.IDataProvider#getCount
        @param {function(Number)} callback Ф-ция, которую нужно вызвать с общим количеством объектов
      */

      /** Это событие должно генерироваться при любом изменении набора данных. Приведёт к перерисовке таблицы
        @event nsGmx.ScrollTable.IDataProvider#change
      */

      /** Получить массив объектов для отрисовки на странице
        @method nsGmx.ScrollTable.IDataProvider#getItems
        @param {Number} page Номер страницы (нумерация с нуля)
        @param {Number} pageSize Размер страницы
        @param {String} sortParam По какому атрибуту сортировать
        @param {Boolean} sortDec Направление сортировки (true - по убыванию)
        @param {function(Array)} callback Ф-ция, которую нужно вызвать с результирующим массивом объектов. Структура самих объектов определяется провайдером
      */

      /** Получить массив объектов для отрисовки на страницы и общее количество данных за один запрос.
          Альтернатива раздельным запросам getItems() и getCount(). Можно реализовать либо эту ф-цию, либо две другие
        @method nsGmx.ScrollTable.IDataProvider#getCountAndItems
        @param {Number} page Номер страницы (нумерация с нуля)
        @param {Number} pageSize Размер страницы
        @param {String} sortParam По какому атрибуту сортировать
        @param {Boolean} sortDec Направление сортировки (true - по убыванию)
        @param {function(count:Number, objs:Object[])} callback Ф-ция, которую нужно вызвать с полученным результатом.
               Первый параметр - общее количество объектов, второй - массив объектов для данной страницы.
      */

      /** Таблица с разбиением данных по страницам. Сильно кастомизируемый виджет. Поддерживает различные провайдеры данных и рендереры.
       * @class
       * @alias nsGmx.ScrollTable
       */


      var scrollTable = function scrollTable(params) {
        /** Перед перерисовкой данных
         * @event nsGmx.ScrollTable#beforeRedraw
         */

        /** После перерисовки данных
         * @event nsGmx.ScrollTable#redraw
         */

        /** Изменились параметры сортировки
         * @event nsGmx.ScrollTable#sortChange
         */
        this._params = $.extend({
          limit: 50,
          page: 0,
          pagesCount: 10,
          height: '',
          showFooter: true
        }, params);
        this.limit = this._params.limit;
        this.pagesCount = this._params.pagesCount;
        this.start = 0;
        this.reportStart = 0;
        this.drawFunc = null;
        this._requestID = 0;
        this._pageVals = [];
        this._currValsCount = 0;
        this._dataProvider = null; // Переход на предыдущую страницу

        this.next = function () {
          var _this = this,
              button = makeImageButton$1(modulePath + 'img/next.png', modulePath + 'img/next_a.png');

          button.style.marginBottom = '-7px';

          button.onclick = function () {
            _this.start += _this.pagesCount;
            _this.reportStart = _this.start * _this.limit;

            _this._drawPagesRow();

            _this.tableBody.scrollTop = 0;
            _this.tableParent.scrollTop = 0;
          };

          _title$1(button, _gtxt('Следующие [value0] страниц', _this.pagesCount));

          return button;
        }; // Переход на следующую страницу


        this.previous = function () {
          var _this = this,
              button = makeImageButton$1(modulePath + 'img/prev.png', modulePath + 'img/prev_a.png');

          button.style.marginBottom = '-7px';

          button.onclick = function () {
            _this.start -= _this.pagesCount;
            _this.reportStart = _this.start * _this.limit;

            _this._drawPagesRow();

            _this.tableBody.scrollTop = 0;
            _this.tableParent.scrollTop = 0;
          };

          _title$1(button, _gtxt('Предыдущие [value0] страниц', _this.pagesCount));

          return button;
        }; // Переход на первую страницу


        this.first = function () {
          var _this = this,
              button = makeImageButton$1(modulePath + 'img/first.png', modulePath + 'img/first_a.png');

          button.style.marginBottom = '-7px';

          button.onclick = function () {
            _this.start = 0;
            _this.reportStart = _this.start * _this.limit;

            _this._drawPagesRow();

            _this.tableBody.scrollTop = 0;
            _this.tableParent.scrollTop = 0;
          };

          _title$1(button, _gtxt('Первая страница'));

          return button;
        }; // Переход на последнюю страницу


        this.last = function () {
          var _this = this,
              button = makeImageButton$1(modulePath + 'img/last.png', modulePath + 'img/last_a.png');

          button.style.marginBottom = '-7px';

          button.onclick = function () {
            _this.start = Math.floor(_this._currValsCount / (_this.pagesCount * _this.limit)) * _this.pagesCount;
            _this.reportStart = Math.floor(_this._currValsCount / _this.limit) * _this.limit;

            _this._drawPagesRow();

            _this.tableBody.scrollTop = 0;
            _this.tableParent.scrollTop = 0;
          };

          _title$1(button, _gtxt('Последняя страница'));

          return button;
        };

        var _this = this;

        this._status = {
          _state: false,
          start: function start() {
            this._state = true;
            var me = this;
            setTimeout(function () {
              if (me._state) {
                $(_this.statusContainer).siblings().hide();
                $(_this.statusContainer).show();
              }
            }, 100);
          },
          stop: function stop() {
            $(_this.statusContainer).siblings().show();
            $(_this.statusContainer).hide();
            this._state = false;
          }
        };
        this.limitSel = nsGmx$1.Utils._select([_option$1([_t$1("10")], [['attr', 'value', 10]]), _option$1([_t$1("20")], [['attr', 'value', 20]]), _option$1([_t$1("50")], [['attr', 'value', 50]]), _option$1([_t$1("100")], [['attr', 'value', 100]]), _option$1([_t$1("200")], [['attr', 'value', 200]]), _option$1([_t$1("500")], [['attr', 'value', 500]])], [['dir', 'className', 'selectStyle floatRight'], ['css', 'width', '60px']]);
      };
      /** Установка провайдера данных
       @param {nsGmx.ScrollTable.IDataProvider} dataProvider Провайдер данных
       */


      scrollTable.prototype.setDataProvider = function (dataProvider) {
        this._dataProvider = dataProvider;

        this._drawTable();
      };
      /** Получить текущий провайдер данных
       @return {nsGmx.ScrollTable.IDataProvider} Текущий провайдер данных
       */


      scrollTable.prototype.getDataProvider = function () {
        return this._dataProvider;
      };
      /** Изменить активность (видимость) колонки в таблице
        @param {String} name имя колонки
        @param {Boolean} isActive активность (видимость) колонки
      */


      scrollTable.prototype.activateField = function (name, isActive) {
        for (var f = 0; f < this._fields.length; f++) {
          if (this._fields[f].title == name) {
            if (this._fields[f].isActive == isActive) return;
            this._fields[f].isActive = isActive;

            this._drawHeader();

            this._drawRows();
          }
        }
      };

      scrollTable.prototype._getActiveFields = function () {
        var res = [];

        for (var f = 0; f < this._fields.length; f++) {
          if (this._fields[f].isActive) res.push(this._fields[f].title);
        }

        return res;
      };

      scrollTable.prototype._drawRows = function () {
        var trs = [],
            tr;
        $(this).triggerHandler('beforeRedraw');
        $(this.tableBody).empty();

        var activeFields = this._getActiveFields();

        for (var i = 0; i < this._pageVals.length; i++) {
          tr = this.drawFunc(this._pageVals[i], i, activeFields);
          tr && trs.push(tr);
        }

        _(this.tableBody, trs);

        if (this._pageVals.length == 0) _(this.tableBody, [_tr$1(null, [['css', 'height', '1px'], ['attr', 'empty', true]])]);
        $(this.tableCount).empty();
        this.statusContainer = _div$1(null, [['dir', 'className', 'fileBrowser-progress'], ['css', 'display', 'none']]);

        if (this._currValsCount) {
          var cntStr = this._currValsCount === 100001 ? 'более 100000' : this._currValsCount;

          _(this.tableCount, [_span$1([_t$1(this.reportStart + 1 + '-' + Math.min(this.reportStart + this.limit, this._currValsCount)), _span$1([_t$1(' ')], [['css', 'margin', '0px 3px']]), _t$1("(" + cntStr + ")")]), this.statusContainer]);
        } else {
          _(this.tableCount, [_span$1([_t$1("0-0"), _span$1([_t$1(' ')], [['css', 'margin', '0px 3px']]), _t$1("(0)")]), this.statusContainer]);
        }

        $(this).triggerHandler('redraw');
      };

      scrollTable.prototype._drawPages = function (end) {
        var _this = this;

        for (var i = this.start + 1; i <= end; i++) {
          // текущий элемент
          if (i - 1 == this.reportStart / this.limit) {
            var el = _span$1([_t$1(i.toString())]);

            _(_this.tablePages, [el]);

            $(el).addClass('page');
          } else {
            var link = makeLinkButton$1(i.toString());
            link.setAttribute('page', i - 1);
            link.style.margin = '0px 2px';

            _(_this.tablePages, [link]);

            link.onclick = function () {
              _this.reportStart = this.getAttribute('page') * _this.limit;

              _this._drawPagesRow(); // мозилла


              _this.tableBody.scrollTop = 0; // ие

              _this.tableParent.scrollTop = 0;
            };
          }
        }
      };

      scrollTable.prototype._updatePageData = function (callback) {
        var _this = this;

        if (this._dataProvider.getCountAndItems) {
          var requestID = this._requestID++;

          this._status.start();

          _this._dataProvider.getCountAndItems(_this.reportStart / _this.limit, _this.limit, _this.currentSortType, _this.currentSortIndex[_this.currentSortType] == 1, function (count, values) {
            if (requestID !== _this._requestID - 1) {
              _this._status.stop();

              return;
            }

            _this._currValsCount = count; //если данных стало слишком мало, мы встанем на первую страницу и перезапросим данные ещё раз

            if (_this.reportStart > _this._currValsCount) {
              requestID = _this._requestID++;
              _this.start = _this.reportStart = 0; //на первую страницу

              _this._dataProvider.getCountAndItems(_this.reportStart / _this.limit, _this.limit, _this.currentSortType, _this.currentSortIndex[_this.currentSortType] == 1, function (count, values) {
                _this._status.stop();

                if (requestID !== _this._requestID - 1) return;
                _this._pageVals = values;
                callback();
              });
            } else {
              _this._status.stop();

              _this._pageVals = values;
              callback();
            }
          });
        } else {
          this._status.start();

          this._dataProvider.getCount(function (count) {
            _this._currValsCount = count; //вообще-то при обновлении данных мы не изменяем текущей страницы
            //однако если данных стало слишком мало, то текущую страницу сохранить нельзя,
            //и мы переключимся на первую

            if (_this.reportStart >= _this._currValsCount) {
              _this.start = _this.reportStart = 0;
            }

            _this._dataProvider.getItems(_this.reportStart / _this.limit, _this.limit, _this.currentSortType, _this.currentSortIndex[_this.currentSortType] == 1, function (values) {
              _this._status.stop();

              _this._pageVals = values || [];
              callback();
            });
          });
        }
      };

      scrollTable.prototype._drawPagesRow = function () {
        var _this = this;

        this._updatePageData(function () {
          // перерисовывем номера страниц
          $(_this.tablePages).empty();

          if (_this._currValsCount > _this.limit) {
            var allPages = Math.ceil(_this._currValsCount / _this.limit);
            var end = _this.start + _this.pagesCount <= allPages ? _this.start + _this.pagesCount : allPages;
            if (_this.start - _this.pagesCount >= 0) _(_this.tablePages, [_this.first(), _this.previous()]);

            _this._drawPages(end);

            if (end + 1 <= allPages) _(_this.tablePages, [_this.next(), _this.last()]);
          }

          _this._drawRows();
        });
      };

      scrollTable.prototype._drawHeader = function () {
        var tds = [],
            _this = this;

        var headerElemFactory = this._isWidthScroll ? _th : _td$1;

        this._fields.forEach(function (field) {
          if (!field.isActive) return;
          var title = field.title,
              button;

          if (title != '' && field.isSortable) {
            button = makeLinkButton$1(title);
            button.sortType = title;
          } else button = _t$1(title);

          var td = headerElemFactory([button], [['css', 'width', field.width]]);

          if (field.isSortable) {
            $(td).click(function () {
              _this.setSortParams(title, 1 - _this.currentSortIndex[title]);
            });
          }

          tds.push(td);
        });

        $(this._tableHeaderRow).empty();

        _(this._tableHeaderRow, tds);
      }; //Если baseWidth == 0, таблица растягивается на весь контейнер по ширине

      /** Нарисовать таблицу
      * @param {Object} params
      * @param {DOMElement} params.parent Контейнер для помещения результата отрисовки
      * @param {String} params.name Уникальное имя таблицы
      * @param {Number} [params.baseWidth] Какой ширины должна быть таблица. Если не указано, будет занимать 100% контейнера
      * @param {String[]} params.fields массив имён колонок
      * @param {String[]} params.fieldsWidths массив с описанием ширины колонок. Описание даётся в терминах css
      * @param {function} params.drawFunc Ф-ция отрисовки одной строки таблицы. На вход - объект для отрисовки (полученный от провайдера). На выходе - "tr" элемент
      * @param {Object} [params.sortableFields] Хеш для указания возможности сортировки колонок (будет включена для всех ключей хеша)
      * @param {Boolean} [params.isWidthScroll] Трубется ли возможность прокрутки данных по горизонтали
      */


      scrollTable.prototype.createTable = function (parent, name, baseWidth, fields, fieldsWidths, drawFunc, sortableFields, isWidthScroll) {
        var params = null; //передача параметров в виде структуры

        if (arguments.length === 1) {
          params = $.extend(true, {
            sortableFields: {}
          }, parent);
        } else {
          params = {
            parent: parent,
            name: name,
            baseWidth: baseWidth,
            fields: fields,
            fieldsWidths: fieldsWidths,
            drawFunc: drawFunc,
            sortableFields: sortableFields,
            isWidthScroll: isWidthScroll
          };
        }

        var name = params.name;

        var _this = this;

        this._isWidthScroll = params.isWidthScroll;
        this._fields = [];

        for (var f = 0; f < params.fields.length; f++) {
          this._fields.push({
            title: params.fields[f],
            width: params.fieldsWidths[f],
            isSortable: params.fields[f] in params.sortableFields,
            isActive: true
          });
        }

        this.limitSel = switchSelect(this.limitSel, this.limit);

        this.limitSel.onchange = function () {
          _this.limit = Number(this.value);
          _this.start = 0;
          _this.reportStart = _this.start * _this.limit;

          _this._drawTable();
        };

        this.tableCount = _div$1();
        this.tableLimit = _div$1([this.limitSel]);
        this.tablePages = _div$1(null, [['dir', 'className', 'tablePages']]);
        this.tableBody = _tbody$1(null, [['attr', 'id', name + 'TableBody']]);
        this._tableHeaderRow = _tr$1();

        if (this._isWidthScroll) {
          this.tableHeader = _thead([this._tableHeaderRow], [['attr', 'id', name + 'TableHeader'], ['dir', 'className', 'tableHeader']]);
        } else {
          //как формировать фиксированный заголовок таблицы, зависит от того, будет ли у таблицы фиксированный размер или нет
          //TODO: убрать возможность задавать фиксированный размер
          if (params.baseWidth) this.tableHeader = _tbody$1([this._tableHeaderRow], [['attr', 'id', name + 'TableHeader']]);else this.tableHeader = _tbody$1([_tr$1([_td$1([_table$1([_tbody$1([this._tableHeaderRow])])]), _td$1(null, [['css', 'width', '20px']])])], [['attr', 'id', name + 'TableHeader']]);
        }

        this._drawHeader();

        if (this._isWidthScroll) {
          this.tableParent = _div$1([_table$1([this.tableHeader, this.tableBody], [['css', 'width', '100%']])], [['attr', 'id', name + 'TableParent'], ['dir', 'className', 'scrollTable'], ['css', 'width', baseWidth ? baseWidth + 'px' : "100%"], ['css', 'height', this._params.height], ['css', 'overflow', 'auto']]);
        } else {
          this.tableParent = _div$1([_div$1([_table$1([this.tableHeader])], [['dir', 'className', 'tableHeader']]), _div$1([_table$1([this.tableBody])], [['dir', 'className', 'tableBody'], ['css', 'height', this._params.height ? this._params.height - 20 + 'px' : ''], ['css', 'width', params.baseWidth ? params.baseWidth + 20 + 'px' : "100%"]])], [['attr', 'id', name + 'TableParent'], ['dir', 'className', 'scrollTable'], ['css', 'height', this._params.height ? this._params.height + 'px' : ''], ['css', 'width', params.baseWidth ? params.baseWidth + 'px' : "100%"]]);
        }

        _(params.parent, [this.tableParent]);

        if (this._params.showFooter) _(params.parent, [_table$1([_tbody$1([_tr$1([_td$1([this.tableCount], [['css', 'width', '20%']]), _td$1([this.tablePages]), _td$1([this.tableLimit], [['css', 'width', '20%']])])])], [['css', 'width', '100%']])]);
        this.drawFunc = params.drawFunc;
        this.start = 0; //Первый номер страницы, показываемый на экране (это не текущая страница!)

        this.reportStart = 0; //Первый номер элемента на текущей странице

        this.currentSortType = null; // сортировка по умолчанию

        for (var name in params.sortableFields) {
          this.currentSortType = name;
          break;
        }

        this.currentSortIndex = {};

        for (var name in params.sortableFields) {
          this.currentSortIndex[name] = 0;
        }

        if (!this._dataProvider) this.setDataProvider(new scrollTable.StaticDataProvider());
        $(this._dataProvider).change(function () {
          _this._drawTable();
        });

        this._drawTable();
      };

      scrollTable.prototype.updateHeight = function (height) {
        if (this._isWidthScroll) {
          this.tableParent.style.height = height - 40 + 'px';
        } else {
          $(this.tableParent).find('.tableBody').height(height - 20);
          $(this.tableParent).height(height);
        }
      };

      scrollTable.prototype._drawTable = function () {
        if (!this.tableBody) return; //ещё не создана таблица

        this._drawPagesRow();
      };
      /** Выбрать страницу для показа
      @param {Number} page Номер страницы (нумерация с нуля)
      */


      scrollTable.prototype.setPage = function (iPage) {
        if (this.limit * iPage >= this._currValsCount || iPage < 0 || this.reportStart == iPage * this.limit) return;
        this.reportStart = iPage * this.limit;
        this.start = Math.floor(iPage / this.pagesCount) * this.pagesCount;

        this._drawPagesRow();

        this.tableBody.scrollTop = 0;
        this.tableParent.scrollTop = 0;
      };
      /** Получить массив объектов, которые нарисованы в данный момент
       @return {Array} массив объектов в формате провайдера данных
      */


      scrollTable.prototype.getVisibleItems = function () {
        return this._pageVals;
      };
      /** Задать параметры сортровки
       @param {String} sortType Имя колонки для сортировки
       @param {Boolean} sortDirection Направление сортровки (false - по возрастанию, true - по убыванию)
      */


      scrollTable.prototype.setSortParams = function (sortType, sortDirection) {
        this.currentSortType = sortType;
        this.currentSortIndex[this.currentSortType] = sortDirection;
        this.start = 0;
        this.reportStart = this.start * this.limit;

        this._drawTable();

        $(this).triggerHandler('sortChange');
      };
      /** Получить текущее направление сортировки.
       @return {Boolean} false - по возрастанию, true - по убыванию
      */


      scrollTable.prototype.getSortDirection = function () {
        return this.currentSortIndex[this.currentSortType] == 1;
      };
      /** Получить по какой колонке происходит сортровка
       @return Имя колонки
      */


      scrollTable.prototype.getSortType = function () {
        return this.currentSortType;
      };
      /** Перерисовать текущую страницу без перезапроса данных у провайдера */


      scrollTable.prototype.repaint = function () {
        this._drawRows();
      }; ///////////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////////
      ///////////////////////////////////////////////////////////////////////////////

      /** Провайдер данных для {@link nsGmx.ScrollTable}.
      * Хранит статический массив данных, умеет их фильтровать и упорядочивать.
      * @class
      * @extends nsGmx.ScrollTable.IDataProvider
      */


      scrollTable.StaticDataProvider = function (originalData) {
        var _vals = originalData || []; //исходный список элементов


        var _filteredVals = []; //список элементов после фильтрации. Валиден только если _isFiltered == true

        var _isFiltered = false;
        var _predicate = {}; //фильтры. Ф-ции predicate(name, value, items)->filteredItems

        var _filterVals = {}; //значения фильтров

        var _sortFunctions = {};

        var _this = this;

        var _filter = function _filter() {
          if (_isFiltered) return;
          _filteredVals = _vals;

          for (var filterElem in _filterVals) {
            _filteredVals = _predicate[filterElem](filterElem, _filterVals[filterElem], _filteredVals);
          }

          _isFiltered = true;
        };

        var _update = function _update() {
          _isFiltered = false;
          $(_this).change();
        };
        /** синхронный вариант getCount() */


        this.getCountDirect = function () {
          _filter();

          return _filteredVals.length;
        };
        /** синхронный вариант getItems() */


        this.getItemsDirect = function (page, pageSize, sortParam, sortDec) {
          var nMin = page * pageSize;
          var nMax = nMin + pageSize;

          _filter();

          var sortDirIndex = sortDec ? 1 : 0;
          var sortedVals;

          if (_sortFunctions[sortParam]) {
            if (typeof _sortFunctions[sortParam] === 'function') //если нет ф-ции для сортировки в обратном порядке, инвертируем прямую ф-цию
              sortedVals = _filteredVals.sort(function (a, b) {
                return (1 - 2 * sortDirIndex) * _sortFunctions[sortParam](a, b);
              });else sortedVals = _filteredVals.sort(_sortFunctions[sortParam][sortDirIndex]);
          } else sortedVals = _filteredVals;

          nMin = Math.min(Math.max(nMin, 0), sortedVals.length);
          nMax = Math.min(Math.max(nMax, 0), sortedVals.length);
          return sortedVals.slice(nMin, nMax);
        }; //IDataProvider interface


        this.getCount = function (callback) {
          callback(this.getCountDirect());
        };

        this.getItems = function (page, pageSize, sortParam, sortDec, callback) {
          callback(this.getItemsDirect(page, pageSize, sortParam, sortDec, callback));
        };
        /** задание исходных данных */


        this.setOriginalItems = function (items) {
          _vals = items;

          _update();
        };
        /** получение исходных данных */


        this.getOriginalItems = function () {
          return _vals;
        };
        /** Фильтруем исходные данные
        * @param {function(val:Object):Boolean} filterFunction ф-ция для фильтрации. На вход принимает элемент массива данных, возвращает false, если элемент отфильтровывается, иначе true
        */


        this.filterOriginalItems = function (filterFunction) {
          var newOrigData = [];

          for (var i = 0; i < _vals.length; i++) {
            if (filterFunction(_vals[i])) newOrigData.push(_vals[i]);
          }

          _vals = newOrigData;

          _update();
        };
        /** Добавляем новый элемент в исходные данные */


        this.addOriginalItem = function (item) {
          _vals.push(item);

          _update();
        };
        /** Добавляем массив элементов в исходные данные */


        this.addOriginalItems = function (itemArr) {
          _vals = _vals.concat(itemArr);

          _update();
        }; //фильтрация


        this.attachFilterEvents = function (inputField, fieldName, predicate) {

          _predicate[fieldName] = predicate;
          $(inputField).bind('keyup', function () {
            if (_filterVals[fieldName] !== this.value) {
              _filterVals[fieldName] = this.value;

              _update();
            }
          });
          _filterVals[fieldName] = inputField.value;

          _update();
        };
        /** Добавить ф-цию фильтрации исходных данных
            @param {String} fieldName Имя фильтра
            @param {function} predicate Ф-ция фильтрации: predicate(name, value, items)->filteredItems
        */


        this.addFilter = function (fieldName, predicate) {
          _predicate[fieldName] = predicate;
        };
        /** Установить значение для фильтра
            @param {String} fieldName Имя фильтра
            @param {String} value Значение для фильтрации
        */


        this.setFilterValue = function (fieldName, value) {
          _filterVals[fieldName] = value;

          _update();
        };

        this.attachSelectFilterEvents = function (selectField, fieldName, predicate) {

          _predicate[fieldName] = predicate;

          selectField.onchange = function () {
            _filterVals[fieldName] = this.value;

            _update();
          };

          _filterVals[fieldName] = selectField.value;

          _update();
        };
        /** Задать ф-ции сортировки
         @param {Object} sortFunctions Хеш из ф-ций {Имя столбца -> ф-ция или массив из двух ф-ций}.
            Если массив из двух ф-ций, то первая используется для сортировки по возрастанию, вторая - по убыванию.
            Если просто ф-ция, то по убыванию используется инвертная к ней.
            Формат ф-ции совпадает с ф-цией для sort().
        */


        this.setSortFunctions = function (sortFunctions) {
          _sortFunctions = sortFunctions;
        };
      }; // простое стравнение по атрибутам объекта.
      // Использование: genAttrSort(func(a)->value), genAttrSort(attrName), genAttrSort(attrName1, attrName2)


      scrollTable.StaticDataProvider.genAttrSort = function (attrName1, attrName2) {
        if (typeof attrName1 === 'function') {
          return function (a, b) {
            var av = attrName1(a),
                bv = attrName1(b);
            if (av > bv) return 1;else if (av < bv) return -1;else return 0;
          };
        } else if (attrName2) {
          return function (a, b) {
            var av = a[attrName1][attrName2];
            var bv = b[attrName1][attrName2];
            if (av > bv) return 1;else if (av < bv) return -1;else return 0;
          };
        } else {
          return function (a, b) {
            var av = a[attrName1];
            var bv = b[attrName1];
            if (av > bv) return 1;else if (av < bv) return -1;else return 0;
          };
        }
      }; // //если есть вьюер, добавляем для него переменные в глобальный namespace
      // if ('nsGmx' in window && 'GeomixerFramework' in window.nsGmx)
      // {


      window.scrollTable = scrollTable; //Depricated - use nsGmx

      window.nsGmx.ScrollTable = scrollTable; // }

      if (typeof window.gmxCore !== 'undefined') {
        gmxCore.addModule("ScrollTableControl", {
          ScrollTable: scrollTable
        }, {
          require: ['translations', 'utilities'],
          // css: 'table.css',
          init: function init(module, path) {
            modulePath = path || "";
            appendTranslations();
          }
        });
      }
    }(jQuery, nsGmx$1.Utils._);

    //позволяет загрузить карту, просмотреть слои карты, перетащить слой в текущую карту

    !function (_) {
      nsGmx$1.MapsManagerControl = function () {
        var _this = this;

        this._activeIndex = 0;
        this._mapsTable = new nsGmx$1.ScrollTable();
        this._canvas = _div$1(null, [['attr', 'id', 'mapsList']]);
        this._mapPreview = null;
        $(this._canvas).append('<div class="gmx-icon-progress"></div>');
        this._dialogDiv = showDialog$1(_gtxt("Список карт"), this._canvas, 571, 360, 535, 130, this._resize.bind(this));
        sendCrossDomainJSONRequest$2(serverBase + "Map/GetMaps.ashx?WrapStyle=func", function (response) {
          $(_this._canvas).empty();
          if (!parseResponse(response)) return;

          _this._drawMapsDialog(response.Result);
        });
        this._previewMapName = null;
      };

      nsGmx$1.MapsManagerControl.prototype._resize = function () {
        var canvas = this._canvas,
            mapsTable = this._mapsTable,
            mapPreview = this._mapPreview;
        var dialogWidth = canvas.parentNode.parentNode.offsetWidth;
        mapsTable.tableParent.style.width = dialogWidth - 15 - 21 + 'px';
        mapsTable.tableBody.parentNode.parentNode.style.width = dialogWidth + 5 - 21 + 'px';
        mapsTable.tableBody.parentNode.style.width = dialogWidth - 15 - 21 + 'px';
        mapsTable.tablePages.parentNode.parentNode.parentNode.parentNode.style.width = dialogWidth - 12 - 21 + 'px';
        mapsTable.tableParent.style.height = '200px';
        mapsTable.tableBody.parentNode.parentNode.style.height = '170px';

        if (mapPreview) {
          mapPreview.style.height = canvas.parentNode.offsetHeight - canvas.firstChild.offsetHeight - 250 + 'px';
          mapPreview.style.width = dialogWidth + 5 - 21 + 'px';
        }
      };

      nsGmx$1.MapsManagerControl.prototype._drawMapsDialog = function (mapsList) {
        var searchUITemplate = Handlebars.compile('<div class="mapslist-search">' + '<table class="mapslist-search-table"><tr>' + '<td>' + '{{i "Название"}}<input class="inputStyle mapslist-search-name">' + '</td><td>' + '{{i "Владелец"}}<input class="inputStyle mapslist-search-owner">' + '</td>' + '</tr></table>' + '</div>');
        var searchCanvas = $(searchUITemplate())[0];

        var canvas = this._canvas,
            name = 'maps',
            mapsTable = this._mapsTable,
            _this = this;

        var mapNameInput = $('.mapslist-search-name', searchCanvas)[0],
            mapOwnerInput = $('.mapslist-search-owner', searchCanvas)[0];

        _(canvas, [searchCanvas]);

        var tableParent = _div$1(),
            sortFuncs = {};

        var sign = function sign(n1, n2) {
          return n1 < n2 ? -1 : n1 > n2 ? 1 : 0;
        };

        var sortFuncFactory = function sortFuncFactory(f1, f2) {
          return [function (_a, _b) {
            return sign(f1(_a), f1(_b)) || sign(f2(_a), f2(_b));
          }, function (_b, _a) {
            return sign(f1(_a), f1(_b)) || sign(f2(_a), f2(_b));
          }];
        };

        var idFunc = function idFunc(_a) {
          return _a.Name;
        };

        var titleFunc = function titleFunc(_a) {
          return String(_a.Title).toLowerCase();
        };

        var ownerFunc = function ownerFunc(_a) {
          return String(_a.Owner).toLowerCase();
        };

        var dateFunc = function dateFunc(_a) {
          return _a.LastModificationDateTime;
        };

        sortFuncs[_gtxt('Имя')] = sortFuncFactory(titleFunc, idFunc);
        sortFuncs[_gtxt('Владелец')] = sortFuncFactory(ownerFunc, idFunc);
        sortFuncs[_gtxt('Последнее изменение')] = sortFuncFactory(dateFunc, idFunc);
        mapsTable.createTable(tableParent, name, 410, ["", _gtxt("Имя"), _gtxt("Владелец"), _gtxt("Последнее изменение"), ""], ['5%', '55%', '15%', '15%', '5%'], function (map, i) {
          return _this._drawMaps.call(this, map, i, _this);
        }, sortFuncs);
        mapsTable.getDataProvider().setSortFunctions(sortFuncs);

        var inputPredicate = function inputPredicate(value, fieldValue) {
          return !!value && String(value).toLowerCase().indexOf(fieldValue) > -1;
        };

        $([mapNameInput, mapOwnerInput]).bind('keydown', function (event) {
          var numItems = mapsTable.getVisibleItems().length;

          if (event.keyCode === 13) {
            var firstItem = mapsTable.getVisibleItems()[_this._activeIndex];

            firstItem && window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + firstItem.Name);
          }

          if (event.keyCode === 38) {
            _this._activeIndex = Math.max(0, Math.min(_this._activeIndex - 1, numItems - 1));
            $(mapsTable.getDataProvider()).change();
            event.preventDefault();
          }

          if (event.keyCode === 40) {
            _this._activeIndex = Math.max(0, Math.min(_this._activeIndex + 1, numItems - 1));
            $(mapsTable.getDataProvider()).change();
            event.preventDefault();
          }
        });
        mapsTable.getDataProvider().attachFilterEvents(mapNameInput, 'Title', function (fieldName, fieldValue, vals) {
          if (fieldValue == "") {
            return vals;
          }

          fieldValue = fieldValue.toLowerCase();
          return vals.filter(function (value) {
            return inputPredicate(value[fieldName], fieldValue) || value['Name'].toLowerCase() === fieldValue;
          });
        });
        mapsTable.getDataProvider().attachFilterEvents(mapOwnerInput, 'Owner', function (fieldName, fieldValue, vals) {
          if (fieldValue == "") {
            return vals;
          }

          fieldValue = fieldValue.toLowerCase();
          return vals.filter(function (value) {
            return inputPredicate(value[fieldName], fieldValue);
          });
        });

        _(canvas, [tableParent]);

        mapsTable.tableHeader.firstChild.childNodes[1].style.textAlign = 'left';

        this._resize();

        mapsTable.getDataProvider().setOriginalItems(mapsList);
        mapNameInput.focus();
      };

      nsGmx$1.MapsManagerControl.prototype._drawMaps = function (map, mapIndex, mapsManager) {
        var name = makeLinkButton$1(map.Title),
            img_url = map.Name === mapsManager._previewMapName ? 'img/collapse-arrow-se.png' : 'img/collapse-arrow-right.gif',
            load = makeImageButton$1(img_url, img_url),
            remove = makeImageButton$1("img/recycle.png", "img/recycle_a.png");

        _title$1(name, _gtxt("Загрузить"));

        _title$1(load, _gtxt("Показать"));

        _title$1(remove, _gtxt("Удалить"));

        name.className = name.className + ' maps-manager-mapname';

        name.onclick = function () {
          window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + map.Name);
        };

        nsGmx$1.ContextMenuController.bindMenuToElem(name, 'MapListItem', function () {
          return true;
        }, {
          name: map.Name
        });

        load.onclick = function () {
          $(mapsManager._mapPreview).empty();

          var loading = _div$1([_img$1(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), _t$1(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px']]);

          if (!mapsManager._mapPreview) {
            mapsManager._mapPreview = _div$1(null, [['css', 'marginTop', '5px'], ['css', 'borderTop', '1px solid #216B9C'], ['css', 'overflowY', 'auto']]);
            $(mapsManager._canvas).append(mapsManager._mapPreview);
            $(mapsManager._dialogDiv).dialog('option', 'height', 550);
            $(mapsManager._dialogDiv).dialog('option', 'minHeight', 550);

            mapsManager._resize();
          }

          _(mapsManager._mapPreview, [loading]); // раз уж мы список получили с сервера, то и карты из этого списка точно нужно загружать с него же...


          mapsManager._loadMapJSON(window.serverBase, map.Name, mapsManager._mapPreview);

          $(mapsManager._mapsTable.getDataProvider()).change();
        };

        remove.onclick = function () {
          if (map.Name == defaultMapID) {
            showErrorMessage(_gtxt("$$phrase$$_14"), true);
            return;
          }

          if (map.Name == globalMapName) {
            showErrorMessage(_gtxt("$$phrase$$_15"), true);
            return;
          }

          if (confirm(_gtxt("Вы действительно хотите удалить эту карту?"))) {
            var loading = loading = _div$1([_img$1(null, [['attr', 'src', 'img/progress.gif']]), _t$1(_gtxt('удаление...'))], [['css', 'marginLeft', '5px']]);

            $(remove.parentNode.parentNode).replaceWith(_tr$1([_td$1([loading], [['attr', 'colSpan', 5]])]));
            sendCrossDomainJSONRequest$2(serverBase + "Map/Delete.ashx?WrapStyle=func&MapID=" + map.MapID, function (response) {
              mapsManager._deleteMapHandler(response, map.MapID);
            });
          }
        };

        var date = new Date(map.LastModificationDateTime * 1000);
        var modificationDateString = $.datepicker.formatDate('dd.mm.yy', date); // + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();

        var tr = _tr$1([_td$1([load], [['css', 'textAlign', 'center']]), _td$1([name]), _td$1([_t$1(map.Owner)], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible maps-manager-owner'], ['dir', 'title', map.Owner]]), _td$1([_t$1(modificationDateString)], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']]), _td$1([remove], [['css', 'textAlign', 'center']])]);

        for (var i = 0; i < tr.childNodes.length; i++) {
          tr.childNodes[i].style.width = this._fields[i].width;
        }

        attachEffects$1(tr, 'hover');

        if (mapsManager._activeIndex === mapIndex) {
          $(tr).addClass('maps-manager-active');
        }

        return tr;
      };

      nsGmx$1.MapsManagerControl.prototype._deleteMapHandler = function (response, id) {
        if (!parseResponse(response)) return;
        var mapsTable = this._mapsTable;

        if (response.Result == 'deleted') {
          mapsTable.start = 0;
          mapsTable.reportStart = mapsTable.start * mapsTable.limit;
          mapsTable.getDataProvider().filterOriginalItems(function (elem) {
            return elem.MapID != id;
          });
        } else showErrorMessage(_gtxt("Ошибка!"), true, _gtxt("Слоя нет в базе"));
      };

      nsGmx$1.MapsManagerControl.prototype._loadMapJSON = function (host, name, parent) {
        //loadMapJSON(host, name, function(layers)
        this._previewMapName = name;
        var hostName = L.gmxUtil.normalizeHostname(host),
            apiKey = window.mapsSite ? window.apiKey : null; //передаём apiKey только если не локальная версия ГеоМиксера

        L.gmx.gmxMapManager.getMap(hostName, apiKey, name, window.gmxSkipTiles).then(function (mapInfo) {
          var previewLayersTree = new layersTree({
            showVisibilityCheckbox: true,
            allowActive: false,
            allowDblClick: false
          }),
              ul = previewLayersTree.drawTree(mapInfo, 2);
          $(ul).treeview(); //раскрываем группы по клику

          $(ul).click(function (event) {
            if ($(event.target).hasClass('groupLayer')) {
              var clickDiv = $(event.target.parentNode.parentNode.parentNode).children("div.hitarea");
              clickDiv.length && $(clickDiv[0]).trigger('click');
            }
          });
          $(parent).empty();
          var hint = $('<div class="mapslist-hint">' + _gtxt('maplist.hint') + '</div>');

          _(parent, [hint[0], ul]);

          _queryMapLayers.addDraggable(parent);
        });
      };

      nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function title() {
          return "Открыть в новом окне";
        },
        clickCallback: function clickCallback(context) {
          window.open(window.location.href.split(/\?|#/)[0] + "?" + context.name, '_blank');
        }
      }, 'MapListItem');
    }(nsGmx$1.Utils._);

    (function ($) {

      _translationsHash.addtext("rus", {
        "pluginsEditor.selectedTitle": "Плагины карты",
        "pluginsEditor.availableTitle": "Доступные плагины",
        "pluginsEditor.add": "Добавить плагин",
        "pluginsEditor.paramsTitle": "Параметры плагина"
      });

      _translationsHash.addtext("eng", {
        "pluginsEditor.selectedTitle": "Map plugins",
        "pluginsEditor.availableTitle": "Available plugins",
        "pluginsEditor.add": "Add plugin",
        "pluginsEditor.paramsTitle": "Parameter of plugin"
      });

      var MapPlugins = function MapPlugins() {
        var _plugins = [];
        var _params = {}; //вместо массива из одного элемента передаём сам элемент

        var normalizeParams = function normalizeParams(params) {
          var res = {};

          for (var p in params) {
            res[p] = params[p].length === 1 ? params[p][0] : params[p];
          }

          return res;
        };

        this.addPlugin = function (pluginName, pluginParams, onlyParams) {
          _params[pluginName] = pluginParams || _params[pluginName] || {};

          if (!onlyParams && _plugins.indexOf(pluginName) === -1) {
            _plugins.push(pluginName);
          }

          $(this).change();
          return true;
        };

        this.each = function (callback) {
          for (var p = 0; p < _plugins.length; p++) {
            callback(_plugins[p], _params[_plugins[p]] || {});
          }
        };

        this.remove = function (pluginName) {
          var nameIndex = _plugins.indexOf(pluginName);

          if (nameIndex !== -1) {
            _plugins.splice(nameIndex, 1);

            $(this).change();
          }
        };

        this.isExist = function (pluginName) {
          return _plugins.indexOf(pluginName) !== -1;
        };

        this.getPluginParams = function (pluginName) {
          return _params[pluginName];
        };

        this.setPluginParams = function (pluginName, pluginParams) {
          _params[pluginName] = pluginParams;
          $(this).change();
        }; //обновляем используемость и параметры плагинов


        this.updateGeomixerPlugins = function () {
          for (var p = 0; p < _plugins.length; p++) {
            var plugin = nsGmx$1.pluginsManager.getPluginByName(_plugins[p]),
                lazyLoad = plugin && plugin.lazyLoad;
            nsGmx$1.pluginsManager.setUsePlugin(_plugins[p], !lazyLoad);
          }

          for (var p in _params) {
            nsGmx$1.pluginsManager.updateParams(p, normalizeParams(_params[p]));
          }
        };

        this.load = function (data, version) {
          if (version === 1) {
            _plugins = data;
            _params = {};
          } else if (version === 2) {
            _plugins = [];
            _params = {};

            for (var p = 0; p < data.length; p++) {
              _plugins.push(data[p].name);

              _params[data[p].name] = data[p].params;
            }
          } else if (version === 3) {
            _plugins = data.plugins; //поддержка ошибки, которая прокралась в базу...

            if ($.isArray(data.params) && data.params.length === 0) {
              _params = {};
            } else {
              _params = data.params;
            }
          }
        };

        this.save = function (version) {
          if (version === 1) {
            return _plugins;
          } else if (version === 2) {
            var res = [];

            _plugins.forEach(function (name) {
              res.push({
                name: name,
                params: _params[name]
              });
            });

            return res;
          } else if (version === 3) {
            return {
              plugins: _plugins,
              params: _params
            };
          }
        };
      };

      var GeomixerPluginsWidget = function GeomixerPluginsWidget(container, mapPlugins) {
        var template = Handlebars.compile('<div class="pluginsEditor-allPlugins-container">' + '<div class="pluginEditor-widgetHeader">{{i "pluginsEditor.availableTitle"}}</div>' + '<div class="pluginEditor-treePlaceholder"></div>' + '<div class="pluginEditor-controls">' + '<input class="inputStyle inputFullWidth pluginEditor-pluginInput"><br>' + '<button class="pluginEditor-addButton">{{i "pluginsEditor.add"}}</button>' + '</div>' + '</div>');
        var lang = window.nsGmx.Translations.getLanguage();
        var DEFAULT_GROUP_NAME = {
          eng: 'Main',
          rus: 'Основные'
        };
        var _allPluginGroups = {},
            configGroups = window.gmxPluginGroups || [],
            groupByPluginName = [],
            groupOrder = {};
        configGroups.forEach(function (group, index) {
          groupOrder[group[lang]] = index;
          group.plugins.forEach(function (plugin) {
            groupByPluginName[plugin] = group[lang];
          });
        });
        nsGmx$1.pluginsManager.forEachPlugin(function (plugin) {
          if (plugin.pluginName && plugin.mapPlugin && (plugin.isPublic || nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN))) {
            var groupName = groupByPluginName[plugin.pluginName] || DEFAULT_GROUP_NAME[lang];
            _allPluginGroups[groupName] = _allPluginGroups[groupName] || {
              groupName: groupName,
              plugins: []
            };

            _allPluginGroups[groupName].plugins.push({
              name: plugin.pluginName,
              isPublic: plugin.isPublic
            }); //_allPlugins.push({name: plugin.pluginName, isPublic: plugin.isPublic});

          }
        }); //по алфавиту

        for (var g in _allPluginGroups) {
          _allPluginGroups[g].plugins.sort(function (a, b) {
            return a.name > b.name ? 1 : -1;
          });
        }

        var isListActive = false;

        var update = function update() {
          $(container).empty();
          var filteredGroups = [];

          for (var g in _allPluginGroups) {
            var plugins = _allPluginGroups[g].plugins.filter(function (plugin) {
              return !mapPlugins.isExist(plugin.name);
            }); //если в группе нет плагинов, не показываем её


            plugins.length && filteredGroups.push({
              groupName: _allPluginGroups[g].groupName,
              plugins: plugins
            });
          }

          filteredGroups.sort(function (a, b) {
            return groupOrder[a.groupName] - groupOrder[b.groupName];
          });
          var pluginGroupTemplate = Handlebars.compile('<ul class="pluginEditor-pluginsTree ui-helper-noselect">{{#groups}}' + '<li>' + '<div class="pluginEditor-groupTitle">{{groupName}}</div>' + '<ul>{{#plugins}}' + '<li class="pluginEditor-pluginItem ui-helper-noselect" data-plugin-name="{{name}}">{{name}}</li>' + '{{/plugins}}</ul>' + '</li>' + '{{/groups}}</ul>');
          var pluginsTree = $(pluginGroupTemplate({
            groups: filteredGroups
          }));
          pluginsTree.find('.pluginEditor-pluginItem').click(function (e) {
            isListActive = true;
            var pluginName = $(this).data('pluginName');

            if (e.ctrlKey) {
              $(this).toggleClass('pluginEditor-activePluginItem');
            } else {
              pluginsTree.find('.pluginEditor-pluginItem').removeClass('pluginEditor-activePluginItem');
              $(this).addClass('pluginEditor-activePluginItem');
            }
          });
          pluginsTree.find('.pluginEditor-groupTitle').click(function () {
            $(this).siblings('.hitarea').click();
          });
          var ui = $(template());
          ui.find('.pluginEditor-treePlaceholder').append(pluginsTree);
          ui.find('.pluginEditor-pluginInput').bind('focus', function () {
            isListActive = false;
          });
          ui.find('.pluginEditor-addButton').click(function () {
            var selected = [];

            if (isListActive) {
              pluginsTree.find('.pluginEditor-activePluginItem').each(function (i, elem) {
                selected.push($(elem).data('pluginName'));
              });
            } else {
              var pluginInput = ui.find('.pluginEditor-pluginInput');

              if (nsGmx$1.pluginsManager.getPluginByName(pluginInput.val())) {
                selected.push(pluginInput.val());
              } else {
                inputError(pluginInput[0]);
              }
            }

            for (var sp = 0; sp < selected.length; sp++) {
              mapPlugins.addPlugin(selected[sp]);
            }
          });
          ui.appendTo(container);
          pluginsTree.treeview();
        };

        $(mapPlugins).change(update);
        update();
      };

      var paramsWidgets = {};

      var MapPluginParamsWidget = function MapPluginParamsWidget(mapPlugins, pluginName) {
        if (paramsWidgets[pluginName]) {
          return;
        }

        var FakeTagMetaInfo = function FakeTagMetaInfo() {
          this.isTag = function (tag) {
            return true;
          };

          this.getTagType = function (tag) {
            return 'String';
          };

          this.getTagDescription = function (tag) {
            return '';
          };

          this.getTagArray = function () {
            return [];
          };

          this.getTagArrayExt = function () {
            return [];
          };
        };

        var fakeTagMetaInfo = new FakeTagMetaInfo();
        var pluginParams = mapPlugins.getPluginParams(pluginName);
        var tagInitInfo = {};

        for (var tagName in pluginParams) {
          tagInitInfo[tagName] = {
            Value: pluginParams[tagName]
          };
        }

        var layerTags = new nsGmx$1.LayerTagsWithInfo(fakeTagMetaInfo, tagInitInfo);
        var container = $('<div/>');
        var pluginValues = new nsGmx$1.LayerTagSearchControl(layerTags, container);

        var updateParams = function updateParams() {
          var newParams = {};
          layerTags.eachValid(function (tagid, tag, value) {
            newParams[tag] = newParams[tag] || [];
            newParams[tag].push(value);
          });
          mapPlugins.setPluginParams(pluginName, newParams);
        };

        var dialogDiv = showDialog(_gtxt('pluginsEditor.paramsTitle') + " " + pluginName, container[0], {
          width: 320,
          height: 200,
          closeFunc: function closeFunc() {
            updateParams();
            delete paramsWidgets[pluginName];
          }
        });
        paramsWidgets[pluginName] = {
          update: updateParams,
          closeDialog: function closeDialog() {
            $(dialogDiv).dialog('close');
          }
        };
      };

      var MapPluginsWidget = Backbone.View.extend({
        template: Handlebars.compile('<div class="pluginEditor-widgetHeader">{{i "pluginsEditor.selectedTitle"}}</div>' + '<div class="pluginEditor-currentMapPlugins">' + '{{#plugins}}' + '<div class="pluginEditor-widgetElem">' + '{{#unless isCommon}}' + '<span class="pluginEditor-remove gmx-icon-close" data-plugin-name="{{name}}"></span>' + '{{/unless}}' + '<span class="pluginEditor-edit gmx-icon-edit" data-plugin-name="{{name}}"></span>' + '<span class="pluginEditor-title {{#if isCommon}} pluginEditor-commonPlugin{{/if}}">{{name}}</span>' + '</div>' + '{{/plugins}}' + '</div>'),
        events: {
          'click .gmx-icon-close': function clickGmxIconClose(event) {
            var pluginName = $(event.target).data('pluginName');

            this._mapPlugins.remove(pluginName);
          },
          'click .gmx-icon-edit': function clickGmxIconEdit(event) {
            var pluginName = $(event.target).data('pluginName');
            new MapPluginParamsWidget(this._mapPlugins, pluginName);
          }
        },
        initialize: function initialize(options) {
          this._mapPlugins = options.mapPlugins;
          $(this._mapPlugins).change(this.render.bind(this));
          this.render();
        },
        render: function render() {
          var mapPlugins = this._mapPlugins,
              pluginsToShow = [];
          nsGmx$1.pluginsManager.forEachPlugin(function (plugin) {
            if (plugin.pluginName && !plugin.mapPlugin && !mapPlugins.isExist(plugin.pluginName)) {
              pluginsToShow.push({
                name: plugin.pluginName,
                isCommon: true
              });
            }
          });
          mapPlugins.each(function (name) {
            pluginsToShow.push({
              name: name,
              isCommon: false
            });
          });
          pluginsToShow.sort(function (a, b) {
            return a.isCommon != b.isCommon ? Number(b.isCommon) - Number(a.isCommon) : a.name > b.name ? 1 : -1;
          });
          this.$el.empty().append(this.template({
            plugins: pluginsToShow
          }));
        }
      });

      var createPluginsEditor = function createPluginsEditor(container, mapPlugins) {
        var widgetContainer = $('<div/>', {
          'class': 'pluginEditor-widgetContainer'
        });
        var allPluginsContainer = $('<div/>', {
          'class': 'pluginEditor-allContainer'
        });
        var mapPluginsWidget = new MapPluginsWidget({
          el: widgetContainer,
          mapPlugins: mapPlugins
        });
        var allPluginsWidget = new GeomixerPluginsWidget(allPluginsContainer, mapPlugins);
        $(container).append($('<table/>', {
          'class': 'pluginEditor-table'
        }).append($('<tr/>').append($('<td/>', {
          'class': 'pluginEditor-allTD'
        }).append(allPluginsContainer)).append($('<td/>', {
          'class': 'pluginEditor-widgetTD'
        }).append(widgetContainer))));
        return {
          update: function update() {
            for (var name in paramsWidgets) {
              paramsWidgets[name].update();
            }
          },
          closeParamsDialogs: function closeParamsDialogs() {
            for (var name in paramsWidgets) {
              paramsWidgets[name].closeDialog();
            }
          }
        };
      };

      gmxCore.addModule('PluginsEditor', {
        createPluginsEditor: createPluginsEditor,
        MapPlugins: MapPlugins
      });
      nsGmx$1.createPluginsEditor = createPluginsEditor;
      _mapHelper.mapPlugins = new MapPlugins(); //Cтарая версия информации о плагинах карты. Поддерживается для обратной совместимости (например, загрузка доп. карт)
      //Формат: {String[]} массив имён плагинов

      nsGmx$1.userObjectsManager.addDataCollector('mapPlugins', {
        load: function load(data) {
          if (data) {
            _mapHelper.mapPlugins.load(data, 1);

            _mapHelper.mapPlugins.updateGeomixerPlugins();
          }
        },
        collect: function collect() {
          return _mapHelper.mapPlugins.save(1);
        }
      }); //Вторая версия информации о плагинах карты.
      //Формат: [{name: pluginName1, params: {param: value, ...}}, ...]

      nsGmx$1.userObjectsManager.addDataCollector('mapPlugins_v2', {
        load: function load(data) {
          if (data) {
            _mapHelper.mapPlugins.load(data, 2);

            _mapHelper.mapPlugins.updateGeomixerPlugins();
          }
        },
        collect: function collect() {
          return _mapHelper.mapPlugins.save(2);
        }
      }); //Третья версия информации о плагинах карты.
      //Формат: {plugins: [name1, ....], params: {name1: {param1: value1, ...}, ...}}

      nsGmx$1.userObjectsManager.addDataCollector('mapPlugins_v3', {
        load: function load(data) {
          if (data) {
            _mapHelper.mapPlugins.load(data, 3);

            _mapHelper.mapPlugins.updateGeomixerPlugins();
          }
        },
        collect: function collect() {
          return _mapHelper.mapPlugins.save(3);
        }
      });
    })(jQuery);

    (function () {
      window.nsGmx = window.nsGmx || {};
      window.nsGmx.widgets = window.nsGmx.widgets || {};
      nsGmx.widgets.notifications = {
        _container: null,
        _actions: [],
        _messagesToShow: [],
        _messageTimer: null,
        _currentStatusClass: '',
        startAction: function startAction(actionId) {
          this._initContainerLazy();

          if (this._actions.indexOf(actionId) === -1) {
            this._actions.push(actionId);

            this._container.find('.notification-process').show();
          }
        },
        //supported statuses: success, failure, warning
        stopAction: function stopAction(actionId, status, message, timeout) {
          var index = this._actions.indexOf(actionId);

          if (index !== -1) {
            this._actions.splice(index, 1);

            this._container.find('.notification-process').toggle(this._actions.length);
          }

          if (message) {
            timeout = typeof timeout !== 'undefined' ? timeout : 1500;

            this._messagesToShow.push({
              text: message,
              status: status,
              timeout: timeout
            });

            this._checkMessages();
          }
        },
        _checkMessages: function _checkMessages() {
          if (this._messageTimer || !this._messagesToShow.length) {
            return;
          }

          var msg = this._messagesToShow.shift();

          var statusClass = 'notification-' + msg.status;

          this._initContainerLazy();

          this._container.find('.notification-message').show().text(msg.text).removeClass(this._currentStatusClass).addClass(statusClass);

          if (msg.timeout) {
            this._messageTimer = setTimeout(function () {
              this._messageTimer = null;

              this._container.find('.notification-message').hide();

              this._checkMessages();
            }.bind(this), msg.timeout);
          }
        },
        _initContainerLazy: function _initContainerLazy() {
          if (this._container) {
            return;
          }

          this._container = $(Handlebars.compile('<div class="notification-container">' + '<span class="notification-process"></span>' + '<span class="notification-message"></span>' + '</div>')()).appendTo($('#flash'));

          this._container.find('.notification-message, .notification-process').hide();
        }
      };
    })();

    (function () {
      /**
      Хранит информацию о тегах: типы и описание
      @memberOf nsGmx
      @class
      @param {Object} initTagsInfo - описание тегов вида tagName: {Type: , Description: }
      */
      var TagMetaInfo = function TagMetaInfo(initTagsInfo) {
        var tags = initTagsInfo || {};

        this.isTag = function (tag) {
          return tag in tags;
        };

        this.getTagType = function (tag) {
          return tag in tags ? tags[tag].Type : null;
        };

        this.getTagDescription = function (tag) {
          return tag in tags ? tags[tag].Description : null;
        };

        this.getTagArray = function () {
          var res = [];

          for (var t in tags) {
            res.push(t);
          }

          return res;
        };

        this.getTagArrayExt = function () {
          var res = [];

          for (var t in tags) {
            res.push({
              name: t,
              type: tags[t].Type,
              desc: tags[t].Description
            });
          }

          return res;
        };
      };

      (function () {
        var def;
        /** Загружает данные о доступных тегах с сервера
        * @memberOf nsGmx.TagMetaInfo
        * @name loadFromServer
        * @function
        * @param {function(tagInfo)} [callback] Ф-ция, которая будет вызвана после загрузки информации о типах.
        * @return {jQuery.Deferred} Будет заресолвен после получения информации о типах
        */

        TagMetaInfo.loadFromServer = function (callback) {
          if (!def) {
            def = $.Deferred();
            sendCrossDomainJSONRequest$2(serverBase + 'Layer/MetaKeys.ashx', function (response) {
              if (!parseResponse(response)) {
                def.resolve();
                return;
              }

              def.resolve(new TagMetaInfo(response.Result));
            });
          }

          callback && def.done(callback);
          return def;
        };
      })();

      var extendClass = function extendClass(base, sub) {
        function ctor() {}

        ctor.prototype = base.prototype;
        sub.prototype = new ctor();
        sub.prototype.constructor = sub;
      };

      var LayerTags = function LayerTags(initTags) {
        /** Вызывается при изменении набора тегов слоя
            @name nsGmx.LayerTags.change
            @event
        */
        this._uniqueID = 1;
        this._tags = {};

        for (var tag in initTags) {
          var values = initTags[tag].Value;

          if (!$.isArray(values)) {
            values = [values];
          }

          for (var i = 0; i < values.length; i++) {
            this.addNewTag(tag, values[i]);
          }
        }
      };

      LayerTags.prototype = {
        _verificationFunctions: {
          'Number': function (_Number) {
            function Number(_x) {
              return _Number.apply(this, arguments);
            }

            Number.toString = function () {
              return _Number.toString();
            };

            return Number;
          }(function (value) {
            return value.length && !isNaN(Number(value));
          }),
          'String': function String(value) {
            return true;
          },
          'Date': function Date(value) {
            try {
              $.datepicker.parseDate('dd.mm.yy', value);
              return true;
            } catch (err) {
              return false;
            }
          }
        },
        _isValidTypeValue: function _isValidTypeValue(type, value) {
          return !(type in this._verificationFunctions) || this._verificationFunctions[type](value);
        },
        updateTag: function updateTag(id, tag, value, type) {
          var tags = this._tags;
          if (!(id in tags)) return false;

          if (tags[id].tag !== tag || tags[id].value !== value || tags[id].type !== type) {
            tags[id] = {
              tag: tag,
              value: value,
              type: type
            };
            $(this).change();
          }

          return true;
        },
        deleteTag: function deleteTag(id) {
          if (!(id in this._tags)) return;
          delete this._tags[id];
          $(this).change();
        },
        each: function each(callback) {
          var tags = this._tags;

          for (var tagId in tags) {
            callback(tagId, tags[tagId].tag, tags[tagId].value, tags[tagId].type);
          }
        },
        eachValid: function eachValid(callback, allowUnknownTags) {
          var tags = this._tags;

          for (var tagId in tags) {
            if ((allowUnknownTags || this.isValidValue(tagId)) && !this.isEmptyTag(tagId)) callback(tagId, tags[tagId].tag, tags[tagId].value, tags[tagId].type);
          }
        },
        addNewTag: function addNewTag(tag, value, type) {
          if (typeof value === 'undefined' || value === null) {
            value = '';
          }
          var newId = 'id' + ++this._uniqueID;
          this._tags[newId] = {
            tag: tag || '',
            value: value,
            type: type
          };
          $(this).change();
          return newId;
        },
        isTag: function isTag(tagId) {
          return tagId in this._tags;
        },
        isEmptyTag: function isEmptyTag(tagId) {
          var tags = this._tags;
          return tagId in tags && tags[tagId].tag === '' && tags[tagId].value === '';
        },
        isValidValue: function isValidValue(tagId) {
          var tags = this._tags;
          return tagId in tags && this._isValidTypeValue(tags[tagId].type, tags[tagId].value);
        },
        getTag: function getTag(tagId) {
          return this._tags[tagId];
        },
        getTagByName: function getTagByName(tagName) {
          var tags = this._tags;

          for (var tagId in tags) {
            if (tags[tagId].tag == tagName) return tags[tagId];
          }
        },
        getTagIdByName: function getTagIdByName(tagName) {
          var tags = this._tags;

          for (var tagId in tags) {
            if (tags[tagId].tag == tagName) return tagId;
          }
        }
        /**
            Набор тегов (метаданных) слоя из определённого набора тегов
            @memberOf nsGmx
            @class
            @param {nsGmx.TagMetaInfo} tagMetaInfo описание типов тегов
            @param {Object} initTags теги для инициализации. Формат: {tagName: {Value: tagValue}, ...}. tagValue может быть массивом
        */

      };

      var LayerTagsWithInfo = function LayerTagsWithInfo(tagMetaInfo, initTags) {
        // чтобы можно было расширять существующий объект LayerTags
        if (this instanceof LayerTagsWithInfo) {
          LayerTags.call(this, initTags);
        }

        this.getTagMetaInfo = function () {
          return tagMetaInfo;
        };

        this.isKnownTagname = function (tagname) {
          return tagMetaInfo.isTag(tagname);
        };

        this.addNewTag = function (tag, value, type) {
          type = type || tagMetaInfo.getTagType(tag) || '';
          LayerTags.prototype.addNewTag.call(this, tag, value, type);
        };

        this.updateTag = function (id, tag, value) {
          var type = tagMetaInfo.getTagType(tag);
          LayerTags.prototype.updateTag.call(this, id, tag, value, type);
        };
      };

      extendClass(LayerTags, LayerTagsWithInfo);
      /**
          Контрол для задания набора тегов (например, для слоя)
          @memberOf nsGmx
          @class
      */

      var LayerTagSearchControl = function LayerTagSearchControl(layerTags, container, params) {
        var _params = $.extend({
          inputWidth: 130,
          tagHeader: _gtxt('Параметр'),
          valueHeader: _gtxt('Значение')
        }, params);

        var mainTable = $('<table/>', {
          'class': 'layertags-table'
        }).appendTo(container);
        mainTable.append($('<tr/>').append($('<th/>').text(_params.tagHeader)).append($('<th/>').text(_params.valueHeader)).append($('<th/>'))); //добавляем к body элемент с id чтобы добавить к нему jQuery autocomplete и задать стили
        //к текущему виджету добавить нельзя, так как он ещё не добавлен в общее дерево, а виджет ac требует глобального селектора

        if ($('#layertagstable').length == 0) $('body').append($('<div id="layertagstable"></div>'));
        var rows = {}; //ссылки на контролы для каждого элемента

        var rowsVector = []; //в зависимости от типа ввода (type), прикрепляет к valueInput виджет выбора даты, время или даты/время

        var updateInput = function updateInput(valueInput, type) {
          if (type == 'Date') {
            $(valueInput).timepicker('destroy');
            $(valueInput).datetimepicker('destroy');
            $(valueInput).datepicker({
              onSelect: function onSelect(dateText, inst) {
                $(this).change();
              },
              changeMonth: true,
              changeYear: true,
              dateFormat: "dd.mm.yy"
            });
          } else if (type == 'DateTime') {
            $(valueInput).timepicker('destroy');
            $(valueInput).datepicker('destroy');
            $(valueInput).datetimepicker({
              changeMonth: true,
              changeYear: true,
              dateFormat: "dd.mm.yy",
              timeFormat: "HH:mm:ss",
              showSecond: true,
              timeOnly: false
            }).addClass('layertags-datetimeinput');
          } else if (type == "Time") {
            $(valueInput).datepicker('destroy');
            $(valueInput).datetimepicker('destroy');
            $(valueInput).timepicker({
              timeOnly: true,
              timeFormat: "HH:mm:ss",
              showSecond: true
            });
          } else {
            $(valueInput).timepicker('destroy');
            $(valueInput).datetimepicker('destroy');
            $(valueInput).datepicker('destroy');
          }
        };

        var validateRow = function validateRow(row) {
          if (!layerTags.isEmptyTag(row.id) && !layerTags.isKnownTagname(row.tag.val())) row.tag.addClass('error');else row.tag.removeClass('error');
          if (!layerTags.isEmptyTag(row.id) && !layerTags.isValidValue(row.id)) row.value.addClass('error');else row.value.removeClass('error');
        };

        var addNewRow = function addNewRow(tagId, tag, value) {
          var tagInput = $('<input/>', {
            'class': 'inputStyle'
          }).val(tag).css('width', _params.inputWidth).autocomplete({
            source: layerTags.getTagMetaInfo().getTagArrayExt(),
            minLength: 0,
            delay: 0,
            appendTo: "#layertagstable",
            select: function select(event, ui) {
              tagInput.val(ui.item.name);
              updateModel(ui.item.name, valueInput.val().trim());
              return false;
            }
          }).bind('click', function () {
            $(tagInput).autocomplete("search", "");
          });

          tagInput.data("ui-autocomplete")._renderItem = function (ul, item) {
            return $("<li/>").append($("<a/>", {
              title: item.desc
            }).text(item.name)).appendTo(ul);
          };

          var valueInput = $('<input/>', {
            'class': 'inputStyle'
          }).val(value).css('width', _params.inputWidth);
          var type = layerTags.getTagMetaInfo().getTagType(tag);
          updateInput(valueInput, type);

          var updateModel = function updateModel() {
            layerTags.updateTag(tagId, tagInput.val().trim(), valueInput.val().trim());
          };

          tagInput.bind('keyup change', updateModel);
          valueInput.bind('keyup change', updateModel);
          var deleteButton = makeImageButton$1('img/recycle.png', 'img/recycle_a.png');

          deleteButton.onclick = function () {
            layerTags.deleteTag(tagId);
          };

          var tr = $('<tr/>').append($('<td/>').append(tagInput)).append($('<td/>').append(valueInput)).append($('<td/>', {
            'class': 'layertags-delete'
          }).append(deleteButton));
          mainTable.append(tr);
          rows[tagId] = {
            id: tagId,
            tr: tr,
            tag: tagInput,
            value: valueInput,
            type: type
          };
          rowsVector.push(rows[tagId]);
          validateRow(rows[tagId]);
        };

        var moveEmptyLayersToBottom = function moveEmptyLayersToBottom() {
          var lastEmptyId = -1;

          for (var irow = 0; irow < rowsVector.length; irow++) {
            if (layerTags.isEmptyTag(rowsVector[irow].id)) lastEmptyId = irow;
          }

          if (lastEmptyId >= 0 && lastEmptyId < rowsVector.length) {
            var tr = rowsVector[lastEmptyId].tr;
            $(tr).detach();
            mainTable.append(tr);
          }
        };

        $(layerTags).change(function () {
          var isAnyEmpty = false;
          layerTags.each(function (tagId, tag, value) {
            if (tag == '' && value == '') isAnyEmpty = true;
            if (!(tagId in rows)) addNewRow(tagId, tag, value);else {
              if (rows[tagId].tag.val() !== tag) rows[tagId].tag.val(tag);
              if (rows[tagId].value.val() !== value) rows[tagId].value.val(value);
              var type = layerTags.getTagMetaInfo().getTagType(tag);

              if (rows[tagId].type !== type) {
                rows[tagId].type = type;
                updateInput(rows[tagId].value, type);
              }

              validateRow(rows[tagId]);
            }
          });

          for (var tagId in rows) {
            if (!layerTags.isTag(tagId)) {
              rows[tagId].tr.remove();
              delete rows[tagId];
            }
          }

          if (!isAnyEmpty) layerTags.addNewTag();
          moveEmptyLayersToBottom();
        });
        layerTags.addNewTag();
      };

      nsGmx$1.LayerTagSearchControl = LayerTagSearchControl;
      nsGmx$1.LayerTags = LayerTags;
      nsGmx$1.LayerTagsWithInfo = LayerTagsWithInfo;
      nsGmx$1.TagMetaInfo = TagMetaInfo;
    })();

    //Управление показом списка слоёв и поиска по этому списку

    (function (_) {
      var LayersListProvider = function LayersListProvider(filtersProvider) {
        var _this = this;

        $(filtersProvider).change(function () {
          $(_this).change();
        });

        var getQueryText = function getQueryText() {
          var filterStrings = [];
          if (filtersProvider.getTitle() !== '') filterStrings.push("([Title] containsIC '" + filtersProvider.getTitle() + "' or [Name] = GetLayerName('" + filtersProvider.getTitle() + "'))");
          if (filtersProvider.getOwner() !== '') filterStrings.push("[OwnerNickname] containsIC '" + filtersProvider.getOwner() + "'");
          var types = filtersProvider.getTypes();
          var typeFilters = $.map(types, function (type) {
            if (type === 'catalog') {
              return "([LayerType]=LayerTypeCode('vector') AND [IsRasterCatalog]=true)";
            } else if (type) {
              return "[LayerType]=LayerTypeCode('" + type + "')";
            }
          });
          if (typeFilters.length > 0) filterStrings.push('(' + typeFilters.join(' OR ') + ')');
          var dateBegin = filtersProvider.getDateBegin();
          var dateEnd = filtersProvider.getDateEnd();
          dateBegin && filterStrings.push("[DateCreate] >= '" + $.datepicker.formatDate('yy.mm.dd', dateBegin) + "'");
          dateEnd && filterStrings.push("[DateCreate] < '" + $.datepicker.formatDate('yy.mm.dd', dateEnd) + "'");
          var layerTags = filtersProvider.getTags();

          if (layerTags) {
            layerTags.each(function (id, tag, value) {
              if (tag) {
                if (value !== '') filterStrings.push("[" + tag + "] containsIC '" + value + "'");else filterStrings.push("PropertyExist('" + tag + "')");
              }
            });
          }

          return '&query=' + encodeURIComponent(filterStrings.join(' AND '));
        };

        this.getCount = function (callback) {
          var query = getQueryText();
          sendCrossDomainJSONRequest$2(serverBase + 'Layer/Search2.ashx?count=true' + query, function (response) {
            if (!parseResponse(response)) {
              callback();
              return;
            }

            callback(response.Result.count);
          });
        };

        this.getItems = function (page, pageSize, sortParam, sortDec, callback) {
          this.getCountAndItems(page, pageSize, sortParam, sortDec, function (count, items) {
            callback(items);
          });
        };

        this.getCountAndItems = function (page, pageSize, sortParam, sortDec, callback) {
          var sortParams = {};
          sortParams[_gtxt("Имя")] = "title";
          sortParams[_gtxt("Дата создания")] = "datecreate";
          sortParams[_gtxt("Владелец")] = "ownernickname";
          var query = getQueryText();
          sendCrossDomainJSONRequest$2(serverBase + 'Layer/Search2.ashx?page=' + page + '&pageSize=' + pageSize + "&orderby=" + sortParams[sortParam] + " " + (sortDec ? "desc" : "") + query, function (response) {
            if (!parseResponse(response)) {
              callback();
              return;
            }

            callback(response.Result.count, response.Result.layers);
          });
        };
      };

      var drawLayers = function drawLayers(layer, params) {
        var _params = $.extend({
          onclick: function onclick() {
            removeLayerFromList();
          },
          enableDragging: true,
          disabled: false
        }, params);

        var newLayerProperties = {
          properties: layer
        };

        var mapProperties = _layersTree.treeModel.getMapProperties();

        newLayerProperties.properties.mapName = mapProperties.name;
        newLayerProperties.properties.hostName = mapProperties.hostName;
        newLayerProperties.properties.visible = false; // newLayerProperties.properties.type = newLayerProperties.properties.type === 1 ? 'Vector' : 'Raster';

        if (newLayerProperties.properties.type == 'Vector') newLayerProperties.properties.styles = [{
          MinZoom: 1,
          MaxZoom: 20,
          RenderStyle: _mapHelper.defaultStyles[newLayerProperties.properties.GeometryType]
        }];else if (newLayerProperties.properties.type != 'Vector' && !newLayerProperties.properties.MultiLayerID) newLayerProperties.properties.styles = [{
          MinZoom: newLayerProperties.properties.MinZoom,
          MaxZoom: 20
        }];

        var res = _layersTree.drawNode({
          type: 'layer',
          content: newLayerProperties
        }, false, 1),
            icon = res.firstChild.cloneNode(true),
            remove = makeImageButton$1("img/recycle.png", "img/recycle_a.png"),
            tr,
            tdRemove = layer.Access == 'edit' ? _td$1([remove], [['css', 'textAlign', 'center']]) : _td$1(),
            removeLayerFromList = function removeLayerFromList() {
          var active = $(_queryMapLayers.buildedTree).find(".active");
          var gmxProperties = $(res).find("span[dragg]")[0].parentNode.parentNode.gmxProperties;

          if (active.length && (active[0].parentNode.getAttribute('MapID') || active[0].parentNode.getAttribute('GroupID'))) {
            _layersTree.copyHandler(gmxProperties, active[0].parentNode, false, true);
          } else {
            _layersTree.copyHandler(gmxProperties, $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0], false, true);
          }

          $(res).addClass('gmx-disabled');
        },
            _this = this;

        _title$1(remove, _gtxt("Удалить"));

        res.firstChild.removeNode(true);

        remove.onclick = function () {
          if (confirm(_gtxt("Вы действительно хотите удалить этот слой?"))) {
            var loading = loading = _div$1([_img$1(null, [['attr', 'src', 'img/progress.gif']]), _t$1('удаление...')], [['css', 'marginLeft', '5px']]);

            $(remove.parentNode.parentNode).replaceWith(_tr$1([_td$1([loading], [['attr', 'colSpan', 5]])]));

            var deleteLayerHandler = function deleteLayerHandler(response, id, flag) {
              if (!parseResponse(response)) return;
              if (response.Result == 'deleted') $(_this.getDataProvider()).change();else showErrorMessage(_gtxt("Ошибка!"), true, _gtxt("Слоя нет в базе"));
            };

            if (newLayerProperties.properties.MultiLayerID) sendCrossDomainJSONRequest$2(serverBase + "MultiLayer/Delete.ashx?WrapStyle=func&MultiLayerID=" + newLayerProperties.properties.MultiLayerID, deleteLayerHandler);else sendCrossDomainJSONRequest$2(serverBase + "Layer/Delete.ashx?WrapStyle=func&LayerID=" + newLayerProperties.properties.LayerID, deleteLayerHandler);
          }
        };

        var span = $(res).find("span.layer")[0];
        if (_params.disabled) $(span).addClass('invisible');

        if (!_params.disabled && _params.onclick) {
          span.onclick = function () {
            _params.onclick({
              elem: layer,
              scrollTable: _this
            });
          };
        } else {
          span.onclick = null;
          $(span).css('cursor', 'auto');
        }

        span.ondblclick = null;

        if (_params.enableDragging && !params.disabled) {
          $(res).find("span[dragg]").draggable({
            helper: function helper(ev) {
              return _layersTree.dummyNode(ev.target);
            },
            cursorAt: {
              left: 5,
              top: 10
            },
            cursor: 'move',
            delay: 200,
            appendTo: document.body
          });
        }

        var nameDivInternal = _div$1([res], [['css', 'position', 'absolute'], ['css', 'width', '100%'], ['css', 'padding', "1px 0px"], ['css', 'overflowX', 'hidden'], ['css', 'whiteSpace', 'nowrap']]);

        var nameDiv = _div$1([nameDivInternal], [['css', 'position', 'relative'], ['css', 'height', '100%']]);

        tr = _tr$1([_td$1(), _td$1([icon], [['css', 'textAlign', 'center']]), _td$1([nameDiv]), _td$1([_t$1(layer.date)], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']]), _td$1([_t$1(layer.Owner)], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']]), tdRemove]);

        for (var i = 0; i < tr.childNodes.length; i++) {
          tr.childNodes[i].style.width = this._fields[i].width;
        }

        attachEffects(tr, 'hover');
        return tr;
      };
      /** Внутри контейнера помещает табличку со списком слоёв и контролами для фильтрации
      * @param {HTMLNode} parentDiv Куда помещать контрол
      * @param {String} name Уникальное имя этого инстанса
      * @param {object} params Параметры отображения списка:
      *
      *  * fixType {String | Vector} Какой тип слоёв показывать. 'vector', 'raster', 'multilayer', 'catalog' или ''. Если '', то добавится контрол с выбором типа слоя. Вектор
      *  * enableDragging {Boolean}
      *  * height {Integer} высота всего виджета. Если не указана, то будет применяться дефолтная высота (~460px)
      *  * onclick {function({ elem: , scrollTable: })}
      */


      var LayerManagerControl = function LayerManagerControl(parentDiv, name, params) {
        var _params = $.extend({
          fixType: [],
          height: ''
        }, params);

        if (typeof _params.fixType === 'string') _params.fixType = [_params.fixType];

        var canvas = _div$1(null, [['attr', 'id', 'layersList']]),
            searchCanvas = _div$1(null, [['dir', 'className', 'layersSearchCanvas']]);

        var layerName = _input$1(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '185px']]),
            layerOwner = _input$1(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '185px']]);

        var typeSel = nsGmx$1.Utils._select([_option$1([_t$1(_gtxt("Любой"))], [['attr', 'value', '']]), _option$1([_t$1(_gtxt("Векторный"))], [['attr', 'value', 'vector']]), _option$1([_t$1(_gtxt("Растровый"))], [['attr', 'value', 'raster']]), _option$1([_t$1(_gtxt("Мультислой"))], [['attr', 'value', 'multilayer']]), _option$1([_t$1(_gtxt("Каталог растров"))], [['attr', 'value', 'catalog']])], [['dir', 'className', 'selectStyle'], ['css', 'width', '100px']]);

        var calendar = new nsGmx$1.CalendarWidget({
          minimized: false,
          showSwitcher: false,
          dateInterval: new nsGmx$1.DateInterval({
            dateBegin: null,
            dateEnd: null
          })
        }); // calendar.init('layerManager', {
        // minimized: false,
        // showSwitcher: false,
        // dateBegin: null,
        // dateEnd: null
        // });

        var _disabledLayers = {};

        _(searchCanvas, [_div$1([_table$1([_tbody$1([_tr$1([_td$1([_span$1([_t$1(_gtxt("Название"))], [['css', 'fontSize', '12px']])]), _td$1([layerName])]), _tr$1([_td$1([_span$1([_t$1(_gtxt("Владелец"))], [['css', 'fontSize', '12px']])]), _td$1([layerOwner])]), _tr$1([_td$1([_span$1([_t$1(_gtxt("Период"))], [['css', 'fontSize', '12px']])]), _td$1([calendar.canvas[0]])]), _tr$1([_td$1([_span$1([_t$1(_gtxt("Тип"))], [['css', 'fontSize', '12px']])]), _td$1([typeSel])])])])], [['css', 'marginBottom', '10px']])]);

        $.each(_params.fixType, function (i, type) {
          if (type !== '') $("tr:last", searchCanvas).hide();
        });

        var tableParent = _div$1();

        var sortColumns = {};
        sortColumns[_gtxt('Имя')] = true;
        sortColumns[_gtxt('Владелец')] = true;
        sortColumns[_gtxt('Дата создания')] = true; // Временно сервер не поддерживает сортировку по типу
        // if (_params.fixType.length > 1 || _params.fixType[0] === '')
        // sortColumns[_gtxt('Тип')] = true;

        var tagsParent = _div$1(null, [['css', 'height', '100px'], ['css', 'overflow', 'auto']]);

        _(canvas, [_table$1([_tbody$1([_tr$1([_td$1([searchCanvas], [['css', 'width', '50%']]), _td$1([tagsParent])])])], [['css', 'width', '100%']])]);

        var LayersFilterParams = function () {
          var prevLayerName, prevLayerOwner;

          layerName.oninput = layerName.onkeyup = function () {
            if (this.value !== prevLayerName) {
              prevLayerName = this.value;
              $(pi).change();
            }
          };

          layerOwner.oninput = layerOwner.onkeyup = function () {
            if (this.value !== prevLayerOwner) {
              prevLayerOwner = this.value;
              $(pi).change();
            }
          };

          typeSel.onchange = function () {
            $(pi).change();
          };

          calendar.getDateInterval().on('change', function () {
            $(pi).change();
          });
          var _layerTags = null;
          var pi = {
            setTags: function setTags(layerTags) {
              _layerTags = layerTags;
              $(_layerTags).change(function () {
                $(pi).change();
              });
            },
            getTitle: function getTitle() {
              return layerName.value;
            },
            getOwner: function getOwner() {
              return layerOwner.value;
            },
            getDateBegin: function getDateBegin() {
              return calendar.getDateInterval().get('dateBegin');
            },
            getDateEnd: function getDateEnd() {
              return calendar.getDateInterval().get('dateEnd');
            },
            getTags: function getTags() {
              return _layerTags;
            },
            getTypes: function getTypes() {
              return _params.fixType.length > 0 ? _params.fixType : [$("option:selected", typeSel).val()];
            }
          };
          return pi;
        }();

        nsGmx$1.TagMetaInfo.loadFromServer(function (tagsInfo) {
          var layerTags = new nsGmx$1.LayerTagsWithInfo(tagsInfo);
          new nsGmx$1.LayerTagSearchControl(layerTags, tagsParent, {
            inputWidth: 115
          });
          LayersFilterParams.setTags(layerTags);
        });
        var layersListProvider = new LayersListProvider(LayersFilterParams);
        var layersTable = new nsGmx$1.ScrollTable({
          height: _params.height ? _params.height - 130 : ''
        });
        layersTable.setDataProvider(layersListProvider);
        layersTable.createTable(tableParent, name, 0, ["", _gtxt("Тип"), _gtxt("Имя"), _gtxt("Дата создания"), _gtxt("Владелец"), ""], ['1%', '5%', '45%', '24%', '20%', '5%'], function (layer) {
          var curParams = $.extend({}, _params, {
            disabled: layer.name in _disabledLayers
          });
          return drawLayers.apply(this, [layer, curParams]);
        }, sortColumns);

        _(canvas, [tableParent]);

        $(parentDiv).empty().append(canvas);
        layerName.focus();

        this.getScrollTable = function () {
          return layersTable;
        };
        /** Деактивировать слои
          @param layerNames {String|String[]} - массив имён слоёв (или просто имя), которые нужно сделать неактивными
        */


        this.disableLayers = function (layerNames) {
          if (!$.isArray(layerNames)) layerNames = [layerNames];

          for (var k = 0; k < layerNames.length; k++) {
            _disabledLayers[layerNames[k]] = true;
          }

          layersTable.repaint();
        };
        /** Aктивировать слои
          @param layerNames {String|String[]} - массив имён слоёв (или просто имя), которые нужно сделать активными
        */


        this.enableLayers = function (layerNames) {
          if (!$.isArray(layerNames)) layerNames = [layerNames];

          for (var k = 0; k < layerNames.length; k++) {
            delete _disabledLayers[layerNames[k]];
          }

          layersTable.repaint();
        };

        this.resize = function (h) {
          layersTable.updateHeight(h - 130);
        };
      };

      nsGmx$1.LayerManagerControl = LayerManagerControl;
      nsGmx$1.drawLayers = drawLayers;
      gmxCore.addModule('LayersManagerControl', {
        LayerManagerControl: LayerManagerControl,
        drawLayers: drawLayers
      });
    })(nsGmx$1.Utils._);

    !function (_) {
      var mapLayers = {
        mapLayers: {}
      };
      window.mapLayers = mapLayers;

      var AbstractTree = function AbstractTree() {};

      AbstractTree.prototype.makeSwapChild = function () {
        var div = _div$1(null, [['attr', 'swap', true], ['dir', 'className', 'swap'], ['css', 'fontSize', '0px']]);

        return div;
      };

      AbstractTree.prototype.getChildsUl = function (node) {
        var ul = $(node).children("ul");
        if (ul.length > 0) return ul[0];else return false;
      };

      AbstractTree.prototype.toggle = function (box) {
        box.onclick = function () {
          $(this.parentNode).find(">.hitarea").swapClass('collapsable-hitarea', 'expandable-hitarea').swapClass('lastCollapsable-hitarea', 'lastExpandable-hitarea').end().swapClass('collapsable', 'expandable').swapClass('lastCollapsable', 'lastExpandable');
          if ($(this.parentNode).hasClass('expandable') || $(this.parentNode).hasClass('lastExpandable')) hide(_abstractTree.getChildsUl(this.parentNode));else show(_abstractTree.getChildsUl(this.parentNode));
        };
      };

      AbstractTree.prototype.addNode = function (node, newNodeCanvas) {
        var childsUl = _abstractTree.getChildsUl(node);

        if (childsUl) childsUl.insertBefore(newNodeCanvas, childsUl.firstChild);else {
          // если первый потомок
          var newSubTree = _ul$1([newNodeCanvas]); //_(node, [newSubTree, this.makeSwapChild()]);


          node.insertBefore(newSubTree, node.lastChild);
          newSubTree.loaded = true;

          var div = _div$1(null, [['dir', 'className', 'hitarea']]);

          if ($(node).hasClass("last")) {
            $(div).addClass('lastCollapsable-hitarea collapsable-hitarea');
            $(node).addClass('lastCollapsable');
          } else {
            $(div).addClass('collapsable-hitarea');
            $(node).addClass('collapsable');
          }

          this.toggle(div);
          node.insertBefore(div, node.firstChild);

          _layersTree.addExpandedEvents(node);

          if ($(newNodeCanvas).hasClass('collapsable')) {
            $(newNodeCanvas).addClass('lastCollapsable');
            $(newNodeCanvas).children('div.hitarea').addClass('lastCollapsable-hitarea');
          }

          if ($(newNodeCanvas).hasClass('expandable')) {
            $(newNodeCanvas).addClass('lastExpandable');
            $(newNodeCanvas).children('div.hitarea').addClass('lastExpandable-hitarea');
          }

          if (!$(newNodeCanvas).hasClass('lastCollapsable') && !$(newNodeCanvas).hasClass('lastExpandable')) $(newNodeCanvas).addClass('last');
        }
        $(_abstractTree.getChildsUl(node)).children(":not(li:last)").each(function () {
          $(this).removeClass('last').replaceClass('lastCollapsable', 'collapsable').replaceClass('lastExpandable', 'expandable');
          $(this).children('div.lastCollapsable-hitarea').replaceClass('lastCollapsable-hitarea', 'collapsable-hitarea');
          $(this).children('div.lastExpandable-hitarea').replaceClass('lastExpandable-hitarea', 'expandable-hitarea');
        });
      };

      AbstractTree.prototype.delNode = function (node, parentTree, parent) {
        if (parentTree.childNodes.length == 0) {
          // потомков не осталось, удалим контейнеры
          parentTree.removeNode(true);
          parent.firstChild.removeNode(true); // изменим дерево родителя

          $(parent).removeClass("collapsable");
          $(parent).replaceClass("lastCollapsable", "last");
        } else {
          // изменим дерево родителя
          if ($(parentTree).children("li:last").hasClass("collapsable")) {
            $(parentTree).children("li:last").addClass("lastCollapsable");
            $(parentTree).children("li:last").each(function () {
              $(this.firstChild).addClass("lastCollapsable-hitarea");
            });
          } else $(parentTree).children("li:last").addClass("last");
        }
      };

      AbstractTree.prototype.swapNode = function (node, newNodeCanvas) {
        $(node).after(newNodeCanvas);
        $(node.parentNode).children(":not(li:last)").each(function () {
          $(this).removeClass('last').replaceClass('lastCollapsable', 'collapsable').replaceClass('lastExpandable', 'expandable');
          $(this).children('div.lastCollapsable-hitarea').replaceClass('lastCollapsable-hitarea', 'collapsable-hitarea');
          $(this).children('div.lastExpandable-hitarea').replaceClass('lastExpandable-hitarea', 'expandable-hitarea');
        }); // изменим дерево родителя

        if ($(node.parentNode).children("li:last").hasClass("collapsable")) {
          $(node.parentNode).children("li:last").addClass("lastCollapsable");
          $(node.parentNode).children("li:last").each(function () {
            $(this.firstChild).addClass("lastCollapsable-hitarea");
          });
        } else if ($(node.parentNode).children("li:last").hasClass("expandable")) {
          $(node.parentNode).children("li:last").addClass("lastExpandable");
          $(node.parentNode).children("li:last").each(function () {
            $(this.firstChild).addClass("lastExpandable-hitarea");
          });
        } else $(node.parentNode).children("li:last").addClass("last");
      };

      var _abstractTree = new AbstractTree();

      window._abstractTree = _abstractTree; //renderParams:
      //  * showVisibilityCheckbox {Bool} - показывать или нет checkbox видимости
      //  * allowActive {Bool} - возможен ли в дереве активный элемент
      //  * allowDblClick {Bool} - переходить ли по двойному клику к видимому экстенту слоя/группы
      //  * showStyle {Bool} - показывать ли иконку стилей
      //  * visibilityFunc {function(layerProps, isVisible)} - ф-ция, которая будет выполнена при изменении видимости слоя.
      //    По умолчанию устанавливает видимость соответствующего слоя в API
      //
      //события:
      //  * layerVisibilityChange - при изменении видимости слоя (параметр - элемент дерева с изменившимся слоем)
      //  * addTreeElem - добавили новый элемент дерева (параметр - новый элемент)
      //  * activeNodeChange - изменили активную ноду дерева (парамер - div активной ноды)
      //  * styleVisibilityChange - при изменении видимости стиля слоя

      var layersTree = function layersTree(renderParams) {
        this._renderParams = $.extend({
          showVisibilityCheckbox: true,
          allowActive: true,
          allowDblClick: true,
          showStyle: true,
          visibilityFunc: function visibilityFunc(props, isVisible) {
            if (props.name in nsGmx$1.gmxMap.layersByID) {
              nsGmx$1.leafletMap[isVisible ? 'addLayer' : 'removeLayer'](nsGmx$1.gmxMap.layersByID[props.name]);
            }
          }
        }, renderParams); // тип узла

        this.type = null; // содержимое узла

        this.content = null;
        this.condition = {
          visible: {},
          expanded: {}
        };
        this.mapStyles = {};
        this.groupLoadingFuncs = [];
        this._treeCanvas = null; //контейнер отрисованного дерева слоёв

        this._layerViewHooks = [];
      };

      layersTree.prototype.addLayerViewHook = function (hook) {
        hook && this._layerViewHooks.push(hook);
      };

      layersTree.prototype._applyLayerViewHooks = function (div, layerProps) {
        this._layerViewHooks.forEach(function (hook) {
          hook(div, layerProps);
        });
      }; // layerManagerFlag == 0 для дерева слева
      // layerManagerFlag == 1 для списка слоев
      // layerManagerFlag == 2 для списка карт


      layersTree.prototype.drawTree = function (tree, layerManagerFlag) {
        var permalinkParams = this.LayersTreePermalinkParams;

        if (permalinkParams) {
          var tempTree = new nsGmx$1.LayersTree(tree);
          tempTree.forEachNode(function (elem) {
            var props = elem.content.properties,
                id = elem.type == 'group' ? props.GroupID : props.LayerID;

            if (id in permalinkParams) {
              props.permalinkParams = permalinkParams[id];
            }
          });
          tree = tempTree.getRawTree();
        }

        this._treeCanvas = _ul$1([this.getChildsList(tree, false, layerManagerFlag, true)], [['dir', 'className', 'filetree']]);
        this.treeModel = new nsGmx$1.LayersTree(tree);
        this._mapTree = tree; //Устарело: используйте this.treeModel для доступа к исходному дереву

        this.treeModel.forEachLayer(function (layerContent, isVisible) {
          layerContent.properties.initVisible = layerContent.properties.visible;
        });

        var _this = this;

        $(this.treeModel).on('nodeVisibilityChange', function (event, elem) {
          var props = elem.content.properties;

          _this.updateVisibilityUI(elem);

          props.changedByViewer = true;

          if (elem.type === 'layer') {
            _this._renderParams.visibilityFunc(props, props.visible);

            $(_this).triggerHandler('layerVisibilityChange', [elem]);
          }
        });
        nsGmx$1.leafletMap.on('layeradd layerremove', function (event) {
          if (event.layer.getGmxProperties) {
            var name = event.layer.getGmxProperties().name; //добавился именно слой из основной карты, а не просто с таким же ID

            if (event.layer === nsGmx$1.gmxMap.layersByID[name]) {
              var searchRes = _this.treeModel.findElem('name', name);

              if (searchRes && (!layerManagerFlag || layerManagerFlag == 0)) {
                _this.treeModel.setNodeVisibility(searchRes.elem, nsGmx$1.leafletMap.hasLayer(event.layer));
              }
            }
          }
        });
        return this._treeCanvas;
      };

      layersTree.prototype.getChildsList = function (elem, parentParams, layerManagerFlag, parentVisibility) {
        // добавляем новый узел
        var li = _li$1();

        _(li, [this.drawNode(elem, parentParams, layerManagerFlag, parentVisibility)]);

        if (elem.content && elem.content.children && elem.content.children.length > 0) {
          var childsUl = _ul$1(); // initExpand - временное свойство, сохраняющее начальное состояние развёрнутости группы.
          // В expanded будет храниться только текущее состояние (не сохраняется)


          if (typeof elem.content.properties.initExpand == 'undefined') elem.content.properties.initExpand = elem.content.properties.expanded;

          if (!elem.content.properties.expanded) {
            childsUl.style.display = 'none';
            childsUl.className = 'hiddenTree';

            if (!layerManagerFlag) {
              childsUl.loaded = false;
              this.addLoadingFunc(childsUl, elem, parentParams, layerManagerFlag);
            } else {
              childsUl.loaded = true;
              var childs = [];

              for (var i = 0; i < elem.content.children.length; i++) {
                childs.push(this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, true));
              }

              _(childsUl, childs);
            }
          } else {
            childsUl.loaded = true;
            var childs = [];

            for (var i = 0; i < elem.content.children.length; i++) {
              childs.push(this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, parentVisibility && elem.content.properties.visible));
            }

            _(childsUl, childs);
          }

          _(li, [childsUl, _abstractTree.makeSwapChild()]);
        } else if (elem.children) {
          if (elem.children.length > 0) {
            var childs = [];

            for (var i = 0; i < elem.children.length; i++) {
              childs.push(this.getChildsList(elem.children[i], elem.properties, layerManagerFlag, true));
            }

            var childsUl = _ul$1(childs);

            childsUl.loaded = true;

            _(li, [childsUl]);
          }

          _(li, [_div$1()]);

          li.root = true;
        } else _(li, [_abstractTree.makeSwapChild()]); // видимость слоя в дереве


        if (!nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN) && elem.type && elem.type == 'layer' && typeof invisibleLayers != 'undefined' && invisibleLayers[elem.content.properties.name]) li.style.display = 'none';
        return li;
      };

      layersTree.prototype.addLoadingFunc = function (parentCanvas, elem, parentParams, layerManagerFlag) {
        var func = function func() {
          $(parentCanvas.parentNode.firstChild).bind('click', function () {
            if (!parentCanvas.loaded) {
              parentCanvas.loaded = true;
              var childs = [],
                  grId = $(parentCanvas.parentNode).children("div[GroupID]");

              for (var i = 0; i < elem.content.children.length; i++) {
                childs.push(_this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, _this.getLayerVisibility($(grId).find('input[type="checkbox"]')[0] || $(grId).find('input[type="radio"]')[0])));
              }

              _(parentCanvas, childs);

              if (_queryMapLayers.currentMapRights() == "edit") {
                _queryMapLayers.addDraggable(parentCanvas);

                if (!layerManagerFlag) {
                  _queryMapLayers.addDroppable(parentCanvas);

                  _queryMapLayers.addSwappable(parentCanvas);
                }
              }

              $(parentCanvas).treeview();

              _layersTree.addExpandedEvents(parentCanvas);

              _this.runLoadingFuncs();

              _queryMapLayers.applyState(_this.condition, _this.mapStyles, $(parentCanvas.parentNode).children("div[GroupID]")[0]);
            }
          });
        },
            _this = this;

        this.groupLoadingFuncs.push(func);
      };

      layersTree.prototype.runLoadingFuncs = function () {
        for (var i = 0; i < this.groupLoadingFuncs.length; i++) {
          this.groupLoadingFuncs[i]();
        }

        this.groupLoadingFuncs = [];
      };

      layersTree.prototype.addExpandedEvents = function (parent) {
        var _this = this;

        $(parent).find("div.hitarea").each(function () {
          if (!this.clickFunc) {
            this.clickFunc = true;
            var divClick = this;
            if (divClick.parentNode.parentNode.parentNode.getAttribute("multiStyle")) return;
            $(divClick).bind('click', function () {
              var div = $(divClick.parentNode).children("div[MapID],div[GroupID],div[LayerID],div[MultiLayerID]")[0],
                  treeElem = _this.findTreeElem(div);

              if (!treeElem.parents.length) return;
              var flag = $(divClick).hasClass("expandable-hitarea");
              treeElem.elem.content.properties.expanded = !flag;
            });
          }
        });
      };

      layersTree.prototype.drawNode = function (elem, parentParams, layerManagerFlag, parentVisibility) {
        var div;

        if (elem.type == "layer") {
          // var elemProperties = !layerManagerFlag ? nsGmx.gmxMap.layersByID[elem.content.properties.name].getGmxProperties(): elem.content.properties;
          var elemProperties;

          if (nsGmx$1.gmxMap.layersByID[elem.content.properties.name]) {
            elemProperties = !layerManagerFlag ? nsGmx$1.gmxMap.layersByID[elem.content.properties.name].getGmxProperties() : elem.content.properties;
          } else {
            elemProperties = elem.content.properties;
          }

          var childs = this.drawLayer(elemProperties, parentParams, layerManagerFlag, parentVisibility);
          if (typeof elem.content.properties.LayerID != 'undefined') div = _div$1(childs, [['attr', 'LayerID', elem.content.properties.LayerID]]);else if (typeof elem.content.properties.MultiLayerID != 'undefined') div = _div$1(childs, [['attr', 'MultiLayerID', elem.content.properties.MultiLayerID]]);else div = _div$1(childs, [['attr', 'LayerID', elem.content.properties.name]]);
          div.gmxProperties = elem;
          div.gmxProperties.content.properties = elemProperties;

          this._applyLayerViewHooks(div, elemProperties);
        } else {
          if (elem.properties && elem.properties.MapID) div = _div$1(this.drawHeaderGroupLayer(elem.properties, parentParams, layerManagerFlag), [['attr', 'MapID', elem.properties.MapID]]);else div = _div$1(this.drawGroupLayer(elem.content.properties, parentParams, layerManagerFlag, parentVisibility), [['attr', 'GroupID', elem.content.properties.GroupID]]);
          div.gmxProperties = elem;
        }

        div.oncontextmenu = function (e) {
          return false;
        };

        return div;
      };

      layersTree.prototype.setActive = function (span) {
        $(this._treeCanvas).find(".active").removeClass("active");

        if (span) {
          $(span.parentNode).addClass("active");
          $(this).triggerHandler("activeNodeChange", [span.parentNode.parentNode]);
        } else {
          $(this).triggerHandler("activeNodeChange", [null]);
        }
      };

      layersTree.prototype.getActive = function () {
        var activeDiv = $(this._treeCanvas).find(".active");
        return activeDiv[0] ? activeDiv[0].parentNode : null;
      };

      layersTree.prototype.getMinLayerZoom = function (layer) {
        if (!layer.getStyles) {
          return 1;
        }

        var minLayerZoom = 20,
            styles = layer.getStyles();

        for (var i = 0; i < styles.length; i++) {
          minLayerZoom = Math.min(minLayerZoom, styles[i].MinZoom);
        }

        return minLayerZoom;
      };

      layersTree.prototype.layerZoomToExtent = function (bounds, minZoom) {
        if (!bounds) return;
        var lmap = nsGmx$1.leafletMap; // var z = lmap.getBoundsZoom(bounds);
        // if (minZoom !== 20) {
        // z = Math.max(z, minZoom);
        // }
        // z = Math.min(lmap.getMaxZoom(), Math.max(lmap.getMinZoom(), z));

        var currentZoom = lmap.getZoom();
        var doubleClickZoom = lmap.getBoundsZoom(bounds);
        var z = Math.min(Math.max(15, currentZoom), doubleClickZoom); //анимация приводит к проблемам из-за бага https://github.com/Leaflet/Leaflet/issues/3249
        //а указать явно zoom в fitBounds нельзя
        //TODO: enable animation!

        lmap.fitBounds(bounds, {
          animation: false,
          maxZoom: z
        }); //если вызывать setZoom всегда, карта начнёт глючить (бага Leaflet?)
        // if (z !== lmap.getZoom()) {
        //     lmap.setZoom(z);
        // }
      };

      layersTree.prototype.drawLayer = function (elem, parentParams, layerManagerFlag, parentVisibility) {
        var box,
            _this = this;

        if (this._renderParams.showVisibilityCheckbox) {
          box = _checkbox$1(elem.visible, parentParams.list ? 'radio' : 'checkbox', parentParams.GroupID || parentParams.MapID);
          box.className = 'box layers-visibility-checkbox';
          box.setAttribute('box', 'layer');

          box.onclick = function () {
            _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
          };
        }

        var span = _span$1([_t(elem.title)], [['dir', 'className', 'layer'], ['attr', 'dragg', true]]);

        var timer = null,
            clickFunc = function clickFunc() {
          var treeNode = _this.findTreeElem(span.parentNode.parentNode).elem;

          $(treeNode).triggerHandler('click', [treeNode]);
          if (_this._renderParams.allowActive) _this.setActive(span);

          if (_this._renderParams.showVisibilityCheckbox) {
            _this.treeModel.setNodeVisibility(treeNode, true);
          }
        },
            dbclickFunc = function dbclickFunc() {
          var treeNode = _this.findTreeElem(span.parentNode.parentNode).elem;

          var layer = nsGmx$1.gmxMap.layersByID[elem.name];
          $(treeNode).triggerHandler('dblclick', [treeNode]);

          if (treeNode.content.geometry && layer && layer.getBounds) {
            var minLayerZoom = _this.getMinLayerZoom(layer);

            _this.layerZoomToExtent(layer.getBounds(), minLayerZoom);
          }
        };

        span.onclick = function () {
          if (timer) clearTimeout(timer);
          timer = setTimeout(clickFunc, 200);
        };

        if (this._renderParams.allowDblClick) {
          span.ondblclick = function () {
            if (timer) clearTimeout(timer);
            timer = null;
            clickFunc();
            dbclickFunc();
          };
        }

        disableSelection(span);

        var spanParent = _div$1([span], [['attr', 'titleDiv', true], ['css', 'display', 'inline'], ['css', 'position', 'relative'], ['css', 'borderBottom', 'none'], ['css', 'paddingRight', '3px']]),
            spanDescr = _span$1(null, [['dir', 'className', 'layerDescription']]);

        spanDescr.innerHTML = elem.description ? elem.description : '';

        if (layerManagerFlag == 1) {
          var imgIconSrc = elem.type == "Vector" ? 'img/vector.png' : typeof elem.MultiLayerID != 'undefined' ? 'img/multi.png' : 'img/rastr.png';
          if (elem.type == "Alias") imgIconSrc = 'img/shortcut.png';
          return [_img(null, [['attr', 'src', imgIconSrc], ['css', 'marginLeft', '3px']]), spanParent, spanDescr];
        }

        if (this._renderParams.showVisibilityCheckbox && !elem.visible) {
          $(spanParent).addClass("invisible");
        }

        nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'Layer', function () {
          return true;
        }, {
          layerManagerFlag: layerManagerFlag,
          elem: elem,
          tree: this
        });

        var borderDescr = _span$1();

        var count = 0;
        var metaProps = {};

        if (elem.MetaProperties) {
          for (var key in elem.MetaProperties) {
            var tagtype = elem.MetaProperties[key].Type;
            metaProps[key] = nsGmx$1.Utils.convertFromServer(tagtype, elem.MetaProperties[key].Value);
            count++;
          }
        }

        if (count || elem.Legend) {
          _(borderDescr, [_t('i')], [['dir', 'className', 'layerInfoButton']]);

          borderDescr.onclick = function () {
            nsGmx$1.Controls.showLayerInfo({
              properties: elem
            }, {
              properties: metaProps
            });
          };
        }

        if (elem.type == "Vector") {
          var styles;

          if (window.newStyles) {
            if (elem.styles && !elem.gmxStyles) {
              elem.gmxStyles = L.gmx.StyleManager.decodeOldStyles(elem);
            }

            styles = elem.gmxStyles.styles;
          } else {
            styles = elem.styles;
          }

          var icon = _mapHelper.createStylesEditorIcon(styles, elem.GeometryType ? elem.GeometryType.toLowerCase() : 'polygon', {
            addTitle: !layerManagerFlag
          }),
              multiStyleParent = _div$1(null, [['attr', 'multiStyle', true]]),
              timelineIcon,
              iconSpan = _span$1([icon]);

          if (styles.length === 1 && elem.name in nsGmx$1.gmxMap.layersByID) {
            var layer = nsGmx$1.gmxMap.layersByID[elem.name];
            layer.on('stylechange', function () {
              if (layer.getStyles().length === 1) {
                var style = L.gmxUtil.toServerStyle(layer.getStyles()[0].RenderStyle);

                var newIcon = _mapHelper.createStylesEditorIcon([{
                  MinZoom: 1,
                  MaxZoom: 21,
                  RenderStyle: style
                }], elem.GeometryType ? elem.GeometryType.toLowerCase() : 'polygon', {
                  addTitle: !layerManagerFlag
                });

                $(iconSpan).empty().append(newIcon);
              }
            });
          }

          $(iconSpan).attr('styleType', $(icon).attr('styleType'));

          _mapHelper.createMultiStyle(elem, this, multiStyleParent, true, layerManagerFlag);

          if (!layerManagerFlag) {
            if (!parentVisibility || !elem.visible) $(multiStyleParent).addClass("invisible");

            iconSpan.onclick = function () {
              if (_queryMapLayers.currentMapRights() == "edit") {
                nsGmx$1.createStylesDialog(elem, _this);
              }
            };

            if (elem.name in nsGmx$1.gmxMap.layersByID) {
              var layer = nsGmx$1.gmxMap.layersByID[elem.name];

              if (layer.getGmxProperties) {
                var props = layer.getGmxProperties(),
                    layerName = props.name;

                if (props.Temporal && (props.IsRasterCatalog || props.Quicklook && props.Quicklook !== 'null')) {
                  timelineIcon = this.CreateTimelineIcon(elem);
                }
              }
            }
          }

          var resElems = [spanParent, spanDescr, borderDescr];

          if (this._renderParams.showStyle) {
            resElems.push(multiStyleParent);
            resElems.unshift(iconSpan);
          }

          this._renderParams.showVisibilityCheckbox && resElems.unshift(box);

          if (timelineIcon) {
            resElems.unshift(timelineIcon);
          }

          return resElems;
        } else {
          if (this._renderParams.showVisibilityCheckbox) return [box, spanParent, spanDescr, borderDescr];else return [spanParent, spanDescr, borderDescr];
        }
      };

      layersTree.prototype.CreateTimelineIcon = function (elem) {
        var conf = {
          disabledSrc: 'img/timeline-icon-disabled.svg',
          enabledSrc: 'img/timeline-icon-enabled.svg',
          addTitle: window._gtxt('Добавить в таймлайн'),
          removeTitle: window._gtxt('Удалить из таймлайна')
        },
            layerID = elem.name,
            icon = nsGmx$1.Utils._img(null, [['attr', 'src', conf.disabledSrc], ['dir', 'className', 'gmx-timeline-icon disabled'], ['dir', 'title', conf.addTitle]]),
            toggleIcon = function toggleIcon(flag) {
          if (flag) {
            icon.src = conf.enabledSrc;
            icon.title = conf.addTitle;
            icon.classList.remove('disabled');
          } else {
            icon.src = conf.disabledSrc;
            icon.title = conf.removeTitle;
            icon.classList.add('disabled');
          }
        }; // TODO: требуется замена jQuery	+ не эффективно устанавливается множество хэндлеров


        $(this).on('layerTimelineRemove', function (e, data) {
          if (data.layerID === layerID) {
            toggleIcon(false);
          }
        });
        $(this).on('layerTimelineAdd', function (e, data) {
          if (data.layerID === layerID) {
            toggleIcon(true);
          }
        });
        L.DomEvent.on(icon, 'click', function () {
          var disabled = icon.classList.contains('disabled'),
              tlc = nsGmx$1.timeLineControl,
              layer = nsGmx$1.gmxMap.layersByID[layerID];

          if (disabled) {
            if (!tlc._map) {
              nsGmx$1.leafletMap.addControl(tlc);
            }

            tlc.addLayer(layer);
          } else {
            tlc.removeLayer(layer);
          }
        }, this);
        return icon;
      };

      layersTree.prototype.drawGroupLayer = function (elem, parentParams, layerManagerFlag, parentVisibility) {
        var box,
            _this = this;

        if (this._renderParams.showVisibilityCheckbox) {
          box = _checkbox$1(elem.visible, parentParams.list ? 'radio' : 'checkbox', parentParams.GroupID || parentParams.MapID);
          box.className = 'box layers-visibility-checkbox';
          box.setAttribute('box', 'group');

          box.onclick = function () {
            _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
          };

          if (typeof elem.ShowCheckbox !== 'undefined' && !elem.ShowCheckbox) {
            box.isDummyCheckbox = true;
            box.style.display = 'none';
          }
        }

        var span = _span$1([_t(elem.title)], [['dir', 'className', 'groupLayer'], ['attr', 'dragg', true]]);

        var timer = null,
            clickFunc = function clickFunc() {
          if (_this._renderParams.allowActive) _this.setActive(span);

          if (_this._renderParams.showVisibilityCheckbox) {
            var div = span.parentNode.parentNode;

            if (div.gmxProperties.content.properties.ShowCheckbox) {
              _this.treeModel.setNodeVisibility(_this.findTreeElem(div).elem, true);
            }

            var clickDiv = $(div.parentNode).children("div.hitarea");
            if (clickDiv.length) $(clickDiv[0]).trigger("click");
          }
        },
            dbclickFunc = function dbclickFunc() {
          var childsUl = _abstractTree.getChildsUl(span.parentNode.parentNode.parentNode);

          if (childsUl) {
            var bounds = new L.LatLngBounds(),
                minLayerZoom = 20;

            _mapHelper.findChilds(_this.findTreeElem(span.parentNode.parentNode).elem, function (child) {
              if (child.type == 'layer' && (child.content.properties.LayerID || child.content.properties.MultiLayerID) && child.content.geometry) {
                var layer = nsGmx$1.gmxMap.layersByID[child.content.properties.name];
                bounds.extend(layer.getBounds());
                minLayerZoom = Math.min(minLayerZoom, _this.getMinLayerZoom(layer));
              }
            });

            _this.layerZoomToExtent(bounds, minLayerZoom);
          }
        };

        span.onclick = function () {
          if (timer) clearTimeout(timer);
          timer = setTimeout(clickFunc, 200);
        };

        if (this._renderParams.allowDblClick) {
          span.ondblclick = function () {
            if (timer) clearTimeout(timer);
            timer = null;
            clickFunc();
            dbclickFunc();
          };
        }

        disableSelection(span);

        var spanParent = _div$1([span], [['attr', 'titleDiv', true], ['css', 'display', 'inline'], ['css', 'position', 'relative'], ['css', 'borderBottom', 'none'], ['css', 'paddingRight', '3px']]);

        if (this._renderParams.showVisibilityCheckbox && (!parentVisibility || !elem.visible)) {
          $(spanParent).addClass("invisible");
        }

        if (!layerManagerFlag) {
          nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'Group', function () {
            return _queryMapLayers.currentMapRights() == "edit";
          }, function () {
            return {
              div: spanParent.parentNode,
              tree: _this
            };
          });
        }

        if (this._renderParams.showVisibilityCheckbox) return [box, spanParent];else return [spanParent];
      };

      layersTree.prototype.drawHeaderGroupLayer = function (elem, parentParams, layerManagerFlag) {
        var span = _span$1([_t(elem.title)], [['dir', 'className', 'groupLayer']]),
            spanParent = _div$1([span], [['css', 'display', 'inline'], ['css', 'position', 'relative'], ['css', 'borderBottom', 'none'], ['css', 'paddingRight', '3px']]),
            _this = this;

        if (this._renderParams.allowActive) {
          span.onclick = function () {
            _this.setActive(this);
          };
        }

        if (!layerManagerFlag) {
          nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'Map', function () {
            return _queryMapLayers.currentMapRights() == "edit";
          }, function () {
            return {
              div: spanParent.parentNode,
              tree: _this
            };
          });
        }

        return [spanParent];
      };

      layersTree.prototype.removeGroup = function (div) {
        var template = Handlebars.compile('<div class="removeGroup-container">' + '{{#if anyChildren}}' + '<label><input type="checkbox" checked class="removeGroup-layers">{{i "Включая вложенные слои"}}</label><br>' + '{{/if}}' + '<button class="removeGroup-remove">{{i "Удалить"}}</button>' + '</div>');

        var groupNode = _layersTree.treeModel.findElemByGmxProperties(div.gmxProperties).elem;

        var ui = $(template({
          anyChildren: groupNode.content.children.length > 0
        })),
            pos = nsGmx$1.Utils.getDialogPos(div, true, 90),
            _this = this;

        ui.find('.removeGroup-remove').click(function () {
          var parentTree = div.parentNode.parentNode,
              childsUl = _abstractTree.getChildsUl(div.parentNode);

          if (ui.find('.removeGroup-layers').prop('checked')) {
            _layersTree.treeModel.forEachLayer(function (layerContent) {
              _queryMapLayers.removeLayer(layerContent.properties.name);
            }, groupNode);
          } else {
            //TODO: не работает, когда группа не раскрыта или раскрыта не полностью
            var divDestination = $(parentTree.parentNode).children("div[MapID],div[GroupID]")[0];

            if (childsUl) {
              // переносим все слои наверх
              $(childsUl).find("div[LayerID],div[MultiLayerID]").each(function () {
                var spanSource = $(this).find("span.layer")[0];

                _this.moveHandler(spanSource, divDestination);
              });
            }
          }

          _this.removeTreeElem(div);

          div.parentNode.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);

          $(dialogDiv).dialog('destroy');
          dialogDiv.removeNode(true);

          _mapHelper.updateUnloadEvent(true);

          _this.updateZIndexes();
        });

        var title = _gtxt("Удаление группы [value0]", div.gmxProperties.content.properties.title);

        var dialogDiv = showDialog$1(title, ui[0], 250, 100, pos.left, pos.top);
      }; //по элементу дерева слоёв ищет соответствующий элемент в DOM представлении


      layersTree.prototype.findUITreeElem = function (elem) {
        var props = elem.content.properties,
            searchStr;
        if (props.LayerID) searchStr = "div[LayerID='" + props.LayerID + "']";else if (props.MultiLayerID) searchStr = "div[MultiLayerID='" + props.MultiLayerID + "']";else if (props.GroupID) searchStr = "div[GroupID='" + props.GroupID + "']";else searchStr = "div[LayerID='" + props.name + "']";
        return $(this._treeCanvas).find(searchStr)[0];
      };

      layersTree.prototype.getLayerVisibility = function (box) {
        if (!box.checked) return false;
        var el = box.parentNode.parentNode.parentNode;

        while (!el.root) {
          var group = $(el).children("[GroupID]"),
              chB = $(group).find('input[type="checkbox"]')[0] || $(group).find('input[type="radio"]')[0];

          if (group.length > 0) {
            if (!chB.checked) return false;
          }

          el = el.parentNode;
        }

        return true;
      }; //Устанавливает галочку в checkbox и нужный стиль DOM ноде дерева в зависимости от видимости
      //ничего не трогает вне ноды и в самом дереве


      layersTree.prototype.updateVisibilityUI = function (elem) {
        var div = this.findUITreeElem(elem);

        if (div) {
          var isVisible = elem.content.properties.visible;
          $(div).children("[titleDiv], [multiStyle]").toggleClass("invisible", !isVisible);
          var checkbox = $(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0];
          checkbox.checked = isVisible;
        }
      };

      layersTree.prototype.dummyNode = function (node) {
        var text = node.innerHTML;

        if (text.length > 40) {
          text = text.substring(0, 37) + '...';
        }

        return div = _div$1([_t(text)], [['dir', 'className', 'dragableDummy']]);
      }; //проходится по всем слоям дерева и устанавливает им z-индексы в соответствии с их порядком в дереве


      layersTree.prototype.updateZIndexes = function () {
        var curZIndex = 0;
        this.treeModel.forEachLayer(function (layerContent, isVisible, nodeDepth) {
          var layer = nsGmx$1.gmxMap.layersByID[layerContent.properties.name];
          var zIndex = curZIndex++;
          layer.setZIndex && layer.setZIndex(zIndex);
        });
      };

      layersTree.prototype.moveHandler = function (spanSource, divDestination) {
        var node = divDestination.parentNode,
            divSource = spanSource.parentNode.parentNode.parentNode,
            parentTree = divSource.parentNode,
            parentElem = this.findTreeElem($(divSource).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0]).parents[0];
        this.removeTreeElem(spanSource.parentNode.parentNode);
        this.addTreeElem(divDestination, 0, spanSource.parentNode.parentNode.gmxProperties); // добавим новый узел

        var childsUl = _abstractTree.getChildsUl(node);

        if (childsUl) {
          _abstractTree.addNode(node, divSource);

          this.updateListType(divSource);
          if (!childsUl.loaded) divSource.removeNode(true);
        } else {
          _abstractTree.addNode(node, divSource);

          this.updateListType(divSource);
        }

        parentElem && parentElem.content && this.treeModel.updateNodeVisibility(parentElem); // удалим старый узел

        _abstractTree.delNode(node, parentTree, parentTree.parentNode);

        _mapHelper.updateUnloadEvent(true);

        this.updateZIndexes();
      };

      layersTree.prototype.swapHandler = function (spanSource, divDestination) {
        var node = divDestination.parentNode,
            divSource = spanSource.parentNode.parentNode.parentNode,
            parentTree = divSource.parentNode,
            parentElem = this.findTreeElem($(divSource).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0]).parents[0];
        if (node == divSource) return;
        this.removeTreeElem(spanSource.parentNode.parentNode);
        var divElem = $(divDestination.parentNode).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0],
            divParent = $(divDestination.parentNode.parentNode.parentNode).children("div[MapID],div[GroupID]")[0],
            index = this.findTreeElem(divElem).index;
        this.addTreeElem(divParent, index + 1, spanSource.parentNode.parentNode.gmxProperties);

        _abstractTree.swapNode(node, divSource);

        this.updateListType(divSource);
        parentElem && parentElem.content && this.treeModel.updateNodeVisibility(parentElem); // удалим старый узел

        _abstractTree.delNode(node, parentTree, parentTree.parentNode);

        _mapHelper.updateUnloadEvent(true);

        this.updateZIndexes();
      };

      layersTree.prototype.copyHandler = function (gmxProperties, divDestination, swapFlag, addToMap) {
        var _this = this;

        var isFromList = typeof gmxProperties.content.geometry === 'undefined';

        var layerProperties = gmxProperties.type !== 'layer' || !isFromList ? gmxProperties : false,
            copyFunc = function copyFunc() {
          if (addToMap) {
            if (!_this.addLayersToMap(layerProperties)) return;
          } else {
            if (_this.treeModel.findElemByGmxProperties(gmxProperties)) {
              if (layerProperties.type === 'layer') showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", layerProperties.content.properties.title), true);else showErrorMessage(_gtxt("Группа '[value0]' уже есть в карте", layerProperties.content.properties.title), true);
              return;
            }
          }

          var node = divDestination.parentNode,
              parentProperties = swapFlag ? $(divDestination.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0].gmxProperties : divDestination.gmxProperties,
              li;

          if (swapFlag) {
            var parentDiv = $(divDestination.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0];
            li = _this.getChildsList(layerProperties, parentProperties, false, parentDiv.getAttribute('MapID') ? true : _this.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0] ? $(parentDiv).find('input[type="checkbox"]')[0] : parentDiv.firstChild));
          } else li = _this.getChildsList(layerProperties, parentProperties, false, _this.getLayerVisibility($(divDestination).find('input[type="checkbox"]')[0] ? $(divDestination).find('input[type="checkbox"]')[0] : divDestination.firstChild));

          if (layerProperties.type == 'group') {
            // добавляем группу
            if (_abstractTree.getChildsUl(li)) {
              var div = _div$1(null, [['dir', 'className', 'hitarea']]);

              if (layerProperties.content.properties.expanded) {
                $(div).addClass('collapsable-hitarea');
                $(li).addClass('collapsable');
              } else {
                $(div).addClass('expandable-hitarea');
                $(li).addClass('expandable');
              }

              _abstractTree.toggle(div);

              li.insertBefore(div, li.firstChild);
              $(li).treeview(); // если копируем из карты

              if (isFromList) _layersTree.runLoadingFuncs();
            }

            _queryMapLayers.addDraggable(li);

            _queryMapLayers.addDroppable(li);
          } else {
            _queryMapLayers.addDraggable(li);

            if (layerProperties.type == 'layer' && layerProperties.content.properties.styles.length > 1) $(li).treeview();
          }

          _queryMapLayers.addSwappable(li);

          if (swapFlag) {
            var divElem = $(divDestination.parentNode).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0],
                divParent = $(divDestination.parentNode.parentNode.parentNode).children("div[MapID],div[GroupID]")[0],
                index = _this.findTreeElem(divElem).index;

            _this.addTreeElem(divParent, index + 1, layerProperties);

            _abstractTree.swapNode(node, li);

            _this.updateListType(li, true);
          } else {
            _this.addTreeElem(divDestination, 0, layerProperties);

            var childsUl = _abstractTree.getChildsUl(node);

            _abstractTree.addNode(node, li);

            _this.updateListType(li, true);

            if (childsUl && !childsUl.loaded) {
              li.removeNode(true);
            }
          }

          _mapHelper.updateUnloadEvent(true);

          _this.updateZIndexes();
        },
            _this = this;

        if (!layerProperties) {
          if (gmxProperties.content.properties.LayerID) {
            sendCrossDomainJSONRequest$2(serverBase + "Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=" + gmxProperties.content.properties.name + "&srs=" + (nsGmx$1.leafletMap.options.srs || "3395"), function (response) {
              if (!parseResponse(response)) return;
              layerProperties = {
                type: 'layer',
                content: response.Result
              };
              if (layerProperties.content.properties.type == 'Vector') layerProperties.content.properties.styles = [{
                MinZoom: 1,
                MaxZoom: 21,
                RenderStyle: layerProperties.content.properties.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[layerProperties.content.properties.GeometryType] : _mapHelper.defaultStyles[layerProperties.content.properties.GeometryType]
              }];else if (layerProperties.content.properties.type != 'Vector' && !layerProperties.content.properties.MultiLayerID) layerProperties.content.properties.styles = [{
                MinZoom: layerProperties.content.properties.MinZoom,
                MaxZoom: 21
              }];
              layerProperties.content.properties.mapName = _this.treeModel.getMapProperties().name;
              layerProperties.content.properties.hostName = _this.treeModel.getMapProperties().hostName;
              layerProperties.content.properties.visible = true;
              copyFunc();
            });
          } else {
            sendCrossDomainJSONRequest$2(serverBase + "MultiLayer/GetMultiLayerJson.ashx?WrapStyle=func&MultiLayerID=" + gmxProperties.content.properties.MultiLayerID, function (response) {
              if (!parseResponse(response)) return;
              layerProperties = {
                type: 'layer',
                content: response.Result
              };
              layerProperties.content.properties.styles = [{
                MinZoom: layerProperties.content.properties.MinZoom,
                MaxZoom: 20
              }];
              layerProperties.content.properties.mapName = _this.treeModel.getMapProperties().name;
              layerProperties.content.properties.hostName = _this.treeModel.getMapProperties().hostName;
              layerProperties.content.properties.visible = true;
              copyFunc();
            });
          }
        } else copyFunc();
      }; //не работает для мультислоёв


      layersTree.prototype.addLayerToTree = function (layerName) {
        var gmxProperties = {
          type: 'layer',
          content: {
            properties: {
              LayerID: layerName,
              name: layerName
            }
          }
        };
        var targetDiv = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0];
        this.copyHandler(gmxProperties, targetDiv, false, true);
      };

      layersTree.prototype.checkGroupForDuplicates = function (elements) {
        var alreadyOnMap = false;

        for (var i = 0; i < elements.length; i++) {
          var elem = elements[i],
              layer = elem.content,
              name = layer.properties.name;

          if (nsGmx$1.gmxMap.layersByID[name]) {
            alreadyOnMap = nsGmx$1.gmxMap.layersByID[name].getGmxProperties().title;
            break;
          }
        }

        return alreadyOnMap;
      }; //геометрия слоёв должна быть в координатах меркатора


      layersTree.prototype.addLayersToMap = function (elem) {
        var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;
        var layerOrder = nsGmx$1.gmxMap.rawTree.properties.LayerOrder,
            currentZoom = nsGmx$1.leafletMap.getZoom();

        if (typeof elem.content.properties.GroupID != 'undefined') {
          var alreadyOnMap = this.checkGroupForDuplicates(elem.content.children);

          if (alreadyOnMap) {
            showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", alreadyOnMap), true);
            return false;
          } else {
            for (var i = 0; i < elem.content.children.length; i++) {
              var res = this.addLayersToMap(elem.content.children[i]);
              if (!res) return false;
            }
          }
        } else {
          var layer = elem.content,
              name = layer.properties.name; // hack to avoid API defaults by initFromDescription;

          var propsHostName = window.serverBase.replace(/https?:\/\//, '');
          propsHostName = propsHostName.replace(/\//g, '');
          layer.properties.hostName = propsHostName;

          if (!nsGmx$1.gmxMap.layersByID[name]) {
            var visibility = typeof layer.properties.visible != 'undefined' ? layer.properties.visible : false,
                rcMinZoom = layer.properties.RCMinZoomForRasters,
                layerOnMap = L.gmx.createLayer(layer, {
              layerID: name,
              hostName: propsHostName,
              zIndexOffset: null,
              srs: nsGmx$1.leafletMap.options.srs || '',
              skipTiles: nsGmx$1.leafletMap.options.skipTiles || '',
              isGeneralized: window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true
            });
            updateZIndex(layerOnMap);
            nsGmx$1.gmxMap.addLayer(layerOnMap);
            visibility && nsGmx$1.leafletMap.addLayer(layerOnMap);
            layerOnMap.getGmxProperties().changedByViewer = true;
            nsGmx$1.leafletMap.on('zoomend', function (e) {
              currentZoom = nsGmx$1.leafletMap.getZoom();

              for (var l = 0; l < nsGmx$1.gmxMap.layers.length; l++) {
                var layer = nsGmx$1.gmxMap.layers[l];
                updateZIndex(layer);
              }
            });
          } else {
            showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", nsGmx$1.gmxMap.layersByID[name].getGmxProperties().title), true);
            return false;
          }
        }

        function updateZIndex(layer) {
          var props = layer.getGmxProperties();

          switch (layerOrder) {
            case 'VectorOnTop':
              if (props.type === 'Vector') {
                if (props.IsRasterCatalog) {
                  var rcMinZoom = props.RCMinZoomForRasters;
                  layer.setZIndexOffset(currentZoom < rcMinZoom ? DEFAULT_VECTOR_LAYER_ZINDEXOFFSET : 0);
                } else {
                  layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                }
              }

              break;
          }
        }

        return true;
      };

      layersTree.prototype.getParentParams = function (li) {
        //при визуализации дерева в него добавляются новые элементы. Используем хак, чтобы понять, было отрисовано дерево или нет
        var parentParams = li.parentNode.parentNode.childNodes[1].tagName == "DIV" ? li.parentNode.parentNode.childNodes[1].gmxProperties : li.parentNode.parentNode.childNodes[0].gmxProperties,
            listFlag;
        if (parentParams.content) listFlag = parentParams.content.properties;else listFlag = parentParams.properties;
        return listFlag;
      };

      layersTree.prototype.updateListType = function (li, skipVisible) {
        //при визуализации дерева в него добавляются новые элементы. Используем хак, чтобы понять, было отрисовано дерево или нет
        var parentParams = li.parentNode.parentNode.childNodes[1].tagName == "DIV" ? li.parentNode.parentNode.childNodes[1].gmxProperties : li.parentNode.parentNode.childNodes[0].gmxProperties,
            listFlag;
        if (parentParams.content) listFlag = parentParams.content.properties.list;else listFlag = parentParams.properties.list;

        var div = $(li).children("div[MapID],div[GroupID],div[LayerID],div[MultiLayerID]")[0],
            box = $(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0],
            newBox = _checkbox$1(box.checked, listFlag ? 'radio' : 'checkbox', parentParams.content ? parentParams.content.properties.GroupID : parentParams.properties.MapID),
            _this = this;

        newBox.className = 'box layers-visibility-checkbox';
        if (box.getAttribute('box') == 'group') newBox.setAttribute('box', 'group');
        $(box).replaceWith(newBox);

        newBox.onclick = function () {
          _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
        };

        if (box.isDummyCheckbox) {
          newBox.isDummyCheckbox = true;
          newBox.style.display = 'none';
        }

        if (!skipVisible) {
          var parentDiv = $(newBox.parentNode.parentNode.parentNode.parentNode).children("div[GroupID]")[0];
          parentDiv && this.treeModel.updateNodeVisibility(this.findTreeElem(parentDiv).elem, this.findTreeElem(newBox.parentNode).elem);
        }

        return newBox;
      };

      layersTree.prototype.removeTreeElem = function (div) {
        var elem = this.findTreeElem(div);
        if (typeof elem.parents[0].children != 'undefined') elem.parents[0].children.splice(elem.index, 1);else elem.parents[0].content.children.splice(elem.index, 1);
      };

      layersTree.prototype.addTreeElem = function (div, index, elemProperties) {
        var elem = this.findTreeElem(div);
        if (typeof elem.elem.children != 'undefined') elem.elem.children.splice(index, 0, elemProperties);else elem.elem.content.children.splice(index, 0, elemProperties);
        $(this.treeModel.getRawTree()).triggerHandler('addTreeElem', [elemProperties]);
      };

      layersTree.prototype.findTreeElem = function (div) {
        if (div.getAttribute("MapID")) return {
          elem: this.treeModel.getRawTree(),
          parents: [],
          index: false
        };else if (div.getAttribute("GroupID")) return this.treeModel.findElem("GroupID", div.getAttribute("GroupID"));else if (div.getAttribute("LayerID")) return this.treeModel.findElem("name", div.getAttribute("LayerID"));else if (div.getAttribute("MultiLayerID")) return this.treeModel.findElem("name", div.getAttribute("MultiLayerID"));
      }; //Дерево основной карты


      var _layersTree = new layersTree({
        showVisibilityCheckbox: true,
        allowActive: true,
        allowDblClick: true
      });

      window.layersTree = layersTree;
      window._layersTree = _layersTree; //Виджет в левой панели для отображения основного дерева

      var queryMapLayers = function queryMapLayers() {
        this.buildedTree = null;
        this.builded = false;
        this.buttonsCanvas = _div$1();
        this.loadDeferred = $.Deferred();
      };

      queryMapLayers.prototype = new leftMenu$1();

      queryMapLayers.prototype.addLayers = function (data, condition, mapStyles, LayersTreePermalinkParams) {
        if (condition) _layersTree.condition = condition;
        if (mapStyles) _layersTree.mapStyles = mapStyles;
        if (LayersTreePermalinkParams) _layersTree.LayersTreePermalinkParams = LayersTreePermalinkParams;
        this.buildedTree = _layersTree.drawTree(data);
      };

      queryMapLayers.prototype.applyState = function (condition, mapLayersParam, div) {
        if (!objLength$1(condition.visible) && !objLength$1(condition.expanded) && !objLength$1(mapLayersParam)) return;

        var parentElem = typeof div == 'undefined' ? _layersTree.treeModel.getRawTree() : _layersTree.findTreeElem(div).elem,
            visFlag = typeof div == 'undefined' ? true : _layersTree.getLayerVisibility($(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0]),
            _this = this;

        _mapHelper.findTreeElems(parentElem, function (elem, visibleFlag) {
          var props = elem.content.properties;

          if (elem.type == 'group') {
            var groupId = props.GroupID;

            if (typeof condition.visible[groupId] != 'undefined' && props.visible != condition.visible[groupId]) {
              props.visible = condition.visible[groupId];
              var group = $(_this.buildedTree).find("div[GroupID='" + groupId + "']");

              if (group.length) {
                var it = $(group).find('input[type="checkbox"]')[0] || $(group).find('input[type="radio"]')[0];
                if (it) it.checked = condition.visible[groupId];
              }
            }

            if (typeof condition.expanded[groupId] != 'undefined' && props.expanded != condition.expanded[groupId]) {
              props.expanded = condition.expanded[groupId];
              var group = $(_this.buildedTree).find("div[GroupID='" + groupId + "']");

              if (group.length) {
                var clickDiv = $(group[0].parentNode).children("div.hitarea");
                if (clickDiv.length) $(clickDiv[0]).trigger("click");
              }
            }
          } else {
            var name = props.name;

            if (typeof condition.visible[name] != 'undefined') {
              _layersTree.treeModel.setNodeVisibility(elem, condition.visible[name]);
            } else {
              _layersTree.treeModel.setNodeVisibility(elem, props.initVisible);
            }

            if (props.type == "Vector" && typeof mapLayersParam != 'undefined' && typeof mapLayersParam[name] != 'undefined' && !_this.equalStyles(props.styles, mapLayersParam[name])) {
              // что-то менялось в стилях
              var newStyles = mapLayersParam[name],
                  div = $(_this.buildedTree).find("div[LayerID='" + props.LayerID + "']")[0];
              props.styles = newStyles;

              _mapHelper.updateMapStyles(newStyles, name);

              props.changedByViewer = true;
              div && _mapHelper.updateTreeStyles(newStyles, div, _layersTree, true);
            }
          }
        }, visFlag);
      };

      queryMapLayers.prototype.equalStyles = function (style1, style2) {
        if (style1.length != style2.length) return false;

        for (var i = 0; i < style1.length; i++) {
          if (!equals(style1[i], style2[i])) return false;
        }

        return true;
      };

      queryMapLayers.prototype.getContainerBefore = function () {
        if (!this.builded) return;
        return $('.layers-before', this.workCanvas).show();
      };

      queryMapLayers.prototype.getContainerAfter = function () {
        if (!this.builded) return;
        return $('.layers-after', this.workCanvas).show();
      };

      queryMapLayers.prototype.load = function (data) {
        if (this.buildedTree && !this.builded) {
          var _this = this;

          this.treeCanvas = _div$1(null, [['dir', 'className', 'layers-tree']]); //Для обратной совместимости - есть много мапплетов карт, которые пытаются интегрироваться после первого table
          //TODO: изнечтожить все такие мапплеты

          _(this.workCanvas, [_table()]);

          _(this.workCanvas, [_div$1([//_table([_tbody([_tr([_td([_span([_t(_gtxt("Шкала прозрачности"))],[['css','marginLeft','7px'],['css','color','#153069'],['css','fontSize','12px']])]), _td([this.rasterLayersSlider(_queryMapLayers.treeCanvas)])])])])
          ], [['dir', 'className', 'layers-before'], ['css', 'display', 'none']])]);

          _(this.workCanvas, [this.treeCanvas]);

          _(this.treeCanvas, [this.buildedTree]);

          _(this.workCanvas, [_div$1([//_table([_tbody([_tr([_td([_span([_t(_gtxt("Шкала прозрачности"))],[['css','marginLeft','7px'],['css','color','#153069'],['css','fontSize','12px']])]), _td([this.rasterLayersSlider(_queryMapLayers.treeCanvas)])])])])
          ], [['dir', 'className', 'layers-after'], ['css', 'display', 'none']])]);

          $(this.buildedTree).treeview();

          _layersTree.runLoadingFuncs();

          _layersTree.addExpandedEvents(this.buildedTree); //при клике на любом пустом месте дерева слоёв снимаем выделение


          $(this.treeCanvas).click(function (event) {
            var t = $(event.target); //все элементы, на которых можно кликнуть без снятия выделения

            if (t.hasClass('hitarea') || t.hasClass('groupLayer') || t.attr('styletype') || t.parents('div[layerid],div[MultiLayerID]').length) {
              return;
            }

            _layersTree.setActive(null);
          });
          $(this.treeCanvas).droppable({
            accept: "span[dragg]",
            drop: function drop(ev, ui) {
              queryMapLayers._droppableHandler.bind($(_this.buildedTree).find('[mapid]')[0], ev, ui)();
            }
          });
          this.applyState(_layersTree.condition, _layersTree.mapStyles);
          this.builded = true;
          $(this).triggerHandler('load');
          this.loadDeferred.resolve();
        }
      };

      queryMapLayers.prototype.applyOpacityToRasterLayers = function (opacity, parent) {
        var active = $(parent).find(".active"); // слой

        if (active[0] && (active[0].parentNode.getAttribute("LayerID") || active[0].parentNode.getAttribute("MultiLayerID"))) {
          var props = active[0].parentNode.gmxProperties.content.properties,
              layer = nsGmx$1.gmxMap.layersByID[props.name];
          layer.setRasterOpacity && layer.setRasterOpacity(opacity / 100);
          return;
        }

        if (active.length) {
          // группа или карта
          var treeElem = _layersTree.findTreeElem(active[0].parentNode);

          _mapHelper.findChilds(treeElem.elem, function (child) {
            var props = child.content.properties;
            var layer = nsGmx$1.gmxMap.layersByID[props.name];
            layer.setRasterOpacity && layer.setRasterOpacity(opacity / 100);
          }, true);
        } else {
          // все растровые слои
          var layers = nsGmx$1.gmxMap.layers;

          for (var i = 0; i < layers.length; i++) {
            layers[i].setRasterOpacity && layers[i].setRasterOpacity(opacity / 100);
          }
        }
      };

      queryMapLayers.prototype.rasterLayersSlider = function (parent) {
        var slider = nsGmx$1.Controls.createSlider(100, function (event, ui) {
          _queryMapLayers.applyOpacityToRasterLayers(ui.value, parent);
        }),
            elem = _div$1([slider], [['css', 'width', '120px']]);

        slider.style.margin = '10px';
        slider.style.backgroundColor = '#F4F4F4';

        _title(slider, _gtxt("Прозрачность выбранного слоя/группы/карты"));

        return _div$1([elem], [['css', 'padding', '5px 0px 0px 15px']]);
      };

      queryMapLayers.prototype.currentMapRights = function () {
        var mapProperties = _layersTree.treeModel && _layersTree.treeModel.getMapProperties();

        return mapProperties ? mapProperties.Access : "none";
      };

      queryMapLayers.prototype.layerRights = function (name) {
        var layer = nsGmx$1.gmxMap.layersByID[name];
        return layer ? layer.getGmxProperties().Access : null;
      };

      queryMapLayers.prototype.addUserActions = function () {
        if (this.currentMapRights() == "edit") {
          this.addDraggable(this.treeCanvas);
          this.addDroppable(this.treeCanvas);
          this.addSwappable(this.treeCanvas);
        }
      };

      queryMapLayers.prototype.removeUserActions = function () {
        //	removeChilds(this.buttonsCanvas);
        this.removeDraggable(this.treeCanvas);
        this.removeDroppable(this.treeCanvas);
        this.removeSwappable(this.treeCanvas);
      };

      queryMapLayers.prototype.addDraggable = function (parent) {
        $(parent).find("span[dragg]").draggable({
          helper: function helper(ev) {
            return _layersTree.dummyNode(ev.target);
          },
          cursorAt: {
            left: 5,
            top: 10
          },
          appendTo: document.body
        });
      };

      queryMapLayers.prototype.removeDraggable = function (parent) {
        $(parent).find("span[dragg]").draggable('destroy');
      };

      queryMapLayers._droppableHandler = function (ev, ui) {
        $('body').css("cursor", ''); // удалим элемент, отображающий копирование

        ui.helper[0].removeNode(true); // уберем заведомо ложные варианты - сам в себя, копирование условий

        if (this == ui.draggable[0].parentNode.parentNode) return;
        var circle = false,
            layerManager = false;
        $(this).parents().each(function () {
          if ($(this).prev().length > 0 && $(this).prev()[0] == ui.draggable[0].parentNode.parentNode) circle = true;
        });
        if (circle) return;
        var isFromExternalMaps = false;
        $(ui.draggable[0].parentNode.parentNode).parents().each(function () {
          if (this == $('#layersList')[0] || this == $('#mapsList')[0] || this == $('#externalMapsCanvas')[0]) layerManager = true;
          if (this == $('#externalMapsCanvas')[0]) isFromExternalMaps = true;
        });
        if (!layerManager) _layersTree.moveHandler(ui.draggable[0], this);else _layersTree.copyHandler(ui.draggable[0].parentNode.parentNode.gmxProperties, this, false, !isFromExternalMaps);
      };

      queryMapLayers.prototype.addDroppable = function (parent) {
        $(parent).find("div[GroupID],div[MapID]").droppable({
          accept: "span[dragg]",
          hoverClass: 'droppableHover',
          greedy: true,
          drop: queryMapLayers._droppableHandler
        });
        $(parent).find("div[LayerID],div[MultiLayerID]").droppable({
          accept: "span[dragg]",
          greedy: true,
          drop: function drop(ev, ui) {
            var swapElem = $(this).next();
            swapElem.removeClass('swap-droppableHover');

            queryMapLayers._swapHandler.call(swapElem[0], ev, ui);
          },
          over: function over(ev, ui) {
            $(this).next().addClass('swap-droppableHover');
          },
          out: function out(ev, ui) {
            $(this).next().removeClass('swap-droppableHover');
          }
        });
      };

      queryMapLayers.prototype.removeDroppable = function (parent) {
        $(parent).find("div[GroupID],div[MapID]").droppable('destroy');
      }; //статическая ф-ция


      queryMapLayers._swapHandler = function (ev, ui) {
        $('body').css("cursor", ''); // удалим элемент, отображающий копирование

        ui.helper[0].removeNode(true); //проверим, не идёт ли копирование группы внутрь самой себя

        var circle = false;
        $(this).parents().each(function () {
          if ($(this).prev().length > 0 && $(this).prev()[0] == ui.draggable[0].parentNode.parentNode) circle = true;
        });
        if (circle) return;
        var layerManager = false;
        var isFromExternalMaps = false;
        $(ui.draggable[0].parentNode.parentNode).parents().each(function () {
          if (this == $('#layersList')[0] || this == $('#mapsList')[0] || this == $('#externalMapsCanvas')[0]) layerManager = true;
          if (this == $('#externalMapsCanvas')[0]) isFromExternalMaps = true;
        });
        var gmxProperties = ui.draggable[0].parentNode.parentNode.gmxProperties;
        if (!layerManager) _layersTree.swapHandler(ui.draggable[0], this);else _layersTree.copyHandler(gmxProperties, this, true, !isFromExternalMaps);
      };

      queryMapLayers.prototype.addSwappable = function (parent) {
        $(parent).find("div[swap]").droppable({
          accept: "span[dragg]",
          hoverClass: 'swap-droppableHover',
          greedy: true,
          drop: queryMapLayers._swapHandler
        });
      };

      queryMapLayers.prototype.removeSwappable = function (parent) {
        $(parent).find("div[swap]").droppable('destroy');
      };

      queryMapLayers.prototype.asyncCreateLayer = function (promise, title) {
        var _this = this;

        var taskDiv = _div$1(),
            active = $(_this.buildedTree).find(".active")[0],
            parentDiv;

        if (active && (active.parentNode.getAttribute('MapID') || active.parentNode.getAttribute('GroupID'))) parentDiv = active.parentNode.parentNode;else parentDiv = _this.buildedTree.firstChild;

        _abstractTree.addNode(parentDiv, _li$1([taskDiv, _div$1(null, [['css', 'height', '5px'], ['css', 'fontSize', '0px']])]));

        promise.fail(function (taskInfo) {
          var parentTree = taskDiv.parentNode.parentNode;
          taskDiv.parentNode.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);
        }).done(function (taskInfo) {
          if (!$.isArray(taskInfo.Result)) {
            taskInfo.Result = [taskInfo.Result];
          }

          var parentDiv = $(taskDiv.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0],
              parentProperties = parentDiv.gmxProperties;
          var parentTree = taskDiv.parentNode.parentNode;
          taskDiv.parentNode.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);

          for (var l = 0; l < taskInfo.Result.length; l++) {
            var newLayer = taskInfo.Result[l];
            var newProps = newLayer.properties;

            var mapProperties = _layersTree.treeModel.getMapProperties();

            newProps.mapName = mapProperties.name;
            newProps.hostName = mapProperties.hostName;
            newProps.visible = true;

            if (!newProps.styles) {
              if (newProps.type == 'Vector') newProps.styles = [{
                MinZoom: 1,
                MaxZoom: 21,
                RenderStyle: newProps.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[newProps.GeometryType] : _mapHelper.defaultStyles[newProps.GeometryType]
              }];else if (newProps.type != 'Vector' && !newProps.MultiLayerID) newProps.styles = [{
                MinZoom: newProps.MinZoom,
                MaxZoom: 21
              }];
            }

            var convertedCoords = newLayer.geometry ? L.gmxUtil.convertGeometry(newLayer.geometry, true) : null;

            _layersTree.addLayersToMap({
              content: {
                properties: newProps,
                geometry: newLayer.geometry
              }
            });

            var li = _layersTree.getChildsList({
              type: 'layer',
              content: {
                properties: newProps,
                geometry: convertedCoords
              }
            }, parentProperties, false, parentDiv.getAttribute('MapID') ? true : _layersTree.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0]));

            _abstractTree.addNode(parentDiv.parentNode, li);

            var divElem = $(li).children("div[LayerID]")[0],
                divParent = $(li.parentNode.parentNode).children("div[MapID],div[GroupID]")[0];

            _layersTree.addTreeElem(divParent, 0, {
              type: 'layer',
              content: {
                properties: newProps,
                geometry: convertedCoords
              }
            });

            _queryMapLayers.addSwappable(li);

            _queryMapLayers.addDraggable(li);

            _layersTree.updateListType(li);
          }

          _mapHelper.updateUnloadEvent(true);

          _layersTree.updateZIndexes();
        }).progress(function (taskInfo) {
          $(taskDiv).empty();

          _(taskDiv, [_span$1([_t(title + ':')], [['css', 'color', '#153069'], ['css', 'margin', '0px 3px']]), _t(taskInfo.Status)]);
        });
      };

      queryMapLayers.prototype.asyncUpdateLayer = function (promise, properties, recreateLayer) {
        var layerDiv = $(_queryMapLayers.buildedTree).find("[LayerID='" + properties.LayerID + "']")[0],
            _this = this;

        promise.done(function (taskInfo) {
          if (recreateLayer) {
            var newLayerProperties = taskInfo.Result.properties;

            var mapProperties = _layersTree.treeModel.getMapProperties();

            newLayerProperties.mapName = mapProperties.name;
            newLayerProperties.hostName = mapProperties.hostName;
            newLayerProperties.visible = layerDiv.gmxProperties.content.properties.visible;
            newLayerProperties.styles = layerDiv.gmxProperties.content.properties.styles; //var convertedCoords = from_merc_geometry(taskInfo.Result.geometry);

            var origGeometry = taskInfo.Result.geometry,
                convertedGeometry = origGeometry ? L.gmxUtil.geometryToGeoJSON(origGeometry, true) : null;

            _this.removeLayer(newLayerProperties.name);

            _layersTree.addLayersToMap({
              content: {
                properties: newLayerProperties,
                geometry: origGeometry
              }
            });

            var parentProperties = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0].gmxProperties,
                li = _layersTree.getChildsList({
              type: 'layer',
              content: {
                properties: newLayerProperties,
                geometry: convertedGeometry
              }
            }, parentProperties, false, _layersTree.getLayerVisibility($(layerDiv).find('input[type="checkbox"]')[0] || $(layerDiv).find('input[type="radio"]')[0]));

            $(li).find('[multiStyle]').treeview();
            $(layerDiv.parentNode).replaceWith(li);
            _layersTree.findTreeElem($(li).children("div[LayerID]")[0]).elem = {
              type: 'layer',
              content: {
                properties: newLayerProperties,
                geometry: convertedGeometry
              }
            };

            _queryMapLayers.addSwappable(li);

            _queryMapLayers.addDraggable(li);

            _layersTree.updateListType(li);

            _layersTree.updateZIndexes();

            var checkedLayer = nsGmx$1.gmxMap.layersByID[newLayerProperties.name];

            if (checkedLayer) {
              L.gmx.layersVersion.chkVersion(checkedLayer);
            }
          } else {
            $('#' + taskInfo.TaskID).remove();
            layerDiv.style.display = '';
          }
        }).fail(function (taskInfo) {
          $('#' + taskInfo.TaskID).remove();
          layerDiv.style.display = '';
        }).progress(function (taskInfo) {
          var taskDiv;

          if (!$('#' + taskInfo.TaskID).length) {
            taskDiv = _div$1(null, [['attr', 'id', taskInfo.TaskID]]);
            layerDiv.style.display = 'none';
            $(layerDiv).before(taskDiv);
          } else {
            taskDiv = $('#' + taskInfo.TaskID)[0];
            $(taskDiv).empty();
          }

          _(taskDiv, [_span$1([_t(properties.Title + ':')], [['css', 'color', '#153069'], ['css', 'margin', '0px 3px']]), _t(taskInfo.Status)]);
        });
      };

      queryMapLayers.prototype.asyncCopyLayer = function (promise, title) {
        console.log('layer copied');

        var _this = this;

        var taskDiv = _div$1(),
            active = $(_this.buildedTree).find(".active")[0],
            parentDiv;

        if (active && (active.parentNode.getAttribute('MapID') || active.parentNode.getAttribute('GroupID'))) parentDiv = active.parentNode.parentNode;else parentDiv = _this.buildedTree.firstChild;

        _abstractTree.addNode(parentDiv, _li$1([taskDiv, _div$1(null, [['css', 'height', '5px'], ['css', 'fontSize', '0px']])]));

        promise.fail(function (taskInfo) {
          console.log('failed');
          var parentTree = taskDiv.parentNode.parentNode;
          taskDiv.parentNode.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);
        }).done(function (taskInfo) {
          console.log('ok');

          if (!$.isArray(taskInfo.Result)) {
            taskInfo.Result = [taskInfo.Result];
          }

          var parentDiv = $(taskDiv.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0],
              parentProperties = parentDiv.gmxProperties;
          var parentTree = taskDiv.parentNode.parentNode;
          taskDiv.parentNode.removeNode(true);

          _abstractTree.delNode(null, parentTree, parentTree.parentNode);

          for (var l = 0; l < taskInfo.Result.length; l++) {
            var newLayer = taskInfo.Result[l];
            var newProps = newLayer.properties;

            var mapProperties = _layersTree.treeModel.getMapProperties();

            newProps.mapName = mapProperties.name;
            newProps.hostName = mapProperties.hostName;
            newProps.visible = true;

            if (!newProps.styles) {
              if (newProps.type == 'Vector') newProps.styles = [{
                MinZoom: 1,
                MaxZoom: 21,
                RenderStyle: newProps.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[newProps.GeometryType] : _mapHelper.defaultStyles[newProps.GeometryType]
              }];else if (newProps.type != 'Vector' && !newProps.MultiLayerID) newProps.styles = [{
                MinZoom: newProps.MinZoom,
                MaxZoom: 21
              }];
            }

            var convertedCoords = newLayer.geometry ? L.gmxUtil.convertGeometry(newLayer.geometry, true) : null;

            _layersTree.addLayersToMap({
              content: {
                properties: newProps,
                geometry: newLayer.geometry
              }
            });

            var li = _layersTree.getChildsList({
              type: 'layer',
              content: {
                properties: newProps,
                geometry: convertedCoords
              }
            }, parentProperties, false, parentDiv.getAttribute('MapID') ? true : _layersTree.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0]));

            _abstractTree.addNode(parentDiv.parentNode, li);

            var divElem = $(li).children("div[LayerID]")[0],
                divParent = $(li.parentNode.parentNode).children("div[MapID],div[GroupID]")[0];

            _layersTree.addTreeElem(divParent, 0, {
              type: 'layer',
              content: {
                properties: newProps,
                geometry: convertedCoords
              }
            });

            _queryMapLayers.addSwappable(li);

            _queryMapLayers.addDraggable(li);

            _layersTree.updateListType(li);
          }

          _mapHelper.updateUnloadEvent(true);

          _layersTree.updateZIndexes();
        }).progress(function (taskInfo) {
          console.log('progress');
          $(taskDiv).empty();

          _(taskDiv, [_span$1([_t(title + ':')], [['css', 'color', '#153069'], ['css', 'margin', '0px 3px']]), _t(taskInfo.Status)]);
        }).always(function (taskInfo) {
          console.log(taskInfo);
        });
      };

      queryMapLayers.prototype.removeLayer = function (name) {
        var layer = nsGmx$1.gmxMap.layersByID[name];

        if (layer) {
          nsGmx$1.leafletMap.removeLayer(layer);
          nsGmx$1.gmxMap.removeLayer(layer);
        }
      };

      queryMapLayers.prototype.getLayers = function () {
        this.createLayersManager();
      };

      queryMapLayers.prototype.createLayersManager = function () {
        var canvas = _div$1();

        var layerManagerControl = new nsGmx$1.LayerManagerControl(canvas, 'layers');
        var existLayers = [];

        for (var i = 0; i < nsGmx$1.gmxMap.layers.length; i++) {
          existLayers.push(nsGmx$1.gmxMap.layers[i].getGmxProperties().name);
        }

        layerManagerControl.disableLayers(existLayers);
        var dialogDiv = showDialog$1(_gtxt("Список слоев"), canvas, 571, 485, 535, 130, function (size) {
          layerManagerControl.resize(size.height - 55);
        });
      };

      queryMapLayers.prototype.getMaps = function () {
        if (!$('#mapsList').length) new nsGmx$1.MapsManagerControl();
      };

      queryMapLayers.prototype.createMapDialog = function (title, buttonName, func, addLink) {
        var uiTemplate = Handlebars.compile('<div class = "createMap-container">' + '<input class = "inputStyle inputFullWidth createMap-input">' + '<button class = "createMap-button">{{buttonName}}</button>' + '</div>');
        var ui = $(uiTemplate({
          buttonName: buttonName
        })),
            input = $('.createMap-input', ui)[0];

        var tryCreateMap = function tryCreateMap() {
          input.focus();

          if (input.value != '') {
            removeDialog$1(dialogDiv);
            func(input.value);
          } else {
            inputError(input);
          }
        };

        $(input, ui).on('keydown', function (e) {
          if (e.keyCode === 13) {
            tryCreateMap();
            return false;
          }
        });
        $('.createMap-button', ui).click(tryCreateMap);
        addLink && ui.append(addLink);
        var dialogDiv = showDialog$1(title, ui[0], 280, 115 + (addLink ? 20 : 0), false, false);
      };

      queryMapLayers.prototype.createMap = function (name) {
        sendCrossDomainJSONRequest$2(serverBase + 'Map/Insert.ashx?WrapStyle=func&Title=' + encodeURIComponent(name), function (response) {
          if (!parseResponse(response)) return;
          window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + response.Result);
        });
      };

      (function () {
        var saveMapInternal = function saveMapInternal(scriptName, mapTitle, callback) {
          var mapID = String($(_queryMapLayers.buildedTree).find("[MapID]")[0].gmxProperties.properties.MapID),
              saveTree = {};
          window._mapEditorsHash && _mapEditorsHash[mapID] && _mapEditorsHash[mapID].update(); //обновим стили слоёв из всех незакрытых диалогов редактирования стилей

          var mStyleEditor = gmxCore.getModule('LayerStylesEditor');
          mStyleEditor && mStyleEditor.updateAllStyles();
          nsGmx$1.userObjectsManager.collect();
          $(_queryMapLayers.buildedTree).find("[MapID]")[0].gmxProperties.properties.UserData = JSON.stringify(nsGmx$1.userObjectsManager.getData());
          $.extend(true, saveTree, _layersTree.treeModel.getRawTree());
          var attributesToSave = ['visible', 'styles', 'AllowSearch', 'TiledQuicklook', 'TiledQuicklookMinZoom', 'name', 'MapStructureID'];
          saveTree.properties.BaseLayers = JSON.stringify(nsGmx$1.leafletMap.gmxBaseLayersManager.getActiveIDs()); //раскрываем все группы так, как записано в свойствах групп

          _mapHelper.findTreeElems(saveTree, function (child, flag) {
            var props = child.content.properties;

            if (child.type === "group") {
              props.expanded = typeof props.initExpand !== 'undefined' ? props.initExpand : false;
              delete props.initVisible;
              delete props.initExpand;
            } else {
              var propsToSave = {};

              for (var i = 0; i < attributesToSave.length; i++) {
                var attrName = attributesToSave[i];

                if (attrName in props) {
                  propsToSave[attrName] = props[attrName];
                }
              }

              var styles = props.styles || [];

              for (var s = 0; s < styles.length; s++) {
                delete styles[s].HoverStyle;
              }

              if (window.newStyles) {
                var keys = L.gmx.StyleManager.DEFAULT_STYLE_KEYS,
                    stylesHash = {};

                for (var i = 0; i < keys.length; i++) {
                  stylesHash[keys[i]] = true;
                }

                propsToSave.gmxStyles = props.gmxStyles;

                for (var s = 0; s < propsToSave.gmxStyles.styles.length; s++) {
                  var st = propsToSave.gmxStyles.styles[s];
                  delete st.HoverStyle;

                  for (var key in st.RenderStyle) {
                    if (!(key in stylesHash)) {
                      delete st.RenderStyle[key];
                    }
                  }
                }
              }

              child.content.properties = propsToSave;
              delete child.content.geometry;
            }
          }, true);

          var params = {
            WrapStyle: 'window',
            MapID: mapID,
            MapJson: JSON.stringify(saveTree)
          };
          if (mapTitle) params.Title = mapTitle;
          sendCrossDomainPostRequest$1(serverBase + scriptName, params, function (response) {
            if (!parseResponse(response)) return;
            callback && callback(response.Result);

            _mapHelper.updateUnloadEvent(false);

            nsGmx$1.widgets.notifications.stopAction('saveMap', 'success', _gtxt("Сохранено"));
          });
        };

        queryMapLayers.prototype.saveMap = function () {
          nsGmx$1.widgets.notifications.startAction('saveMap');
          saveMapInternal("Map/SaveMap.ashx", null);
        };

        queryMapLayers.prototype.saveMapAs = function (name) {
          nsGmx$1.widgets.notifications.startAction('saveMap');
          saveMapInternal("Map/SaveAs.ashx", name);
        };
      })();

      var _queryMapLayers = new queryMapLayers();

      window._queryMapLayers = _queryMapLayers;

      mapLayers.mapLayers.load = function () {
        var alreadyLoaded = _queryMapLayers.createWorkCanvas('layers', {
          path: null,
          showCloseButton: false,
          showMinimizeButton: false
        });

        if (!alreadyLoaded) _queryMapLayers.load();
      };

      mapLayers.mapLayers.unload = function () {};
    }(nsGmx$1.Utils._);

    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.AuthWidget = {};
    nsGmx$1.Templates.AuthWidget["authWidget"] = "{{#if userName}}\n" + "    <div class=\"authWidget_authorized\">\n" + "        <div class=\"authWidget-userPanel\">\n" + "            <div class=\"authWidget-userPanel-iconCell\">\n" + "                <div class=\"authWidget-userPanel-userIcon\"></div>\n" + "            </div>\n" + "            <div class=\"authWidget-userPanel-userMenuCell\"></div>\n" + "        </div>\n" + "    </div>\n" + "{{else}}\n" + "\n" + "    <div class=\"authWidget_unauthorized\">\n" + "        <div class=\"authWidget-userPanel\">\n" + "            <div class=\"authWidget-userPanel-iconCell\">\n" + "                <div class=\"authWidget-userPanel-userIcon\"></div>\n" + "            </div>\n" + "            <div class=\"authWidget-loginButton\">\n" + "                {{i 'auth.login'}}\n" + "            </div>\n" + "        </div>\n" + "    </div>\n" + "{{/if}}\n" + "";

    nsGmx$1.AuthWidget = function () {
      // options.loginDialog
      var AuthWidget = function AuthWidget(options) {
        this._view = $('<div>');

        this._view.addClass('authWidget ui-widget');

        this._authManager = options.authManager;
        this._userInfo = null;
        this._options = $.extend({
          showAccountLink: true,
          accountLink: 'http://my.kosmosnimki.ru/Home/Settings/',
          showMapLink: true,
          changePassword: false
          /* mapLink */

        }, options);

        this._authManager.getUserInfo().then(function (response) {
          this._render({
            login: response.Result && response.Result.Login,
            userName: response.Result && (response.Result.FullName || response.Result.Nickname || response.Result.Login)
          });

          this._userInfo = response.Result;
          $(this).trigger('ready');
        }.bind(this)).fail(function (response) {
          this._render(response);
        }.bind(this));
      };

      AuthWidget.prototype._render = function (vm) {

        this._view.html(Handlebars.compile(nsGmx$1.Templates.AuthWidget.authWidget)(vm));

        if (vm.userName) {
          var dropdownItems = [];

          if (this._options.showAccountLink) {
            dropdownItems.push({
              title: nsGmx$1.Translations.getText('auth.myAccount'),
              link: this._options.accountLink,
              id: 'AuthWidgetAccountLink',
              newWindow: true
            });
          }

          if (this._options.showMapLink) {
            var defaultMapLink = 'http://maps.kosmosnimki.ru/api/index.html?' + encodeURIComponent('@' + vm.login);
            dropdownItems.push({
              title: nsGmx$1.Translations.getText('auth.myMap'),
              link: this._options.mapLink || defaultMapLink,
              id: 'AuthWidgetMapLink',
              newWindow: true
            });
          }

          if (this._options.changePassword) {
            dropdownItems.push({
              title: nsGmx$1.Translations.getText('auth.changePassword'),
              className: 'authWidget-changePasswordButton'
            });
          }

          if (this._options.isAdmin) {
            dropdownItems.push({
              title: nsGmx$1.Translations.getText('Системные настройки'),
              link: window.serverBase + 'Administration/Actions.aspx',
              id: 'AuthWidgetAdminLink',
              newWindow: true
            });
            dropdownItems.push({
              title: nsGmx$1.Translations.getText('Управление группами'),
              link: 'javascript:void(0)',
              className: 'authWidget-usergroupMenuItem'
            });
          }

          dropdownItems.push({
            title: nsGmx$1.Translations.getText('auth.logout'),
            className: 'authWidget-logoutButton'
          });
          var dropdownMenuWidget = new nsGmx$1.DropdownMenuWidget({
            items: [{
              title: vm.userName,
              dropdown: dropdownItems
            }]
          });
          dropdownMenuWidget.appendTo(this._view.find('.authWidget-userPanel-userMenuCell'));
        }

        this._view.find('.authWidget-usergroupMenuItem').click(function (e) {
          if (this._options.callbacks && 'authWidget-usergroupMenuItem' in this._options.callbacks) {
            this._options.callbacks['authWidget-usergroupMenuItem']();
          } else {
            return false;
          }
        }.bind(this));

        this._view.find('.authWidget-changePasswordButton').click(function (e) {
          var _native = this._authManager.getNative();

          _native.changePasswordDialog();
        }.bind(this));

        this._view.find('.authWidget-loginButton').click(function (e) {
          var $iframeContainer;

          if (this._options.loginDialog) {
            $iframeContainer = $('<div>').addClass('authWidget-iframeContainer');
            var dialog = $iframeContainer.dialog({
              width: 500,
              height: 450,
              closeText: nsGmx$1.Translations.getText('auth.closeDialog'),
              close: function close(je, ui) {
                $(this).dialog('destroy');
              }
            }); // HACK:

            $(dialog).parent().find('button.ui-button').addClass('ui-icon').css('outline', 'none');
          }

          this._authManager.login({
            iframeContainer: $iframeContainer && $iframeContainer[0]
          });
        }.bind(this));

        this._view.find('.authWidget-logoutButton').click(function (e) {
          this._authManager.logout().then(function (response) {
            this._render(response);

            this._userInfo = response.Result;
            $(this).trigger('logout');
          }.bind(this));
        }.bind(this));
      };
      /** Получить информацию о пользователе, которую вернул AuthManager
       * @return {Object}
       */


      AuthWidget.prototype.getUserInfo = function () {
        return this._userInfo;
      };

      AuthWidget.prototype.on = function (eventName, callback) {
        $(this).on(eventName, callback);
      };

      AuthWidget.prototype.appendTo = function (placeholder) {
        placeholder.append(this._view);
      };

      return AuthWidget;
    }();
    nsGmx$1.Translations.addText('rus', {
      auth: {
        'login': 'Войти',
        'logout': 'Выйти',
        'myAccount': 'Личный кабинет',
        'changePassword': 'Сменить пароль',
        'myMap': 'Личная карта',
        'closeDialog': 'Закрыть'
      }
    });
    nsGmx$1.Translations.addText('eng', {
      auth: {
        'login': 'Login',
        'logout': 'Logout',
        'myAccount': 'My account',
        'changePassword': 'Change password',
        'myMap': 'My map',
        'closeDialog': 'Close'
      }
    });

    /** Виджет для визуализации информации о текущем статусе пользователя.
    * Показывает кнопки Вход/Выход, имя пользователя. Позволяет отослать логин/пароль на сервер, сменить пароль.
     @memberOf nsGmx
     @class
     @name GeoMixerAuthWidget
    */

    (function ($, _) {
      var _dialogCanvas = null;

      function changePasswordDialog() {
        if ($('#changePasswordCanvas').length) return;

        var oldInput = _input$1(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '160px'], ['attr', 'type', 'password']]),
            newInput = _input$1(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '160px'], ['attr', 'type', 'password']]),
            confirmInput = _input$1(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '160px'], ['attr', 'type', 'password']]),
            changeButton = makeButton(_gtxt("Изменить")),
            canvas = _div$1([_div$1([_span$1([_t(_gtxt("Старый пароль"))]), _br$1(), oldInput, _br$1(), _span$1([_t(_gtxt("Новый пароль"))]), _br$1(), newInput, _br$1(), _span$1([_t(_gtxt("Подтвердите пароль"))]), _br$1(), confirmInput, _br$1()], [['css', 'textAlign', 'center']]), _div$1([changeButton], [['css', 'textAlign', 'center'], ['css', 'margin', '5px']])], [['attr', 'id', 'changePasswordCanvas']]),
            checkPassw = function checkPassw() {
          if (newInput.value != confirmInput.value) {
            newInput.value = '';
            confirmInput.value = '';
            inputError([newInput, confirmInput], 2000);
            newInput.focus();
            return;
          }

          nsGmx$1.widgets.notifications.startAction('changePassword');
          nsGmx$1.AuthManager.changePassword(oldInput.value, newInput.value, function () {
            jQuery(canvas.parentNode).dialog("destroy");
            canvas.parentNode.removeNode(true);
            nsGmx$1.widgets.notifications.stopAction('changePassword', 'success', _gtxt('Пароль изменён'));
          }, function (message) {
            message && showErrorMessage(message, true);
            nsGmx$1.widgets.notifications.stopAction('changePassword', 'failure');
          });
          oldInput.value = '';
          newInput.value = '';
          confirmInput.value = '';
        };

        showDialog(_gtxt("Изменение пароля"), canvas, 200, 200, false, false);
        canvas.parentNode.style.overflow = 'hidden';
        oldInput.focus();

        changeButton.onclick = function () {
          checkPassw();
        };

        $(confirmInput).on('keyup', function (e) {
          if (e.keyCode === 13) {
            checkPassw();
            return false;
          }

          return true;
        });
      }

      var loginDialogTemplate = '<div>' + '<div class = "loginMainDiv">' + '<form>' + '<div>' + '<span class="loginLabel">{{i "Логин"}}</span><br>' + '<input name="login" class = "inputStyle inputLogin" placeholder = "{{i "адрес электронной почты"}}"><br>' + '</div>' + '<div>' + '<span class="loginLabel">{{i "Пароль"}}</span><br>' + '<input name="password" class = "inputStyle inputPass" type = "password" placeholder = "{{i "пароль"}}"><br>' + '</div>' + '<button class="loginButton">{{i "Вход"}}</button>' + '</form>' + '</div>' + '{{#isMapsSite}}' + '<div class="loginLinks">' + '<span class = "buttonLink registration">{{i "Регистрация"}}</span><br>' + '<span class = "buttonLink passRecovery">{{i "Восстановление пароля"}}</span>' + '</div>' + '{{/isMapsSite}}' + '</div>';

      nsGmx$1.GeoMixerAuthWidget = function (container, authManager, loginCallback, options) {
        var _container = container;
        var _authManager = authManager;

        var _this = this;

        _this.changePasswordDialog = changePasswordDialog;
        options = options || {};

        var _createLogin = function _createLogin() {
          var span = makeLinkButton$1(_gtxt('Вход'));

          span.onclick = function () {
            _this.showLoginDialog(loginCallback);
          };

          _(_container, [_div$1([span], [['attr', 'id', 'log'], ['dir', 'className', 'log']])]);
        };

        var _createLogout = function _createLogout() {
          var logoutSpan = makeLinkButton$1(_gtxt('Выход'));

          logoutSpan.onclick = function () {
            _authManager.logout(function () {
              if (nsGmx$1.GeomixerFramework) _mapHelper.reloadMap();else window.location.replace(window.location.href.split("?")[0] + (defaultMapID == globalMapName ? "" : "&" + globalMapName));
            });
          };

          var userText = _authManager.getLogin();

          if (_authManager.getFullname() !== null && _authManager.getFullname() !== '') userText += ' (' + _authManager.getFullname() + ')';

          var userSpan = _span$1([_t(userText)], [['css', 'cursor', 'pointer']]);

          userSpan.onclick = function () {
            if (_authManager.isAccounts()) {
              if (window.gmxAuthServer) window.open(window.gmxAuthServer + "Account/ChangePassword", '_blank');
            } else changePasswordDialog();
          };

          if (_authManager.isAccounts()) $(userSpan).css('color', '#5555FF');

          _title$1(userSpan, _gtxt("Изменение пароля"));

          _(_container, [_table([_tr([_td([_div$1([userSpan], [['attr', 'id', 'user'], ['dir', 'className', 'user']])]), _td([_div$1([logoutSpan], [['attr', 'id', 'log'], ['dir', 'className', 'log']])])])])]);
        };

        var _update = function _update() {
          if (window.gmxViewerUI && window.gmxViewerUI.hideLogin) return;
          $(_container).empty();

          if (_authManager.isLogin()) {
            _createLogout();
          } else {
            _createLogin();
          }
        };

        $(_authManager).change(_update);

        _update(); //Показывает диалог с вводом логина/пароля, посылает запрос на сервер.


        this.showLoginDialog = function () {
          if (_dialogCanvas) {
            return;
          }

          var isMapsSite = !!window.mapsSite;
          var dialogHeight = isMapsSite ? 210 : 175;
          var canvas = $(Handlebars.compile(loginDialogTemplate)({
            isMapsSite: isMapsSite
          })),
              loginInput = canvas.find('.inputLogin')[0],
              passwordInput = canvas.find('.inputPass')[0],
              loginButton = canvas.find('.loginButton')[0];

          var checkLogin = function checkLogin() {
            _authManager.login(loginInput.value, passwordInput.value, function () {
              //всё хорошо
              $(jQueryDialog).dialog("destroy");
              jQueryDialog.removeNode(true);
              _dialogCanvas = null;
              loginCallback && loginCallback();
            }, function (err) {
              //ошибка
              if (err.emailWarning) {
                var errorDiv = $("<div/>", {
                  'class': 'EmailErrorMessage'
                }).text(err.message);
                $(loginButton).after(errorDiv);
                setTimeout(function () {
                  errorDiv.hide(500, function () {
                    errorDiv.remove();
                  });
                }, 8000);
              }

              loginInput.value = '';
              passwordInput.value = '';
              inputError([loginInput, passwordInput], 2000);
              loginInput.focus();
            });
          };

          _dialogCanvas = canvas;
          var jQueryDialog = showDialog(_gtxt("Пожалуйста, авторизуйтесь"), canvas[0], 248, dialogHeight, false, false, null, function () {
            _dialogCanvas = null;
          });
          loginInput.focus();
          loginButton.onclick = checkLogin;
          canvas.find('form').submit(function (e) {
            e.preventDefault();
          });
          canvas.find('.registration').click(options.registrationCallback || function () {
            window.open(window.gmxAuthServer + 'Account/Registration', '_blank');
          });
          canvas.find('.passRecovery').click(function () {
            window.open(window.gmxAuthServer + 'Account/Retrive', '_blank');
          });
          $(passwordInput).on('keyup', function (e) {
            if (e.keyCode === 13) {
              checkLogin();
              return false;
            }

            return true;
          });
        };

        this.getContainer = function () {
          return _container;
        };
      }; // Обратная совместимость. Проверка нужна из-за возможного конфликта с одноимённым классом из общих компонент


      if (!nsGmx$1.AuthWidget) {
        nsGmx$1.AuthWidget = nsGmx$1.GeoMixerAuthWidget;
      }
    })(jQuery, nsGmx$1.Utils._);

    var _$3 = nsGmx$1.Utils._;
    /**
    * @namespace DrawingObjects
    * @description SDK для редактирования объектов на карте
    */

    nsGmx$1.Translations.addText('rus', {
      drawingObjects: {
        editStyleTitle: 'Редактировать стиль',
        removeObject: 'Удалить',
        pointTitle: 'точка',
        lineTitle: 'линия',
        polygonTitle: 'многоугольник',
        rectangleTitle: 'прямоугольник',
        removeAll: 'Очистить',
        downloadShp: 'shp',
        downloadGeoJSON: 'geojson',
        downloadGpx: 'gpx',
        downloadCsv: 'csv',
        downloadNameTitle: 'Введите имя файла для скачивания',
        download: 'Скачать файл',
        downloadRaster: 'Скачать фрагмент растра',
        noRectangleError: 'Выберите область рамкой на карте',
        noRasterError: 'К прямоугольнику не подходит ни одного растрового слоя',
        edit: {
          border: 'Граница',
          color: 'Цвет',
          transparency: 'Прозрачность',
          lineWidth: 'Толщина линии',
          description: 'Описание',
          title: 'Редактирование стиля объекта'
        }
      }
    });
    nsGmx$1.Translations.addText('eng', {
      drawingObjects: {
        editStyleTitle: 'Edit style',
        removeObject: 'Delete',
        pointTitle: 'point',
        lineTitle: 'line',
        polygonTitle: 'polygon',
        rectangleTitle: 'rectangle',
        removeAll: 'Delete',
        downloadShp: 'shp',
        downloadGeoJSON: 'geojson',
        downloadGpx: 'gpx',
        downloadCsv: 'csv',
        downloadNameTitle: 'Enter file name to download',
        download: 'Download file',
        downloadRaster: 'Download fragment of raster',
        noRectangleError: 'Select region using frame',
        noRasterError: 'No one raster layer fit the rectangle',
        edit: {
          border: 'Outline',
          color: 'Color',
          transparency: 'Transparency',
          lineWidth: 'Line thickness',
          description: 'Description',
          title: 'Object style editing'
        }
      }
    });

    var setDrawingFeatureStyle = function setDrawingFeatureStyle(drawingFeature, templateStyle) {
      var color = '#' + L.gmxUtil.dec2hex(templateStyle.outline.color),
          opacity = templateStyle.outline.opacity / 100;
      drawingFeature.setOptions({
        lineStyle: {
          color: color,
          opacity: opacity,
          weight: templateStyle.outline.thickness
        },
        pointStyle: {
          color: color,
          opacity: opacity
        }
      });
    };

    var CreateDrawingStylesEditorIcon = function CreateDrawingStylesEditorIcon(style, type) {
      var icon = nsGmx$1.Controls.createGeometryIcon(style, type);

      _title$1(icon, _gtxt('drawingObjects.editStyleTitle'));

      return icon;
    };

    var CreateDrawingStylesEditor = function CreateDrawingStylesEditor(parentObject, style, elemCanvas) {
      var templateStyle = {};
      var jQueryDialog = null;
      $.extend(true, templateStyle, style);

      elemCanvas.onclick = function () {
        if (jQueryDialog) {
          return;
        }

        var canvas = _div$1(null, [['css', 'marginTop', '10px']]),
            outlineParent = _tr$1(),
            outlineTitleTds = [],
            outlineTds = [];

        outlineTitleTds.push(_td$1([_t$1(_gtxt('drawingObjects.edit.border'))], [['css', 'width', '70px']]));
        var outlineColor = nsGmx$1.Controls.createColorPicker(templateStyle.outline.color, function (colpkr) {
          $(colpkr).fadeIn(500);
          return false;
        }, function (colpkr) {
          $(colpkr).fadeOut(500);
          return false;
        }, function (hsb, hex, rgb) {
          outlineColor.style.backgroundColor = '#' + hex;
          templateStyle.outline.color = outlineColor.hex = parseInt('0x' + hex);
          $(elemCanvas).find(".borderIcon")[0].style.borderColor = '#' + hex;
          setDrawingFeatureStyle(parentObject, templateStyle);
        });
        outlineColor.hex = templateStyle.outline.color;

        _title$1(outlineColor, _gtxt('drawingObjects.edit.color'));

        outlineTds.push(_td$1([outlineColor], [['css', 'width', '40px']]));
        var divSlider = nsGmx$1.Controls.createSlider(templateStyle.outline.opacity, function (event, ui) {
          templateStyle.outline.opacity = ui.value;
          setDrawingFeatureStyle(parentObject, templateStyle);
        });

        _title$1(divSlider, _gtxt('drawingObjects.edit.transparency'));

        outlineTds.push(_td$1([divSlider], [['css', 'width', '100px'], ['css', 'padding', '4px 5px 3px 5px']]));

        var outlineThick = nsGmx$1.Controls.createInput(templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined' ? templateStyle.outline.thickness : 2, function () {
          templateStyle.outline.thickness = Number(this.value);
          setDrawingFeatureStyle(parentObject, templateStyle);
          return true;
        }),
            closeFunc = function closeFunc() {
          var newIcon = CreateDrawingStylesEditorIcon(templateStyle, parentObject.toGeoJSON().geometry.type.toLowerCase());
          CreateDrawingStylesEditor(parentObject, templateStyle, newIcon);
          $(elemCanvas).replaceWith(newIcon);
          $(canvas).find(".colorSelector").each(function () {
            $('#' + $(this).data("colorpickerId")).remove();
          });
        };

        _title$1(outlineThick, _gtxt('drawingObjects.edit.lineWidth'));

        outlineTds.push(_td$1([outlineThick], [['css', 'width', '30px']]));

        _$3(outlineParent, outlineTitleTds.concat(_td$1([_div$1([_table$1([_tbody$1([_tr$1(outlineTds)])])], [['attr', 'fade', true]])])));

        var text = _input(null, [['attr', 'value', parentObject.options.title || ""], ['dir', 'className', 'inputStyle'], ['css', 'width', '180px']]);

        $(text).on('keyup', function (evt) {
          if (evt.keyCode === 13) {
            $(jQueryDialog).dialog('destroy');
            return;
          }

          parentObject.setOptions({
            title: this.value
          });
          $(parentObject).triggerHandler('onEdit', [parentObject]);
          return true;
        });

        _$3(canvas, [_table$1([_tbody$1([_tr$1([_td$1([_t$1(_gtxt('drawingObjects.edit.description'))], [['css', 'width', '70px']]), _td$1([text])])])]), _br(), _table$1([_tbody$1([outlineParent])])]);

        var pos = nsGmx$1.Utils.getDialogPos(elemCanvas, false, 80);
        jQueryDialog = showDialog(_gtxt('drawingObjects.edit.title'), canvas, 280, 130, pos.left, pos.top, false, closeFunc);
        $(jQueryDialog).addClass('drawing-object-leaflet-id-' + parentObject._leaflet_id);
      };

      elemCanvas.getStyle = function () {
        return templateStyle;
      };
    };
    /** Конструктор
     @class Коллекция нарисованных объектов
     @memberOf DrawingObjects
     @param oInitMap Карта, из которой будут добавляться объекты в коллекцию
    */


    var DrawingObjectCollection = function DrawingObjectCollection(oInitMap) {
      var _objects = []; //{item:, editID: , removeID: }

      var _this = this;

      var onEdit = function onEdit(drawingObject) {
        /** Вызывается при изменении объекта в коллекции
        @name DrawingObjects.DrawingObjectCollection.onEdit
        @event
        @param {drawingObject} drawingObject изменённый объект*/
        $(_this).triggerHandler('onEdit', [drawingObject]);
      };

      var onRemove = function onRemove(drawingObject) {
        _this.Remove(drawingObject);
      };
      /** Возвращает элемент по номеру
      @param {int} index № объекта в коллекции*/


      this.Item = function (index) {
        return _objects[index].item;
      };
      /** Возвращает количество элементов в коллекции*/


      this.Count = function () {
        return _objects.length;
      };
      /** Добавляет объект в коллекцию
      @param {drawingObject} drawingObject Добавляемый объект*/


      this.Add = function (drawingObject) {
        var editID = drawingObject.on('edit', function () {
          onEdit(drawingObject);
        });
        var removeID = drawingObject.on('remove', function () {
          onRemove(drawingObject);
        });

        _objects.push({
          item: drawingObject,
          editID: editID,
          removeID: removeID
        });
        /** Вызывается при добавлении объекта в коллекцию
        @name DrawingObjects.DrawingObjectCollection.onAdd
        @event
        @param {drawingObject} drawingObject добавленный объект*/


        $(this).triggerHandler('onAdd', [drawingObject]);
      };
      /** Удаляет объект из коллекции
      @param {int} index индекс удаляемого объекта*/


      this.RemoveAt = function (index) {
        var obj = _objects.splice(index, 1)[0];
        /** Вызывается при удалении объекта из коллекции
        @name DrawingObjects.DrawingObjectCollection.onRemove
        @event
        @param {int} index индекс удаляённого объекта*/


        $(this).triggerHandler('onRemove', [index]);
      };
      /** Удаляет объект из коллекции
      @param {drawingObject} drawingObject удаляемый объект*/


      this.Remove = function (drawingObject) {
        for (var i = 0; i < _objects.length; i++) {
          if (_objects[i].item === drawingObject) this.RemoveAt(i);
        }
      };
      /** Получить индекс объекта в коллекции. null, если объект не найден
      @param {drawingObject} drawingObject объект, индекс которого мы хотим найти*/


      this.getIndex = function (drawingObject) {
        for (var i = 0; i < _objects.length; i++) {
          if (_objects[i].item === drawingObject) return i;
        }

        return null;
      };
    };
    /** Конструктор
     @class Строка с описанием объекта и ссылкой на него
     @description К строке биндится контекстное меню типа "DrawingObject"
     @memberOf DrawingObjects
     @param {L.Map} oInitMap Карта Leaflet
     @param oInitContainer Объект, в котором находится контрол (div)
     @param drawingObject Объект для добавления на карту
     @param options дополнительные параметры
     @param {bool} [options.allowDelete=true] рисовать ли крестик удаления объекта
     @param {bool} [options.editStyle=true] нужна ли возможность редактировать стили
     @param {function(DrawingObject)} [options.click] ф-ция, которая будет вызвана при клике на объекте.
            По умолчанию - центрирование карты на объекте.
    */


    var DrawingObjectInfoRow = function DrawingObjectInfoRow(oInitMap, oInitContainer, drawingObject, options) {
      var defaultClickFunction = function defaultClickFunction(obj) {
        var geom = obj.toGeoJSON().geometry;
        var coords = geom.coordinates;

        if (geom.type == "Point") {
          _map.setView([coords[1], coords[0]], Math.max(14, _map.getZoom()));
        } else {
          _map.fitBounds(drawingObject.getBounds());
        }
      };

      var _options = $.extend({
        allowDelete: true,
        editStyle: true,
        click: defaultClickFunction
      }, options);

      var _drawingObject = drawingObject;

      var _this = this;

      var _map = oInitMap;

      var _canvas = _div$1(null, [['dir', 'className', 'drawingObjectsItemCanvas']]);

      var _title = _span$1(null, [['dir', 'className', 'drawingObjectsItemTitle']]);

      var _text = _span$1(null, [['dir', 'className', 'drawingObjectsItemTitle']]);

      var _summary = _span$1(null, [['dir', 'className', 'summary']]);

      if (_options.click) {
        _canvas.onclick = function (e) {
          if (e.target !== remove && (!_options.editStyle || e.target !== icon)) {
            _options.click(_drawingObject);
          }
        };
      }

      var lineOptions = _drawingObject.options.lineStyle || L.GmxDrawing.utils.defaultStyles.lineStyle;
      var icon = null;

      var geom = _drawingObject.toGeoJSON().geometry;

      if (_options.editStyle) {
        if (geom.type == "Point") {
          icon = _img(null, [['attr', 'src', (window.gmxJSHost || '') + 'img/flag_min.png'], ['dir', 'className', 'colorIcon']]);
        } else {
          var regularDrawingStyle = {
            outline: {
              color: parseInt('0x' + lineOptions.color.split('#')[1]),
              thickness: lineOptions.weight,
              opacity: lineOptions.opacity * 100
            }
          };
          icon = CreateDrawingStylesEditorIcon(regularDrawingStyle, geom.type.toLowerCase());
          CreateDrawingStylesEditor(_drawingObject, regularDrawingStyle, icon);
        }
      } else icon = _span$1(null, [['dir', 'className', geom.type + (L.gmxUtil.isRectangle(geom.coordinates) ? ' RECTANGLE' : '')]]);

      var remove = _span$1();

      if (_options.allowDelete) {
        remove.setAttribute('title', _gtxt('drawingObjects.removeObject'));
        remove.className = 'gmx-icon-close';

        remove.onclick = function () {
          $(_this).triggerHandler('onRemove', [_drawingObject]);
        };
      }

      _$3(_canvas, [_span$1([icon, _title, _text, _summary], [['dir', 'className', 'drawingObjectsItem']]), remove]);

      _$3(oInitContainer, [_canvas]);

      this._mouseOverHandler = function () {
        $(_canvas).addClass('drawingObjectsActiveItemCanvas');
      };

      this._mouseOutHandler = function () {
        $(_canvas).removeClass('drawingObjectsActiveItemCanvas');
      };

      _drawingObject.on('mouseover', this._mouseOverHandler);

      _drawingObject.on('mouseout', this._mouseOutHandler);
      /** Обновляет информацию о геометрии */


      this.UpdateRow = function () {
        var summary = _drawingObject.getSummary(),
            text = _drawingObject.options.title,
            type = _drawingObject.getType();

        $(_title).empty();
        $(_text).empty();
        $(_summary).empty();

        if (type === 'Point') {
          _$3(_title, [_t$1(_gtxt('drawingObjects.pointTitle'))]);

          _$3(_summary, [_t$1("(" + summary + ")")]);
        } else if (type === 'Polyline' || type === 'MultiPolyline') {
          _$3(_title, [_t$1(_gtxt('drawingObjects.lineTitle'))]);

          _$3(_summary, [_t$1("(" + summary + ")")]);
        } else if (type === 'Polygon' || type === 'MultiPolygon' || type === 'Rectangle') {
          _$3(_title, [_t$1(type === 'Rectangle' ? _gtxt('drawingObjects.rectangleTitle') : _gtxt('drawingObjects.polygonTitle'))]);

          _$3(_summary, [_t$1("(" + summary + ")")]);
        }

        _$3(_text, [_t$1(text ? text.replace(/<[^<>]*>/g, " ") : "")]);

        if (text) _title.style.display = 'none';else _title.style.display = '';
      };
      /** Удаляет строчку */


      this.RemoveRow = function () {
        if (_canvas.parentNode) _canvas.parentNode.removeChild(_canvas);
        if (_drawingObject === null) return;

        _drawingObject.off('edit', this.UpdateRow);

        _drawingObject.off('remove', this.RemoveRow);

        _drawingObject.off('mouseover', this._mouseOverHandler);

        _drawingObject.off('mouseout', this._mouseOutHandler);

        _drawingObject = null;
      };
      /** Удаляет строчку */


      this.getContainer = function () {
        return _canvas;
      };

      if (nsGmx$1 && nsGmx$1.ContextMenuController) {
        nsGmx$1.ContextMenuController.bindMenuToElem(_title, 'DrawingObject', function () {
          return true;
        }, {
          obj: _drawingObject
        });
      }

      this.getDrawingObject = function () {
        return _drawingObject;
      };

      _drawingObject.on('edit', this.UpdateRow);

      _drawingObject.on('remove', this.RemoveRow);

      this.UpdateRow();
    };
    /** Конструктор
     @class Контрол для отображения коллекции пользовательских объектов
     @memberOf DrawingObjects
     @param oInitMap Карта
     @param {documentElement} oInitContainer Объект, в котором находится контрол (div)
     @param {DrawingObjects.DrawingObjectCollection} oInitDrawingObjectCollection Коллекция пользовательских объектов
     @param {Object} options Дополнительные параметры.Включает все доп. параметры DrawingObjectInfoRow
     @param {bool} [options.showButtons=true] показывать ли кнопки под списком
     @param {selectedIndex} [options.selectedIndex=null] индекс выбранного элемента
    */


    var DrawingObjectList = function DrawingObjectList(oInitMap, oInitContainer, oInitDrawingObjectCollection, options) {
      var _options = $.extend({
        showButtons: true,
        selectedIndex: null
      }, options);

      var _this = this;

      var _rows = [];
      var _containers = [];
      var _map = oInitMap;
      var _collection = oInitDrawingObjectCollection;

      var _divList = _div$1(null, [['dir', 'className', 'DrawingObjectList']]);

      var _divButtons = _div$1();
      /** Добавляет объект в "список объектов на карте"
      @param {drawingObject} drawingObject добавляемый объект */


      var add = function add(drawingObject) {
        var divRow = _div$1();

        _$3(_divList, [divRow]);

        var row = new DrawingObjectInfoRow(_map, divRow, drawingObject, options);

        _containers.push(divRow);

        _rows.push(row);

        $(row).bind('onRemove', function () {
          drawingObject.remove();
        });
        if (_collection.Count() == 1 && _options.showButtons) show$1(_divButtons);
        /** В списке мышь переместилась над объект
        @name DrawingObjects.DrawingObjectList.mouseover
        @event
        @param {drawingObject} drawingObject объект, над которым находится мышь*/

        /** В списке мышь переместилась с объекта
        @name DrawingObjects.DrawingObjectList.mouseout
        @event
        @param {drawingObject} drawingObject объект, с которого переместилась мышь*/

        $(divRow).bind({
          mouseover: function mouseover() {
            $(_this).triggerHandler('mouseover', [drawingObject]);
          },
          mouseout: function mouseout() {
            $(_this).triggerHandler('mouseout', [drawingObject]);
          }
        });
      };

      var onRemove = function onRemove(event, index) {
        if (_collection.Count() == 0) hide$1(_divButtons);

        var removedDiv = _containers.splice(index, 1)[0];

        _rows.splice(index, 1);

        removedDiv.parentNode && removedDiv.parentNode.removeChild(removedDiv);

        if (index === _selectedIndex) {
          _selectedIndex = null;
        } else if (index < _selectedIndex) {
          _selectedIndex--;
        }
      };

      $(_collection).bind('onRemove', onRemove);
      $(_collection).bind('onAdd', function (event, drawingObject) {
        add(drawingObject);
      });

      for (var i = 0; i < _collection.Count(); i++) {
        add(_collection.Item(i));
      }
      /** Очищает список пользовательских объектов*/


      this.Clear = function () {
        while (_collection.Count() > 0) {
          _collection.Item(0).remove();
        }

        _selectedIndex = null;
      };
      /** Возвращает div, в котором находится кнопка "Очистить" и который не виден при пустой коллекции */


      this.GetDivButtons = function () {
        return _divButtons;
      };

      var delAll = makeLinkButton$1(_gtxt('drawingObjects.removeAll'));
      delAll.onclick = this.Clear;

      _$3(_divButtons, [_div$1([delAll])]);

      _$3(oInitContainer, [_divList, _divButtons]);

      if (_collection.Count() == 0 || !_options.showButtons) hide$1(_divButtons);
      var _selectedIndex = null;
      /** Устанавливает выбранный элемент списка пользовательских объектов.
          null - нет активного. Неправильные индексы игнорируются. К контейнеру выбранного элемента добавляется класс drawingObjectsSelectedItemCanvas
      */

      this.setSelection = function (selectedIndex) {
        var isValidIndex = !!_rows[selectedIndex] || selectedIndex === null;

        if (selectedIndex === _selectedIndex || !isValidIndex) {
          return _selectedIndex;
        }

        if (_rows[_selectedIndex]) {
          $(_rows[_selectedIndex].getContainer()).removeClass('drawingObjectsSelectedItemCanvas');
        }

        if (_rows[selectedIndex]) {
          $(_rows[selectedIndex].getContainer()).addClass('drawingObjectsSelectedItemCanvas');
        }

        _selectedIndex = selectedIndex;
        return _selectedIndex;
      };
      /** Возвращает индекс выбранного элемента списка пользовательских объектов, null - если нет выбранного*/


      this.getSelection = function () {
        return _selectedIndex;
      };

      this.setSelection(_options.selectedIndex);
    };
    /** Конструктор
     @memberOf DrawingObjects
     @class Встраивает список объектов на карте в геомиксер*/


    var DrawingObjectGeomixer = function DrawingObjectGeomixer() {
      var _this = this;

      var oMap = null;
      var gmxMap = null;
      var oMenu = new leftMenu$1();

      var oListDiv = _div$1(null, [['dir', 'className', 'DrawingObjectsLeftMenu']]);

      var bVisible = false;
      var oCollection = null;
      /** Вызывается при скрывании меню*/

      this.Unload = function () {
        bVisible = false;
      };
      /** Загружает меню*/


      this.Load = function () {
        if (oMenu != null) {
          var alreadyLoaded = oMenu.createWorkCanvas("DrawingObjects", this.Unload);
          if (!alreadyLoaded) _$3(oMenu.workCanvas, [oListDiv]);
        }

        bVisible = true;
      };

      var fnAddToCollection = function fnAddToCollection(ev) {
        var feature = ev.object;

        if (!nsGmx$1.DrawingObjectCustomControllers || !nsGmx$1.DrawingObjectCustomControllers.isHidden(feature)) {
          oCollection.Add(feature);
        }
      };

      var checkDownloadVisibility = function checkDownloadVisibility() {
        var isAnyRectangle = false,
            isNonPolygon = false;

        for (var i = 0; i < oCollection.Count(); i++) {
          var feature = oCollection.Item(i);
          var geom = feature.toGeoJSON().geometry;
          isAnyRectangle = isAnyRectangle || L.gmxUtil.isRectangle(geom.coordinates);
          isNonPolygon = isNonPolygon || geom.type !== 'Polygon';
        }

        $(downloadContainer).toggle(oCollection.Count() > 0);
        $(downloadRaster).toggle(gmxMap.properties.CanDownloadRasters && isAnyRectangle);
        $(downloadGpx).toggle(isNonPolygon);
      };

      var downloadFormat = null;
      var downloadShp = makeLinkButton$1(_gtxt('drawingObjects.downloadShp'));

      downloadShp.onclick = function () {
        downloadFormat = 'Shape';
        downloadNameContainer.toggle();
      };

      downloadShp.style.margin = '0px 3px';
      var downloadGeoJSON = makeLinkButton$1(_gtxt('drawingObjects.downloadGeoJSON'));

      downloadGeoJSON.onclick = function () {
        downloadFormat = 'GeoJSON';
        downloadNameContainer.toggle();
      };

      downloadGeoJSON.style.margin = '0px 3px';
      var downloadGpx = makeLinkButton$1(_gtxt('drawingObjects.downloadGpx'));

      downloadGpx.onclick = function () {
        downloadFormat = 'gpx';
        downloadNameContainer.toggle();
      };

      downloadGpx.style.margin = '0px 3px';
      var downloadCsv = makeLinkButton$1(_gtxt('drawingObjects.downloadCsv'));

      downloadCsv.onclick = function () {
        downloadFormat = 'csv_wkt';
        downloadNameContainer.toggle();
      };

      downloadCsv.style.margin = '0px 3px';
      var downloadNameInput = $('<input/>', {
        title: _gtxt('drawingObjects.downloadNameTitle')
      }).val('markers').addClass('inputStyle');
      downloadNameInput.keyup(function (e) {
        if (e.keyCode == 13) {
          downloadNameButton.click();
        }
      });
      var downloadNameButton = $('<input/>', {
        type: 'button'
      }).val(_gtxt('drawingObjects.download')).addClass('btn').click(function () {
        downloadMarkers(downloadNameInput.val(), downloadFormat);
        downloadNameContainer.hide();
        downloadFormat = null;
      });
      var downloadNameContainer = $('<div/>').append(downloadNameInput, downloadNameButton).hide();
      var downloadRasterOptions = $('<div class="drawingObjectsDownloadRaster">' + '<label><input type="radio" name="rasterFormat" checked value="univers">jpeg + georefernce</label>' + '<label><input type="radio" name="rasterFormat" value="garmin">kmz (Garmin Custom Maps)</label>' + '<button id="downloadRaster" class="btn">' + _gtxt('drawingObjects.download') + '</button>' + '</div>').hide();
      $('#downloadRaster', downloadRasterOptions).click(function () {
        var checkInfo = checkRasterLayer();

        if (checkInfo) {
          var bounds = checkInfo.bounds,
              layer = checkInfo.layer,
              format = $('input:checked', downloadRasterOptions).val(),
              temporalParam = "",
              props = layer.getGmxProperties();

          if (props.Temporal) {
            var dateInterval = layer.getDateInterval();

            if (dateInterval) {
              var dateBeginStr = nsGmx$1.Utils.convertFromServer('date', dateInterval.beginDate / 1000),
                  dateEndStr = nsGmx$1.Utils.convertFromServer('date', dateInterval.endDate / 1000);
              temporalParam = "&StartDate=" + encodeURIComponent(dateBeginStr) + "&EndDate=" + encodeURIComponent(dateEndStr);
            }
          }

          var truncate9 = function truncate9(x) {
            return ("" + x).substring(0, 9);
          };

          window.location.href = window.location.protocol + "//" + props.hostName + "/DownloadLayer.ashx" + "?t=" + props.name + "&MinX=" + truncate9(bounds.getWest()) + "&MinY=" + truncate9(bounds.getSouth()) + "&MaxX=" + truncate9(bounds.getEast()) + "&MaxY=" + truncate9(bounds.getNorth()) + "&Format=" + format + temporalParam;
        }
      });
      var downloadRaster = makeLinkButton$1(_gtxt('drawingObjects.downloadRaster'));

      downloadRaster.onclick = function () {
        if (downloadRasterOptions.find(':visible').length || checkRasterLayer()) {
          downloadRasterOptions.toggle();
        }
      };

      var downloadContainer = _div$1();
      /** Встраивает список объектов на карте в геомиксер*/


      this.Init = function (leafletMap, initGmxMap) {
        oMap = leafletMap;
        gmxMap = initGmxMap;
        oCollection = new DrawingObjectCollection(leafletMap);
        $(oCollection).bind('onAdd', function () {
          if (!bVisible) _this.Load();
        });
        $(oCollection).bind('onRemove', function () {
          oCollection.Count() || oMenu.leftPanelItem.close();
        });
        var lmap = nsGmx$1.leafletMap,
            gmxDrawing = lmap.gmxDrawing,
            features = gmxDrawing.getFeatures();
        features.map(function (ret) {
          fnAddToCollection(ret);
        });
        lmap.gmxDrawing.on('add', fnAddToCollection);
        $(oCollection).bind('onRemove onAdd', checkDownloadVisibility);
        var oDrawingObjectList = new DrawingObjectList(oMap, oListDiv, oCollection);

        _$3(downloadContainer, [_div$1([_span$1([_t$1(_gtxt('drawingObjects.download'))], [['css', 'fontSize', '12px']]), downloadShp, downloadGeoJSON, downloadGpx, downloadCsv]), downloadNameContainer[0], _div$1([downloadRaster]), downloadRasterOptions[0]]);

        _$3(oDrawingObjectList.GetDivButtons(), [downloadContainer]);

        checkDownloadVisibility();
      };
      /** Скачивает shp файл*/


      var downloadMarkers = function downloadMarkers(fileName, format) {
        var geoms = [];

        for (var i = 0; i < oCollection.Count(); i++) {
          geoms.push(oCollection.Item(i).toGeoJSON());
        }

        nsGmx$1.Utils.downloadGeometry(geoms, {
          fileName: fileName,
          format: format
        });
      };
      /** Скачивает растровые слои*/


      var checkRasterLayer = function checkRasterLayer() {
        var obj = false;

        for (var i = 0; i < oCollection.Count(); i++) {
          var elem = oCollection.Item(i);

          if (elem.getType() == 'Rectangle') {
            obj = elem;
          }
        }

        if (!obj) {
          showErrorMessage(_gtxt('drawingObjects.noRectangleError'), true);
          return;
        }

        var bounds = obj.getBounds(),
            center = bounds.getCenter(),
            layer = false;

        var testPolygon = function testPolygon(polygon, latlng) {
          var testRing = function testRing(ring, x, y) {
            var isInside = false;

            for (var j = 0; j < ring.length - 1; j++) {
              var x1 = ring[j][0],
                  y1 = ring[j][1],
                  x2 = ring[j + 1][0],
                  y2 = ring[j + 1][1];
              if (y1 >= y != y2 >= y && x1 + (x2 - x1) * (y - y1) / (y2 - y1) > x) isInside = !isInside;
            }

            return isInside;
          };

          for (var j = 0; j < polygon.length; j++) {
            if (testRing(polygon[j], latlng.lng, latlng.lat) != (j == 0)) return false;
          }

          return true;
        };

        for (var iLayerN = 0; iLayerN < gmxMap.layers.length; iLayerN++) {
          var l = gmxMap.layers[iLayerN],
              props = l.getGmxProperties(),
              layerBounds = l.getBounds && l.getBounds(),
              isProperType = props.type == "Raster" || props.IsRasterCatalog;

          if (isProperType && oMap.hasLayer(l) && layerBounds && layerBounds.isValid() && layerBounds.contains(center)) {
            var geom = l.getGeometry(),
                coords = geom.coordinates,
                bIsPolygonBad = false;

            if (geom.type === "Polygon" && !testPolygon(coords, center)) {
              bIsPolygonBad = true;
            } else if (geom.type == "MultiPolygon") {
              bIsPolygonBad = true;

              for (var k = 0; k < coords.length; k++) {
                if (testPolygon(coords[k], center)) {
                  bIsPolygonBad = false;
                  break;
                }
              }
            }

            if (!bIsPolygonBad && l && (!layer || props.MaxZoom > layer.getGmxProperties().MaxZoom)) {
              layer = l;
            }
          }
        }

        if (!layer) {
          showErrorMessage(_gtxt('drawingObjects.noRasterError'), true);
          return;
        }

        return {
          bounds: bounds,
          layer: layer
        };
      };
    };

    var publicInterface = {
      DrawingObjectCollection: DrawingObjectCollection,
      DrawingObjectInfoRow: DrawingObjectInfoRow,
      DrawingObjectList: DrawingObjectList,
      DrawingObjectGeomixer: DrawingObjectGeomixer
    };
    gmxCore$1.addModule("DrawingObjects", publicInterface);

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var EventTarget = function () {
        function EventTarget() {
            classCallCheck(this, EventTarget);

            this.listeners = {};
        }

        createClass(EventTarget, [{
            key: 'addEventListener',
            value: function addEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    this.listeners[type] = [];
                }
                this.listeners[type].push(callback);
            }
        }, {
            key: 'on',
            value: function on(type, callback) {
                this.addEventListener(type, callback);
                return this;
            }
        }, {
            key: 'removeEventListener',
            value: function removeEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[type];
                for (var i = 0, l = stack.length; i < l; i++) {
                    if (stack[i] === callback) {
                        stack.splice(i, 1);
                        return this.removeEventListener(type, callback);
                    }
                }
            }
        }, {
            key: 'off',
            value: function off(type, callback) {
                this.removeEventListener(type, callback);
                return this;
            }
        }, {
            key: 'dispatchEvent',
            value: function dispatchEvent(event) {
                if (!(event.type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[event.type];
                Object.defineProperty(event, 'target', {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: this
                });
                for (var i = 0, l = stack.length; i < l; i++) {
                    stack[i].call(this, event);
                }
            }
        }]);
        return EventTarget;
    }();

    var scanexEventTarget_cjs = EventTarget;

    var scanexObjectExtensions_cjs = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', { value: true });

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var copy = function copy(source) {
        switch (typeof source === 'undefined' ? 'undefined' : _typeof(source)) {
            case 'number':
            case 'string':
            case 'function':
            default:
                return source;
            case 'object':
                if (source === null) {
                    return null;
                } else if (Array.isArray(source)) {
                    return source.map(function (item) {
                        return copy(item);
                    });
                } else if (source instanceof Date) {
                    return source;
                } else {
                    return Object.keys(source).reduce(function (a, k) {
                        a[k] = copy(source[k]);
                        return a;
                    }, {});
                }
        }
    };

    var extend = function extend(target, source) {
        if (target === source) {
            return target;
        } else {
            return Object.keys(source).reduce(function (a, k) {
                var value = source[k];
                if (_typeof(a[k]) === 'object' && k in a) {
                    a[k] = extend(a[k], value);
                } else {
                    a[k] = copy(value);
                }
                return a;
            }, copy(target));
        }
    };

    exports.copy = copy;
    exports.extend = extend;

    });

    unwrapExports(scanexObjectExtensions_cjs);
    var scanexObjectExtensions_cjs_1 = scanexObjectExtensions_cjs.copy;
    var scanexObjectExtensions_cjs_2 = scanexObjectExtensions_cjs.extend;

    class IconSidebarWidget extends scanexEventTarget_cjs {
      constructor(container, options) {
        super();
        this._options = options;
        this._options.position = this._options.position || 'left';
        this._collapsedWidth = this._options.collapsedWidth || 40;
        this._extendedWidth = this._options.extendedWidth || 400;
        this._container = container;

        this._container.classList.add('iconSidebarControl');

        this._container.innerHTML = `<ul class="iconSidebarControl-tabs"></ul><div class="iconSidebarControl-content"></div>`;

        this._container.classList.add(this._options.position.indexOf('left') !== -1 ? 'iconSidebarControl-left' : 'iconSidebarControl-right');

        this._tabsContainer = this._container.querySelector('.iconSidebarControl-tabs');
        this._panesContainer = this._container.querySelector('.iconSidebarControl-content');
        this._onTabClick = this._onTabClick.bind(this);
        this._panes = {};
      }

      setPane(id, paneOptions) {
        paneOptions = paneOptions || {};
        let defaultPaneOptions = {
          position: 0,
          enabled: true
        };
        let activeTabId = this._activeTabId;
        this._panes[id] = scanexObjectExtensions_cjs_2(scanexObjectExtensions_cjs_2(scanexObjectExtensions_cjs_2({}, defaultPaneOptions), this._panes[id] || {}), paneOptions);

        if (!this._panes[id].enabled && this._activeTabId === id) {
          this.close();
        }

        this._renderTabs({
          activeTabId
        });

        return this._ensurePane(id);
      }

      enable(id, enabled) {
        let pane = this._panes[id];

        if (pane) {
          pane.enabled = enabled;
        }
      }

      enabled(id) {
        let pane = this._panes[id];

        if (pane) {
          return pane.enabled;
        } else {
          return false;
        }
      }

      open(paneId) {
        if (this._isAnimating) {
          return;
        }

        const pane = this._panes[paneId];

        if (!pane || !pane.enabled) {
          return;
        }

        this._activeTabId = paneId;

        this._setTabActive(paneId, true);

        this._setActiveClass(paneId);

        if (this._isOpened) {
          let event = document.createEvent('Event');
          event.initEvent('opened', false, false);
          event.detail = {
            id: this._activeTabId
          };
          this.dispatchEvent(event);
          return;
        }

        this._isAnimating = true;

        this._container.classList.add('iconSidebarControl_opened');

        this._container.classList.add('iconSidebarControl_expanded');

        this._isOpened = true;
        let event = document.createEvent('Event');
        event.initEvent('opening', false, false);
        this.dispatchEvent(event);
        setTimeout(() => {
          let ev = document.createEvent('Event');
          ev.initEvent('opened', false, false);
          ev.detail = {
            id: this._activeTabId
          };
          this.dispatchEvent(ev);
          this._isAnimating = false;
        }, 250);
      }

      _setTabActive(paneId, flag) {
        let tabs = this._tabsContainer.querySelectorAll('.iconSidebarControl-tab');

        for (let i = 0; i < tabs.length; ++i) {
          let id = tabs[i].getAttribute('data-tab-id');
          let tab = tabs[i].querySelector('.tab-icon');

          if (id === paneId) {
            if (flag) {
              tab.classList.add('tab-icon-active');
            } else {
              tab.classList.remove('tab-icon-active');
            }
          } else {
            tab.classList.remove('tab-icon-active');
          }
        }
      }

      close() {
        if (this._isAnimating) {
          return;
        }

        this._setTabActive(this._activeTabId, false);

        this._container.classList.remove('iconSidebarControl_opened');

        this._isAnimating = true;
        this._isOpened = false;
        let event = document.createEvent('Event');
        event.initEvent('closing', false, false);
        this.dispatchEvent(event);
        setTimeout(() => {
          this._container.classList.remove('iconSidebarControl_expanded');

          let ev = document.createEvent('Event');
          ev.detail = {
            id: this._activeTabId
          };
          ev.initEvent('closed', false, false);
          this.dispatchEvent(ev);
          this._isAnimating = false;

          this._setActiveClass('');

          this._activeTabId = null;
        }, 250);
      }

      getWidth() {
        if (this._isOpened) {
          return this._extendedWidth;
        } else {
          return this._collapsedWidth;
        }
      }

      getActiveTabId() {
        return this._activeTabId;
      }

      isOpened() {
        return this._isOpened;
      }

      _ensurePane(id) {
        for (let i = 0; i < this._panesContainer.childNodes.length; ++i) {
          let node = this._panesContainer.childNodes[i];

          if (node.getAttribute('data-pane-id') === id) {
            return node;
          }
        }

        let paneEl = document.createElement('div');
        paneEl.classList.add('iconSidebarControl-pane');
        paneEl.setAttribute('data-pane-id', id);

        this._panesContainer.appendChild(paneEl);

        return paneEl;
      }

      _setActiveClass(activeId) {
        for (let i = 0; i < this._panesContainer.children.length; i++) {
          let id = this._panesContainer.children[i].getAttribute('data-pane-id');

          let pane = this._panesContainer.querySelector('[data-pane-id=' + id + ']');

          if (id === activeId) {
            pane.classList.add('iconSidebarControl-pane-active');
          } else {
            pane.classList.remove('iconSidebarControl-pane-active');
          }
        }
      }

      _onTabClick(e) {
        let tabId = e.currentTarget.getAttribute('data-tab-id');
        let pane = this._panes[tabId];

        if (!pane || !pane.enabled) {
          return;
        }

        if (!this._isOpened || this._activeTabId !== tabId) {
          this._renderTabs({
            activeTabId: tabId
          });

          this.open(tabId);
        } else {
          this._renderTabs({});

          this.close();
        }
      }

      _renderTabs(options) {
        const getFlag = (tabId, activeTabId, hoveredTabId, enabled) => {
          if (!enabled) {
            return 'disabled';
          } else if (hoveredTabId && tabId === hoveredTabId) {
            return 'hover';
          } else if (activeTabId && tabId === activeTabId) {
            return 'active';
          } else {
            return 'default';
          }
        };

        let activeTabId = options.activeTabId;
        let hoveredTabId = options.hoveredTabId;
        this._tabsContainer.innerHTML = '';
        Object.keys(this._panes).map(id => scanexObjectExtensions_cjs_2({
          id
        }, this._panes[id])).sort((a, b) => a.position - b.position).forEach(options => {
          const {
            id,
            createTab,
            enabled
          } = options;

          if (!createTab) {
            return;
          }

          let tabContainerEl = document.createElement('li');
          tabContainerEl.classList.add('iconSidebarControl-tab');
          tabContainerEl.setAttribute('data-tab-id', id);
          let tabEl = createTab(getFlag(id, activeTabId, hoveredTabId, enabled));
          tabContainerEl.addEventListener('click', this._onTabClick);
          tabContainerEl.appendChild(tabEl);

          this._tabsContainer.appendChild(tabContainerEl);
        });
      }

    }

    /** Узел дерева слоёв
     * @typedef nsGmx.LayersTree~Node
     * @property {String} type тип узла (`layer` или `group`)
     * @property {Object} content содержимое узла
     * @property {Object} [content.properties] свойства узла
     * @property {Object} [content.children] потомки узла
    */

    /** Результат поиска узла в дереве слоёв
     * @typedef nsGmx.LayersTree~SearchResult
     * @property {nsGmx.LayersTree~Node} elem Найденный элемент
     * @property {nsGmx.LayersTree~Node[]} parents Массив родителей. Самый последний элемент массива - сама карта
     * @property {Number} index Индекс найденного элемента в своей группе
    */

    /** Visitor при обходе слоёв дерева
     * @callback nsGmx.LayersTree~LayerVisitor
     * @param {Object} layerContent Содержимое узла слоя
     * @param {Boolean} isVisible Видимость слоя с учётом видимости всех родителей
     * @param {Number} nodeDepth Глубина слоя в дереве (начинается с 0)
    */

    /** Visitor при обходе узлов дерева слоёв
     * @callback nsGmx.LayersTree~NodeVisitor
     * @param {nsGmx.LayersTree~Node} node Свойства узла
     * @param {Boolean} isVisible Видимость узла с учётом видимости всех родителей
     * @param {Number} nodeDepth Глубина узла в дереве (начинается с 0)
    */

    /** Класс для работы с деревом слоёв
     * @class
     * @param {Object} tree Дерево слоёв в формате сервера
    */

    nsGmx$1.LayersTree = function (tree) {
      /** Изменилась видимость узла дерева. Если изменения касаются нескольких узлов, событие будет 
          генерироваться для каждого узла по отдельности. Кроме того, это же событие генерируется 
          на отдельных узлах дерева.
       * @event nsGmx.LayersTree#nodeVisibilityChange
       * @param {nsGmx.LayersTree~Node} node Узел, видимость которой изменилась
       */
      var _tree = tree;

      var _this = this;

      var _findElem = function _findElem(elem, propName, propValue, parents) {
        var childs = typeof elem.children != 'undefined' ? elem.children : elem.content.children;

        for (var i = 0; i < childs.length; i++) {
          var props = childs[i].content.properties;

          if (propName in props && props[propName] === propValue) {
            return {
              elem: childs[i],
              parents: [elem].concat(parents || []),
              index: i
            };
          }

          if (typeof childs[i].content.children != 'undefined') {
            var res = _findElem(childs[i], propName, propValue, [elem].concat(parents || []));

            if (res) return res;
          }
        }
      };
      /** Получить исходное дерево слоёв
      */


      this.getRawTree = function () {
        return _tree;
      };
      /** Получить свойства карты
      */


      this.getMapProperties = function () {
        return _tree.properties;
      };
      /** Поиск узла дерева по значению одного из атрибутов. Ищет как папки, так и слои. Возвращает первый найденный результат
       * @param {String} propName Имя атрибута
       * @param {String} propValue Значение атрибута
       * @return {nsGmx.LayersTree~SearchResult} Результат поиска. undefined если ничего не найденно
      */


      this.findElem = function (propName, propValue) {
        return _findElem(_tree, propName, propValue);
      };

      this.findElemByGmxProperties = function (gmxProperties) {
        if (gmxProperties.type == 'group') //группа
          return this.findElem("GroupID", gmxProperties.content.properties.GroupID);else return this.findElem("name", gmxProperties.content.properties.name);
      };
      /** Итерирование по всем слоям группы дерева
       * @param {nsGmx.LayersTree~LayerVisitor} callback Будет вызвана для каждого слоя внутри группы. Первый аргумент - свойства слоя, второй - видимость слоя
       * @param {nsGmx.LayersTree~Node} [groupNode] Группа, внутри которой проводить поиск. Если не указана, будет проводиться поиск по всему дереву.
       */


      this.forEachLayer = function (callback, groupNode) {
        this.forEachNode(function (node, isVisible, nodeDepth) {
          if (node.type === 'layer') {
            callback(node.content, isVisible, nodeDepth);
          }
        }, groupNode);
      };
      /** Итерирование по всем под-узлам узла дерева
       * @param {nsGmx.LayersTree~NodeVisitor} callback Будет вызвана для каждого узла внутри группы. Первый аргумент - узел, второй - видимость узла
       * @param {nsGmx.LayersTree~Node} [groupNode] Группа, внутри которой проводить поиск. Если не указана, будет проводиться поиск по всему дереву.
       */


      this.forEachNode = function (callback, groupNode) {
        var forEachNodeRec = function forEachNodeRec(o, isVisible, nodeDepth) {
          isVisible = isVisible && !!o.content.properties.visible;
          callback(o, isVisible, nodeDepth);

          if (o.type === 'group') {
            var a = o.content.children;

            for (var k = a.length - 1; k >= 0; k--) {
              forEachNodeRec(a[k], isVisible, nodeDepth + 1);
            }
          }
        };

        var layers = groupNode ? groupNode.content : _tree;

        for (var k = layers.children.length - 1; k >= 0; k--) {
          forEachNodeRec(layers.children[k], true, 0);
        }
      };
      /** Клонирование дерева с возможностью его модификации
       * @param {function(node):nsGmx.LayersTree~Node|null} filterFunc - ф-ция, которая может модифицировать узлы дерева. 
                  Вызывается при клонировании очередного узла. Изменения данных можно делать in-place.
                  Для групп вызывается после обработки всех потомков. Если возвращает null, то узел удаляется
       */


      this.cloneRawTree = function (filterFunc) {
        filterFunc = filterFunc || function (node) {
          return node;
        };

        var forEachLayerRec = function forEachLayerRec(o) {
          if (o.type == "layer") {
            return filterFunc($.extend(true, {}, o));
          } else if (o.type == "group") {
            var a = o.content.children;
            var newChildren = [];

            for (var k = 0; k < a.length; k++) {
              var newNode = forEachLayerRec(a[k]);
              newNode && newChildren.push(newNode);
            }

            return filterFunc({
              type: 'group',
              content: {
                children: newChildren,
                properties: $.extend(true, {}, o.content.properties)
              }
            });
          }
        };

        var newFirstLevelGroups = [];

        for (var k = 0; k < _tree.children.length; k++) {
          var newNode = forEachLayerRec(_tree.children[k]);
          newNode && newFirstLevelGroups.push(newNode);
        }

        return {
          properties: $.extend(true, {}, _tree.properties),
          children: newFirstLevelGroups
        };
      }; //Методы управления видимостью слоёв в дереве
      //проходится по всему поддереву elem и устанавливает видимость isVisible всем узлам включая elem (учитывая ограничения на radio buttons)


      var setSubtreeVisibility = function setSubtreeVisibility(elem, isVisible) {
        var props = elem.content.properties;

        if (props.visible != isVisible) {
          props.visible = isVisible;
          $(_this).triggerHandler('nodeVisibilityChange', [elem]);
          $(elem).triggerHandler('nodeVisibilityChange', [elem]);

          if (elem.content.children) {
            for (var c = 0; c < elem.content.children.length; c++) {
              var vis = isVisible && (!props.list || c == 0); //когда делаем видимой группу-список, виден только первый элемент группы

              setSubtreeVisibility(elem.content.children[c], vis);
            }
          }
        }
      };
      /** Устанавливает видимость узла дерева и всех родительских элементов данного узла в зависимости от видимости его прямых потомков. Узел должен быть группой.
       * При этом разруливаются конфликты с несколькими видимыми узлами в radio-группах.
       * @param {nsGmx.LayersTree~Node} node Узел дерева, видимость которого нужно обновить
       * @param {nsGmx.LayersTree~Node} triggerSubnode один их прямых потомков node, состояние которого должно остаться неизменным (важно для разруливания конфликтов в radio-групп)
       * @param {nsGmx.LayersTree~Node[]} [parents] массив всех родителей, опционально
       */


      this.updateNodeVisibility = function (elem, triggerSubnode, parents) {
        var props = elem.content.properties,
            isList = props.list,
            children = elem.content.children,
            triggerNodeVisible = triggerSubnode ? triggerSubnode.content.properties.visible : false,
            visibleNode = triggerNodeVisible ? triggerSubnode : null;
        var isVisible = false;

        for (var c = 0; c < children.length; c++) {
          var child = children[c];
          var childVisible = child.content.properties.visible;
          isVisible = isVisible || childVisible;

          if (childVisible && !visibleNode) {
            visibleNode = child;
          }

          if (isList && childVisible && child !== visibleNode) {
            setSubtreeVisibility(child, false);
          }
        }

        if (isVisible !== props.visible) {
          props.visible = isVisible;
          $(this).triggerHandler('nodeVisibilityChange', [elem]);
          $(elem).triggerHandler('nodeVisibilityChange', [elem]);

          if (!parents) {
            parents = this.findElemByGmxProperties(elem).parents;
            parents.pop(); //последний элемент - карта; нас не интересует
          }

          var parent = parents.shift();
          parent && this.updateNodeVisibility(parent, elem, parents);
        }
      };
      /** Задать видимость узла дерева. Будут сделаны все нужные изменения видимости как выше, 
       * так и ниже по дереву относительно этого узла.
       * @param {nsGmx.LayersTree~Node} node Узел дерева, которому мы хотим задать видимость
       * @param {Boolean} isVisible Видимость узла (true - виден)
       */


      this.setNodeVisibility = function (node, isVisible) {
        if (node.content.properties.visible != isVisible) {
          //устанавливаем видимость поддерева, которое начинается с этого элемента
          setSubtreeVisibility(node, isVisible); //идём вверх по дереву до корня и меняем видимость родителей

          var parentElem = _this.findElemByGmxProperties(node).parents[0];

          parentElem && parentElem.content && this.updateNodeVisibility(parentElem, node);
        }
      };
    };

    $('#flash').droppable({
      drop: function drop(event, ui) {
        var obj = ui.draggable[0].gmxDrawingObject;

        if (obj) {
          var text = Functions.GetFullName(obj.TypeName, obj.ObjName);
          nsGmx$1.leafletMap.gmxDrawing.addGeoJSON({
            type: 'Feature',
            geometry: L.gmxUtil.geometryToGeoJSON(obj.Geometry)
          }, {
            text: text
          });
        }
      }
    });

    window._translationsHash.addtext("rus", {
      "Текущее местоположение отображается только для России и Украины": "Текущее местоположение отображается только для России и Украины",
      "Следующие [value0] страниц": "Следующие [value0] страниц",
      "Следующие [value0] страницы": "Следующие [value0] страницы",
      "Следующая страница": "Следующая страница",
      "Следующая [value0] страница": "Следующая [value0] страница",
      "Предыдущие [value0] страниц": "Предыдущие [value0] страниц",
      "Первая страница": "Первая страница",
      "Последняя страница": "Последняя страница"
    });

    window._translationsHash.addtext("eng", {
      "Текущее местоположение отображается только для России и Украины": "Current location is shown only for Russia and Ukraine",
      "Следующие [value0] страниц": "Next [value0] pages",
      "Следующие [value0] страницы": "Next [value0] pages",
      "Следующая страница": "Next page",
      "Следующая [value0] страница": "Next [value0] pages",
      "Предыдущие [value0] страниц": "Previous [value0] pages",
      "Первая страница": "First page",
      "Последняя страница": "Last page"
    });

    var imagesHost = "img";
    /** Вспомогательные функции
     @namespace Functions
     @memberOf Search
    */

    var Functions = {
      /** Возвращает полное наименование объекта, состоящее из типа и наименования
       @static
       @param sType Наименование типа объекта
       @param sName Наименование объекта
         */
      GetFullName: function GetFullName(
      /** string */
      sType,
      /** string */
      sName) {
        var sFullName = "";
        if (sType == null || sType == "государство" || sType == "г." || /[a-zA-Z]/.test(sName)) sFullName = sName;else if (sType.indexOf("район") != -1 || sType.indexOf("область") != -1 || sType.indexOf("край") != -1) sFullName = sName + " " + sType;else sFullName = sType + " " + sName;
        return sFullName;
      },

      /** Возвращает полный путь к объекту
         * @memberOf Search.Functions
         *
      * @param oFoundObject найденный объект
      * @param sObjectsSeparator разделитель между дочерним элементом и родителем в строке пути
      * @param bParentAfter признак того, что родительский элемент идет после дочернего
      * @param sObjNameField название свойства, из которого брать наименование
         */
      GetPath: function GetPath(
      /*object*/
      oFoundObject,
      /* string */
      sObjectsSeparator,
      /* bool */
      bParentAfter,
      /* string */
      sObjNameField) {
        if (sObjNameField == null) sObjNameField = "ObjName";
        if (oFoundObject == null) return "";
        var oParentObj = oFoundObject.Parent;

        if (oParentObj != null && (oParentObj.ObjName == "Российская Федерация" || oParentObj.TypeName == "административный округ")) {
          oParentObj = oParentObj.Parent;
        }

        var sObjectName = oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183 ? oFoundObject[sObjNameField] : this.GetFullName(oFoundObject.TypeName, oFoundObject[sObjNameField]);

        if (oParentObj != null && oParentObj[sObjNameField] != null && oParentObj[sObjNameField]) {
          if (bParentAfter) {
            return sObjectName + sObjectsSeparator + this.GetPath(oParentObj, sObjectsSeparator, bParentAfter, sObjNameField);
          } else {
            return this.GetPath(oParentObj, sObjectsSeparator, bParentAfter, sObjNameField) + sObjectsSeparator + sObjectName;
          }
        } else {
          return sObjectName;
        }
      },

      /** Возвращает строку, соединяющую переданные свойства
       @static
       @param oProps - Свойства
       @param sObjectsSeparator Разделитель 2х свойств в строке*/
      GetPropertiesString: function GetPropertiesString(
      /**object[]*/
      oProps,
      /**string*/
      sPropSeparator,
      /**object[]*/
      arrDisplayFields) {
        var sResultString = "";

        if (oProps != null) {
          for (var sPropName in oProps) {
            if (sResultString != "") sResultString += sPropSeparator;
            sResultString += sPropName + ": " + oProps[sPropName];
          }
        }

        return sResultString;
      }
      /** Конструктор
       @class Предоставляет функции, отображающие найденные объекты на карте
       @memberof Search
       @param {L.Map} map карта, на которой будут рисоваться объекты
       @param {string} sInitImagesHost - строка пути к картинкам
       @param {bool} bInitAutoCenter - если true, карта будет центрироваться по 1ому найденному объекту*/

    };

    var ResultRenderer = function ResultRenderer(map, sInitImagesHost, bInitAutoCenter) {
      if (map == null) throw "ResultRenderer.Map is null";
      var sImagesHost = sInitImagesHost || "http://maps.kosmosnimki.ru/api/img";
      var bAutoCenter = bInitAutoCenter == null || bInitAutoCenter;
      this.arrContainer = [];
      var counts = [];
      /** возвращает стили найденных объектов, используется только для точки*/

      var getSearchIcon = function getSearchIcon(iPosition) {
        iPosition = Math.min(iPosition, 9);
        return L.icon({
          iconUrl: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png",
          iconAnchor: [15, 38],
          popupAnchor: [0, -28]
        }); // return [
        // { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png", dx: -14, dy: -38} },
        // { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + "a.png", dx: -14, dy: -38} }
        // ];
      };

      var bindHoverPopup = function bindHoverPopup(layer, content) {
        layer.bindPopup(content);
      };
      /**Помещает объект на карту
      @param {MapObject} oContainer контейнер, содержащий в себе объекты текущей группы результатов поиска
      @param {MapObject} oFoundObject добавляемый объект
      @param {int} iPosition порядковый номер добавляемого объекта в группе
      @param {int} iCount общее количество объектов в группе
         @return {Object} Нарисованные на карте объекты: хеш с полями center и boundary */


      var DrawObject = function DrawObject(oContainer, oFoundObject, iPosition, iCount) {
        var color = Math.round(0x22 + 0x99 * iPosition / iCount);
        var sDescr = "<b>" + Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName) + "</b><br/>" + Functions.GetPath(oFoundObject.Parent, "<br/>", true);
        if (oFoundObject.properties != null) sDescr += "<br/>" + Functions.GetPropertiesString(oFoundObject.properties, "<br/>");
        sDescr = sDescr.replace(/;/g, "<br/>");

        var centerMapElem, boundaryMapElem; //Рисуем центр объекта

        if (oFoundObject.Geometry != null && oFoundObject.Geometry.type.toUpperCase() == 'POINT') {
          centerMapElem = L.marker([oFoundObject.Geometry.coordinates[1], oFoundObject.Geometry.coordinates[0]], {
            icon: getSearchIcon(iPosition)
          });
          bindHoverPopup(centerMapElem, sDescr);
          oContainer.addLayer(centerMapElem);
        } else if (oFoundObject.CntrLon != null && oFoundObject.CntrLat != null) {
          centerMapElem = L.marker([oFoundObject.CntrLat, oFoundObject.CntrLon], {
            icon: getSearchIcon(iPosition)
          });
          bindHoverPopup(centerMapElem, sDescr);
          oContainer.addLayer(centerMapElem);
        } //Рисуем контур объекта


        if (oFoundObject.Geometry != null && oFoundObject.Geometry.type.toUpperCase() != 'POINT') {
          boundaryMapElem = L.geoJson(L.gmxUtil.geometryToGeoJSON(oFoundObject.Geometry), {
            style: function style(feature) {
              return;
            },
            onEachFeature: function onEachFeature(feature, layer) {
              layer.setStyle({
                color: '#' + (0x1000000 + (color << 16) + (color << 8) + color).toString(16).substr(-6),
                weight: 3,
                opacity: 0.6,
                fill: false
              });
              bindHoverPopup(layer, sDescr);
            }
          });
          oContainer.addLayer(boundaryMapElem);
        }

        return {
          center: centerMapElem,
          boundary: boundaryMapElem
        };
      };
      /**Центрует карту по переданному объекту*/


      var CenterObject = function CenterObject(oFoundObject) {
        if (!oFoundObject) return;
        var iZoom = oFoundObject.TypeName == "г." ? 9 : 15;

        if (oFoundObject.Geometry == null) {
          if (oFoundObject.MinLon != null && oFoundObject.MaxLon != null && oFoundObject.MinLat != null && oFoundObject.MaxLat != null && oFoundObject.MaxLon - oFoundObject.MinLon < 1e-9 && oFoundObject.MaxLat - oFoundObject.MinLat < 1e-9) map.setView([oFoundObject.CntrLat, oFoundObject.CntrLon], iZoom);else map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
        } else {
          if (oFoundObject.Geometry.type.toUpperCase() == 'POINT') {
            if (oFoundObject.MinLon != oFoundObject.MaxLon && oFoundObject.MinLat != oFoundObject.MaxLat) {
              map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
            } else {
              var c = oFoundObject.Geometry.coordinates;
              map.setView([c[1], c[0]], iZoom);
            }
          } else {
            var bounds = L.gmxUtil.getGeometryBounds(oFoundObject.Geometry); //var oExtent = getBounds(oFoundObject.Geometry.coordinates);

            map.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
          }
        }
      };
      /**Центрует карту по переданному объекту
      @param {MapObject} oFoundObject объект, который нужно поместить в центр
      @returns {void}*/


      this.CenterObject = function (oFoundObject) {
        CenterObject(oFoundObject);
      };
      /** Рисует объекты на карте.
      @param {int} iDataSourceN № источника данных (группы результатов поиска)
      @param {Array} arrFoundObjects Массив объектов для отрисовки. Каждый объект имеет свойства
      @param {bool} [options.append=false] Добавить к существующим объектам для источника данных, а не удалять их
      @return {Array} Нарисованные на карте объекты: массив хешей с полями center и boundary
         */


      this.DrawObjects = function (iDataSourceN, arrFoundObjects, options) {
        options = $.extend({
          append: false
        }, options);

        if (!options.append && this.arrContainer[iDataSourceN]) {
          map.removeLayer(this.arrContainer[iDataSourceN]);
          delete this.arrContainer[iDataSourceN];
        }

        if (!this.arrContainer[iDataSourceN]) {
          this.arrContainer[iDataSourceN] = L.layerGroup();
          counts[iDataSourceN] = 0;
        }

        iCount = arrFoundObjects.length;
        var mapObjects = [];
        counts[iDataSourceN] += arrFoundObjects.length; //Отрисовываем задом наперед, чтобы номер 1 был сверху от 10ого

        for (var i = arrFoundObjects.length - 1; i >= 0; i--) {
          mapObjects.unshift(DrawObject(this.arrContainer[iDataSourceN], arrFoundObjects[i], counts[iDataSourceN] + i - arrFoundObjects.length, counts[iDataSourceN]));
        }

        this.arrContainer[iDataSourceN].addTo(map);
        if (bAutoCenter && iDataSourceN == 0) CenterObject(arrFoundObjects[0]);
        return mapObjects;
      };
    };

    var ResultList = function ResultList(oInitContainer, oRenderer, ImagesHost) {
      /**Объект, в котором находится контрол (div)*/
      // создается в начале searchLogic.showResult
      var Container = oInitContainer;

      var _this = this;

      var sImagesHost = ImagesHost || "http://maps.kosmosnimki.ru/api/img";
      var arrDisplayedObjects = []; //Объекты, которые отображаются на текущей странице

      var iLimit = 10; //Максимальное количество результатов на странице

      var iPagesCount = 7; //Количество прокручиваемых страниц при нажатии на двойные стрелки

      if (Container == null) throw "ResultList.Container is null";
      var oResultCanvas;
      var arrTotalResultSet = [];

      if (oResultCanvas == null) {
        oResultCanvas = nsGmx$1.Utils._div(null, [['dir', 'className', 'searchResultCanvas']]);
        Container.appendChild(oResultCanvas);
      }

      var oLoading = nsGmx$1.Utils._div([_img(null, [['attr', 'src', sImagesHost + '/progress.gif'], ['dir', 'className', 'searchResultListLoadingImg']]), _t(_gtxt("загрузка..."))], [['dir', 'className', 'searchResultListLoading']]);

      var fnNotFound = function fnNotFound() {
        nsGmx$1.Utils._(oResultCanvas, [nsGmx$1.Utils._div([_t(_gtxt("Поиск не дал результатов"))], [['dir', 'className', 'SearchResultListNotFound']])]);
      };
      /**Удаляет все найденные объекты из результатов поиска*/


      var unload = function unload() {
        for (i = 0; i < arrDisplayedObjects.length; i++) {
          SetDisplayedObjects(i, []);
        }

        $(oResultCanvas).empty();
      };
      /** Переход на предыдущие страницы*/


      var previous = function previous(iDataSourceN, divChilds, divPages) {
        var button = makeImageButton(sImagesHost + '/prev.png', sImagesHost + '/prev_a.png');
        button.style.marginBottom = '-7px';

        button.onclick = function () {
          var oDataSource = arrTotalResultSet[iDataSourceN];
          oDataSource.start -= iPagesCount;
          oDataSource.reportStart = oDataSource.start * iLimit;
          drawPagesRow(iDataSourceN, divChilds, divPages);
        };

        _title(button, _gtxt('Предыдущие [value0] страниц', iPagesCount));

        return button;
      };
      /** Переход на первую страницу*/


      var first = function first(iDataSourceN, divChilds, divPages) {
        var button = makeImageButton(sImagesHost + '/first.png', sImagesHost + '/first_a.png');

        button.style.marginBottom = '-7px';

        button.onclick = function () {
          var oDataSource = arrTotalResultSet[iDataSourceN];
          oDataSource.start = 0;
          oDataSource.reportStart = oDataSource.start * iLimit;
          drawPagesRow(iDataSourceN, divChilds, divPages);
        };

        _title(button, _gtxt('Первая страница'));

        return button;
      };
      /**Добавляет объект в список найденных результатов*/


      var drawObject = function drawObject(oFoundObject, elemDiv, bIsParent) {
        var realPath = oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183 ? oFoundObject.ObjName : Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);
        if (oFoundObject.Parent != null) realPath += ",";

        var searchElemHeader = _span([_t(realPath)], [['dir', 'className', bIsParent ? 'searchElemParent' : 'searchElem']]);
        /** Вызывается при клике на найденный объект в списке результатов поиска
        @name Search.ResultList.onObjectClick
        @event
        @param {object} oFoundObject Найденный объект*/


        searchElemHeader.onclick = function () {
          $(_this).triggerHandler('onObjectClick', [oFoundObject]);
        };

        nsGmx$1.Utils._(elemDiv, [searchElemHeader]);

        if (oFoundObject.Parent != null) drawObject(oFoundObject.Parent, elemDiv, true);
        if (oFoundObject.properties != null) nsGmx$1.Utils._(elemDiv, [document.createTextNode(" " + Functions.GetPropertiesString(oFoundObject.properties, "; "))]);
      };
      /** Рисует строки списка*/


      var drawRows = function drawRows(iDataSourceN, divChilds) {
        var arrObjects = arrDisplayedObjects[iDataSourceN];
        $(divChilds).empty();

        var tbody = _tbody();

        for (var i = 0; i < arrObjects.length; i++) {
          var elemTR = _tr(null, [['dir', 'className', 'SearchResultRow']]);

          var elemTD = _td(null, [['dir', 'className', 'SearchResultText']]);

          nsGmx$1.Utils._(elemTR, [_td([_t((i + 1).toString() + ".")], [['dir', 'className', 'searchElemPosition']]), elemTD]);

          drawObject(arrObjects[i], elemTD); // загрузка SHP Файла

          if (window.gmxGeoCodeShpDownload && arrObjects[i].Geometry != null) {
            var shpFileLink = _span([_t(".shp")], [['dir', 'className', 'searchElem'], ['attr', 'title', 'скачать SHP-файл'], ['attr', 'number', i]]);

            shpFileLink.onclick = function () {
              var obj = arrObjects[$(this).attr('number')];
              var objsToDownload = [obj];
              $(_this).triggerHandler('onDownloadSHP', [obj.ObjCode, objsToDownload]);
            };

            nsGmx$1.Utils._(elemTD, [_t(" ")]);

            nsGmx$1.Utils._(elemTD, [shpFileLink]);
          }

          elemTD.gmxDrawingObject = arrObjects[i];
          $(elemTD).draggable({
            scroll: false,
            appendTo: document.body,
            helper: 'clone',
            distance: 10
          });

          nsGmx$1.Utils._(tbody, [elemTR]);
        }

        nsGmx$1.Utils._(divChilds, [_table([tbody])]);
      };
      /**Рисует одну из страниц списка
      @param iDataSourceN - номер источника данных
      @param divChilds - раздел для элементов списка
      @param divPages - раздел для номеров страниц списка*/


      var drawPagesRow = function drawPagesRow(iDataSourceN, divChilds, divPages) {
        var oDataSource = arrTotalResultSet[iDataSourceN]; // перерисовывем номера страниц

        $(divPages).empty();
        var end = oDataSource.start + iPagesCount <= oDataSource.allPages ? oDataSource.start + iPagesCount : oDataSource.allPages;
        if (oDataSource.start - iPagesCount >= 0) nsGmx$1.Utils._(divPages, [first(iDataSourceN, divChilds, divPages), previous(iDataSourceN, divChilds, divPages)]); // drawPages(end, iDataSourceN, divChilds, divPages);
        // if (end + 1 <= oDataSource.allPages)
        // 	nsGmx.Utils._(divPages, [next(iDataSourceN, divChilds, divPages), last(iDataSourceN, divChilds, divPages)]);

        var startFrom = oDataSource.reportStart * iLimit;
        SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult.slice(startFrom, startFrom + iLimit));
        drawRows(iDataSourceN, divChilds);
      };
      /**Рисует таблицу для результатов источника данных
      @param iDataSourceN - номер источника данных
      @param divChilds - раздел для элементов списка
      @param divPages - раздел для номеров страниц списка*/


      var drawTable = function drawTable(iDataSourceN, divChilds, divPages) {
        var oDataSource = arrTotalResultSet[iDataSourceN];

        if (oDataSource.SearchResult.length <= iLimit
        /* && iDataSourceN < oDataSource.SearchResult.length - 1*/
        ) {
            $(divPages).empty();
            SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult);
            drawRows(iDataSourceN, divChilds);
          } else {
          oDataSource.allPages = Math.ceil(oDataSource.SearchResult.length / iLimit);
          drawPagesRow(iDataSourceN, divChilds, divPages);
        }
      };
      /**Обрабатывает событие нажатия на кнопку "Скачать SHP-файл"
      @param iDataSourceN - номер источника данных*/


      var downloadMarkers = function downloadMarkers(iDataSourceN) {
        var oDataSource = arrTotalResultSet[iDataSourceN];

        var canvas = nsGmx$1.Utils._div(),
            filename = _input(null, [['dir', 'className', 'filename'], ['attr', 'value', oDataSource.name]]);

        var downloadButton = makeButton(_gtxt("Скачать"));

        downloadButton.onclick = function () {
          if (filename.value == '') {
            inputError(filename, 2000);
            return;
          }
          /** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
          @name Search.ResultList.onDownloadSHP
          @event
          @param {string} filename Имя файла, которой необходимо будет сформировать
          @param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/


          $(_this).triggerHandler('onDownloadSHP', [filename.value, oDataSource.SearchResult]);
          $(canvas.parentNode).dialog("destroy").remove();
        };

        nsGmx$1.Utils._(canvas, [nsGmx$1.Utils._div([_t(_gtxt("Введите имя файла для скачивания")), filename], [['dir', 'className', 'DownloadSHPButtonText']]), nsGmx$1.Utils._div([downloadButton], [['dir', 'className', 'DownloadSHPButton']])]);

        var area = getOffsetRect(Container);
        showDialog(_gtxt("Скачать shp-файл"), canvas, 291, 120, 30, area.top + 10);
      };
      /**Отображает результаты поиска с источника данных
      @param iDataSourceN - номер источника данных*/


      var drawSearchResult = function drawSearchResult(iDataSourceN, options) {
        var oDataSource = arrTotalResultSet[iDataSourceN];
        var arrDataSourceList = oDataSource.SearchResult;
        var header = oDataSource.name;

        var divChilds = nsGmx$1.Utils._div(null, [['dir', 'className', 'SearchResultListChildsCanvas']]),
            divPages = nsGmx$1.Utils._div(),
            liInner = _li([divChilds, divPages]),
            li;

        if (arrTotalResultSet.length == 1) {
          li = nsGmx$1.Utils._ul([liInner]);
        } else {
          li = _li([nsGmx$1.Utils._div([_t(header), _span([_t("(" + arrDataSourceList.length + ")")])], [['dir', 'className', 'searchLayerHeader']]), nsGmx$1.Utils._ul([liInner])]);
        }

        oDataSource.start = 0;
        oDataSource.reportStart = options.page || 0;
        oDataSource.allPages = 0;
        drawTable(iDataSourceN, divChilds, divPages);

        if (oDataSource.CanDownloadVectors) {
          var downloadVector = makeLinkButton(_gtxt("Скачать shp-файл"));

          downloadVector.onclick = function () {
            downloadMarkers(iDataSourceN);
          };

          liInner.insertBefore(nsGmx$1.Utils._div([downloadVector], [['dir', 'className', 'SearchDownloadShpLink']]), liInner.firstChild);
        }

        return li;
      };

      var fnDisplayedObjectsChanged = function fnDisplayedObjectsChanged(event, iDataSourceN, arrFoundObjects) {
        oRenderer.DrawObjects(iDataSourceN, arrFoundObjects);
        /** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
        @name Search.ResultListMap.onDisplayedObjectsChanged
        @event
        @param {int} iDataSourceN № источника данных(группы результатов поиска)
        @param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
        // $(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
      };

      var fnObjectClick = function fnObjectClick(event, oFoundObject) {
        oRenderer.CenterObject(oFoundObject);
        /** Вызывается при клике на найденный объект в списке результатов поиска
        @name Search.ResultListMap.onObjectClick
        @event
        @param {object} oFoundObject Найденный объект*/
        // $(oSearchResultDiv).triggerHandler('onObjectClick', [oFoundObject]);
      };

      var fnDownloadSHP = function fnDownloadSHP(event, filename, arrObjectsToDownload) {
        /** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
        @name Search.ResultListMap.onDownloadSHP
        @event
        @param {string} filename Имя файла, которой необходимо будет сформировать
        @param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/
        // $(oSearchResultDiv).triggerHandler('onDownloadSHP', [filename, arrObjectsToDownload]);
      };

      $(_this).bind('onDisplayedObjectsChanged', fnDisplayedObjectsChanged);
      $(_this).bind('onObjectClick', fnObjectClick);
      $(_this).bind('onDownloadSHP', fnDownloadSHP);
      /**Отображает результаты поиска в списке
      @param sTotalListName - заголовок итогового результата
      @param {Array.<Object>} arrTotalList. Массив объектов со следующими свойствами{name:DataSourceName, CanDownloadVectors:CanDownloadVectors, SearchResult:arrDataSourceList[oObjFound,...]}
      @returns {void}
      */

      this.ShowResult = function (sTotalListName, arrTotalList, options) {
        arrTotalResultSet = arrTotalList;
        $(oResultCanvas).empty();
        arrDisplayedObjects = [];

        if (!objLength(arrTotalResultSet)) {
          fnNotFound();
          return;
        } else {
          var foundSomething = false;

          for (var i = 0; i < arrTotalResultSet.length; i++) {
            if (arrTotalResultSet[i].SearchResult.length > 0) {
              foundSomething = true;
              break;
            }
          }

          if (!foundSomething) {
            fnNotFound();
            return;
          }
        }

        var ulSearch = nsGmx$1.Utils._ul();

        for (var iDataSourceN = 0; iDataSourceN < arrTotalResultSet.length; iDataSourceN++) {
          nsGmx$1.Utils._(ulSearch, [drawSearchResult(iDataSourceN, options)]);
        }

        if (arrTotalResultSet.length == 1) {
          nsGmx$1.Utils._(oResultCanvas, [ulSearch]);
        } else {
          nsGmx$1.Utils._(oResultCanvas, [_li([nsGmx$1.Utils._div([_t(sTotalListName)], [['dir', 'className', 'SearchTotalHeader']]), ulSearch])]);
        }

        if (typeof $.fn.treeview === 'function') {
          $(oResultCanvas).treeview();
        }

        $(oResultCanvas).find(".SearchResultListChildsCanvas").each(function () {
          this.parentNode.style.padding = '0px';
          this.parentNode.style.background = 'none';
        });
      };
      /**Создается переключатель страниц
      @param results - набор результатов
      @param onclick - обработчик нажатия переключателя страниц
      @returns {void}*/


      this.CreatePager = function (results, onclick) {
        function makeNavigButton(pager, img, imga, id, title) {
          var b = makeImageButton(sImagesHost + img, sImagesHost + imga);
          b.style.marginBottom = '-7px';
          $(b).attr('id', id);

          nsGmx$1.Utils._title(b, title);

          nsGmx$1.Utils._(pager, [b]);

          return b;
        }

        containerList = Container;
        $('#respager').remove(); //var pager = nsGmx.Utils._div([_t('всего: ' + results[0].ResultsCount)], [["attr", "id", "respager"]]);

        var pager = nsGmx$1.Utils._div([_t('')], [["attr", "id", "respager"]]);

        nsGmx$1.Utils._(containerList, [pager]);

        var pcount = results[0].SearchResult[0] ? Math.ceil(results[0].SearchResult[0].OneOf / iLimit) : 0;

        if (pcount > 1) {
          var first = makeNavigButton(pager, '/first.png', '/first_a.png', 'firstpage', _gtxt('Первая страница'));
          $(first).bind('click', function () {
            fnShowPage(0);
          });
          var prev = makeNavigButton(pager, '/prev.png', '/prev_a.png', 'prevpages', _gtxt('Предыдущие [value0] страниц', iPagesCount));
          $(prev).bind('click', function () {
            fnShowPage(parseInt($('#page1').text()) - iPagesCount - 1);
          });
          $(first).hide();
          $(prev).hide();

          for (var i = 0; i < iPagesCount && i < pcount; ++i) {
            var pagelink = makeLinkButton(i + 1);
            $(pagelink).attr('id', 'page' + (i + 1));

            if (i == 0) {
              $(pagelink).attr('class', 'page');
              attachEffects(pagelink, '');
            }

            $(pagelink).bind('click', onclick);

            nsGmx$1.Utils._(pager, [pagelink, _t(' ')]);
          }

          var remains = pcount % iPagesCount;
          var nextPages = pcount / iPagesCount < 2 ? remains : iPagesCount;
          var nextButTitle = 'Следующие [value0] страниц';
          if (nextPages == 1) nextButTitle = 'Следующая страница';
          if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11) nextButTitle = 'Следующая [value0] страница';
          if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages < 10 || nextPages > 20)) nextButTitle = 'Следующие [value0] страницы';
          var next = makeNavigButton(pager, '/next.png', '/next_a.png', 'nextpages', _gtxt(nextButTitle, nextPages));
          $(next).bind('click', function () {
            fnShowPage(parseInt($('#page' + iPagesCount).text()));
          });
          var last = makeNavigButton(pager, '/last.png', '/last_a.png', 'lastpage', _gtxt('Последняя страница'));
          $(last).bind('click', function () {
            var lastindex = remains == 0 ? iPagesCount : remains;
            fnShowPage(pcount - lastindex, $('#page' + lastindex));
          });

          if (iPagesCount >= pcount) {
            $(next).hide();
            $(last).hide();
          }
        }

        var fnShowPage = function fnShowPage(n, active) {
          //alert(n + "\n" + pcount);
          for (var i = 0; i < iPagesCount; ++i) {
            //pcount
            if (i + n < pcount) {
              $('#page' + (i + 1)).text(i + n + 1);
              $('#page' + (i + 1)).show();
            } else $('#page' + (i + 1)).hide();
          }

          if (n < iPagesCount) {
            $('#prevpages').hide();
            $('#firstpage').hide();
          } else {
            $('#prevpages').show();
            $('#firstpage').show();
          }

          if (n + iPagesCount < pcount) {
            $('#nextpages').show();
            $('#lastpage').show();
            var rest = pcount - n - iPagesCount;
            var nextPages = rest < iPagesCount ? rest : iPagesCount;
            var nextButTitle = 'Следующие [value0] страниц';
            if (nextPages == 1) nextButTitle = 'Следующая страница';
            if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11) nextButTitle = 'Следующая [value0] страница';
            if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages < 10 || nextPages > 20)) nextButTitle = 'Следующие [value0] страницы';
            $('#nextpages').attr('title', _gtxt(nextButTitle, nextPages));
          } else {
            $('#nextpages').hide();
            $('#lastpage').hide();
          }

          if (active == null) active = $('#prevpages~span')[0];
          $(active).trigger('click');
        };
      };
      /*----------------------------------------------------------*/

      /**Возвращает список объектов, которые отображаются на текущей странице во всех разделах*/


      this.GetDisplayedObjects = function () {
        return arrDisplayedObjects;
      };

      var SetDisplayedObjects = function SetDisplayedObjects(iDataSourceN, value) {
        arrDisplayedObjects[iDataSourceN] = value;
        /** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
        @name Search.ResultList.onDisplayedObjectsChanged
        @event
        @param {int} iDataSourceN № источника данных(группы результатов поиска)
        @param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/

        $(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrDisplayedObjects[iDataSourceN]]);
      };
      /** Показывает режим загрузки
      @returns {void}*/


      this.ShowLoading = function () {
        $('#respager').remove();
        $(oResultCanvas).empty(); // Container.appendChild(oResultCanvas);

        nsGmx$1.Utils._(oResultCanvas, [oLoading]);
      };
      /**Показывает сообщение об ошибке
      @returns {void}*/


      this.ShowError = function () {
        $(oResultCanvas).empty();

        nsGmx$1.Utils._(oResultCanvas, [_t("Произошла ошибка")]);
      };
      /**Очищает результаты поиска
      @returns {void}*/


      this.Unload = function () {
        unload();
      };
      /** Возвращает контрол, в котором находится данный контрол*/


      this.getContainer = function () {
        return Container;
      };
    };

    nsGmx$1.SearchLogic = function () {};

    nsGmx$1.SearchLogic.prototype = {
      init: function init(params) {
        this.oMenu = params.oMenu || new leftMenu();
        this.oRenderer = new ResultRenderer(nsGmx$1.leafletMap, imagesHost, true);
        this.oSearchResultDiv = document.createElement('div');
        this.searchByStringHooks = [];
        this.oSearchResultDiv.className = 'ddfdfdf';
        this.oSearchResultDiv.title = window._gtxt('Изменить параметры поиска');

        var fnBeforeSearch = function fnBeforeSearch(event) {
          /** Вызывается перед началом поиска
          @name Search.SearchGeomixer.onBeforeSearch
          @event */
          $(this.oSearchResultDiv).triggerHandler('onBeforeSearch');
          fnLoad();
        };

        var fnAfterSearch = function fnAfterSearch(event) {
          /** Вызывается после окончания поиска
          @name Search.SearchGeomixer.onAfterSearch
          @event */
          $(this.oSearchResultDiv).triggerHandler('onAfterSearch');
        };

        var onDisplayedObjectsChanged = function onDisplayedObjectsChanged(event, iDataSourceN, arrFoundObjects) {
          /** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
          @name Search.SearchGeomixer.onDisplayedObjectsChanged
          @event
          @param {int} iDataSourceN № источника данных(группы результатов поиска)
          @param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
          $(this.oSearchResultDiv).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
        };

        var onObjectClick = function onObjectClick(event, oFoundObject) {
          /** Вызывается при клике на найденный объект в списке результатов поиска
          @name Search.SearchGeomixer.onObjectClick
          @event
          @param {object} oFoundObject Найденный объект*/
          $(this.oSearchResultDiv).triggerHandler('onObjectClick', [oFoundObject]);
        };

        $(this.oSearchResultDiv).bind('onBeforeSearch', fnBeforeSearch);
        $(this.oSearchResultDiv).bind('onAfterSearch', fnAfterSearch);
        $(this.oSearchResultDiv).bind('onDisplayedObjectsChanged', onDisplayedObjectsChanged);
        $(this.oSearchResultDiv).bind('onObjectClick', onObjectClick); // coordinates search hook

        this.addSearchByStringHook(function (searchString) {
          var pos = L.gmxUtil.parseCoordinates(searchString);

          if (pos) {
            nsGmx$1.leafletMap.panTo(pos); // Добавим иконку по умолчанию
            // L.Icon.Default.imagePath = 'leaflet/images';

            nsGmx$1.leafletMap.gmxDrawing.add(L.marker(pos, {
              draggable: true,
              title: searchString
            })); // Либо задать свою иконку
            // map.gmxDrawing.add(L.marker(pos, {
            // draggable: true, title: searchString,
            // icon: L.icon({ iconUrl: 'img/flag_blau1.png', iconAnchor: [6, 36] })
            // }));
            //map.moveTo(pos[0], pos[1], map.getZ());
            //map.drawing.addObject({ type: "POINT", coordinates: pos }, { text: searchString });

            return true;
          }
        });
      },
      fnLoad: function fnLoad() {
        if (this.oMenu != null) {
          var alreadyLoaded = this.oMenu.createWorkCanvas("search", this.fnUnload.bind(this));

          if (!alreadyLoaded) {
            this.oMenu.workCanvas.appendChild(this.oSearchResultDiv);
          }

          $(this.oSearchResultDiv).empty();
        }
      },
      fnUnload: function fnUnload() {
        if (this.lstResult) {
          this.lstResult.Unload();
        }
      },
      showResult: function showResult(response) {
        var _this = this;

        var searchString = response.searchString || '';

        if (searchString) {
          for (var h = 0; h < this.searchByStringHooks.length; h++) {
            if (this.searchByStringHooks[h].hook(searchString)) {
              return;
            }
          }
        }

        this.fnLoad();
        this.lstResult = new ResultList(this.oSearchResultDiv, this.oRenderer, imagesHost);
        this.lstResult.ShowLoading();
        this.lstResult.ShowResult(searchString, response, {
          page: 0
        });
        this.lstResult.CreatePager(response, function (e) {
          var evt = e || window.event,
              active = evt.srcElement || evt.target,
              activePage = parseInt($(this).text()) - 1;
          $('#prevpages~span:visible').attr('class', 'buttonLink');

          for (var i = 0; i < $('#prevpages~span:visible').length; ++i) {
            attachEffects($('#prevpages~span:visible')[i], 'buttonLinkHover');
          }

          $(active).attr('class', 'page');
          attachEffects(active, '');

          _this.lstResult.ShowResult(searchString, response, {
            page: activePage
          });
        });
      },
      addSearchByStringHook: function addSearchByStringHook(hook, priority) {
        var _this = this;

        this.searchByStringHooks.push({
          hook: hook,
          priority: priority || 0,
          index: _this.searchByStringHooks.length
        });
        this.searchByStringHooks.sort(function (a, b) {
          return b.priority - a.priority || a.index - b.index;
        });
      },
      removeSearchByStringHook: function removeSearchByStringHook(hook) {
        for (var h = 0; h < this.searchByStringHooks.length; h++) {
          if (this.searchByStringHooks[h].hook === hook) {
            this.searchByStringHooks.splice(h, 1);
            return;
          }
        }
      },
      layersSearch: function layersSearch(res) {

        if (!nsGmx$1.gmxMap) {
          reject(res);
        }

        var promisesArr = [];
        var layersToSearch = [];

        for (var i = 0; i < nsGmx$1.gmxMap.layers.length; i++) {
          //свойства мы берём из дерева слоёв, а не из API. Cвойство AllowSearch относится к карте и не поддерживаются API
          var searchRes = window._layersTree.treeModel.findElem('name', nsGmx$1.gmxMap.layers[i].getGmxProperties().name);

          if (searchRes) {
            var props = searchRes.elem.content.properties;

            if (props.type == "Vector" && props.AllowSearch) {
              layersToSearch.push(props);
            }
          }
        }

        if (layersToSearch.length > 0) {
          layersToSearch.forEach(function (props) {
            var mapName = nsGmx$1.gmxMap.layersByID[props.name].options.mapID;
            var url = window.serverBase + "SearchObject/SearchVector.ashx" + "?LayerNames=" + props.name + "&MapName=" + mapName + "&SearchString=" + encodeURIComponent(res.Result.searchString);
            var promise = new Promise(function (resolve, reject) {
              var req = new XMLHttpRequest();
              req.withCredentials = true;
              req.open('GET', url);

              req.onload = function () {
                if (req.status == 200) {
                  var res = handleResponse(req.response, props);
                  res.then(function (res2) {
                    resolve(res2);
                  });
                } else {
                  reject(Error(req.statusText));
                }
              };

              req.onerror = function () {
                reject(Error("Network Error"));
              };

              req.send();
            });
            promisesArr.push(promise);
          });
          return Promise.all(promisesArr);
        } else {
          return new Promise(function (resolve, reject) {
            resolve(res);
          });
        }

        function handleResponse(searchReq, layerProps) {
          searchReq = typeof searchReq === 'string' ? JSON.parse(searchReq.substring(1, searchReq.length - 1)) : searchReq;
          var arrLayerResult = [];
          var arrResult = [];

          if (searchReq.Status == 'ok') {
            for (var iServer = 0; iServer < searchReq.Result.length; iServer++) {
              var limitSearchResults = typeof LayerSearchLimit == "number" ? LayerSearchLimit : 100;
              var req = searchReq.Result[iServer];

              for (var j = 0; j < limitSearchResults && j < req.SearchResult.length; j++) {
                var arrDisplayProperties = {};

                {
                  arrDisplayProperties = req.SearchResult[j].properties;
                }

                for (var p in arrDisplayProperties) {
                  var type = layerProps.attrTypes[layerProps.attributes.indexOf(p)];
                  arrDisplayProperties[p] = nsGmx$1.Utils.convertFromServer(type, arrDisplayProperties[p]);
                }

                arrLayerResult.push({
                  ObjName: req.SearchResult[j].properties.NAME || req.SearchResult[j].properties.Name || req.SearchResult[j].properties.name || req.SearchResult[j].properties.text || req.SearchResult[j].properties["Название"] || "[объект]",
                  properties: arrDisplayProperties,
                  Geometry: L.gmxUtil.convertGeometry(req.SearchResult[j].geometry, true)
                });
              }
            }

            if (arrLayerResult.length > 0) arrResult.push({
              name: layerProps.title,
              SearchResult: arrLayerResult,
              CanDownloadVectors: true
            });

            return Promise.resolve(arrResult);
          } else {
            return Promise.reject(searchReq);
          }
        }
      }
    };

    var main = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', { value: true });

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var EventTarget = function () {
        function EventTarget() {
            classCallCheck(this, EventTarget);

            this.listeners = {};
        }

        createClass(EventTarget, [{
            key: 'addEventListener',
            value: function addEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    this.listeners[type] = [];
                }
                this.listeners[type].push(callback);
            }
        }, {
            key: 'on',
            value: function on(type, callback) {
                this.addEventListener(type, callback);
                return this;
            }
        }, {
            key: 'removeEventListener',
            value: function removeEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[type];
                for (var i = 0, l = stack.length; i < l; i++) {
                    if (stack[i] === callback) {
                        stack.splice(i, 1);
                        return this.removeEventListener(type, callback);
                    }
                }
            }
        }, {
            key: 'off',
            value: function off(type, callback) {
                this.removeEventListener(type, callback);
                return this;
            }
        }, {
            key: 'dispatchEvent',
            value: function dispatchEvent(event) {
                if (!(event.type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[event.type];
                Object.defineProperty(event, 'target', {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: this
                });
                for (var i = 0, l = stack.length; i < l; i++) {
                    stack[i].call(this, event);
                }
            }
        }]);
        return EventTarget;
    }();

    var scanexEventTarget_cjs = EventTarget;

    var ResultView =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(ResultView, _EventTarget);

      function ResultView(_ref) {
        var _this;

        var input = _ref.input,
            _ref$replaceInput = _ref.replaceInput,
            replaceInput = _ref$replaceInput === void 0 ? false : _ref$replaceInput;

        _classCallCheck(this, ResultView);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(ResultView).call(this));
        _this._input = input;
        _this.index = -1;
        _this.count = 0;
        _this._item = null;
        _this._inputText = '';
        _this._replaceInput = replaceInput;
        _this._list = L.DomUtil.create('div');

        _this._list.setAttribute('class', 'leaflet-ext-search-list noselect');

        _this.allowNavigation = true;
        _this._list.style.top = "".concat(_this._input.offsetTop + _this._input.offsetHeight + 2, "px");
        _this._list.style.left = "".concat(_this._input.offsetLeft, "px");
        _this._handleKey = _this._handleKey.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('keydown', _this._handleKey);

        _this._handleInputClick = _this._handleInputClick.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('click', _this._handleInputClick);

        _this._handleFocus = _this._handleFocus.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('focus', _this._handleFocus);

        _this._list.addEventListener('keydown', _this._handleKey);

        _this._handleWheel = _this._handleWheel.bind(_assertThisInitialized(_this));

        _this._list.addEventListener('wheel', _this._handleWheel);

        L.DomEvent.disableClickPropagation(_this._list).disableScrollPropagation(_this._list); // this._list.addEventListener('mousewheel', this._handleWheel.bind(this));
        // this._list.addEventListener('MozMousePixelScroll', this._handleWheel.bind(this));       

        _this._input.parentElement.appendChild(_this._list);

        _this._handleChange = _this._handleChange.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('input', _this._handleChange);

        return _this;
      }

      _createClass(ResultView, [{
        key: "_handleInputClick",
        value: function _handleInputClick(e) {
          e.stopPropagation();
        }
      }, {
        key: "_handleFocus",
        value: function _handleFocus(e) {
          if (this.index >= 0) {
            var el = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

            L.DomUtil.removeClass(el, 'leaflet-ext-search-list-selected');
          }

          this.index = -1;
          this._item = null;
        }
      }, {
        key: "_handleChange",
        value: function _handleChange(e) {
          this._inputText = this._input.value;
        }
      }, {
        key: "_handleWheel",
        value: function _handleWheel(e) {
          e.stopPropagation();
        }
      }, {
        key: "_handleKey",
        value: function _handleKey(e) {
          if (this.listVisible()) {
            switch (e.keyCode) {
              // ArroLeft / ArrowRight
              case 37:
              case 39:
                e.stopPropagation();
                break;
              // ArrowDown

              case 40:
                e.preventDefault();
                e.stopPropagation();

                if (this.allowNavigation) {
                  if (this.index < 0) {
                    this.index = 0;
                  } else if (0 <= this.index && this.index < this.count - 1) {
                    var _el = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                    L.DomUtil.removeClass(_el, 'leaflet-ext-search-list-selected');
                    ++this.index;
                  } else {
                    var _el2 = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                    L.DomUtil.removeClass(_el2, 'leaflet-ext-search-list-selected');
                    this.index = this.count - 1;
                  }

                  var el = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                  L.DomUtil.addClass(el, 'leaflet-ext-search-list-selected');
                  this.selectItem(this.index);
                  el.focus();
                }

                break;
              // ArrowUp

              case 38:
                e.preventDefault();
                e.stopPropagation();

                if (this.allowNavigation) {
                  if (this.index > 0) {
                    var _el3 = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                    L.DomUtil.removeClass(_el3, 'leaflet-ext-search-list-selected');
                    --this.index;
                    _el3 = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));
                    L.DomUtil.addClass(_el3, 'leaflet-ext-search-list-selected');
                    this.selectItem(this.index);

                    _el3.focus();
                  } else if (this.index === 0) {
                    this._input.focus();

                    this._input.value = this._inputText;
                  }
                }

                break;
              // Enter

              case 13:
                if (this.index < 0 && this._input.value) {
                  var text = this._input.value;

                  this._input.focus();

                  this._input.setSelectionRange(text.length, text.length);

                  this.hide();
                  var event = document.createEvent('Event');
                  event.initEvent('suggestions:confirm', false, false);
                  event.detail = text;
                  this.dispatchEvent(event);
                } else {
                  this.complete(this.index);
                }

                break;
              // Escape

              case 27:
                if (this.index < 0) {
                  this.hide();
                }

                this._input.focus();

                this._input.value = this._inputText;
                break;

              default:
                break;
            }
          } else {
            if (e.keyCode === 13 && this._input.value) {
              var _text = this._input.value;

              this._input.setSelectionRange(_text.length, _text.length);

              var _event = document.createEvent('Event');

              _event.initEvent('suggestions:confirm', false, false);

              _event.detail = _text;
              this.dispatchEvent(_event);
            } else if (e.keyCode === 27) {
              this._input.value = '';
              this.index = -1;

              this._input.focus();
            }
          }
        }
      }, {
        key: "listVisible",
        value: function listVisible() {
          return this.count > 0 && this._list.style.display !== 'none';
        }
      }, {
        key: "selectItem",
        value: function selectItem(i) {
          this._item = this._items[i];
          var text = this._item.name;

          if (this._replaceInput) {
            this._input.value = text;

            this._input.setSelectionRange(text.length, text.length);
          }
        }
      }, {
        key: "_handleClick",
        value: function _handleClick(i, e) {
          e.preventDefault();
          this.complete(i);
        }
      }, {
        key: "complete",
        value: function complete(i) {
          var item = i >= 0 ? this._items[i] : this._item ? this._item : null;

          if (item) {
            this._item = item;
            this.index = -1;
            var text = item.name;

            if (this._replaceInput) {
              this._input.value = text;

              this._input.setSelectionRange(text.length, text.length);
            }

            this._input.focus();

            this.hide();
            var event = document.createEvent('Event');
            event.initEvent('suggestions:select', false, false);
            event.detail = item;
            this.dispatchEvent(event);
          }
        }
      }, {
        key: "show",
        value: function show(items, highlight) {
          if (items.length) {
            this._item = null;
            this.index = -1;
            this._items = items;
            var html = '<ul>' + this._items.filter(function (x) {
              return x.name && x.name.length;
            }).map(function (x, i) {
              var name = "<span class=\"leaflet-ext-search-list-item-normal\">".concat(x.name, "</span>");

              if (highlight && highlight.length) {
                var start = x.name.toLowerCase().indexOf(highlight.toLowerCase());

                if (start != -1) {
                  var head = x.name.substr(0, start);

                  if (head.length) {
                    head = "<span class=\"leaflet-ext-search-list-item-normal\">".concat(head, "</span>");
                  }

                  var tail = x.name.substr(start + highlight.length);

                  if (tail.length) {
                    tail = "<span class=\"leaflet-ext-search-list-item-normal\">".concat(tail, "</span>");
                  }

                  name = "".concat(head, "<span class=\"leaflet-ext-search-list-item-highlight\">").concat(highlight, "</span>").concat(tail);
                }
              }

              return "<li tabindex=".concat(i, ">").concat(name, "</li>");
            }, []).join('') + '</ul>';
            this._list.innerHTML = html;

            var elements = this._list.querySelectorAll('li');

            for (var i = 0; i < elements.length; ++i) {
              elements[i].addEventListener('click', this._handleClick.bind(this, i));
            }

            this.count = elements.length;
            this._list.style.display = 'block';
          }
        }
      }, {
        key: "hide",
        value: function hide() {
          this._list.style.display = 'none';
        }
      }]);

      return ResultView;
    }(scanexEventTarget_cjs);

    function chain(tasks, state) {
      return tasks.reduce(function (prev, next) {
        return prev.then(next);
      }, new Promise(function (resolve, reject) {
        return resolve(state);
      }));
    }

    var SearchWidget =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(SearchWidget, _EventTarget);

      function SearchWidget(container, _ref) {
        var _this;

        var placeHolder = _ref.placeHolder,
            providers = _ref.providers,
            _ref$suggestionTimeou = _ref.suggestionTimeout,
            suggestionTimeout = _ref$suggestionTimeou === void 0 ? 1000 : _ref$suggestionTimeou,
            _ref$suggestionLimit = _ref.suggestionLimit,
            suggestionLimit = _ref$suggestionLimit === void 0 ? 10 : _ref$suggestionLimit,
            _ref$fuzzySearchLimit = _ref.fuzzySearchLimit,
            fuzzySearchLimit = _ref$fuzzySearchLimit === void 0 ? 1000 : _ref$fuzzySearchLimit,
            _ref$retrieveManyOnEn = _ref.retrieveManyOnEnter,
            retrieveManyOnEnter = _ref$retrieveManyOnEn === void 0 ? false : _ref$retrieveManyOnEn,
            _ref$replaceInputOnEn = _ref.replaceInputOnEnter,
            replaceInputOnEnter = _ref$replaceInputOnEn === void 0 ? false : _ref$replaceInputOnEn;

        _classCallCheck(this, SearchWidget);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(SearchWidget).call(this));
        _this._container = container;
        _this._allowSuggestion = true;
        _this._providers = providers;
        _this._suggestionTimeout = suggestionTimeout;
        _this._suggestionLimit = suggestionLimit;
        _this._fuzzySearchLimit = fuzzySearchLimit;
        _this._retrieveManyOnEnter = retrieveManyOnEnter;
        _this._replaceInputOnEnter = replaceInputOnEnter;

        _this._container.classList.add('leaflet-ext-search');

        _this._container.innerHTML = "<input type=\"text\" value=\"\" placeholder=\"".concat(placeHolder, "\" /><span class=\"leaflet-ext-search-button\"></span>");
        _this._input = _this._container.querySelector('input');
        _this._handleChange = _this._handleChange.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('input', _this._handleChange);

        _this._handleMouseMove = _this._handleMouseMove.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('mousemove', _this._handleMouseMove);

        _this._input.addEventListener('dragstart', _this._handleMouseMove);

        _this._input.addEventListener('drag', _this._handleMouseMove);

        _this._handleSearch = _this._handleSearch.bind(_assertThisInitialized(_this));
        _this._button = _this._container.querySelector('.leaflet-ext-search-button');

        _this._button.addEventListener('click', _this._handleSearch);

        _this.results = new ResultView({
          input: _this._input,
          replaceInput: _this._replaceInputOnEnter
        });
        _this._search = _this._search.bind(_assertThisInitialized(_this));
        _this._selectItem = _this._selectItem.bind(_assertThisInitialized(_this));

        _this.results.addEventListener('suggestions:confirm', function (e) {
          var event = document.createEvent('Event');
          event.initEvent('suggestions:confirm', false, false);
          event.detail = e.detail;

          _this.dispatchEvent(event);

          _this._search(e);
        });

        _this.results.addEventListener('suggestions:select', _this._selectItem); // map.on ('click', this.results.hide.bind(this.results));
        // map.on ('dragstart', this.results.hide.bind(this.results));


        return _this;
      }

      _createClass(SearchWidget, [{
        key: "_suggest",
        value: function _suggest(text) {
          var _this2 = this;

          this.results.allowNavigation = false;

          var tasks = this._providers.filter(function (provider) {
            return provider.showSuggestion;
          }).map(function (provider) {
            return function (state) {
              return new Promise(function (resolve) {
                if (state.completed) {
                  resolve(state);
                } else {
                  provider.find(text, _this2._suggestionLimit, false, false).then(function (response) {
                    state.completed = response.length > 0;
                    state.response = state.response.concat(response);
                    resolve(state);
                  })["catch"](function (e) {
                    return console.log(e);
                  });
                }
              });
            };
          });

          chain(tasks, {
            completed: false,
            response: []
          }).then(function (state) {
            _this2.results.show(state.response, text.trim());

            _this2.results.allowNavigation = true;
          });
        }
      }, {
        key: "_handleChange",
        value: function _handleChange(e) {
          var _this3 = this;

          if (this._input.value.length) {
            if (this._allowSuggestion) {
              this._allowSuggestion = false;
              this._timer = setTimeout(function () {
                clearTimeout(_this3._timer);
                _this3._allowSuggestion = true;
                var text = _this3._input.value;

                _this3._suggest(text);
              }, this._suggestionTimeout);
            }
          } else {
            this.results.hide();
          }
        }
      }, {
        key: "_handleMouseMove",
        value: function _handleMouseMove(e) {
          e.stopPropagation();
          e.preventDefault();
        }
      }, {
        key: "_search",
        value: function _search(e) {
          var _this4 = this;

          var text = e.detail;

          var tasks = this._providers.filter(function (provider) {
            return provider.showOnEnter;
          }).map(function (provider) {
            return function (state) {
              return new Promise(function (resolve) {
                if (state.completed) {
                  resolve(state);
                } else {
                  provider.find(text, _this4._retrieveManyOnEnter ? _this4._fuzzySearchLimit : 1, true, true).then(function (response) {
                    state.completed = response.length > 0;
                    state.response = state.response.concat(response);
                    resolve(state);
                  })["catch"](function (e) {
                    console.log(e);
                    resolve(state);
                  });
                }
              });
            };
          });

          chain(tasks, {
            completed: false,
            response: []
          }).then(function (state) {// if(state.response.length > 0 && !this._retrieveManyOnEnter){
            //     let item = state.response[0];
            //     item.provider
            //     .fetch(item.properties)
            //     .then(response => {});                    
            // }
          });
          this.results && this.results.hide();
        }
      }, {
        key: "_selectItem",
        value: function _selectItem(e) {
          var item = e.detail;
          return item.provider.fetch(item.properties);
        }
      }, {
        key: "_handleSearch",
        value: function _handleSearch(e) {
          e.stopPropagation();

          this._search({
            detail: this._input.value
          });
        }
      }, {
        key: "setText",
        value: function setText(text) {
          this._input.value = text;
        }
      }, {
        key: "setPlaceHolder",
        value: function setPlaceHolder(value) {
          this._input.placeholder = value;
        }
      }]);

      return SearchWidget;
    }(scanexEventTarget_cjs);

    var SearchControl = L.Control.extend({
      includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,
      initialize: function initialize(options) {
        L.setOptions(this, options);
        this._allowSuggestion = true;
        this.options.suggestionTimeout = this.options.suggestionTimeout || 1000;
        this.options.suggestionLimit = this.options.suggestionLimit || 10;
      },
      onAdd: function onAdd(map) {
        this._container = L.DomUtil.create('div', 'leaflet-ext-search');
        this._widget = new SearchWidget(this._container, this.options);
        map.on('click', this._widget.results.hide.bind(this._widget.results));
        map.on('dragstart', this._widget.results.hide.bind(this._widget.results));
        return this._container;
      },
      addTo: function addTo(map) {
        L.Control.prototype.addTo.call(this, map);

        if (this.options.addBefore) {
          this.addBefore(this.options.addBefore);
        }

        return this;
      },
      addBefore: function addBefore(id) {
        var parentNode = this._parent && this._parent._container;

        if (!parentNode) {
          parentNode = this._map && this._map._controlCorners[this.getPosition()];
        }

        if (!parentNode) {
          this.options.addBefore = id;
        } else {
          for (var i = 0, len = parentNode.childNodes.length; i < len; i++) {
            var it = parentNode.childNodes[i];

            if (id === it._id) {
              parentNode.insertBefore(this._container, it);
              break;
            }
          }
        }

        return this;
      },
      setText: function setText(text) {
        this._widget.setText(text);
      },
      setPlaceHolder: function setPlaceHolder(value) {
        this._widget.setPlaceHolder(value);
      }
    });

    var OsmDataProvider =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(OsmDataProvider, _EventTarget);

      function OsmDataProvider(_ref) {
        var _this;

        var serverBase = _ref.serverBase;

        _classCallCheck(this, OsmDataProvider);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(OsmDataProvider).call(this));
        _this._serverBase = serverBase;
        _this.showSuggestion = true;
        _this.showOnSelect = true;
        _this.showOnEnter = true;
        _this.find = _this.find.bind(_assertThisInitialized(_this));
        _this.fetch = _this.fetch.bind(_assertThisInitialized(_this));
        _this._convertGeometry = _this._convertGeometry.bind(_assertThisInitialized(_this));
        _this._key = window.KOSMOSNIMKI_SESSION_KEY == null || window.KOSMOSNIMKI_SESSION_KEY == 'INVALID' ? '' : "&key=".concat(window.KOSMOSNIMKI_SESSION_KEY);
        return _this;
      }

      _createClass(OsmDataProvider, [{
        key: "_convertGeometry",
        value: function _convertGeometry(geometry) {
          switch (geometry.type.toUpperCase()) {
            case 'POINT':
              geometry.type = 'Point';
              break;

            case 'POLYGON':
              geometry.type = 'Polygon';
              break;

            case 'MULTIPOLYGON':
              geometry.type = 'MultiPolygon';
              break;

            case 'LINESTRING':
            case 'POLYLINE':
              geometry.type = 'LineString';
              break;

            case 'MULTILINESTRING':
              geometry.type = 'MultiLineString';
              break;

            default:
              throw 'Unknown WKT type';
          }

          return geometry;
        }
      }, {
        key: "fetch",
        value: function (_fetch) {
          function fetch(_x) {
            return _fetch.apply(this, arguments);
          }

          fetch.toString = function () {
            return _fetch.toString();
          };

          return fetch;
        }(function (obj) {
          var _this2 = this;

          var query = "WrapStyle=None&RequestType=ID&ID=".concat(obj.ObjCode, "&TypeCode=").concat(obj.TypeCode, "&UseOSM=1");
          var req = new Request("".concat(this._serverBase, "/SearchObject/SearchAddress.ashx?").concat(query).concat(this._key));
          var headers = new Headers();
          headers.append('Content-Type', 'application/json');
          var init = {
            method: 'GET',
            mode: 'cors',
            credentials: 'include',
            cache: 'default'
          };
          return new Promise(function (resolve, reject) {
            fetch(req, init).then(function (response) {
              return response.json();
            }).then(function (json) {
              if (json.Status === 'ok') {
                var rs = json.Result.reduce(function (a, x) {
                  return a.concat(x.SearchResult);
                }, []).map(function (x) {
                  var g = _this2._convertGeometry(x.Geometry);

                  var props = Object.keys(x).filter(function (k) {
                    return k !== 'Geometry';
                  }).reduce(function (a, k) {
                    a[k] = x[k];
                    return a;
                  }, {});
                  return {
                    feature: {
                      type: 'Feature',
                      geometry: g,
                      properties: props
                    },
                    provider: _this2,
                    query: obj
                  };
                });
                var event = document.createEvent('Event');
                event.initEvent('fetch', false, false);
                event.detail = rs;

                _this2.dispatchEvent(event);

                resolve(rs);
              } else {
                reject(json);
              }
            })["catch"](function (response) {
              return reject(response);
            });
          });
        })
      }, {
        key: "find",
        value: function find(value, limit, strong, retrieveGeometry) {
          var _this3 = this;

          return new Promise(function (resolve, reject) {
            if (value || value.trim()) {
              var _strong = Boolean(strong) ? 1 : 0;

              var _withoutGeometry = Boolean(retrieveGeometry) ? 0 : 1;

              var query = "WrapStyle=None&RequestType=SearchObject&IsStrongSearch=".concat(_strong, "&WithoutGeometry=").concat(_withoutGeometry, "&UseOSM=1&Limit=").concat(limit, "&SearchString=").concat(encodeURIComponent(value));
              var req = new Request("".concat(_this3._serverBase, "/SearchObject/SearchAddress.ashx?").concat(query).concat(_this3._key));
              var headers = new Headers();
              headers.append('Content-Type', 'application/json');
              var init = {
                method: 'GET',
                mode: 'cors',
                credentials: 'include',
                cache: 'default'
              };
              fetch(req, init).then(function (response) {
                return response.json();
              }).then(function (json) {
                if (json.Status === 'ok') {
                  var rs = json.Result.reduce(function (a, x) {
                    return a.concat(x.SearchResult);
                  }, []).map(function (x) {
                    if (retrieveGeometry && x.Geometry) {
                      var g = _this3._convertGeometry(x.Geometry);

                      var props = Object.keys(x).filter(function (k) {
                        return k !== 'Geometry';
                      }).reduce(function (a, k) {
                        a[k] = x[k];
                        return a;
                      }, {});
                      return {
                        name: x.ObjNameShort,
                        feature: {
                          type: 'Feature',
                          geometry: g,
                          properties: props
                        },
                        properties: props,
                        provider: _this3,
                        query: value
                      };
                    } else {
                      return {
                        name: x.ObjNameShort,
                        properties: x,
                        provider: _this3,
                        query: value
                      };
                    }
                  });

                  if (strong && retrieveGeometry) {
                    var event = document.createEvent('Event');
                    event.initEvent('fetch', false, false);
                    event.detail = rs;

                    _this3.dispatchEvent(event);
                  }

                  resolve(rs);
                } else {
                  reject(json);
                }
              })["catch"](function (response) {
                return reject(response);
              });
            } else {
              reject('Empty string');
            }
          });
        }
      }]);

      return OsmDataProvider;
    }(scanexEventTarget_cjs);

    var CoordinatesDataProvider =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(CoordinatesDataProvider, _EventTarget);

      function CoordinatesDataProvider() {
        var _this;

        _classCallCheck(this, CoordinatesDataProvider);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(CoordinatesDataProvider).call(this));
        _this.showSuggestion = false;
        _this.showOnSelect = false;
        _this.showOnEnter = true;
        _this.fetch = _this.fetch.bind(_assertThisInitialized(_this));
        _this.find = _this.find.bind(_assertThisInitialized(_this));
        _this.rxF = new RegExp('^\\s*\\-?(\\d+(\\.\\d+)?)(\\s+[N|S])?(,\\s*|\\s+)\\-?(\\d+(\\.\\d+)?)(\\s+[E|W])?');
        _this.rxD = new RegExp("^\\s*(\\d{1,2})[\\s|\\u00b0](\\d{1,2})[\\s|\\u0027](\\d{1,2}\\.\\d+)\\u0022?(\\s+[N|S])?,?\\s+(\\d{1,2})[\\s|\\u00b0](\\d{1,2})[\\s|\\u0027](\\d{1,2}\\.\\d+)\\u0022?(\\s+[E|W])?");
        return _this;
      }

      _createClass(CoordinatesDataProvider, [{
        key: "_parseCoordinates",
        value: function _parseCoordinates(value) {
          var m = this.rxD.exec(value);

          if (Array.isArray(m) && m.length === 9) {
            return this._parseDegrees([m[1], m[2], m[3], m[5], m[6], m[7]].map(function (x) {
              return parseFloat(x);
            }));
          }

          m = this.rxF.exec(value);

          if (Array.isArray(m) && m.length === 8) {
            return {
              type: 'Point',
              coordinates: [parseFloat(m[5]), parseFloat(m[1])]
            };
          }

          return null;
        }
      }, {
        key: "_parseDegrees",
        value: function _parseDegrees(_ref) {
          var _ref2 = _slicedToArray(_ref, 6),
              latDeg = _ref2[0],
              latMin = _ref2[1],
              latSec = _ref2[2],
              lngDeg = _ref2[3],
              lngMin = _ref2[4],
              lngSec = _ref2[5];

          return {
            type: 'Point',
            coordinates: [lngDeg + lngMin / 60 + lngSec / 3600, latDeg + latMin / 60 + latSec / 3600]
          };
        }
      }, {
        key: "fetch",
        value: function fetch(value) {
          return new Promise(function (resolve) {
            return resolve([]);
          });
        }
      }, {
        key: "find",
        value: function find(value, limit, strong, retrieveGeometry) {
          var _this2 = this;

          var g = this._parseCoordinates(value);

          return new Promise(function (resolve) {
            var result = {
              feature: {
                type: 'Feature',
                geometry: g,
                properties: {}
              },
              provider: _this2,
              query: value
            };

            if (g) {
              var event = document.createEvent('Event');
              event.initEvent('fetch', false, false);
              event.detail = result;

              _this2.dispatchEvent(event);
            }

            resolve(g ? [result] : []);
          });
        }
      }]);

      return CoordinatesDataProvider;
    }(scanexEventTarget_cjs);

    var CadastreDataProvider =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(CadastreDataProvider, _EventTarget);

      function CadastreDataProvider(_ref) {
        var _this;

        var serverBase = _ref.serverBase,
            tolerance = _ref.tolerance;

        _classCallCheck(this, CadastreDataProvider);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(CadastreDataProvider).call(this));
        _this._serverBase = serverBase;
        _this._tolerance = tolerance;
        _this.showSuggestion = true;
        _this.showOnSelect = false;
        _this.showOnEnter = true;
        _this._cadastreLayers = [{
          id: 1,
          title: 'Участок',
          reg: /^\d\d:\d+:\d+:\d+$/
        }, {
          id: 2,
          title: 'Квартал',
          reg: /^\d\d:\d+:\d+$/
        }, {
          id: 3,
          title: 'Район',
          reg: /^\d\d:\d+$/
        }, {
          id: 4,
          title: 'Округ',
          reg: /^\d\d$/
        }, {
          id: 5,
          title: 'ОКС',
          reg: /^\d\d:\d+:\d+:\d+:\d+$/
        }, {
          id: 10,
          title: 'ЗОУИТ',
          reg: /^\d+\.\d+\.\d+/ // ,
          // {id: 7, title: 'Границы', 	reg: /^\w+$/},
          // {id: 6, title: 'Тер.зоны', 	reg: /^\w+$/},
          // {id: 12, title: 'Лес', 		reg: /^\w+$/},
          // {id: 13, title: 'Красные линии', 		reg: /^\w+$/},
          // {id: 15, title: 'СРЗУ', 	reg: /^\w+$/},
          // {id: 16, title: 'ОЭЗ', 		reg: /^\w+$/},
          // {id: 9, title: 'ГОК', 		reg: /^\w+$/},
          // {id: 10, title: 'ЗОУИТ', 	reg: /^\w+$/}
          // /[^\d\:]/g,
          // /\d\d:\d+$/,
          // /\d\d:\d+:\d+$/,
          // /\d\d:\d+:\d+:\d+$/

        }];
        return _this;
      }

      _createClass(CadastreDataProvider, [{
        key: "getCadastreLayer",
        value: function getCadastreLayer(str, type) {
          str = str.trim();

          for (var i = 0, len = this._cadastreLayers.length; i < len; i++) {
            var it = this._cadastreLayers[i];

            if (it.id === type) {
              return it;
            }

            if (it.reg.exec(str)) {
              return it;
            }
          }

          return this._cadastreLayers[0];
        }
      }, {
        key: "find",
        value: function find(value, limit, strong, retrieveGeometry) {
          var _this2 = this;

          var cadastreLayer = this.getCadastreLayer(value);
          return new Promise(function (resolve) {
            // let req = new Request(`${this._serverBase}/typeahead?limit=${limit}&skip=0&text=${value}&type=${cadastreLayer.id}`);
            var req = new Request("".concat(_this2._serverBase, "/features/").concat(cadastreLayer.id, "?text=").concat(value, "&tolerance=").concat(_this2._tolerance, "&limit=").concat(limit));
            var headers = new Headers();
            headers.append('Content-Type', 'application/json');
            var init = {
              method: 'GET',
              mode: 'cors',
              cache: 'default'
            };
            fetch(req, init).then(function (response) {
              return response.json();
            }).then(function (json) {
              // if(json.status === 200){
              var rs = json.features.map(function (x) {
                return {
                  name: x.attrs.name || x.attrs.cn || x.attrs.id,
                  properties: x,
                  provider: _this2,
                  query: value
                };
              });
              resolve(rs); // }
              // else {
              // resolve(json);
              // }                                       
            });
          });
        }
      }, {
        key: "fetch",
        value: function (_fetch) {
          function fetch(_x) {
            return _fetch.apply(this, arguments);
          }

          fetch.toString = function () {
            return _fetch.toString();
          };

          return fetch;
        }(function (obj) {
          var _this3 = this;

          var text = obj.attrs.name || obj.attrs.cn || obj.attrs.id;
          var cadastreLayer = this.getCadastreLayer(text, obj.type);
          return new Promise(function (resolve) {
            if (cadastreLayer) {
              // let req = new Request(`${this._serverBase}/features/${cadastreLayer.id}?tolerance=${this._tolerance}&limit=1&text=${obj.value}`);
              var req = new Request("".concat(_this3._serverBase, "/features/").concat(cadastreLayer.id, "?tolerance=").concat(_this3._tolerance, "&limit=1&text=").concat(text));
              var headers = new Headers();
              headers.append('Content-Type', 'application/json');
              var init = {
                method: 'GET',
                mode: 'cors',
                cache: 'default'
              };
              fetch(req, init).then(function (response) {
                return response.json();
              }).then(function (json) {
                if (json.status === 200) {
                  var event = document.createEvent('Event');
                  event.initEvent('fetch', false, false);
                  event.detail = json;

                  _this3.dispatchEvent(event);

                  var rs = json.features.map(function (x) {
                    return {
                      name: x.attrs.name || x.attrs.cn || x.attrs.id,
                      properties: x,
                      provider: _this3,
                      query: obj
                    };
                  });
                  resolve(rs);
                } else {
                  resolve(json);
                }
              });
            } else {
              resolve([]);
            }
          });
        })
      }]);

      return CadastreDataProvider;
    }(scanexEventTarget_cjs);

    exports.CadastreDataProvider = CadastreDataProvider;
    exports.CoordinatesDataProvider = CoordinatesDataProvider;
    exports.OsmDataProvider = OsmDataProvider;
    exports.SearchControl = SearchControl;
    exports.SearchWidget = SearchWidget;

    });

    unwrapExports(main);
    var main_1 = main.CadastreDataProvider;
    var main_2 = main.CoordinatesDataProvider;
    var main_3 = main.OsmDataProvider;
    var main_4 = main.SearchControl;
    var main_5 = main.SearchWidget;

    nsGmx$1.OsmDataProvider = main_3;
    nsGmx$1.searchProviders = {};

    nsGmx$1.searchProviders.Osm2DataProvider = function (options) {
      nsGmx$1.OsmDataProvider.call(this, options);
    };

    nsGmx$1.searchProviders.Osm2DataProvider.prototype = Object.create(nsGmx$1.OsmDataProvider.prototype);
    nsGmx$1.searchProviders.Osm2DataProvider.prototype.constructor = nsGmx$1.Osm2DataProvider;

    nsGmx$1.searchProviders.Osm2DataProvider.prototype.fetch = function (obj) {
      var _this = this;

      var query = 'WrapStyle=None&RequestType=ID&ID=' + obj.ObjCode + '&TypeCode=' + obj.TypeCode + '&UseOSM=1';
      var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
      var headers = new Headers();
      headers.append('Content-Type', 'application/json');
      var init = {
        method: 'GET',
        mode: 'cors',
        credentials: 'include',
        cache: 'default'
      };
      return new Promise(function (resolve, reject) {
        fetch(req, init).then(function (response) {
          return response.json();
        }).then(function (json) {
          if (json.Status === 'ok') {
            if (typeof _this._onFetch === 'function') {
              _this._onFetch(json.Result);
            }

            var event = document.createEvent('Event');
            event.initEvent('fetch', false, false);
            event.detail = json.Result;

            _this.dispatchEvent(event);

            resolve(json.Result);
          } else {
            reject(json.Result);
          }
        })["catch"](function (response) {
          return reject(response);
        });
      });
    };

    nsGmx$1.searchProviders.Osm2DataProvider.prototype.find = function (value, limit, strong, retrieveGeometry) {
      var result;

      var _this2 = this;

      _this2.searchString = value;

      var _strong = Boolean(strong) ? 1 : 0;

      var _withoutGeometry = Boolean(retrieveGeometry) ? 0 : 1;

      var query = 'WrapStyle=None&RequestType=SearchObject&IsStrongSearch=' + _strong + '&WithoutGeometry=' + _withoutGeometry + '&UseOSM=1&Limit=' + limit + '&SearchString=' + encodeURIComponent(value);
      var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
      var headers = new Headers();
      headers.append('Content-Type', 'application/json');
      var init = {
        method: 'GET',
        mode: 'cors',
        credentials: 'include',
        cache: 'default'
      };
      return new Promise(function (resolve, reject) {
        var initPromise;

        if (!window.useInternalSearch) {
          initPromise = fetch(req, init).then(function (response) {
            return response.json();
          });
        } else {
          initPromise = Promise.resolve({
            Status: 'ok',
            Result: []
          });
        }

        initPromise.then(function (json) {
          if (json.Status === 'ok') {
            json.Result.searchString = _this2.searchString;
            result = json;
            return json;
          } else {
            reject(json.Result);
          }
        }).then(function (json1) {
          return window.searchLogic && window.searchLogic.layersSearch(json1);
        }).then(function (json2) {
          var arr = [];

          for (var i = 0; i < result.Result.length; i++) {
            arr.push(result.Result[i]);
          }

          for (var i = 0; i < json2.length; i++) {
            if (json2[i] && json2[i].length) {
              for (var j = 0; j < json2[i].length; j++) {
                arr.push(json2[i][j]);
              }
            }
          }

          arr.searchString = result.Result.searchString;
          return {
            Status: result.Status,
            Result: arr
          };
        }).then(function (json3) {
          if (json3.Status === 'ok') {
            var rs = json3.Result.reduce(function (a, x) {
              return a.concat(x.SearchResult);
            }, []).map(function (x) {
              if (retrieveGeometry && x.Geometry) {
                var g = _this2._convertGeometry(x.Geometry);

                var props = Object.keys(x).filter(function (k) {
                  return k !== 'Geometry';
                }).reduce(function (a, k) {
                  a[k] = x[k];
                  return a;
                }, {});
                return {
                  name: x.ObjNameShort,
                  feature: {
                    type: 'Feature',
                    geometry: g,
                    properties: props
                  },
                  properties: props,
                  provider: _this2,
                  query: value
                };
              } else {
                return {
                  name: x.ObjNameShort,
                  properties: x,
                  provider: _this2,
                  query: value
                };
              }
            });

            if (strong && retrieveGeometry) {
              var event = document.createEvent('Event');
              event.initEvent('fetch', false, false);
              event.detail = json3.Result;

              _this2.dispatchEvent(event);
            }

            resolve(rs);
          } else {
            reject(json3);
          }
        });
      });
    };

    _translationsHash.addtext("rus", {
      "loadShape.inputTitle": "Добавить shp-файл (в zip)",
      "loadShape.loadDone": "Геометрия успешно загружена",
      "loadShape.loadFail": "Ошибка загрузки геометрии"
    });

    _translationsHash.addtext("eng", {
      "loadShape.inputTitle": "Add shp-file (zipped)",
      "loadShape.loadDone": "Successfully loaded",
      "loadShape.loadFail": "Error loading file"
    });

    var drawingObjects = {
      loadShp: {}
    };

    var queryLoadShp = function queryLoadShp() {
      this.builded = false;
      this.uploader = null;
    };

    queryLoadShp.prototype = new leftMenu$1(); //Старый вариант для IE9
    //просто удаляет все контролы и создаёт все их заново...

    queryLoadShp.prototype._regenerateControl = function () {
      var _this = this;

      $(this.workCanvas).empty();

      var fileInput = _input(null, [['attr', 'type', 'file'], ['attr', 'name', 'file'], ['attr', 'id', 'upload_shapefile']]);

      fileInput.onchange = function () {
        if (this.value != "") _this.upload();
      }; //задаём одновременно и enctype и encoding для корректной работы в IE


      this.postForm = _form([fileInput], [['attr', 'method', 'POST'], ['attr', 'encoding', 'multipart/form-data'], ['attr', 'enctype', 'multipart/form-data'], ['attr', 'id', 'upload_shapefile_form']]);
      this.progress = _img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'display', 'none']]);
      this.inputControl = _div([_span([_t(_gtxt("loadShape.inputTitle") + ":")]), this.postForm]);
      this.workCanvas.appendChild(_div([this.inputControl, this.progress], [['css', 'padding', '10px 0px 5px 20px']]));
    };

    queryLoadShp.prototype.load = function () {
      if (!this.builded) {
        this._regenerateControl();

        this.builded = true;
      }
    };

    queryLoadShp.prototype._showObjectsOnMap = function (objs) {
      if (objs.length == 0) {
        showErrorMessage(_gtxt("Загруженный shp-файл пуст"), true);
        return;
      }

      var lmap = nsGmx.leafletMap,
          gmxDrawing = lmap.gmxDrawing,
          latLngBounds = L.latLngBounds([]);

      for (var i = 0; i < objs.length; i++) {
        var it = objs[i],
            geoJSON = L.gmxUtil.geometryToGeoJSON(it.geometry),
            b = gmxDrawing.addGeoJSON(geoJSON, {
          fill: false,
          properties: it.properties
        })[0].getBounds();
        latLngBounds.extend(b);
      }

      if (latLngBounds.isValid()) {
        lmap.fitBounds(latLngBounds);
      }
    }; //files - массив File или WebForms


    queryLoadShp.prototype.loadAndShowFiles = function (files) {
      nsGmx.widgets.notifications.startAction('uploadShp');
      var def = $.when.apply($, [].slice.call(files).map(function (file) {
        return nsGmx.Utils.parseShpFile(file);
      }));
      def.then(function () {
        this._showObjectsOnMap(_.flatten([].slice.call(arguments)));

        nsGmx.widgets.notifications.stopAction('uploadShp', 'success', _gtxt('loadShape.loadDone'));
      }.bind(this), function () {
        nsGmx.widgets.notifications.stopAction('uploadShp', 'failure', _gtxt('loadShape.loadFail'));
      });
      return def;
    }; //Загружает файлы из поля "file"


    queryLoadShp.prototype.upload = function () {
      hide(this.inputControl);
      show(this.progress);
      this.loadAndShowFiles([this.postForm]).always(function () {
        this.inputControl.removeChild(this.postForm);

        this._regenerateControl();
      }.bind(this));
    };

    var _queryLoadShp = new queryLoadShp();

    drawingObjects.loadShp.load = function () {
      if ('File' in window) {
        $('<input type="file" multiple>').change(function (e) {
          _queryLoadShp.loadAndShowFiles(e.target.files);
        }).click();
      } else {
        //IE9
        var alreadyLoaded = _queryLoadShp.createWorkCanvas(arguments[0] || "shp");

        if (!alreadyLoaded) _queryLoadShp.load();
      }
    };

    drawingObjects.loadShp.unload = function () {};

    var _$4 = nsGmx$1.Utils._;
    var wmsProjections = ['EPSG:3395', 'EPSG:4326', 'EPSG:41001']; // типы проекций

    var getTextContent = function getTextContent(node) {
      if (typeof node.textContent != 'undefined') return node.textContent;
      var data = '';

      for (var i = 0; i < node.childNodes.length; i++) {
        data += node.childNodes[i].data;
      }

      return data;
    };

    var getScale = function getScale(z) {
      return Math.pow(2, -z) * 156543.033928041;
    };
    /** Формирует URL картинки, который можно использовать для получения WMS слоя для данного положения карты
     * @property {String} url - WMS ссылка.
     * @property {object} props - атрибуты.
     * @property {String} props.srs - тип проекции.
     * @property {String} props.version - версия.
     * @property {String} props.name - Идентификатор слоя.
     * @property {object} props.bbox - ограничение по bounds(в географических координатах).
     * @property {object} requestProperties - атрибуты формата результирующего image.
     * @property {String} requestProperties.format - тип (по умолчанию 'image/jpeg').
     * @property {String} requestProperties.transparent - прозрачность подложки ('TRUE'/'FALSE' по умолчанию 'FALSE').
     * @returns {object} - {url: String, bounds: {Extent}}. bounds в географических координатах.
    */


    var getWMSMapURL = function getWMSMapURL(url, props, requestProperties) {
      var CRSParam = {
        '1.1.1': 'SRS',
        '1.3.0': 'CRS'
      };
      requestProperties = requestProperties || {};
      var lmap = nsGmx$1.leafletMap,
          extend = lmap.getBounds();
      var miny = Math.max(extend.getSouth(), -90);
      var maxy = Math.min(extend.getNorth(), 90);
      var minx = Math.max(extend.getWest(), -180);
      var maxx = Math.min(extend.getEast(), 180);

      if (props.bbox) {
        minx = Math.max(props.bbox.minx, minx);
        miny = Math.max(props.bbox.miny, miny);
        maxx = Math.min(props.bbox.maxx, maxx);
        maxy = Math.min(props.bbox.maxy, maxy);
        if (minx >= maxx || miny >= maxy) return;
      }

      var mercMin = L.Projection.Mercator.project({
        lat: miny,
        lng: minx
      }),
          mercMax = L.Projection.Mercator.project({
        lat: maxy,
        lng: maxx
      });
      var scale = getScale(lmap.getZoom());
      var w = Math.round((mercMax.x - mercMin.x) / scale);
      var h = Math.round((mercMax.y - mercMin.y) / scale);
      var isMerc = !(props.srs == wmsProjections[1]);
      var st = url;
      var format = requestProperties.format || 'image/jpeg';
      var transparentParam = requestProperties.transparent ? 'TRUE' : 'FALSE';
      var version = props.version || '1.1.1';
      var isV130 = version === '1.3.0'; //st = st.replace(/Service=WMS[\&]*/i, '');
      //st = st.replace(/\&$/, '');

      st += (st.indexOf('?') == -1 ? '?' : '&') + 'request=GetMap&Service=WMS';
      st += "&layers=" + encodeURIComponent(props.name) + "&VERSION=" + encodeURIComponent(version) + "&" + CRSParam[version] + "=" + encodeURIComponent(props.srs) + "&styles=" + "&width=" + w + "&height=" + h + "&bbox=" + (isMerc ? mercMin.x : isV130 ? miny : minx) + "," + (isMerc ? mercMin.y : isV130 ? minx : miny) + "," + (isMerc ? mercMax.x : isV130 ? maxy : maxx) + "," + (isMerc ? mercMax.y : isV130 ? maxx : maxy);
      if (url.indexOf('format=') == -1) st += "&format=" + encodeURIComponent(format);
      if (url.indexOf('transparent=') == -1) st += "&transparent=" + encodeURIComponent(transparentParam);
      return {
        url: st,
        bounds: {
          minX: minx,
          maxX: maxx,
          minY: miny,
          maxY: maxy
        }
      };
    };
    /**
     * Возвращает описание WMS-слоёв от XML, которую вернул сервер на запрос GetCapabilities
     * @returns {Array} - массив объектов с описанием слоёв
    */


    var parseWMSCapabilities = function parseWMSCapabilities(response) {
      var supportedVersions = {
        '1.1.1': true,
        '1.3.0': true
      };
      var SRSTagName = {
        '1.1.1': 'SRS',
        '1.3.0': 'CRS'
      };
      var BBOXTagName = {
        '1.1.1': 'LatLonBoundingBox',
        '1.3.0': 'EX_GeographicBoundingBox'
      };
      var serviceLayers = [],
          strResp = response.replace(/[\t\n\r]/g, ' '),
          strResp = strResp.replace(/\s+/g, ' '),
          xml = parseXML(response),
          mainTag = xml.getElementsByTagName('WMS_Capabilities')[0] || xml.getElementsByTagName('WMT_MS_Capabilities')[0],
          version = mainTag.getAttribute('version'),
          layersXML = xml.getElementsByTagName('Layer');

      if (!(version in supportedVersions)) {
        return [];
      }

      for (var i = 0; i < layersXML.length; i++) {
        var layer = {
          version: version
        },
            name = layersXML[i].getElementsByTagName('Name'),
            title = layersXML[i].getElementsByTagName('Title'),
            bbox = layersXML[i].getElementsByTagName(BBOXTagName[version]),
            srs = layersXML[i].getElementsByTagName(SRSTagName[version]);

        if (srs.length) {
          layer.srs = null;
          var supportedSrs = {};

          for (var si = 0; si < srs.length; si++) {
            var srsName = strip(getTextContent(srs[si]));
            supportedSrs[srsName] = true;
          } //порядок имеет значение!


          for (var p = 0; p < wmsProjections.length; p++) {
            if (wmsProjections[p] in supportedSrs) {
              layer.srs = wmsProjections[p];
              break;
            }
          }

          if (!layer.srs) continue;
        } else {
          layer.srs = wmsProjections[0];
        }

        if (name.length) layer.name = getTextContent(name[0]);

        if (bbox.length) {
          if (version == '1.1.1') {
            layer.bbox = {
              minx: Number(bbox[0].getAttribute('minx')),
              miny: Number(bbox[0].getAttribute('miny')),
              maxx: Number(bbox[0].getAttribute('maxx')),
              maxy: Number(bbox[0].getAttribute('maxy'))
            };
          } else {
            layer.bbox = {
              minx: Number(getTextContent(bbox[0].getElementsByTagName('westBoundLongitude')[0])),
              miny: Number(getTextContent(bbox[0].getElementsByTagName('southBoundLatitude')[0])),
              maxx: Number(getTextContent(bbox[0].getElementsByTagName('eastBoundLongitude')[0])),
              maxy: Number(getTextContent(bbox[0].getElementsByTagName('northBoundLatitude')[0]))
            };
          }
        }

        if (title.length) layer.title = getTextContent(title[0]);
        if (layer.name) serviceLayers.push(layer);
      }

      return serviceLayers;
    };

    var loadServerData = window.loadServerData = {
      WFS: {},
      WMS: {}
      /* Порядок координат в WFS зависит от формата SRS (http://geoserver.org/display/GEOSDOC/2.+WFS+-+Web+Feature+Service)
          * EPSG:xxxx: longitude/latitude (supported in WFS 1.1 requests too)
          * http://www.opengis.net/gml/srs/epsg.xml#xxxx: longitude/latitude (supported in WFS 1.1 requests too)
          * urn:x-ogc:def:crs:EPSG:xxxx: latitude/longitude
      */

    };

    var wfsParser = function wfsParser() {
      this.gmlns = window.location.protocol + '//www.opengis.net/gml';
      this.kmlns = window.location.protocol + '//earth.google.com/kml/2.0';
      this.axisOrder = null;
    };

    wfsParser.prototype.elementsNS = function (node, uri, name) {
      var elements = [];
      if (node.getElementsByTagNameNS) elements = node.getElementsByTagNameNS(uri, name);else {
        var allNodes = node.getElementsByTagName("*"),
            potentialNode,
            fullName;

        for (var i = 0, len = allNodes.length; i < len; ++i) {
          potentialNode = allNodes[i];
          fullName = potentialNode.prefix ? potentialNode.prefix + ":" + name : name;

          if (name == "*" || fullName == potentialNode.nodeName) {
            if (uri == "*" || uri == potentialNode.namespaceURI) elements.push(potentialNode);
          }
        }
      }
      return elements;
    };

    wfsParser.prototype.getChildValue = function (node, def) {
      var value = def || "";

      if (node) {
        for (var child = node.firstChild; child; child = child.nextSibling) {
          switch (child.nodeType) {
            case 3:
            case 4:
              value += child.nodeValue;
          }
        }
      }

      return value;
    };

    wfsParser.prototype.parse = function (response, srs) {
      var geometries = [],
          strResp = response.replace(/[\t\n\r]/g, ' '),
          strResp = strResp.replace(/\s+/g, ' '),
          xml = parseXML(strResp),
          parsedNS = strResp.indexOf('<kml') > -1 ? this.kmlns : this.gmlns;
      this.axisOrder = srs && srs.indexOf("urn:") == 0 ? 'latlong' : 'longlat';
      var order = ["Polygon", "LineString", "Point"];

      for (var i = 0, len = order.length; i < len; ++i) {
        var type = order[i],
            nodeList = this.elementsNS(xml.documentElement, parsedNS, type);

        for (var j = 0; j < nodeList.length; ++j) {
          geometry = this['parse' + type].apply(this, [nodeList[j]]);
          if (geometry) geometries.push(geometry);
        }
      }

      return geometries;
    };

    wfsParser.prototype.parsePoint = function (node) {
      var coordString,
          coords = [],
          nodeList = this.elementsNS(node, this.gmlns, "pos");

      if (nodeList.length > 0) {
        coordString = strip(nodeList[0].firstChild.nodeValue);
        coords = coordString.split(" ");
      }

      if (coords.length == 0) {
        nodeList = this.elementsNS(node, this.gmlns, "coordinates");

        if (nodeList.length > 0) {
          coordString = strip(nodeList[0].firstChild.nodeValue);
          coords = coordString.split(",");
        }
      }

      if (coords.length == 0) {
        nodeList = this.elementsNS(node, this.gmlns, "coord");

        if (nodeList.length > 0) {
          var xList = this.elementsNS(nodeList[0], this.gmlns, "X"),
              yList = this.elementsNS(nodeList[0], this.gmlns, "Y");
          if (xList.length > 0 && yList.length > 0) coords = [xList[0].firstChild.nodeValue, yList[0].firstChild.nodeValue];
        }
      }

      return {
        feature: {},
        geometry: {
          type: 'Point',
          coordinates: this.swapCoordinates([Number(coords[0]), Number(coords[1])])
        }
      };
    };

    wfsParser.prototype.parseLineString = function (node) {
      var nodeList,
          coordString,
          coords = [],
          points = [],
          nodeList = this.elementsNS(node, this.gmlns, "posList");

      if (nodeList.length > 0) {
        coordString = strip(this.getChildValue(nodeList[0]));
        coords = coordString.split(" ");

        for (var i = 0; i < coords.length / 2; ++i) {
          j = i * 2;
          x = coords[j];
          y = coords[j + 1];
          points.push(this.swapCoordinates([Number(coords[j]), Number(coords[j + 1])]));
        }
      }

      if (coords.length == 0) {
        nodeList = this.elementsNS(node, this.gmlns, "coordinates");

        if (nodeList.length > 0) {
          coordString = strip(this.getChildValue(nodeList[0]));
          coordString = coordString.replace(/\s*,\s*/g, ",");
          var pointList = coordString.split(" ");

          for (var i = 0; i < pointList.length; ++i) {
            coords = pointList[i].split(",");
            points.push(this.swapCoordinates([Number(coords[0]), Number(coords[1])]));
          }
        }
      }

      if (points.length != 0) {
        return {
          feature: {},
          geometry: {
            type: 'LineString',
            coordinates: points
          }
        };
      } else return false;
    };

    wfsParser.prototype.parsePolygon = function (node) {
      var nodeList = this.elementsNS(node, this.gmlns, "LinearRing"),
          components = [];

      if (nodeList.length > 0) {
        var ring;

        for (var i = 0; i < nodeList.length; ++i) {
          ring = this.parseLineString.apply(this, [nodeList[i], true]);
          if (ring) components.push(ring.geometry.coordinates);
        }
      }

      return {
        feature: {},
        geometry: {
          type: 'Polygon',
          coordinates: components
        }
      };
    };

    wfsParser.prototype.swapCoordinates = function (arr) {
      if (this.axisOrder == 'latlong') return [arr[1], arr[0]];else return [arr[0], arr[1]];
    };

    var _wfsParser = new wfsParser();

    var jsonParser = function jsonParser() {
      this.axisOrder = null;
    };

    jsonParser.prototype.parse = function (response, srs) {
      var resp = JSON.parse(response),
          geometries = [];
      this.axisOrder = srs && srs.indexOf("urn:") == 0 ? 'latlong' : 'longlat';

      for (var i = 0; i < resp.features.length; i++) {
        if (resp.features[i].geometry.type.toLowerCase().indexOf('point') > -1) this.parsePoint(resp.features[i], geometries);else if (resp.features[i].geometry.type.toLowerCase().indexOf('linestring') > -1) this.parseLineString(resp.features[i], geometries);else if (resp.features[i].geometry.type.toLowerCase().indexOf('polygon') > -1) this.parsePolygon(resp.features[i], geometries);
      }

      return geometries;
    };

    jsonParser.prototype.parsePoint = function (feature, geometryArr) {
      if (feature.geometry.type.toLowerCase().indexOf('multi') < 0) geometryArr.push({
        feature: feature,
        geometry: {
          type: 'POINT',
          coordinates: this.swapCoordinates(feature.geometry.coordinates)
        }
      });else {
        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
          geometryArr.push({
            feature: feature,
            geometry: {
              type: 'POINT',
              coordinates: this.swapCoordinates(feature.geometry.coordinates[i])
            }
          });
        }
      }
    };

    jsonParser.prototype.parseLineString = function (feature, geometryArr) {
      if (feature.geometry.type.toLowerCase().indexOf('multi') < 0) {
        var newCoords = [];

        for (var j = 0; j < feature.geometry.coordinates.length; j++) {
          newCoords.push(this.swapCoordinates(feature.geometry.coordinates[j]));
        }

        geometryArr.push({
          feature: feature,
          geometry: {
            type: 'LINESTRING',
            coordinates: newCoords
          }
        });
      } else {
        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
          var newCoords = [];

          for (var j = 0; j < feature.geometry.coordinates[i].length; j++) {
            newCoords.push(this.swapCoordinates(feature.geometry.coordinates[i][j]));
          }

          geometryArr.push({
            feature: feature,
            geometry: {
              type: 'LINESTRING',
              coordinates: newCoords
            }
          });
        }
      }
    };

    jsonParser.prototype.parsePolygon = function (feature, geometryArr) {
      if (feature.geometry.type.toLowerCase().indexOf('multi') < 0) {
        var newCoords = [];

        for (var k = 0; k < feature.geometry.coordinates.length; j++) {
          var newCoords2 = [];

          for (var j = 0; j < feature.geometry.coordinates[k].length; k++) {
            newCoords2.push(this.swapCoordinates(feature.geometry.coordinates[k][j]));
          }

          newCoords.push(newCoords2);
        }

        geometryArr.push({
          feature: feature,
          geometry: {
            type: 'POLYGON',
            coordinates: newCoords
          }
        });
      } else {
        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
          var newCoords = [];

          for (var k = 0; k < feature.geometry.coordinates[i].length; k++) {
            var newCoords2 = [];

            for (var j = 0; j < feature.geometry.coordinates[i][k].length; j++) {
              newCoords2.push(this.swapCoordinates(feature.geometry.coordinates[i][k][j]));
            }

            newCoords.push(newCoords2);
          }

          geometryArr.push({
            feature: feature,
            geometry: {
              type: 'POLYGON',
              coordinates: newCoords
            }
          });
        }
      }
    };

    jsonParser.prototype.swapCoordinates = function (arr) {
      if (this.axisOrder == 'latlong') return [arr[1], arr[0]];else return [arr[0], arr[1]];
    };

    var _jsonParser = new jsonParser();

    var queryServerData = function queryServerData() {
      this.inputField = null;
      this.parentCanvas = null;
      this.wfsFormats = {};
      this.oldBalloon = false;
      this.oldBalloonIndex = -1;
      this.proj = ['EPSG:4326', 'EPSG:3395', 'EPSG:41001'];
      this.customParams = undefined;
    };

    queryServerData.prototype = new leftMenu$1();
    /**
        Загружает виджет для добавления/просмотра WMS/WFS слоёв
     @param protocol
     @param parseFunc
     @param drawFunc
     @param customParamsManager {object}- контролер дополнительных параметров. Имеет методы: <br/>
            - init(targetDiv)->void Добавляет контрол к элементу targetDiv<br/>
            - collect()->Object Возвращает выбранные пользователем объекты<br/>
     @param version {string} Версия протокола, которая будет использоваться
    */

    queryServerData.prototype.load = function (protocol, parseFunc, drawFunc, customParamsManager, version) {
      window.convertCoords = function (coordsStr) {
        var res = [],
            coordsPairs = strip(coordsStr).replace(/\s+/, ' ').split(' ');

        if (coordsStr.indexOf(',') == -1) {
          for (var j = 0; j < Math.floor(coordsPairs.length / 2); j++) {
            res.push([Number(coordsPairs[2 * j + 1]), Number(coordsPairs[2 * j])]);
          }
        } else {
          for (var j = 0; j < coordsPairs.length; j++) {
            var parsedCoords = coordsPairs[j].split(',');
            res.push([Number(parsedCoords[1]), Number(parsedCoords[0])]);
          }
        }

        return res;
      };

      window.parseGML = function (response, format, srs) {
        if (format == 'gml') return _wfsParser.parse(response, srs);else if (format == 'json') return _jsonParser.parse(response, srs);else return [];
      };

      var inputField = _input(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '200px']]);

      this.parentCanvas = _div(null, [['dir', 'className', 'serverDataCanvas']]);

      var goButton = makeButton(_gtxt("Загрузить")),
          _this = this;

      var doGetCapabilities = function doGetCapabilities() {
        if (inputField.value != '') {
          if (customParamsManager) _this.customParams = customParamsManager.collect();

          _this.getCapabilities(protocol, strip(inputField.value), parseFunc, drawFunc);

          inputField.value = '';
        } else inputError(inputField);
      };

      goButton.onclick = doGetCapabilities;
      $(inputField).on('keydown', function (e) {
        if (e.keyCode === 13) {
          doGetCapabilities();
          return false;
        }
      });

      var canvas = _div([_div([_span([_t(_gtxt("URL сервера"))])], [['css', 'marginBottom', '3px']]), _table([_tbody([_tr([_td([inputField]), _td([goButton])])])], [['css', 'marginBottom', '5px']])], [['css', 'margin', '3px 0px 0px 10px']]);

      if (customParamsManager) {
        var customParamsDiv = _div();

        $(canvas).append(customParamsDiv);
        _this.customParams = customParamsManager.init(customParamsDiv);
      }

      _$4(this.workCanvas, [canvas, this.parentCanvas]);
    };

    queryServerData.prototype.getCapabilities = function (protocol, url, parseFunc, drawFunc, version) {
      var loading = _div([_img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), _t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px']]),
          _this = this;

      if (this.parentCanvas.childNodes.length == 0) _$4(this.parentCanvas, [loading]);else this.parentCanvas.insertBefore(loading, this.parentCanvas.firstChild);
      var capabilitiesUrl = url.replace(/REQUEST=GetCapabilities[\&]*/i, '').replace(new RegExp('SERVICE=' + protocol + '[\&]', 'i'), '').replace(/\&$/, '');
      capabilitiesUrl += capabilitiesUrl.indexOf('?') !== -1 ? '&' : '?';
      capabilitiesUrl += 'REQUEST=GetCapabilities&SERVICE=' + protocol;

      if (version) {
        capabilitiesUrl += '&VERSION=' + version;
      }

      sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(capabilitiesUrl), function (response) {
        if (!parseResponse(response)) return;
        var servicelayers = parseFunc.call(_this, response.Result);
        drawFunc.call(_this, servicelayers, url, loading, undefined, _this.customParams);
      });
    };

    queryServerData.prototype.parseWFSCapabilities = function (response) {
      var serviceLayers = [],
          strResp = response.replace(/[\t\n\r]/g, ' '),
          strResp = strResp.replace(/\s+/g, ' '),
          featuresXML = parseXML(response).getElementsByTagName('FeatureType');

      for (var i = 0; i < featuresXML.length; i++) {
        var layer = {},
            name = featuresXML[i].getElementsByTagName('Name'),
            title = featuresXML[i].getElementsByTagName('Title'),
            srs = featuresXML[i].getElementsByTagName('DefaultSRS');
        if (name.length) layer.name = getTextContent(name[0]);
        if (title.length) layer.title = getTextContent(title[0]);
        if (srs.length) layer.srs = getTextContent(srs[0]);
        if (layer.name) serviceLayers.push(layer);
      }

      return serviceLayers;
    };

    queryServerData.prototype.loadGML = function (url, parentTreeCanvas, box, header, format, loadLayerParams, srs) {
      var _this = this;

      sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(url), function (response) {
        if (!parseResponse(response)) return;
        var geometries = parseGML(response.Result, format, srs);

        _this.drawGML(geometries, url, parentTreeCanvas, box, header, loadLayerParams);
      });
    };

    queryServerData.prototype.saveGML = function (geometries) {
      if (typeof geometries == 'undefined' || geometries == null) {
        geometries = [];
        globalFlashMap.drawing.forEachObject(function (ret) {
          geometries.push(ret.geometry);
        });
      }

      window.promptFunction(_gtxt('Введите имя gml-файла для скачивания:'), 'objects.gml', function (fileName) {
        globalFlashMap.saveObjects(geometries, nsGmx$1.Utils.translit(fileName));
      });
      return false;
    };

    queryServerData.prototype.drawGML = function (geometries, url, parentTreeCanvas, box, header, loadLayerParams) {
      var parent = {
        'Point': L.gmx.createLayer({
          properties: {}
        }).addTo(nsGmx$1.leafletMap),
        'LineString': L.gmx.createLayer({
          properties: {}
        }).addTo(nsGmx$1.leafletMap),
        'Polygon': L.gmx.createLayer({
          properties: {}
        }).addTo(nsGmx$1.leafletMap)
      },
          styles = {
        'Point': typeof loadLayerParams != 'undefined' && loadLayerParams['point'] ? loadLayerParams['point'].RenderStyle : {
          marker: {
            size: 2
          },
          outline: {
            color: 0x0000ff,
            thickness: 1
          }
        },
        'LineString': typeof loadLayerParams != 'undefined' && loadLayerParams['linestring'] ? loadLayerParams['linestring'].RenderStyle : {
          outline: {
            color: 0x0000ff,
            thickness: 2
          }
        },
        'Polygon': typeof loadLayerParams != 'undefined' && loadLayerParams['polygon'] ? loadLayerParams['polygon'].RenderStyle : {
          outline: {
            color: 0x0000ff,
            thickness: 2,
            opacity: 100
          },
          fill: {
            color: 0xffffff,
            opacity: 20
          }
        }
      }; // parent['POINT'].setStyle(styles['POINT']);
      // parent['LINESTRING'].setStyle(styles['LINESTRING']);
      // parent['POLYGON'].setStyle(styles['POLYGON']);

      var geomsPresent = {},
          bounds = L.gmxUtil.bounds(),
          items = {
        'Point': [],
        'LineString': [],
        'Polygon': []
      };

      for (var i = 0; i < geometries.length; i++) {
        //var elem = parent[geometries[i].geometry.type].addObject(geometries[i].geometry);
        items[geometries[i].geometry.type].push([L.gmxUtil.geoJSONtoGeometry(geometries[i].geometry, true)]); //parent[geometries[i].geometry.type].addItems();

        /*if (objLength(geometries[i].feature) > 0)
        {
        	(function(i)
        	{
        		elem.setHandler("onClick", function(obj)
        		{
        			var elemCanvas = $(divCanvas).find("[geometryType='" + geometries[i].geometry.type + "']")[0];
        					if (!elemCanvas.graphDataProperties ||
        				!geometries[i].feature.properties)
        				return;
        					var balloonCanvas = _div();
        					if (!_diagram.createBalloon(obj, balloonCanvas))
        				return;
        					if (_diagram.createDateTimeDiagramByAttrs(balloonCanvas, 500, 300, geometries[i].feature.properties, elemCanvas.graphDataProperties))
        				_diagram.oldBalloon.resize();
        		})
        	})(i);
        }*/

        geomsPresent[geometries[i].geometry.type] = true;
        bounds.extendArray(geometries[i].geometry.coordinates[0]);
      }

      parent['Point'].addData(items['Point']);
      parent['LineString'].addData(items['LineString']);
      parent['Polygon'].addData(items['Polygon']);

      var divCanvas = _div(),
          divChilds = _div(),
          spanHeader = _span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')]),
          _this = this;

      var clickFunc = function clickFunc(flag) {
        var lmap = nsGmx$1.leafletMap,
            method = flag ? 'addLayer' : 'removeLayer';
        lmap[method](parent['Point']);
        lmap[method](parent['LineString']);
        lmap[method](parent['Polygon']);
        if (flag) show(divChilds);else hide(divChilds);
      };

      parentTreeCanvas.loaded = function () // переопределим функцию загрузки слоя на центрирование
      {
        if (!box.checked) {
          clickFunc.call(_this, true);
          box.checked = true;
        } //globalFlashMap.zoomToExtent(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);


        nsGmx$1.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
      };

      parentTreeCanvas.clear = function () {
        var lmap = nsGmx$1.leafletMap;
        lmap.removeLayer(parent['Point']);
        lmap.removeLayer(parent['LineString']);
        lmap.removeLayer(parent['Polygon']);
        divCanvas.removeNode(true);
      };

      box.onclick = function () {
        clickFunc.call(_this, this.checked);
      };

      $(parentTreeCanvas).empty();
      if (parentTreeCanvas.childNodes.length == 0) _$4(parentTreeCanvas, [divCanvas]);else parentTreeCanvas.insertBefore(divCanvas, parentTreeCanvas.firstChild);

      _$4(divCanvas, [divChilds]); // for (var type in geomsPresent)
      // {
      // var elemCanvas = _div(null, [['css','padding','2px'],['attr','geometryType', type]]),
      // //icon = _mapHelper.createStylesEditorIcon([{MinZoom:1,MaxZoom:20,RenderStyle:styles[type]}], type.toLowerCase()),
      // spanElem = _span(null, [['dir','className','layerfeature']]);
      // if (type == 'Point')
      // _(spanElem, [_t(_gtxt('точки'))]);
      // else if (type == 'LineString')
      // _(spanElem, [_t(_gtxt('линии'))]);
      // else if (type == 'Polygon')
      // _(spanElem, [_t(_gtxt('полигоны'))]);
      // var icon;
      // (function(type){
      // icon = _mapHelper.createWFSStylesEditor(parent[type], styles[type], type.toLowerCase(), divCanvas)
      // })(type);
      // if (typeof loadLayerParams != 'undefined' && loadLayerParams[type.toLowerCase()])
      // {
      // var info = loadLayerParams[type.toLowerCase()];
      // elemCanvas.graphDataType = info.graphDataType;
      // elemCanvas.graphDataProperties = info.graphDataProperties;
      // }
      // else
      // {
      // elemCanvas.graphDataType = "func";
      // elemCanvas.graphDataProperties = "";
      // }
      // _(elemCanvas, [icon, spanElem])
      // _(divChilds, [elemCanvas]);
      // }
      //globalFlashMap.zoomToExtent(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);


      nsGmx$1.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
      box.checked = true;
    }; //loadParams - параметры для отдельных слоёв
    //serverParams - параметры сервера, которые были указаны пользователем.


    queryServerData.prototype.drawWMS = function (serviceLayers, url, replaceElem, loadParams, serverParams) {
      var ulCanvas = _ul(null, [['css', 'paddingBottom', '5px'], ['attr', 'url', url]]),
          ulChilds = _ul(),
          remove = makeImageButton('img/closemin.png', 'img/close_orange.png'),
          lmap = nsGmx$1.leafletMap;

      $(replaceElem).replaceWith(ulCanvas);
      $(ulCanvas).data('serverParams', serverParams);

      remove.onclick = function () {
        for (var i = 0; i < ulChilds.childNodes.length; i++) {
          ulChilds.childNodes[i].firstChild.lastChild.clear && ulChilds.childNodes[i].firstChild.lastChild.clear();
          lmap.removeLayer(ulChilds.childNodes[i].firstChild.lastChild.gmxObject);
        }

        this.parentNode.parentNode.parentNode.removeNode(true);
      };

      remove.className = 'remove';
      remove.style.right = '0px';

      _$4(ulCanvas, [_li([_div([_span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')], [['dir', 'className', 'urlHeader']]), remove], [['css', 'position', 'relative']]), ulChilds])]);

      var clickFunc = function clickFunc(layer, parent, flag) {
        if (!flag) {
          lmap.removeLayer(parent);
        } else {
          updateFunc(layer, parent);
          lmap.addLayer(parent);
        }
      };

      var updateFunc = function updateFunc(layer, parent) {
        var requestParams = {};

        if (serverParams && serverParams.format) {
          requestParams.format = "image/" + serverParams.format;
          requestParams.transparent = serverParams.format === 'png';
        }

        var res = getWMSMapURL(url, layer, requestParams);

        if (res) {
          var b = res.bounds;
          parent.clearLayers();
          parent.addLayer(L.imageOverlay(serverBase + "ImgSave.ashx?now=true&get=" + encodeURIComponent(res.url), L.latLngBounds([[b.minY, b.minX], [b.maxY, b.maxX]])));
        }
      };

      serviceLayers.forEach(function (layer) {
        var elemCanvas = _div(null, [['css', 'padding', '2px']]),
            box = _checkbox(false, 'checkbox'),
            spanElem = _span([_t(layer.title)], [['css', 'cursor', 'pointer'], ['dir', 'className', 'layerfeature']]),
            parent = L.layerGroup().addTo(nsGmx$1.leafletMap);

        spanElem.gmxObject = parent;
        box.className = 'floatLeft';

        spanElem.onclick = function () {
          if (!box.checked) box.checked = true;
          clickFunc(layer, parent, true);
        };

        box.onclick = function () {
          clickFunc(layer, parent, this.checked);
        };

        box.update = function () {
          updateFunc(layer, parent);
        };

        box.setAttribute('layerName', layer.name);

        _$4(elemCanvas, [box, spanElem]);

        _$4(ulChilds, [_li([elemCanvas])]);

        if (typeof loadParams != 'undefined' && loadParams[layer.name]) $(spanElem).trigger("click");
      });
      $(ulCanvas).treeview();
      nsGmx$1.leafletMap.on('moveend', function () {
        var boxes = ulChilds.getElementsByTagName('input');

        for (var i = 0; i < boxes.length; i++) {
          if (boxes[i].checked) boxes[i].update();
        }
      });
    }; //Добавляет контрол выбора формата запроса к WMS и возвращает его в параметре format (пример: "png", "jpg")


    queryServerData.prototype.customWMSParamsManager = function () {
      var _targetDiv = null;
      return {
        init: function init(targetDiv) {
          var select = nsGmx$1.Utils._select([_option([_t('png')]), _option([_t('jpeg')])], [['dir', 'className', 'selectStyle'], ['css', 'width', '60px']]);

          _targetDiv = targetDiv;

          _$4(_targetDiv, [_t(_gtxt('Формат изображения') + ': '), select]);

          _targetDiv.style.marginBottom = '5px';
        },
        collect: function collect() {
          return {
            format: $("option:selected", _targetDiv).text()
          };
        }
      };
    }();

    queryServerData.prototype.drawWFS = function (serviceLayers, url, replaceElem, loadParams) {
      var ulCanvas = _ul(null, [['css', 'paddingBottom', '5px'], ['attr', 'url', url]]),
          ulChilds = _ul(),
          divFormat = _div(),
          remove = makeImageButton('img/closemin.png', 'img/close_orange.png'),
          _this = this;

      $(replaceElem).replaceWith(ulCanvas);

      remove.onclick = function () {
        for (var i = 0; i < ulChilds.childNodes.length; i++) {
          ulChilds.childNodes[i].firstChild.lastChild.clear && ulChilds.childNodes[i].firstChild.lastChild.clear();
        }

        this.parentNode.parentNode.parentNode.removeNode(true);
      };

      remove.className = 'remove';
      remove.style.right = '0px';

      _$4(ulCanvas, [_li([_div([_span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')], [['dir', 'className', 'urlHeader']]), divFormat, remove], [['css', 'position', 'relative']]), ulChilds])]);

      var formatSelect = nsGmx$1.Utils._select([_option([_t("JSON")], [['attr', 'value', 'json']]), _option([_t("GML / KML")], [['attr', 'value', 'gml']])], [['dir', 'className', 'selectStyle'], ['css', 'width', '100px']]);

      _$4(divFormat, [formatSelect]);

      var clickFunc = function clickFunc(layer, flag, elemCanvas, box, header, loadLayerParams) {
        if (flag) {
          var newFormat = formatSelect.value; // загружаем данные только один раз

          if (!elemCanvas.loaded || elemCanvas.format != newFormat) {
            elemCanvas.clear && elemCanvas.clear();
            var separator = url.indexOf('?') !== -1 ? '&' : '?';
            var objUrl = url + separator + "request=GetFeature&version=1.0.0&typeName=" + layer.name;
            if (formatSelect.value == 'json') objUrl += '&outputFormat=json';

            _this.loadGML(objUrl, elemCanvas, box, header, newFormat, loadLayerParams, layer.srs);

            elemCanvas.loaded = true;
            elemCanvas.format = newFormat;

            var loading = _div([_img(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), _t(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px']]);

            _$4(elemCanvas, [loading]);
          } else {
            if (typeof elemCanvas.loaded == 'function') elemCanvas.loaded();
          }
        }
      };

      for (var i = 0; i < serviceLayers.length; i++) {
        var elemCanvas = _div(null, [['css', 'padding', '2px']]),
            box = _checkbox(false, 'checkbox'),
            spanElem = _span([_t(serviceLayers[i].title != '' ? serviceLayers[i].title : serviceLayers[i].name)], [['css', 'cursor', 'pointer'], ['dir', 'className', 'layerfeature']]),
            elemChilds = _div(null, [['css', 'marginLeft', '20px']]);

        box.className = 'floatLeft';
        box.setAttribute('layerName', serviceLayers[i].name);

        (function (layer, parentTreeCanvas, box, header) {
          spanElem.onclick = function () {
            if (!box.checked) box.checked = true;
            clickFunc.call(_this, layer, true, parentTreeCanvas, box, header);
          };

          box.onclick = function () {
            clickFunc.call(_this, layer, this.checked, parentTreeCanvas, box, header);
          };
        })(serviceLayers[i], elemChilds, box, spanElem);

        _$4(elemCanvas, [box, _div([spanElem], [['css', 'display', 'inline']]), elemChilds]);

        _$4(ulChilds, [_li([elemCanvas])]);

        if (typeof loadParams != 'undefined' && loadParams[serviceLayers[i].name]) {
          if (!box.checked) box.checked = true;
          formatSelect.value = loadParams[serviceLayers[i].name].format;
          clickFunc.call(_this, serviceLayers[i], true, elemChilds, box, spanElem, loadParams[serviceLayers[i].name].info);
        }
      }

      $(ulCanvas).treeview();
    };

    var _queryServerDataWFS = new queryServerData(),
        _queryServerDataWMS = new queryServerData();

    loadServerData.WFS.load = function () {
      var alreadyLoaded = _queryServerDataWFS.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _queryServerDataWFS.load('WFS', _queryServerDataWFS.parseWFSCapabilities, _queryServerDataWFS.drawWFS, null, '1.0.0');
    };

    loadServerData.WFS.unload = function () {//	removeChilds($$('leftContent'))
    };

    loadServerData.WMS.load = function () {
      var alreadyLoaded = _queryServerDataWMS.createWorkCanvas(arguments[0]);

      if (!alreadyLoaded) _queryServerDataWMS.load('WMS', parseWMSCapabilities, _queryServerDataWMS.drawWMS, _queryServerDataWMS.customWMSParamsManager);
    };

    loadServerData.WMS.unload = function () {//	removeChilds($$('leftContent'))
    };

    nsGmx$1.userObjectsManager.addDataCollector('wms', {
      collect: function collect() {
        if (!_queryServerDataWMS.workCanvas) return null;
        var value = {};
        $(_queryServerDataWMS.workCanvas.lastChild).children("ul[url]").each(function () {
          var url = this.getAttribute('url');
          var serverParams = $(this).data('serverParams');
          value[url] = {
            params: serverParams,
            layersVisibility: {}
          };
          $(this).find("input[type='checkbox']").each(function () {
            if (this.checked) {
              value[url].layersVisibility[this.getAttribute('layerName')] = true;
            }
          });
        });
        if (!objLength(value)) return null;
        return value;
      },
      load: function load(data) {
        if (!data) return;
        $('#left_wms').remove();
        _queryServerDataWMS.builded = false;
        loadServerData.WMS.load('wms');

        for (var url in data) {
          (function (loadParams) {
            //поддержка старого формата данных
            if (!('layersVisibility' in loadParams)) {
              loadParams = {
                layersVisibility: loadParams
              };
            }

            _queryServerDataWMS.getCapabilities('WMS', url, parseWMSCapabilities, function (serviceLayers, url, replaceElem) {
              _queryServerDataWMS.drawWMS(serviceLayers, url, replaceElem, loadParams.layersVisibility, loadParams.params);
            });
          })(data[url]);
        }
      }
    });
    nsGmx$1.userObjectsManager.addDataCollector('wfs', {
      collect: function collect() {
        if (!_queryServerDataWFS.workCanvas) return null;
        var value = {};
        $(_queryServerDataWFS.workCanvas.lastChild).children("ul[url]").each(function () {
          var url = this.getAttribute('url');
          value[url] = {};
          $(this).find("input[type='checkbox']").each(function () {
            if (this.checked) {
              var wfsLayerInfo = {};
              $(this.parentNode.lastChild).find(".colorIcon").each(function () {
                wfsLayerInfo[this.geometryType] = {
                  RenderStyle: this.getStyle(),
                  graphDataType: this.parentNode.graphDataType,
                  graphDataProperties: this.parentNode.graphDataProperties
                };
              });
              value[url][this.getAttribute('layerName')] = {
                format: this.parentNode.lastChild.format,
                info: wfsLayerInfo
              };
            }
          });
        });
        if (!objLength(value)) return null;
        return value;
      },
      load: function load(data) {
        if (!data) return;
        $('#left_wfs').remove();
        _queryServerDataWFS.builded = false;
        loadServerData.WFS.load('wfs');

        for (var url in data) {
          (function (loadParams) {
            _queryServerDataWFS.getCapabilities('WFS', url, _queryServerDataWFS.parseWFSCapabilities, function (serviceLayers, url, replaceElem) {
              _queryServerDataWFS.drawWFS(serviceLayers, url, replaceElem, loadParams);
            }, '1.0.0');
          })(data[url]);
        }
      }
    });

    /**
        Возвращает массив ссылок в верхнее левое мета-меню в формате HeaderWidget из CommonComponents.
        Считывает информацию из window.gmxViewerUI.headerLinkItems в формате [{icon: iconPath, title: TITLE, href: HREF}, ...] (формат ГеоМиксера)
        Если переменной нет, подставляет значения по умолчению ("Карта пожаров", "Поиск снимков", "Платформа Геомиксер")
        @memberOf nsGmx
    */

    nsGmx$1.addHeaderLinks = function () {
      var isHeaderLinks = false;
      if (typeof window.headerLinks === 'boolean') isHeaderLinks = window.headerLinks; //совместимость с предыдущими версиями

      if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.headerLinks !== 'undefined') isHeaderLinks = window.gmxViewerUI.headerLinks;

      if (!isHeaderLinks) {
        return [];
      }

      var items = window.gmxViewerUI && window.gmxViewerUI.headerLinkItems || [{
        title: _gtxt("Карта пожаров"),
        href: _gtxt("http://fires.ru"),
        newWindow: true
      }, {
        title: _gtxt("Поиск снимков"),
        href: _gtxt("https://search.kosmosnimki.ru"),
        newWindow: true
      }, {
        title: _gtxt("Платформа Геомиксер"),
        newWindow: true,
        id: 'HeaderLinkGeoMixer'
      }];
      return $.extend(true, [], items).map(function (item, index, array) {
        item.link = item.href;
        return {
          id: 'headerLinksItem' + index,
          title: item.title,
          func: function () {
            if (item.link) {
              window.open(item.link, '_blank');
            }
          }.bind(item)
        };
      });
    };

    nsGmx$1.TransparencySliderWidget = function (container) {
      var _this = this;

      var ui = $(Handlebars.compile('<div class="leaflet-gmx-iconSvg leaflet-gmx-iconSvg-transparency svgIcon leaflet-control gmx-transslider-toggle-icon" title="{{i "TransparencySliderWidget.title"}}"><svg role="img" class="svgIcon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency"></use></svg></div>' + '<div class = "gmx-transslider-container"></div>' + '<div class = "leaflet-gmx-iconSvg leaflet-gmx-iconSvg-transparency-eye svgIcon leaflet-gmx-iconSvg-active leaflet-control gmx-transslider-onoff" title="{{i "TransparencySliderWidget.onOffTitle"}}"><svg role="img" class="svgIcon gmx-transslider-hide"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency-eye"></use></svg><svg role="img" class="svgIcon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency-eye-off"></use></svg></div>')()).appendTo(container);
      var sliderContainer = container.find('.gmx-transslider-container');
      this._isCollapsed = true;
      container.find('.gmx-transslider-toggle-icon').click(function () {
        this._isCollapsed = !this._isCollapsed;
        sliderContainer.toggle(!this._isCollapsed);
        container.find('.gmx-transslider-onoff').toggle(!this._isCollapsed);
        container.find('.gmx-transslider-toggle-icon').toggleClass('leaflet-gmx-iconSvg-active', !this._isCollapsed);
      }.bind(this));
      var isOpaque = true;

      var updateOnOffIcon = function updateOnOffIcon(value) {
        var isOpaqueNew = value === 1.0;

        if (isOpaqueNew !== isOpaque) {
          isOpaque = isOpaqueNew;
          var arr = container.find('.gmx-transslider-onoff')[0].childNodes;

          if (isOpaque) {
            L.DomUtil.removeClass(arr[1], 'gmx-transslider-hide');
            L.DomUtil.addClass(arr[0], 'gmx-transslider-hide');
          } else {
            L.DomUtil.removeClass(arr[0], 'gmx-transslider-hide');
            L.DomUtil.addClass(arr[1], 'gmx-transslider-hide');
          }
        }
      };

      sliderContainer.slider({
        range: 'min',
        min: 0.0,
        max: 1.0,
        step: 0.01,
        value: 1.0,
        change: function change(event, ui) {
          $(_this).triggerHandler(event, ui);
          updateOnOffIcon(ui.value);
        },
        slide: function slide(event, ui) {
          $(_this).triggerHandler(event, ui);
          updateOnOffIcon(ui.value);
        }
      }).hide(); // fix map moving in IE

      if (nsGmx$1.leafletMap) {
        var dragging = nsGmx$1.leafletMap.dragging;
        L.DomEvent.on(sliderContainer[0], 'mouseover', dragging.disable, dragging).on(sliderContainer[0], 'mouseout', dragging.enable, dragging);
      }

      container.find('.gmx-transslider-onoff').click(function () {
        var curValue = sliderContainer.slider('value');
        sliderContainer.slider('value', curValue !== 1.0 ? 1.0 : 0.0);
      }).hide();
      container.on('mousedown click', function (event) {
        event.stopPropagation();
      });
    };

    nsGmx$1.TransparencySliderWidget.prototype.isCollapsed = function () {
      return this._isCollapsed;
    };

    nsGmx$1.Translations.addText('rus', {
      TransparencySliderWidget: {
        title: 'Прозрачность растровых слоёв',
        onOffTitle: 'Показать/скрыть растры'
      }
    });
    nsGmx$1.Translations.addText("eng", {
      TransparencySliderWidget: {
        title: 'Raster layers transparency',
        onOffTitle: 'Show/hide rasters'
      }
    });

    L.Control.GmxLayers2 = L.Control.Layers.extend({
      options: {
        collapsed: true,
        autoZIndex: false,
        id: 'layers'
      },
      initialize: function initialize(baseLayers, overlays, options) {
        L.Control.Layers.prototype.initialize.call(this, baseLayers, overlays, options);
      },
      onAdd: function onAdd(map) {
        L.Control.Layers.prototype.onAdd.call(this, map);
        this.init = false;

        this._initLayout();

        this._update();

        this._iconClick = function () {
          if (this._iconContainer) {
            this.setActive(!this.options.isActive);

            this._update();

            if (this.options.stateChange) {
              this.options.stateChange(this);
            }
          }
        };

        var stop = L.DomEvent.stopPropagation;
        L.DomEvent.on(this._iconContainer, 'mousemove', stop).on(this._iconContainer, 'touchstart', stop).on(this._iconContainer, 'mousedown', stop).on(this._iconContainer, 'dblclick', stop).on(this._iconContainer, 'click', stop).on(this._iconContainer, 'click', this._iconClick, this);
        return this._container;
      },
      _initLayout: function _initLayout() {
        var controlClassName = 'leaflet-control-layers2',
            prefix = 'leaflet-gmx-iconSvg',
            iconClassName = prefix + ' ' + prefix + '-overlays svgIcon',
            listClassName = 'leaflet-control-layers',
            container = this._container = L.DomUtil.create('div', controlClassName),
            iconContainer = this._iconContainer = L.DomUtil.create('div', iconClassName),
            listContainer = this._listContainer = L.DomUtil.create('div', listClassName);
        var openingDirection = this.options.direction || 'bottom';
        L.DomUtil.addClass(listContainer, listClassName + '-' + openingDirection);

        if (this.options.title) {
          this._iconContainer.title = this.options.title;
        }

        this._prefix = prefix; //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released

        container.setAttribute('aria-haspopup', true);

        if (!L.Browser.touch) {
          L.DomEvent.disableClickPropagation(container).disableScrollPropagation(container);
        } else {
          L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
        }

        var placeHolder = this._placeHolder = L.DomUtil.create('div', 'layers-placeholder');
        placeHolder.innerHTML = this.options.placeHolder;
        var form = this._form = L.DomUtil.create('form', listClassName + '-list');

        if (this.options.collapsed) {
          var useHref = '#' + 'overlays';
          iconContainer.innerHTML = '<svg role="img" class="svgIcon">\
              <use xlink:href="' + useHref + '"></use>\
            </svg>';
          var link = this._layersLink = L.DomUtil.create('a', '', listContainer);
          link.href = '#';
          link.title = 'Layers';

          if (L.Browser.touch) {
            L.DomEvent.on(iconContainer, 'click', L.DomEvent.stop).on(iconContainer, 'click', this._expand, this);
          } //Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033


          L.DomEvent.on(form, 'click', function () {
            setTimeout(L.bind(this._onInputClick, this), 0);
          }, this);

          this._map.on('click', this._collapse, this);
        } else {
          this._expand();
        }

        this._baseLayersList = L.DomUtil.create('div', listClassName + '-base', form);
        this._separator = L.DomUtil.create('div', listClassName + '-separator', form);
        this._overlaysList = L.DomUtil.create('div', listClassName + '-overlays', form);
        listContainer.appendChild(form);
        listContainer.appendChild(placeHolder);
        container.appendChild(iconContainer);
        container.appendChild(listContainer);

        if (!this.init) {
          container.style.display = 'none';
        }
      },
      _addLayer: function _addLayer(layer, name, overlay) {
        if (Object.keys(this._layers).length === 0) {
          this.init = true;
        }

        L.Control.Layers.prototype._addLayer.call(this, layer, name, overlay);
      },
      _addItemObject: function _addItemObject(obj) {
        var label = this._addItem(obj);

        if (obj.layer && obj.layer._gmx && obj.layer._gmx.layerID) {
          label.className = '_' + obj.layer._gmx.layerID;
        }
      },
      _addItem: function _addItem(obj) {
        if (L.version === '0.7.7') {
          var label = document.createElement('label'),
              input,
              checked = this._map.hasLayer(obj.layer);

          if (obj.overlay) {
            input = document.createElement('input');
            input.type = 'checkbox';
            input.className = 'leaflet-control-layers-selector';
            input.defaultChecked = checked;
          } else {
            input = this._createRadioElement('leaflet-base-layers', checked);
          }

          input.layerId = L.stamp(obj.layer);
          L.DomEvent.on(input, 'click', this._onInputClick, this);
          var name = document.createElement('span');
          name.innerHTML = ' ' + obj.name;
          label.appendChild(input);
          label.appendChild(name);
          var container = obj.overlay ? this._overlaysList : this._baseLayersList;
          container.appendChild(label);
          return label;
        } else {
          var label = document.createElement('label'),
              checked = this._map.hasLayer(obj.layer),
              input;

          if (obj.overlay) {
            input = document.createElement('input');
            input.type = 'checkbox';
            input.className = 'leaflet-control-layers-selector';
            input.defaultChecked = checked;
          } else {
            input = this._createRadioElement('leaflet-base-layers', checked);
          }

          var presentLayer, presentIndex;

          for (var i = 0; i < this._layerControlInputs.length; i++) {
            var inp = this._layerControlInputs[i];

            if (inp.layerId === obj.layer._leaflet_id) {
              presentLayer = inp;
            }
          }

          presentIndex = this._layerControlInputs.indexOf(presentLayer);

          if (presentLayer) {
            this._layerControlInputs = [].concat(this._layerControlInputs.slice(0, presentIndex), input, this._layerControlInputs.slice(presentIndex + 1, this._layerControlInputs.length));
          } else {
            this._layerControlInputs.push(input);
          }

          input.layerId = L.Util.stamp(obj.layer);
          L.DomEvent.on(input, 'click', this._onInputClick, this);
          var name = document.createElement('span');
          name.innerHTML = ' ' + obj.name; // Helps from preventing layer control flicker when checkboxes are disabled
          // https://github.com/Leaflet/Leaflet/issues/2771

          var holder = document.createElement('div');
          label.appendChild(holder);
          holder.appendChild(input);
          holder.appendChild(name);
          var container = obj.overlay ? this._overlaysList : this._baseLayersList;
          container.appendChild(label);

          this._checkDisabledLayers();

          return label;
        }
      },
      _update: function _update() {
        if (!this._listContainer) {
          return;
        }

        var options = this.options;

        if (this.init) {
          this._container.style.display = '';
          this.setActive(false);
          this.init = false;
        }

        this._baseLayersList.innerHTML = '';
        this._overlaysList.innerHTML = '';
        var baseLayersPresent = false,
            overlaysPresent = false,
            i,
            obj;

        for (i in this._layers) {
          obj = this._layers[i];

          if (obj.overlay) {
            this._addItemObject(obj);

            overlaysPresent = true;
          } else {
            baseLayersPresent = true;
          }
        }

        this._container.style.display = overlaysPresent ? '' : 'none';
        this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
        this._form.style.display = overlaysPresent || baseLayersPresent ? '' : 'none';
        this._placeHolder.style.display = overlaysPresent || baseLayersPresent ? 'none' : '';

        if (!options.isActive) {
          this._form.style.display = 'none';
          this._placeHolder.style.display = 'none';
        }
      },
      _expand: function _expand() {
        L.DomUtil.addClass(this._listContainer, 'leaflet-control-layers-expanded');
      },
      _collapse: function _collapse() {
        this._listContainer.className = this._listContainer.className.replace(' leaflet-control-layers-expanded', '');
        this.setActive(false);
      },
      setActive: function setActive(active, skipEvent) {
        var options = this.options,
            togglable = options.togglable || options.toggle;

        if (togglable) {
          var prev = options.isActive,
              prefix = this._prefix,
              className = prefix + '-' + options.id,
              container = this._iconContainer;
          options.isActive = active;

          if (active) {
            L.DomUtil.addClass(container, prefix + '-active');
            L.DomUtil.addClass(container, className + '-active');

            if (container.children.length) {
              L.DomUtil.addClass(container, prefix + '-externalImage-active');
            }

            if (options.styleActive) {
              this.setStyle(options.styleActive);
            }

            L.DomUtil.addClass(this._listContainer, 'leaflet-control-layers-expanded');
          } else {
            L.DomUtil.removeClass(container, prefix + '-active');
            L.DomUtil.removeClass(container, className + '-active');

            if (container.children.length) {
              L.DomUtil.removeClass(container, prefix + '-externalImage-active');
            }

            if (options.style) {
              this.setStyle(options.style);
            }

            L.DomUtil.removeClass(this._listContainer, 'leaflet-control-layers-expanded');
          } // ugly bug in IE
          // IE appends 'extended' class to the parent!


          if (L.DomUtil.hasClass(this._container, 'leaflet-control-layers-expanded')) {
            L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
          }
        }
      },
      addTo: function addTo(map) {
        // L.Control.prototype.addTo.call(this, map);
        L.Control.GmxIcon.prototype.addTo.call(this, map);

        if (this.options.addBefore) {
          this.addBefore(this.options.addBefore);
        }

        return this;
      },
      addBefore: function addBefore(id) {
        var parentNode = this._parent && this._parent._container;

        if (!parentNode) {
          parentNode = this._map && this._map._controlCorners[this.getPosition()];
        }

        if (!parentNode) {
          this.options.addBefore = id;
        } else {
          for (var i = 0, len = parentNode.childNodes.length; i < len; i++) {
            var it = parentNode.childNodes[i];

            if (id === it._id) {
              parentNode.insertBefore(this._container, it);
              break;
            }
          }
        }

        return this;
      }
    });
    L.Control.gmxLayers2 = L.Control.GmxLayers2;

    L.control.gmxLayers2 = function (baseLayers, overlays, options) {
      return new L.Control.GmxLayers2(baseLayers, overlays, options);
    };

    var gmxMediaDescription = function gmxMediaDescription(descField, descData, storeDescFieldName, mode, mediaLayerName, mediaObjId, mediaLayer, dialogSettings) {
      //Основные переменные
      var editor,
          mediaDescDialog = jQuery('<div class="mediaDesc-Div"><img src="' + pluginPath + 'addit/media_img_load.gif"></img></div>'),
          mediaDescDialogTitle,
          mediaDescTextArea = jQuery('<textarea name="mediaDescInput" id="mediaDescInput"></textarea>'),
          exp1 = /(?:^|[^"'])(\b((https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|]))/gim,
          exp2 = /(?:^|[^"'https?:\/\/])(\b((www.)[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|]))/gim; //descData = descData.replace(exp1, '<a href="$1" target="_blank">$1</a>'); //Проверяем текст на наличие ссылок вида http/ftp и превращаем в URL.
      //descData = descData.replace(exp2, '<a href="http://$1" target="_blank">$1</a>'); //Проверяем текст на наличие ссылок вида www и превращаем в URL.
      //Основные функции диалога
      //Исправление бага с окном добавления ссылок через CKEditor в модальном режиме диалога описания

      $.widget("ui.dialog", $.ui.dialog, {
        //  jQuery UI - v1.10.2 - 2013-12-12
        //  http://bugs.jqueryui.com/ticket/9087#comment:27 - bugfix
        //  http://bugs.jqueryui.com/ticket/4727#comment:23 - bugfix
        //  allowInteraction fix to accommodate windowed editors
        _allowInteraction: function _allowInteraction(event) {
          if (this._super(event)) {
            return true;
          } // address interaction issues with general iframes with the dialog


          if (event.target.ownerDocument != this.document[0]) {
            return true;
          } // address interaction issues with dialog window


          if ($(event.target).closest(".cke_dialog").length) {
            return true;
          } // address interaction issues with iframe based drop downs in IE


          if ($(event.target).closest(".cke").length) {
            return true;
          }
        },
        // jQuery UI - v1.10.2 - 2013-10-28
        //  http://dev.ckeditor.com/ticket/10269 - bugfix
        //  moveToTop fix to accommodate windowed editors
        _moveToTop: function _moveToTop(event, silent) {
          if (!event || !this.options.modal) {
            this._super(event, silent);
          }
        }
      }); //Функция сохранения описание из Режима Чтения (данные записываются сразу в слой)

      var saveDescfromReadMode = function saveDescfromReadMode() {
        var newData = mediaDescTextArea.val();
        var descriptionLength = newData.length;
        var edata = editor.getData();
        newData = edata.replace(/>/gim, '> ');
        newData = newData.replace(exp1, ' <a href="$1" target="_blank">$1</a> ' + ' ');
        newData = newData.replace(exp2, ' <a href="http://$1" target="_blank">$1</a> ' + ' ');

        if (descriptionLength > 5000) {
          var descriptionLengthDIFF = descriptionLength - 5000;
          alert(_gtxt('mediaPlugin2.mediaDescDialogLimit.alert') + descriptionLengthDIFF + _gtxt('mediaPlugin2.mediaDescDialogSymbols.alert'));
        } else {
          _mapHelper.modifyObjectLayer(mediaLayerName, [{
            id: mediaObjId,
            properties: {
              '_mediadescript_': newData
            },
            action: 'update'
          }]).done(function () {
            mediaDescDialog.dialog('close').remove();
            new gmxMediaDescription(null, newData, null, 'read', mediaLayerName, mediaObjId, mediaLayer, dialogSettings); //После сохранения закрываем старое окно и открываем новое с описанием.
          });
        }
      }; //Функция сохранения описание из Режима Чтения (Пользователь решает сохранять данные или нет)


      var saveDescfromEditMode = function saveDescfromEditMode() {
        var newdescData = mediaDescTextArea.val();
        var descriptLength = newdescData.length;
        var eddata = editor.getData();
        newdescData = eddata.replace(/>/gim, '> ');
        newdescData = newdescData.replace(exp1, ' <a href="$1" target="_blank">$1</a> ' + ' ');
        newdescData = newdescData.replace(exp2, ' <a href="http://$1" target="_blank">$1</a> ' + ' ');

        if (descriptLength > 5000) {
          var descriptLengthDIFF = descriptLength - 5000;
          alert(_gtxt('mediaPlugin2.mediaDescDialogLimit.alert') + descriptLengthDIFF + _gtxt('mediaPlugin2.mediaDescDialogSymbols.alert'));
        } else {
          descField.set(storeDescFieldName, newdescData);
          mediaDescDialog.dialog('close').remove();
        }
      }; //Функция переключения в режим "HTML"


      var editortoHTML = function editortoHTML(prevmode) {
        for (var editorHTMLInstance in CKEDITOR.instances) {
          var curHTMLInstance = editorHTMLInstance;
          break;
        }
        $('#' + editor.id + '_top').hide();
        editor.resize('100%', mediaDescDialog.height() - 5, true);
        CKEDITOR.instances[curHTMLInstance].setMode('source');

        if (prevmode == 'fromedit') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'WYSIWYGMode',
              text: _gtxt("mediaPlugin2.descDialogWYSIWYGButton.label"),
              click: function click() {
                editortoWYSIWYG('fromedit');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt('mediaPlugin2.descDialogEditSaveButton.label'),
              click: saveDescfromEditMode
            }]
          });
        } else if (prevmode == 'fromread') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'WYSIWYGMode',
              text: _gtxt("mediaPlugin2.descDialogWYSIWYGButton.label"),
              click: function click() {
                editortoWYSIWYG('fromread');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt("mediaPlugin2.descDialogSaveButton.label"),
              click: saveDescfromReadMode
            }]
          });
        }
      }; //Функция переключения в режим "WYSIWYG"


      var editortoWYSIWYG = function editortoWYSIWYG(prevmode) {
        for (var editorWYSIWYGInstance in CKEDITOR.instances) {
          var curWYSIWYGInstance = editorWYSIWYGInstance;
          break;
        }
        $('#' + editor.id + '_top').show();
        editor.resize('100%', mediaDescDialog.height() - 50, true);
        CKEDITOR.instances[curWYSIWYGInstance].setMode('wysiwyg');

        if (prevmode == 'fromedit') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'htmlMode',
              text: 'HTML',
              click: function click() {
                editortoHTML('fromedit');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt('mediaPlugin2.descDialogEditSaveButton.label'),
              click: saveDescfromEditMode
            }]
          });
        } else if (prevmode == 'fromread') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'htmlMode',
              text: 'HTML',
              click: function click() {
                editortoHTML('fromread');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt("mediaPlugin2.descDialogSaveButton.label"),
              click: saveDescfromReadMode
            }]
          });
        }
      }; //Функция переключения из режима "Чтение" в режим "Редактирование"


      var changeDescDialogMode = function changeDescDialogMode() {
        mediaDescDialog.dialog('close');
        descEditMode();
        mediaDescDialog.dialog({
          buttons: [{
            id: 'htmlMode',
            text: 'HTML',
            click: function click() {
              editortoHTML('fromread');
            }
          }, {
            id: 'saveDescData',
            text: _gtxt("mediaPlugin2.descDialogSaveButton.label"),
            click: saveDescfromReadMode
          }]
        });
        mediaDescDialog.dialog('open');
      }; //Режим "Чтение"


      var descReadMode = function descReadMode() {
        var isEditableLayer = function isEditableLayer(layer) {
          var layerProps = layer.getGmxProperties();

          var layerRights = _queryMapLayers.layerRights(layerProps.name);

          return layerProps.type === 'Vector' && (layerRights == 'edit' || layerRights == 'editrows');
        };

        $(mediaDescDialog).on('click', '.imgMedia', function (e) {
          var newwindowHref = $(this).find('img').attr('src');

          if (newwindowHref) {
            e.preventDefault();
            window.open(newwindowHref, 'new' + e.screenX);
          }
        });
        mediaDescDialog.dialog({
          title: mediaDescDialogTitle,
          width: 510,
          height: dialogSettings.dialogDescHeight,
          minHeight: dialogSettings.dialogDescHeight,
          maxWidth: 510,
          minWidth: 510,
          modal: false,
          autoOpen: false,
          dialogClass: 'media-DescDialog',
          close: function close() {
            mediaDescDialog.dialog('close').remove();
          }
        });
        mediaDescDialog.html('<div class="media-descDiv">' + descData + '</div>');
        mediaDescDialog.dialog('open');

        if (isEditableLayer(mediaLayer)) {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'changeDescMode',
              text: _gtxt("mediaPlugin2.descDialogEditButton.label"),
              click: changeDescDialogMode
            }]
          });
        }
      }; //Режим "Редактирование"


      var descEditMode = function descEditMode() {
        gmxCore.loadScript(pluginPath + 'ckeditor_4.4.1_custom/ckeditor/ckeditor.js');
        gmxCore.loadScript(pluginPath + 'ckeditor_4.4.1_custom/ckeditor/adapters/jquery.js').done(function () {
          var CKEDITOR_BASEPATH = gmxCore.getModulePath('ckeditor'); //CKEDITOR.config.enterMode = '2';

          mediaDescTextArea.val(descData);
          mediaDescTextArea.ckeditor();
          CKEDITOR.on('instanceReady', function (ev) {
            editor = ev.editor;
            $('#' + editor.id + '_top').show();
            editor.resize('100%', mediaDescDialog.height() - 65, true);
            editor.on('doubleclick', function (evt) {
              var element = evt.data.element;

              if (element.is('img') && !element.data('cke-realelement') && !element.isReadOnly()) {
                var targetSrc = element.getAttribute('src');
                window.open(targetSrc, 'new' + e.screenX);
              }
            });
            $('iframe').contents().click(function (e) {
              if (typeof e.target.href != 'undefined' && e.ctrlKey == true) {
                window.open(e.target.href, 'new' + e.screenX);
              }
            });
          });
          CKEDITOR.on('dialogDefinition', function (ev) {
            var dialogName = ev.data.name;
            var dialogDefinition = ev.data.definition;

            if (dialogName == 'link') {
              var informationTab = dialogDefinition.getContents('target');
              var targetField = informationTab.get('linkTargetType');
              targetField['default'] = '_blank';
            }
          });
          mediaDescDialog.html(mediaDescTextArea);
        });
        mediaDescDialog.dialog({
          //title: mediaDescDialogTitle,
          width: 510,
          height: dialogSettings.dialogDescHeight,
          minHeight: dialogSettings.dialogDescHeight,
          maxWidth: 510,
          minWidth: 510,
          modal: true,
          resize: function resize() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          resizeStop: function resizeStop() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          drag: function drag() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          dragStop: function dragStop() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          autoOpen: false,
          buttons: [{
            id: 'htmlMode',
            text: 'HTML',
            click: function click() {
              editortoHTML('fromedit');
            }
          }, {
            id: 'saveDescData',
            text: _gtxt('mediaPlugin2.descDialogEditSaveButton.label'),
            click: saveDescfromEditMode
          }],
          dialogClass: 'media-DescDialog',
          close: function close() {
            mediaDescDialog.dialog('close').remove();
          }
        });
        mediaDescDialog.dialog('open');
      }; //Дополнительные условия


      if (mode == 'read') {
        //mediaDescDialogTitle = _gtxt('mediaPlugin2.mediaDescDialogTitleRead.label');
        descReadMode();
      } else if (mode == 'edit') {
        //mediaDescDialogTitle = _gtxt('mediaPlugin2.mediaDescDialogTitleEdit.label');
        descEditMode();
      } else if (mode == 'baloon') {
        /*mediaDescDialogTitle = _gtxt('mediaPlugin2.mediaDescDialogTitleEdit.label');*/
        descReadMode();
        changeDescDialogMode();
      }
    };

    _translationsHash.addtext("rus", {
      mediaPlugin2: {
        "layerPropertiesTitle": 'Добавить описание',
        "balloonDefaultTitle": 'Медиа Описание',
        "descButton.label": 'Редактировать',
        "descButton.help": 'Редактировать медиа описание',
        "descSpan.label": 'Описание',
        "descSpan.help": 'Медиа описание',
        "descDialogEditButton.label": 'Редактировать',
        "descDialogWYSIWYGButton.label": 'Визуально',
        "descDialogSaveButton.label": 'Сохранить',
        "descDialogEditSaveButton.label": 'Готово',
        "descBalloonButton.label": 'Описание',
        "descInBalloonButton.label": 'Редактировать описание',
        "descDialogTitle.label": 'Просмотр Медиа-Описания',
        "mediaDescDialogTitleEdit.label": 'Редактировать описание',
        "mediaDescDialogTitleRead.label": 'Чтение описания',
        "mediaDescDialogLimit.alert": 'Количество символов в описании больше 5000.\nУкоротите описание на ',
        "mediaDescDialogSymbols.alert": ' символов',
        "mediaDescImgDialogError.alert": 'Не удалось загрузить изображение.\n Проверьте правильность ссылки',
        "WarningText": 'Для хранения описаний требуется добавление нового поля к слою'
      }
    });

    _translationsHash.addtext("eng", {
      mediaPlugin2: {
        "layerPropertiesTitle": 'Add media description',
        "balloonDefaultTitle": 'Media description',
        "descButton.label": 'Edit',
        "descButton.help": 'Edit media description',
        "descSpan.label": 'Description',
        "descSpan.help": 'Media Description',
        "descDialogEditButton.label": 'Edit',
        "descDialogWYSIWYGButton.label": 'WYSIWYG',
        "descDialogSaveButton.label": 'Save',
        "descDialogEditSaveButton.label": 'OK',
        "descBalloonButton.label": 'Description',
        "descInBalloonButton.label": 'Edit Description',
        "descDialogTitle.label": 'Media-Description Viewer',
        "mediaDescDialogTitleEdit.label": 'Edit Description',
        "mediaDescDialogTitleRead.label": 'View Description',
        "mediaDescDialogLimit.alert": 'Description length more then 5000 symbols.\nDelete ',
        "mediaDescDialogSymbols.alert": ' symbols',
        "mediaDescImgDialogError.alert": 'Image load failure.\n Check URL on error',
        "WarningText": 'New attribute will be added to this layer to store descriptions'
      }
    }); //Модифицирует описание слоя, добавляя или удаляя свойства, необходимые для хранения описания объектов.
    //Метатег удаляется и добавляется, а необходимый атриут только добавляется (никогда не удаляется)


    var modifyLayerProperties = function modifyLayerProperties(layerProperties, isAddDescription) {
      var metaProps = layerProperties.get('MetaProperties'),
          tagId = metaProps.getTagIdByName(DESC_METATAG);

      if (isAddDescription) {
        tagId || metaProps.addNewTag(DESC_METATAG, DESC_DEFAULT_FIELD, 'String');
        var columns = layerProperties.get('Columns').slice();

        if (!_.findWhere(columns, {
          Name: DESC_DEFAULT_FIELD
        })) {
          columns.push({
            Name: DESC_DEFAULT_FIELD,
            ColumnSimpleType: 'String'
          });
        }

        layerProperties.set('Columns', columns);
      } else {
        metaProps.deleteTag(tagId);
      }

      layerProperties.set('MetaProperties', metaProps);
    };

    var DESC_METATAG = 'mediaDescField',
        DESC_DEFAULT_FIELD = '_mediadescript_',
        DESC_INLINE_HOOK = 'mediainline';
    var pluginPath = gmxCore.getModulePath('MediaPlugin2');
    var publicInterface$1 = {
      pluginName: 'Media Plugin',
      afterViewer: function afterViewer(mediaDescDialogSettings, map) {
        mediaDescDialogSettings = $.extend({
          dialogDescHeight: 450,
          inBaloonDesc: false
        }, mediaDescDialogSettings);

        gmxCore.loadModule('LayerEditor').done(function () {
          nsGmx.LayerEditor.addInitHook(function (layerEditor, layerProperties, parametres) {
            var metaProps = layerProperties.get('MetaProperties'),
                isMedia = metaProps.getTagByName(DESC_METATAG);

            if (layerProperties.get('Type') !== 'Vector') {
              return;
            }

            var uiTemplate = Handlebars.compile('<label class = "media-props">' + '<input type="checkbox" id="media-props-checkbox" {{#isMedia}}checked{{/isMedia}}>' + '{{i "mediaPlugin2.layerPropertiesTitle"}}' + '</label>');
            $(layerEditor).on('premodify', function () {
              modifyLayerProperties(layerProperties, $('#media-props-checkbox', ui).prop("checked"));
            });
            var ui = $(uiTemplate({
              isMedia: isMedia
            }));
            parametres.additionalUI = parametres.additionalUI || {};
            parametres.additionalUI.advanced = parametres.additionalUI.advanced || [];
            parametres.additionalUI.advanced.push(ui[0]);
          });
        });

        var balloonHook = function balloonHook(layer, props, div, node, hooksCount) {
          //Если есть описание в балуне, отдельной ссылки на описание не нужно
          if (hooksCount[DESC_INLINE_HOOK]) {
            return;
          } // var layer = o.layer,


          var layerProps = layer.getGmxProperties(),
              layerName = layerProps.name,
              metaTag = layerProps.MetaProperties && layerProps.MetaProperties[DESC_METATAG];

          if (!metaTag) {
            $(node).empty().append(props[DESC_DEFAULT_FIELD]);
          } else if (props[metaTag.Value].length) {
            var descBaloonButtonLabel = '<b><a href="">{{i "mediaPlugin2.descBalloonButton.label"}}</a></b>',
                mediaDescDialogMode = 'read';
            var ui = $(Handlebars.compile(descBaloonButtonLabel)()).click(function (e) {
              e.preventDefault();
              var mediaObjectId = props[layerProps.identityField];
              var descripText = props[metaTag.Value];
              new gmxMediaDescription('', descripText, '', mediaDescDialogMode, layerName, mediaObjectId, layer, mediaDescDialogSettings);
            });

            if (node) {
              $(node).empty().append(ui);
            } else {
              $(div).append($('<br/>'), ui);
            }
          }
        };

        var attachBalloonHook = function attachBalloonHook(layer) {
          if (!layer.addPopupHook) {
            //например, виртуальные слои могут не поддерживать popup hooks
            return;
          }

          var props = layer.getGmxProperties();
          var metaTag = props.MetaProperties && props.MetaProperties[DESC_METATAG];
          layer.addPopupHook(metaTag ? metaTag.Value : DESC_DEFAULT_FIELD, function (properties, div, node, hooksCount) {
            balloonHook(layer, properties, div, node, hooksCount);
          }); //добавляем просмотр описания внутри балуна

          layer.addPopupHook(DESC_INLINE_HOOK, function (properties, div, node) {
            var metaTag = props.MetaProperties && props.MetaProperties[DESC_METATAG];

            if (!node || !metaTag) {
              return;
            }

            var html = properties[metaTag.Value];
            $(node).html('<div class="media-inlineDescr media-descDiv">' + html + '</div>');
            $(node).on('click', '.imgMedia', function (e) {
              e.preventDefault();
              var contwindowHref = $(this).find('img').attr('src');
              window.open(contwindowHref, 'new' + e.screenX);
            });
          });
        };

        nsGmx.gmxMap.layers.forEach(attachBalloonHook);

        var paramHook = function paramHook(layerName, id, parametres) {
          var layer = nsGmx.gmxMap.layersByID[layerName],
              props = layer.getGmxProperties(),
              fieldName = props.MetaProperties && props.MetaProperties[DESC_METATAG] && props.MetaProperties[DESC_METATAG].Value; //layer.bringToTopItem(id);

          parametres = parametres || {};
          parametres.fields = parametres.fields || [];

          if (fieldName) {
            var fieldDescription = _.findWhere(parametres.fields, {
              name: fieldName
            });

            if (fieldDescription) {
              fieldDescription.hide = true;
            } else {
              parametres.fields.push({
                name: fieldName,
                hide: true
              });
            }
          }

          parametres.afterPropertiesControl = function (EOCInteraction) {
            var mediaGUI = $('<div class="media-Desc-GUI"><span id="media-Desc-EditLabel" title="' + _gtxt("mediaPlugin2.descSpan.help") + '">' + _gtxt("mediaPlugin2.descSpan.label") + '</span><span id ="mediaDesc-EditButton" class="buttonLink" title="' + _gtxt("mediaPlugin2.descButton.help") + '">' + _gtxt("mediaPlugin2.descButton.label") + '</span></div>');
            $('#mediaDesc-EditButton', mediaGUI).click(function () {
              if (!fieldName) {
                var ui = $(Handlebars.compile('<div>{{i "mediaPlugin2.WarningText"}}</div>')());
                ui.dialog({
                  buttons: [{
                    id: 'warning-ok',
                    text: 'OK',
                    click: function click() {
                      $(this).dialog("close");
                      gmxCore.loadModule('LayerProperties').then(function () {
                        var layerProperties = new nsGmx.LayerProperties();
                        layerProperties.initFromServer(layerName).then(function () {
                          modifyLayerProperties(layerProperties, true);
                          layerProperties.save().then(function () {
                            L.gmx.layersVersion.chkVersion(layer, function () {
                              fieldName = layer.getGmxProperties().MetaProperties[DESC_METATAG].Value;
                              var fields = EOCInteraction.getAll();

                              if (!fields[fieldName]) {
                                EOCInteraction.add({
                                  name: fieldName,
                                  view: {
                                    _value: '',
                                    setValue: function setValue(value) {
                                      this._value = value;
                                    },
                                    getValue: function getValue() {
                                      return this._value;
                                    },
                                    checkValue: function checkValue() {
                                      return true;
                                    }
                                  }
                                });
                              }

                              var getdescData = EOCInteraction.get(fieldName) || '';
                              new gmxMediaDescription(EOCInteraction, getdescData, fieldName, 'edit', null, null, null, mediaDescDialogSettings);
                            });
                          });
                        });
                      });
                    }
                  }, {
                    id: 'warning-cancel',
                    text: 'Cancel',
                    click: function click() {
                      $(this).dialog("close");
                    }
                  }]
                });
              } else {
                var getdescData = EOCInteraction.get(fieldName);
                new gmxMediaDescription(EOCInteraction, getdescData, fieldName, 'edit', null, null, null, mediaDescDialogSettings);
              }
            });
            return mediaGUI[0];
          };

          return parametres;
        };

        nsGmx.EditObjectControl.addParamsHook(paramHook);
      }
    };
    gmxCore.addModule("MediaPlugin2", publicInterface$1, {// css: 'MediaPlugin2.css'
    });

    var _$5 = nsGmx$1.Utils._; //для отслеживания того, что не открыли диалог редактирования одного и того же объекта несколько раз

    var EditObjectControlsManager = {
      _editControls: [],
      _paramsHooks: [],
      find: function find(layerName, oid) {
        for (var iD = 0; iD < this._editControls.length; iD++) {
          if (layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid) return this._editControls[iD].control;
        }
      },
      add: function add(layerName, oid, control) {
        for (var iD = 0; iD < this._editControls.length; iD++) {
          if (layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid) {
            this._editControls[iD].control = control;
            return;
          }
        }

        this._editControls.push({
          layer: layerName,
          oid: oid,
          control: control
        });
      },
      remove: function remove(layerName, oid) {
        for (var iD = 0; iD < this._editControls.length; iD++) {
          if (layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid) {
            this._editControls.splice(iD, 1);

            return;
          }
        }
      },
      addParamsHook: function addParamsHook(paramsHook) {
        this._paramsHooks.push(paramsHook);
      },
      applyParamsHook: function applyParamsHook(layerName, objectId, params) {
        for (var h = 0; h < this._paramsHooks.length; h++) {
          params = this._paramsHooks[h](layerName, objectId, params);
        }

        return params;
      }
    };

    var getInputElement = function getInputElement(type) {
      var input = _input$1(null, [['dir', 'className', 'inputStyle edit-obj-input']]);

      if (type == 'date') {
        $(input).datepicker({
          changeMonth: true,
          changeYear: true,
          dateFormat: "dd.mm.yy"
        });
      } else if (type == 'datetime') {
        $(input).datetimepicker({
          changeMonth: true,
          changeYear: true,
          dateFormat: "dd.mm.yy",
          timeFormat: "HH:mm:ss",
          showSecond: true,
          timeOnly: false
        });
      } else if (type == "time") {
        $(input).timepicker({
          timeOnly: true,
          timeFormat: "HH:mm:ss",
          showSecond: true
        });
      }

      return input;
    }; //Коллекция полей с информацией для создания диалога редактирования


    var FieldsCollection = function FieldsCollection() {
      var _asArray = [];
      var _asHash = {};

      this.append = function (field) {
        if (field.name && _asHash[field.name]) {
          var origIndex = _asHash[field.name].origIndex;
          $.extend(true, _asHash[field.name], field);
          _asHash[field.name].origIndex = origIndex;
        } else {
          field.origIndex = _asArray.length;

          _asArray.push(field);

          if (field.name) {
            _asHash[field.name] = field;
          }
        }
      };

      this.get = function (name) {
        return _asHash[name];
      };

      this.each = function (callback) {
        _asArray.forEach(callback);
      };

      this.updateValue = function (name) {
        var field = _asHash[name];

        if (field && field.view) {
          field.value = field.view.getValue();
        }

        return field && field.value;
      }; //Сначала isRequired, потом identityField, потом в порядке добавления


      this.sort = function () {
        _asArray = _asArray.sort(function (a, b) {
          if (!!a.isRequired !== !!b.isRequired) {
            return Number(!!b.isRequired) - Number(!!a.isRequired);
          }

          if (!!a.identityField !== !!b.identityField) {
            return Number(!!b.identityField) - Number(!!a.identityField);
          }

          var userZIndexDelta = (a.index || 0) - (b.index || 0);
          return userZIndexDelta || a.origIndex - b.origIndex;
        });
      };
    };
    /** Объект, описывающий один атрибут слоя
     * @typedef {Object} nsGmx.EditObjectControl.FieldInfo
     * @property {String} name имя атрибута (обязательно)
     * @property {String|int} [value] значение атрибута в формате сервера
     * @property {bool} [constant=false] можно ли редактировать атрибут
     * @property {bool} [hide=false] совсем не показыавать этот атрибут
     * @property {String} [title=<совпадает с name>] что показывать вместо имени атрибута
     * @property {function(val):bool} [validate] ф-ция для валидации результата. На вход получает введённое пользователем значение
    *      (до преобразования в серверный формат), должна вернуть валидно ли это значение.
     * @property {String} [isRequired=false] является ли значение атрибута обязательным. Обязательные атрибуты показываются выше всех остальных и выделяются жирным шрифтом.
     * @property {Number} [index=0] индекс для сортировки. Влияет на порядок показа полей в диалоге. Больше - выше.
    */

    /** Контрол, который показывает диалог редактирования существующего или добавления нового объекта в слой.
    *
    * @memberOf nsGmx
    * @class
    * @param {String}   layerName ID слоя
    * @param {Number}   objectId ID объекта (null для нового объекта)
    * @param {Object}   [params] Дополнительные параметры контрола
    * @param {gmxAPI.drawingObject} [params.drawingObject] Пользовательский объект для задании геометрии или null, если геометрия не задана
    * @param {function} [params.onGeometrySelection] Внешняя ф-ция для выбора геометрии объекта.
             Сигнатура: function(callback), параметр callback(gmxAPI.drawingObject|geometry) должен быть вызван когда будет выбрана геометрия.
    * @param {HTMLNode} [params.geometryUI] HTML элемент, который нужно использовать вместо стандартных контролов для выбора геометрии (надпись + иконка)
    * @param {nsGmx.EditObjectControl.FieldInfo[]} [params.fields] массив с описанием характеристик атрибутов для редактирования . Должен содержать только атрибуты, которые есть в слое.
    * @param {bool} [params.allowDuplicates=<depends>] Разрешать ли несколько диалогов для редактирования/создания этого объекта.
             По умолчанию для редактирования запрещено, а для создания нового разрешено.
    * @param {HTMLNode | function(nsGmx.EditObjectControl): HTMLNode} [params.afterPropertiesControl] HTML элемент, который нужно поместить после списка атрибутов или ф-ция, которая возвращает этот элемент
    */


    var EditObjectControl = function EditObjectControl(layerName, objectId, params) {
      /** Объект был изменён/добавлен
       * @event nsGmx.EditObjectControl#modify
       */

      /** Генерируется перед изменением/добавлением объекта. Может быть использован для сохранения в свойствах объекта каких-то внешних данных.
       * @event nsGmx.EditObjectControl#premodify
       */

      /** Закрытие диалога редактирования
       * @event nsGmx.EditObjectControl#close
       */
      if (_queryMapLayers.layerRights(layerName) !== 'edit' && _queryMapLayers.layerRights(layerName) !== 'editrows') {
        showErrorMessage$1(_gtxt('Недостаточно прав для редактирования объектов слоя'), true);
        return;
      }

      var isNew = objectId == null;

      var _params = $.extend({
        drawingObject: null,
        fields: [],
        validate: {},
        allowDuplicates: isNew,
        afterPropertiesControl: _span$1()
      }, params);

      _params = EditObjectControlsManager.applyParamsHook(layerName, objectId, _params);

      var _this = this;

      if (!_params.allowDuplicates && EditObjectControlsManager.find(layerName, objectId)) return EditObjectControlsManager.find(layerName, objectId);
      EditObjectControlsManager.add(layerName, objectId, this);
      var lmap = nsGmx$1.leafletMap,
          layersByID = nsGmx$1.gmxMap.layersByID;
      var layer = layersByID[layerName];

      var geometryInfoContainer = _div$1(null, [['css', 'color', '#215570'], ['css', 'fontSize', '12px']]);

      var originalGeometry = null;
      var identityField = layer._gmx.properties.identityField;
      var geometryInfoRow = null;
      var drawingObjectLeafletID = null;

      var bindDrawingObject = function bindDrawingObject(obj) {
        geometryInfoRow && geometryInfoRow.RemoveRow();
        if (!obj) return;
        var InfoRow = gmxCore.getModule('DrawingObjects').DrawingObjectInfoRow;
        geometryInfoRow = new InfoRow(lmap, geometryInfoContainer, obj, {
          editStyle: false,
          allowDelete: false
        });
        drawingObjectLeafletID = obj._leaflet_id;
      };

      var objStyle = params && params.event ? params.event.gmx.target.currentStyle : null;

      var bindGeometry = function bindGeometry(geom) {
        if (geom) {
          var geojson = new L.GeoJSON(geom),
              styleParams = objStyle ? {
            pointStyle: {
              shape: 'box',
              color: objStyle.strokeStyle
            },
            lineStyle: {
              color: objStyle.strokeStyle
            }
          } : {},
              arr = lmap.gmxDrawing.addGeoJSON(geojson, styleParams);

          for (var i = 0, len = arr.length; i < len; i++) {
            bindDrawingObject(arr[i]);
          }
        }
      };
      var fieldsCollection = new FieldsCollection();

      var createDialog = function createDialog() {
        var createButton = makeLinkButton$1(isNew ? _gtxt("Создать") : _gtxt("Изменить")),
            removeButton = makeLinkButton$1(_gtxt("Удалить")),
            isSaving = false;

        var canvas = _div$1(null, [['dir', 'className', 'edit-obj']]);

        $(canvas).bind('dragover', function () {
          return false;
        });
        $(canvas).bind('drop', function (e) {
          var files = e.originalEvent.dataTransfer.files;
          nsGmx$1.Utils.parseShpFile(files[0]).done(function (objs) {
            bindGeometry(nsGmx$1.Utils.joinPolygons(nsGmx$1._.pluck(objs, 'geometry')));
          });
          return false;
        });

        removeButton.onclick = function () {
          _mapHelper.modifyObjectLayer(layerName, [{
            action: 'delete',
            id: objectId
          }]).done(function () {
            removeDialog$1(dialogDiv);
            closeFunc();
          });
        };

        removeButton.style.marginLeft = '10px';
        isNew && $(removeButton).hide();

        createButton.onclick = function () {
          if (isSaving) {
            return;
          }

          $(_this).trigger('premodify');
          var properties = {};
          var anyErrors = false;
          fieldsCollection.each(function (field) {
            var name = field.name;

            if (!name) {
              return;
            }

            var isValid = field.view.checkValue();

            if (isValid) {
              properties[name] = fieldsCollection.updateValue(name);
            }

            anyErrors = anyErrors || !isValid;
          });
          if (anyErrors) return;
          var obj = {
            properties: properties
          };

          var selectedGeom = _this.getGeometry(); // if (!selectedGeom)
          // {
          // showErrorMessage("Геометрия для объекта не задана", true, "Геометрия для объекта не задана");
          // return;
          // }


          if (!isNew) {
            obj.id = objectId;
            var curGeomString = JSON.stringify(selectedGeom);
            var origGeomString = JSON.stringify(originalGeometry);

            if (origGeomString !== curGeomString) {
              obj.geometry = selectedGeom;
            }
          } else {
            obj.geometry = selectedGeom;
          }

          isSaving = true;

          _mapHelper.modifyObjectLayer(layerName, [obj], 'EPSG:4326').done(function () {
            $(_this).trigger('modify');
            removeDialog$1(dialogDiv);
            closeFunc();
          });
        };

        var resizeFunc = function resizeFunc(event, ui) {
          if (!isNew && $(canvas).children("[loading]").length) return;
          canvas.firstChild.style.height = canvas.parentNode.offsetHeight - 25 - 10 - 10 + 'px';
        };

        var closeFunc = function closeFunc() {
          // search for opened styles editing dialog
          if (drawingObjectLeafletID) {
            var styleEditingDialog = $('.drawing-object-leaflet-id-' + drawingObjectLeafletID);
          }

          geometryInfoRow && geometryInfoRow.getDrawingObject() && nsGmx$1.leafletMap.gmxDrawing.remove(geometryInfoRow.getDrawingObject());
          originalGeometry = null;

          if (styleEditingDialog) {
            removeDialog$1(styleEditingDialog);
          }
          EditObjectControlsManager.remove(layerName, objectId);
          $(_this).trigger('close');
        };

        var drawAttrList = function drawAttrList(fields) {
          var trs = [],
              firstInput; //сначала идёт геометрия

          var geomTitleTmpl = Handlebars.compile('<span>' + '<span class="edit-obj-geomtitle">{{i "Геометрия"}}</span>' + '<span id = "choose-geom" class="gmx-icon-choose"></span>' + '</span>');
          var geometryUI = _params.geometryUI || $(geomTitleTmpl())[0];
          $('#choose-geom', geometryUI).click(function () {
            if (_params.onGeometrySelection) {
              _params.onGeometrySelection(bindGeometry);
            } else {
              nsGmx$1.Controls.chooseDrawingBorderDialog('editObject', bindDrawingObject, {
                geomType: layer.getGmxProperties().GeometryType
              });
            }
          });
          trs.push(_tr$1([_td$1([geometryUI], [['css', 'height', '20px']]), _td$1([geometryInfoContainer])]));
          fields.sort(); //потом все остальные поля

          fields.each(function (field) {
            var td = _td$1();

            if (field.constant) {
              field.view = field.view || {
                getUI: function getUI() {
                  var span = _span$1(null, [['dir', 'className', 'edit-obj-constant-value']]);

                  span.rowName = field.name;
                  span.rowType = field.type;

                  if ('value' in field) {
                    _$5(span, [_t$1(nsGmx$1.Utils.convertFromServer(field.type, field.value))]);
                  }

                  return span;
                },
                getValue: function getValue() {
                  return field.value;
                },
                setValue: function setValue() {},
                checkValue: function checkValue() {
                  return true;
                }
              };
            } else {
              field.view = field.view || {
                getUI: function getUI() {
                  if (!this._input) {
                    var input = this._input = getInputElement(field.type);
                    input.rowName = field.name;
                    input.rowType = field.type;
                    firstInput = firstInput || input;
                    if ('value' in field) input.value = nsGmx$1.Utils.convertFromServer(field.type, field.value);
                  }

                  return this._input;
                },
                getValue: function getValue() {
                  return nsGmx$1.Utils.convertToServer(field.type, this._input.value);
                },
                setValue: function setValue(value) {
                  this._input.value = nsGmx$1.Utils.convertFromServer(field.type, value);
                },
                checkValue: function checkValue() {
                  var validationFunc = field.validate || _params.validate[field.name];
                  var isValid = !validationFunc || validationFunc(this._input.value);

                  if (!isValid) {
                    inputError(this._input);
                  }

                  return isValid;
                },
                _input: null
              };
            }

            _$5(td, [field.view.getUI(_this)]);

            var fieldHeader = _span$1([_t$1(field.title || field.name)], [['css', 'fontSize', '12px']]);

            if (field.isRequired) {
              fieldHeader.style.fontWeight = 'bold';
            }

            var tr = _tr$1([_td$1([fieldHeader]), td], [['css', 'height', '22px']]);

            field.hide && $(tr).hide();
            trs.push(tr);
          });
          var afterPropUI = typeof _params.afterPropertiesControl === 'function' ? _params.afterPropertiesControl(_this) : _params.afterPropertiesControl;

          _$5(canvas, [_div$1([_table$1([_tbody$1(trs)], [['dir', 'className', 'obj-edit-proptable']]), afterPropUI], [['dir', 'className', 'obj-edit-canvas'], ['css', 'overflow', 'auto']])]);

          _$5(canvas, [_div$1([createButton, removeButton], [['css', 'margin', '10px 0px'], ['css', 'height', '20px']])]);

          firstInput && firstInput.focus();
          resizeFunc();
        };

        var prop = layer._gmx.properties;
        var dialogDiv = showDialog$1(isNew ? _gtxt("Создать объект слоя [value0]", prop.title) : _gtxt("Редактировать объект слоя [value0]", prop.title), canvas, 520, 300, false, false, resizeFunc, closeFunc);

        if (!isNew) {
          var loading = _div$1([_img$1(null, [['attr', 'src', 'img/progress.gif'], ['css', 'marginRight', '10px']]), _t$1(_gtxt('загрузка...'))], [['css', 'margin', '3px 0px 3px 20px'], ['attr', 'loading', true]]);

          _$5(canvas, [loading]); //получаем геометрию объекта


          sendCrossDomainJSONRequest$2(serverBase + "VectorLayer/Search.ashx?WrapStyle=func&layer=" + layerName + "&page=0&pagesize=1&orderby=" + identityField + "&geometry=true&query=[" + identityField + "]=" + objectId, function (response) {
            if (!parseResponse$1(response)) return;
            $(canvas).children("[loading]").remove();
            var columnNames = response.Result.fields;
            var geometryRow = response.Result.values.length > 0 ? response.Result.values[0] : [];

            if (geometryRow.length > 0) {
              var types = response.Result.types;

              for (var i = 0; i < geometryRow.length; ++i) {
                if (columnNames[i] === 'geomixergeojson') {
                  var geom = L.gmxUtil.geometryToGeoJSON(geometryRow[i], true);

                  if (geom) {
                    bindGeometry(geom);
                    originalGeometry = $.extend(true, {}, geom);
                  }
                } else {
                  var field = {
                    value: geometryRow[i],
                    type: types[i],
                    name: columnNames[i],
                    constant: columnNames[i] === identityField,
                    identityField: columnNames[i] === identityField,
                    isRequired: false
                  };
                  fieldsCollection.append(field);
                }
              }

              _params.fields.forEach(fieldsCollection.append);

              drawAttrList(fieldsCollection);
            } else {
              console.log('Geometry row is empty');
              $(dialogDiv).dialog('close');
            }

            _this.initPromise.resolve();
          });
        } else {
          for (var i = 0; i < prop.attributes.length; ++i) {
            fieldsCollection.append({
              type: prop.attrTypes[i],
              name: prop.attributes[i]
            });
          }

          _params.fields.forEach(fieldsCollection.append);

          if (_params.drawingObject) {
            bindDrawingObject(_params.drawingObject);
          }

          drawAttrList(fieldsCollection);

          _this.initPromise.resolve();
        }
      };
      /** Promise для отслеживания момента полной инициализации диалога. Только после полной инициализации можно полноценно пользоваться методами get/set
        * @memberOf nsGmx.EditObjectControl.prototype
        * @member {jQuery.Deferred} initPromise
      */


      this.initPromise = $.Deferred();
      /** Получить текущее значение атрибута из контрола
        @memberOf nsGmx.EditObjectControl.prototype
        @param {String} fieldName Имя атрибута
        @method get
      */

      this.get = function (fieldName) {
        return fieldsCollection.updateValue(fieldName);
      };

      this.getAll = function () {
        var res = {};
        fieldsCollection.each(function (field) {
          res[field.name] = fieldsCollection.updateValue(field.name);
        });
        return res;
      };
      /** Задать значение атрибута объекта из контрола
        @memberOf nsGmx.EditObjectControl.prototype
        @method set
        @param {String} fieldName Имя атрибута
        @param {String|Integer} value Значение в клиентском формате, который нужно установить для этого атрибута
      */


      this.set = function (fieldName, value) {
        var field = fieldsCollection.get(fieldName);

        if (field) {
          field.view.setValue(value);
        }
      };
      /** Задать геометрию для редактируемого объекта
        @memberOf nsGmx.EditObjectControl.prototype
        @method setGeometry
        @param {gmxAPI.DrawingObject|geometry} geometry Геометрия в виде drawing объекта или просто описание геометрии
      */


      this.setGeometry = function (geometry) {
        bindGeometry(geometry);
      };

      this.getGeometryObj = function () {
        return geometryInfoRow ? geometryInfoRow.getDrawingObject() : null;
      };

      this.getGeometry = function () {
        if (geometryInfoRow) {
          var geom = geometryInfoRow.getDrawingObject();
          var geojson = geom.toGeoJSON();
          return geojson.geometry;
        } else {
          return null;
        }
      };

      this.getLayer = function () {
        return layer;
      };

      this.add = function (field) {
        fieldsCollection.append(field);
      };

      createDialog();
    };

    nsGmx$1.EditObjectControl = EditObjectControl;
    /** Добавить "хук" для модификации параметров при всех вызовах ф-ции {@link nsGmx.EditObjectControl}
        @function
        @param {function(Object): Object} {paramsHook} Ф-ция, которая принимает на вход параметры ф-ции {@link nsGmx.EditObjectControl}
            и возвращает модифицируемые параметры (возможна замена in place)
    */

    nsGmx$1.EditObjectControl.addParamsHook = EditObjectControlsManager.addParamsHook.bind(EditObjectControlsManager);

    (function ($) {
      var mykosmosnimki = location.protocol + "//my.kosmosnimki.ru"; //"http://localhost:56319"; //

      var initTranslations = function initTranslations() {
        _translationsHash.addtext("rus", {
          ProfilePlugin: {
            profile: "Профиль",
            billing: "Биллинг",
            developer: "Разработчикам",
            firstName: "Фамилия",
            lastName: "Имя",
            email: "Электронная почта",
            login: "Псевдоним",
            fullName: "Полное имя",
            phone: "Телефон",
            company: "Название организации",
            companyProfile: "Вид деятельности организации",
            companyPosition: "Должность",
            isCompany: "Я выступаю от имени организации",
            subscribe: "Я согласен получать сообщения по почте",
            saveChanges: "Сохранить",
            used: "используется",
            remain: "осталось",
            fileStorage: "Файлы",
            fileStorageUsed: "Хранилище файлов используется",
            fileStorageRemain: "Хранилище файлов осталось",
            vectorLayerStorage: "Векторные данные",
            vectorLayerStorageUsed: "Хранилище векторных слоев используется",
            vectorLayerStorageRemain: "Хранилище векторных слоев осталось",
            subscription: "Подписки (Live Alerts)",
            subscriptionUsed: "Подписок (Live Alerts) имеется",
            subscriptionRemain: "Подписок (Live Alerts) осталось",
            smsAvailable: "Sms (Live Alerts) доступны",
            apiKeys: "API-ключи",
            apiKeyInvite: "Для получения ключей воспользуйтесь соответсвующими ссылками",
            apiKeyDomain: "API-ключ на домен (вставка окна карты на сайт)",
            //"API-ключ для сайтов (вставка окна карты на сайт)", //"API-Ключ для домена (для сайтов)",
            apiKeyDomainCap: "API-ключ на домен",
            apiKeyDirect: "API-ключ для приложений (запросы к REST/OGC)",
            //"API-Ключ прямого доступа (для приложений)",
            apiKeyDirectCap: "API-ключ для приложений",
            apiKeyList: "Список API-ключей",
            apiKeyListCap: "Список API-ключей",
            apiKeyDirectShort: "Ключ для приложения",
            apiKeyFilter: "API-ключ или домен",
            apiKeyFilterApply: "Найти",
            apiKeyEnabled: "активен",
            apiKeyDisabled: "не активен",
            apiKeyCreated: "получен",
            directKeyPurpose1: "API-ключ для приложений используется для обращений к <a target='blank' class='hyperLink' href='https://geomixer.ru/docs/dev-manual/rest-api/get-started/'>REST-сервисам</a> для подключения данных в настольные и/или веб-приложения.",
            directKeyPurpose2: "API-ключ для приложений НЕ может быть использован на публичных сайтах.",
            apiKeySite: "Сайт:",
            apiKeyReadAgreement: "Пожалуйста, ознакомьтесь с ",
            apiKeyAgreement: "я согласен с ",
            apiKeyConditions: "условиями использования",
            apiKeyGet: "Получить ключ",
            apiKeyUrge: "Необходимо принять условия использования",
            apiKeyAccept: "Принять",
            apiKeyCancel: "Отклонить",
            apiKeyReceive: "Ваш новый ключ",
            ErrorApiKeySiteEmpty: "Поле сайт не может быть пустым!",
            ErrorApiKeySiteInvalid: "Введите корректный адрес вашего сайта! Например, http://kosmosnimki.ru",
            ErrorApiKeyConditionsNotAccepted: "Для получения ключа необходимо согласиться с условиями использования!",
            clientRegistration: "Регистрация oAuth клиента",
            appName: "Название приложения",
            clientID: "ID клиента (client_id)",
            clientSecret: "oAuth ключ клиента (client_secret)",
            redirectUri: "URI скрипта обратного вызова (redirect_uri)",
            registerClient: "Получить новый ключ",
            password: "Пароль",
            getNew: "Изменить",
            cancelNew: "Закрыть",
            passwordSaved: "сохранен",
            passwordChanged: "изменен",
            old: "Старый пароль",
            newp: "Новый пароль",
            repeat: "Повтор пароля",
            submitp: "Изменить",
            megabyte: " мБ",
            yes: "да",
            no: "нет",
            ErrorNOT_AUTHORIZED: "Пользователь не авторизован!",
            ErrorLoginEmpty: "Требуется указать псевдоним!",
            ErrorLoginFormat: "Неправильный псевдоним! Допустимый вариант ",
            ErrorLoginExists: "Псевдоним уже используется!",
            ErrorAppName: "Не указано название приложения!",
            ErrorRedirectUri: "Требуется действительный uri обратного вызыва!",
            ErrorOldPassword: "Старый пароль указан неверно!",
            ErrorNewPassword: "Пароль не может быть пустым!",
            ErrorNotMatch: "Введённые пароли не совпадают!",
            ErrorCapchaRequired: "Введите число!",
            ErrorWrongCapcha: "Числа не совпадают!",
            ErrorEmailEmpty: "Требуется указать email!",
            ErrorWrongEmail: "Недопустимый адрес электронной почты!",
            ErrorEmailExists: "Такой адрес электронной почты уже зарегистрирован!",
            dataUpdateSuccess: "Изменения сохранены",
            registration: "Регистрация",
            registrationPageAnnotation: "Заполните поля формы",
            //registrationPageAnnotation: "Заполните поля формы. Введите ваш адрес электронной почты, псевдоним, желаемый пароль и число с картинки. Можете указать фамилилию и имя.",
            capcha: "Введите число",
            register: "Зарегистрироваться",
            backOn: "Повторить",
            loginPage: "вход",
            close: "Закрыть"
          }
        });

        _translationsHash.addtext("eng", {
          ProfilePlugin: {
            profile: "Profile",
            billing: "Billing",
            developer: "Developer",
            firstName: "First name",
            lastName: "Last name",
            email: "Email",
            login: "Nickname",
            fullName: "Full name",
            phone: "Phone",
            company: "Company",
            companyProfile: "Type of company activity",
            companyPosition: "Company position",
            isCompany: "I am speaking on behalf of the organization",
            subscribe: "I agree to receive updates and news by email",
            saveChanges: "Save",
            used: "used",
            remain: "rest",
            fileStorage: "Files",
            fileStorageUsed: "File storage consumtion",
            fileStorageRemain: "File storage remain",
            vectorLayerStorage: "Vector data",
            vectorLayerStorageUsed: "Vector storage consumption",
            vectorLayerStorageRemain: "Vector storage remain",
            subscription: "Subscriptions",
            subscriptionUsed: "Subscription consumption",
            subscriptionRemain: "Subscription remain",
            smsAvailable: "Sms",
            apiKeys: "API-keys",
            apiKeyInvite: "To get a key use apropriate links below",
            apiKeyDomain: "Domain API-key (for sites)",
            apiKeyDomainCap: "Domain API-key",
            apiKeyDirect: "Direct access API-key (for applications)",
            apiKeyDirectCap: "Direct access API-key",
            apiKeyList: "Issued API-keys list",
            apiKeyListCap: "Issued API-keys list",
            apiKeyDirectShort: "Direct access key",
            apiKeyFilter: "Key or domain",
            apiKeyFilterApply: "Search",
            apiKeyEnabled: "enabled",
            apiKeyDisabled: "disabled",
            apiKeyCreated: "created",
            directKeyPurpose1: "API-ключ для приложений используется для обращений к REST-сервисам (https://geomixer.ru/docs/dev-manual/rest-api/get-started/) для подключения данных в настольные и/или веб-приложения. API-ключ для приложений НЕ может быть использован на публичных сайтах.",
            directKeyPurpose2: "Ключ прямого доступа не может быть использован на сайте.",
            apiKeySite: "Site:",
            apiKeyReadAgreement: "Пожалуйста, ознакомьтесь с ",
            apiKeyAgreement: "я согласен с ",
            apiKeyConditions: "условиями использования",
            apiKeyGet: "Get the key",
            apiKeyUrge: "Необходимо принять условия использования",
            apiKeyAccept: "Accept",
            apiKeyCancel: "Cancel",
            apiKeyReceive: "Ваш новый ключ",
            ErrorApiKeySiteEmpty: "Поле сайт не может быть пустым!",
            ErrorApiKeySiteInvalid: "Введите корректный адрес вашего сайта! Например, http://kosmosnimki.ru",
            ErrorApiKeyConditionsNotAccepted: "Для получения ключа необходимо согласиться с условиями использования!",
            clientRegistration: "oAuth Client Registration",
            appName: "Client Application",
            clientID: "Client ID (client_id)",
            clientSecret: "Client secret key (client_secret)",
            redirectUri: "Redirect endpoint URI",
            registerClient: "Issue new secret key",
            password: "Password",
            getNew: "change",
            cancelNew: "close",
            passwordSaved: "saved",
            passwordChanged: "changed",
            old: "Old password",
            newp: "New password",
            repeat: "Repeat",
            submitp: "Change",
            megabyte: " MB",
            yes: "yes",
            no: "no",
            ErrorNOT_AUTHORIZED: "Authorization is required!",
            ErrorLoginEmpty: "Nickname is required!",
            ErrorLoginFormat: "Invalid nickname! Allowable nickname ",
            ErrorLoginExists: "Nickname duplicates!",
            ErrorAppName: "Application name is required!",
            ErrorRedirectUri: "Valid redirect uri is required!",
            ErrorOldPassword: "Password is invalid!",
            ErrorNewPassword: "Password is required!",
            ErrorNotMatch: "Passwords does not match!",
            ErrorCapchaRequired: "Input a number!",
            ErrorWrongCapcha: "Number mismatch!",
            ErrorEmailEmpty: "Email is required!",
            ErrorWrongEmail: "Invalid email!",
            ErrorEmailExists: "Email duplicates!",
            dataUpdateSuccess: "Saved successfully",
            registration: "Registration",
            registrationPageAnnotation: "Please fill all fields",
            capcha: "Input a number",
            register: "Register",
            backOn: "Back to",
            loginPage: "Login",
            close: "Close"
          }
        });
      };

      var ppBackScreen = $("div.profilePanel"),
          ppMainParts;

      var showProfile = function showProfile() {
        if (!ppBackScreen.length) {
          // Create
          ppBackScreen = $('<div class="profilePanel"><table width="100%" height="100%"><tr><td><img src="img/progress.gif"></td></tr></table></div>').hide().appendTo('#all');
          var ppFrame = $('<div class="profilePanel-content"></div>');
          var ppScrollableContainer = $('<div class="profilePanel-scrollable"></div>');
          var ppMenu = $('<div class="profilePanel-menu"></div>');
          var success = $('<div class="UpdateMessage"><div class="success">' + _gtxt('ProfilePlugin.dataUpdateSuccess') + '</div></div>');
          var fail = $('<div class="UpdateMessage"><div class="fail">' + 'Error' + '</div></div>'); // Pages

          var pageTemplate = '<div class="page">' + '{{#each items}}' + '{{#if form_caption}}' + '<div class="form-caption {{#if first}}first{{/if}}">{{text}}</div>' + '{{/if}}' + '{{#if span}}' + '<div>{{text}}: <span {{#if id}}class="{{id}}"{{/if}}></span></div>' + '{{/if}}' + '{{#if span_nl}}' + '<div>{{text}}:<br/><span {{#if id}}class="{{id}}"{{/if}}></span></div>' + '{{/if}}' + '{{#if block}}' + '<div>' + '{{#content}}' + '{{#if p}}<p>{{text}}</p>{{/if}}' + '{{#if link_button}}<div {{#if id}}class="{{id}} link_button"{{/if}}><span>{{text}}</span></div>{{/if}}' + '{{/content}}' + '</div>' + '{{/if}}' + '{{#if text_input}}' + '<div onclick="$(this).children().focus()" class="editable">{{text}}: <input {{#if id}}class="{{id}}"{{/if}} type="text" value=""></div>' + '{{/if}}' + '{{#if text_area}}' + '<div onclick="$(this).children().focus()" class="editable">{{text}}: <textarea {{#if id}}class="{{id}}"{{/if}}></textarea></div>' + '{{/if}}' + '{{#if error}}' + '<div class="ErrorSummary">error</div>' + '{{/if}}' + '{{#if button_input}}' + '<div class="SubmitBlock" {{#if width}}style="width:{{width}}"{{/if}}>' + '<input type="button" {{#if id}}class="{{id}}"{{/if}} value="{{text}}"/>' + '<img src="img/progress.gif"></div>' + '{{/if}}' + '{{#if checkbox_group}}' + '<table>' + '{{#each checkbox_group}}' + '<tr><td><input type="checkbox" class="{{id}}" id="pp{{id}}"></td><td><label for="pp{{id}}">{{text}}</label></td></tr>' + '{{/each}}' + '</table>' + '{{/if}}' + '{{#if table}}' + '<table border=0 class="{{id}}">' + '{{#columns}}' + '<tr><th>{{column1}}</th><th>{{column2}}</th><th>{{column3}}</th></tr>' + '{{/columns}}' + '{{#rows}}' + '<tr>{{#cells}}<td class="{{id}}">{{text}}</td>{{/cells}}</tr>' + '{{/rows}}' + '</table>' + '{{/if}}' + '{{/each}}' + '</div>';
          var page1 = $(Handlebars.compile(pageTemplate)({
            id: "page1",
            items: [{
              span: true,
              id: "Email",
              text: _gtxt('ProfilePlugin.email')
            }, {
              text_input: true,
              id: "Login LoginEmpty LoginFormat LoginExists correct",
              text: _gtxt('ProfilePlugin.login')
            }, {
              text_input: true,
              id: "FullName correct",
              text: _gtxt('ProfilePlugin.fullName')
            }, {
              text_input: true,
              id: "Phone correct",
              text: _gtxt('ProfilePlugin.phone')
            }, {
              text_input: true,
              id: "Company correct",
              text: _gtxt('ProfilePlugin.company')
            }, {
              text_input: true,
              id: "CompanyProfile correct",
              text: _gtxt('ProfilePlugin.companyProfile')
            }, {
              text_input: true,
              id: "CompanyPosition correct",
              text: _gtxt('ProfilePlugin.companyPosition')
            }, {
              checkbox_group: [{
                id: "IsCompany",
                text: _gtxt('ProfilePlugin.isCompany')
              }, {
                id: "Subscribe",
                text: _gtxt('ProfilePlugin.subscribe')
              }]
            }, {
              error: true
            }, {
              button_input: true,
              id: "SaveChanges",
              text: _gtxt('ProfilePlugin.saveChanges')
            }]
          })).appendTo(ppFrame),
              page2 = $(Handlebars.compile(pageTemplate)({
            id: "page2",
            items: [{
              table: true,
              id: "ResourceTable",
              columns: [{
                column1: "",
                column2: _gtxt('ProfilePlugin.used'),
                column3: _gtxt('ProfilePlugin.remain')
              }],
              rows: [{
                cells: [{
                  id: "FileStorage",
                  text: _gtxt('ProfilePlugin.fileStorage')
                }, {
                  id: "FileStorageUsed value",
                  text: "b1"
                }, {
                  id: "FileStorageRemain value",
                  text: "c1"
                }]
              }, {
                cells: [{
                  id: "VectorLayerStorage",
                  text: _gtxt('ProfilePlugin.vectorLayerStorage')
                }, {
                  id: "VectorLayerStorageUsed value",
                  text: "b2"
                }, {
                  id: "VectorLayerStorageRemain value",
                  text: "c2"
                }]
              }, {
                cells: [{
                  id: "Subscription",
                  text: _gtxt('ProfilePlugin.subscription')
                }, {
                  id: "SubscriptionUsed value",
                  text: "b3"
                }, {
                  id: "SubscriptionRemain value",
                  text: "c3"
                }]
              }]
            }, {
              span: true,
              id: "SmsAvailable",
              text: _gtxt('ProfilePlugin.smsAvailable')
            }]
          })).appendTo(ppFrame),
              page3 = $(Handlebars.compile(pageTemplate)({
            id: "page3",
            items: [{
              form_caption: true,
              text: _gtxt('ProfilePlugin.apiKeys'),
              first: true
            }, {
              block: true,
              content: [{
                link_button: true,
                text: _gtxt('ProfilePlugin.apiKeyList'),
                id: "apiKeyList"
              }]
            }, {
              block: true,
              content: [{
                p: true,
                text: _gtxt('ProfilePlugin.apiKeyInvite')
              }, {
                link_button: true,
                text: _gtxt('ProfilePlugin.apiKeyDomain'),
                id: "apiKeyDomain"
              }, {
                link_button: true,
                text: _gtxt('ProfilePlugin.apiKeyDirect'),
                id: "apiKeyDirect"
              }]
            }, {
              form_caption: true,
              text: _gtxt('ProfilePlugin.clientRegistration')
            }, {
              text_input: true,
              id: "AppName correct",
              text: _gtxt('ProfilePlugin.appName')
            }, {
              span: true,
              id: "ClientID",
              text: _gtxt('ProfilePlugin.clientID')
            }, {
              span_nl: true,
              id: "ClientSecret",
              text: _gtxt('ProfilePlugin.clientSecret')
            }, {
              text_input: true,
              id: "RedirectUri correct",
              text: _gtxt('ProfilePlugin.redirectUri')
            }, {
              error: true
            }, {
              button_input: true,
              id: "RegisterClient",
              text: _gtxt('ProfilePlugin.registerClient'),
              width: '180px'
            }]
          })).appendTo(ppFrame); // Profile submit

          var successmess_timeout;
          page1.find('.SaveChanges').click(function () {
            changePassForm.slideUp("fast");
            changePassControls.first().val(_gtxt('ProfilePlugin.getNew'));
            success.hide();
            var wait = $(this).next().css('visibility', 'visible');
            clearTimeout(successmess_timeout);
            sendCrossDomainPostRequest(mykosmosnimki + "/Handler/Settings", {
              WrapStyle: 'message',
              Login: page1.find('.Login').val().trim(),
              FullName: page1.find('.FullName').val().trim(),
              Phone: page1.find('.Phone').val().trim(),
              Company: page1.find('.Company').val().trim(),
              Profile: page1.find('.CompanyProfile').val().trim(),
              Position: page1.find('.CompanyPosition').val().trim(),
              IsCompany: page1.find('.IsCompany').is(":checked"),
              Subscribe: page1.find('.Subscribe').is(":checked")
            }, function (response) {
              wait.css('visibility', 'hidden');

              if (response.Status.toLowerCase() == 'ok' && response.Result) {
                //page1.children('.ErrorSummary').text('error').css('visibility', 'hidden');
                page1.children('.ErrorSummary').hide();
                success.show();
                successmess_timeout = setTimeout(function () {
                  success.hide();
                }, 2000);
              } else {
                if (response.Result.length > 0 && response.Result[0].Key) page1.trigger('onerror', [response.Result[0].Key, response.Result[0].Value.Errors[0].ErrorMessage]);else page1.trigger('onerror', response.Result.Message);
              }
            });
          }); // Register client submit

          var newsecret_timeout;
          page3.find('.RegisterClient').click(function () {
            closeApiKeyDialog();
            var wait = $(this).next().css('visibility', 'visible');
            var client_secret = page3.find('.ClientSecret').removeClass('new');
            clearTimeout(newsecret_timeout);
            sendCrossDomainPostRequest(mykosmosnimki + "/Handler/RegisterClient", {
              WrapStyle: 'message',
              AppName: page3.find('.AppName').val(),
              RedirectUri: page3.find('.RedirectUri').val()
            }, function (response) {
              wait.css('visibility', 'hidden');

              if (response.Status.toLowerCase() == 'ok' && response.Result) {
                client_secret.addClass('new').text(response.Result.Key);
                newsecret_timeout = setTimeout(function () {
                  client_secret.removeClass('new');
                }, 2000); //page3.children('.ErrorSummary').css('visibility', 'hidden');

                page3.children('.ErrorSummary').hide();
              } else {
                page3.trigger('onerror', response.Result.Message);
              }
            });
          });
          var ppPages = ppFrame.find('div.page').hide(); // Change password form

          var changePassControls = $(Handlebars.compile('<input style="width:80px; float:right; margin:6px 12px 0 0;" type="button" value="{{i "ProfilePlugin.getNew"}}"/>' + '<div style="border:none; font-weight:normal;margin:10px 0 10px 12px;">{{i "ProfilePlugin.password"}} <span class="PasswordState">{{i "ProfilePlugin.passwordSaved"}}</span></div>')()).insertAfter(page1.find('.Email').parent()),
              changePassForm = $(Handlebars.compile('<div class="newpass-form">' + '{{i "ProfilePlugin.old"}}: <input type="password" class="OldPassword" value=""><br/>' + '{{i "ProfilePlugin.newp"}}: <input type="password" class="NewPassword NotMatch" value=""><br/>' + '{{i "ProfilePlugin.repeat"}}: <input type="password" class="PasswordRepeat NotMatch" value=""><br/>' + '<div class="ErrorSummary" style="padding-top:6px"></div>\
                <div class="SubmitBlock">\
                <input type="button" class="ChangePassword" value="{{i "ProfilePlugin.submitp"}}"/>\
                <img src="img/progress.gif"></div>' + '</div>')()),
              changePass_timeout;
          changePassForm.insertAfter(changePassControls.last());
          changePassForm.find('.ChangePassword').click(function () {
            //clearPageErrors($(this));
            //clearPageErrors(page1);
            var wait = $(this).next().css('visibility', 'visible');
            sendCrossDomainPostRequest(mykosmosnimki + "/Handler/ChangePassword", {
              WrapStyle: 'message',
              oldpassword: changePassForm.children('.OldPassword').val().trim(),
              password: changePassForm.children('.NewPassword').val().trim(),
              repeat: changePassForm.children('.PasswordRepeat').val().trim()
            }, function (response) {
              wait.css('visibility', 'hidden');
              clearTimeout(changePass_timeout);

              if (response.Status.toLowerCase() == 'ok' && response.Result) {
                var state = changePassForm.hide().prev().find('.PasswordState').text(_gtxt('ProfilePlugin.passwordChanged')).addClass('changed');
                changePassControls.first().val(_gtxt('ProfilePlugin.getNew'));
                changePass_timeout = setTimeout(function () {
                  state.fadeOut("slow", function () {
                    $(this).text(_gtxt('ProfilePlugin.passwordSaved')).removeClass('changed');
                  }).fadeIn("slow");
                }, 2000);
              } else changePassForm.trigger('onerror', response.Result.Message);
            });
          });
          changePassControls.first().click(function (e) {
            if (changePassForm.is(':visible')) {
              changePassForm.slideUp("fast");
              $(this).val(_gtxt('ProfilePlugin.getNew'));
            } else {
              changePassForm.slideDown("fast");
              $(this).val(_gtxt('ProfilePlugin.cancelNew'));
              changePassForm.trigger('onrender');
            }
          }); // API-keys dialogs

          var closeApiKeyDialog = function closeApiKeyDialog() {
            var akd = $('.apiKeyDialog');

            if (akd.length > 0) {
              // akd.find('.licence').mCustomScrollbar("destroy");
              // akd.find('.list').mCustomScrollbar("destroy");
              removeDialog($('.apiKeyDialog').parent()[0]);
            }
          },
              showApiKeyDialog = function showApiKeyDialog(dtype) {
            //if ($('.apiKeyDialog').length > 0) {
            //  return;
            //}
            closeApiKeyDialog();
            clearPageErrors($('.page:visible'));

            if (dtype == 'List') {
              var startW = 556,
                  startH = 340,
                  akDialog = $('<div class="apiKeyDialog"></div>'),
                  wait = $('<div style="position:absolute; top:120px; left:270px"><img src="img/progress.gif"></div>');
              akDialog.append(wait);
              window.showDialog(_gtxt('ProfilePlugin.apiKey' + dtype + 'Cap'), akDialog[0], startW, startH).style.overflow = 'hidden';
              akDialog.parent().on("dialogresizestart", function (event, ui) {//startW = ui.size.width;
                //startH = ui.size.height;
              }).on("dialogresize", function (event, ui) {
                var list = akDialog.find('.list');
                list.height(list.height() + ui.size.height - startH); //startW = ui.size.width;

                startH = ui.size.height;
              });
              sendCrossDomainJSONRequest(mykosmosnimki + "/handler/apikeys?wrapstyle=func", function (response) {
                if (parseResponse(response) || response.Status == 'OK') {
                  wait.remove();

                  if (response.Result && response.Result.length > 0) {
                    var list = $('<div class="list"></div>'),
                        apiKeyActivation = function apiKeyActivation() {
                      var checkboxes = $('input[type="checkbox"]', list).click(function () {
                        checkboxes.prop('disabled', true);
                        var progress = $('<span>&nbsp;</span><img src="img/progress.gif">');
                        var checkbox = $(this);
                        checkbox.parent().append(progress);
                        sendCrossDomainPostRequest(mykosmosnimki + "/Handler/ActivateKey", {
                          WrapStyle: 'message',
                          Apikey: checkbox.val()
                        }, function (apiKeyResp) {
                          checkboxes.prop('disabled', false);
                          progress.remove();

                          if (apiKeyResp.Status.toLowerCase() == 'ok') {
                            for (var i = 0; i < response.Result.length; ++i) {
                              if (response.Result[i].Apikey == apiKeyResp.Result.Apikey) {
                                response.Result[i].IsActive = apiKeyResp.Result.IsActive;
                                break;
                              }
                            }
                          } else {
                            console.log(response);
                          }
                        });
                      });
                    },
                        createTbl = function createTbl(filter) {
                      var tbl = '<div><table border=0>';
                      var re = new RegExp(filter, 'i');

                      for (var i = 0; i < response.Result.length; ++i) {
                        if (filter == null || filter.search(/\S/) < 0 || response.Result[i].Apikey.search(re) != -1 || response.Result[i].Domain != 'Direct' && response.Result[i].Domain.search(re) != -1) tbl += '<tr><td>' + response.Result[i].Apikey + '</td><td style="word-break:break-all">' + (response.Result[i].AllowDirect ? _gtxt('ProfilePlugin.apiKeyDirectShort') : response.Result[i].Domain) + //'</td><td>' + (response.Result[i].IsActive ? '<i class="icon-check">' : '') +
                        '</td><td>' + '<input type="checkbox" ' + (response.Result[i].IsActive ? 'checked' : '') + ' value="' + response.Result[i].Apikey + '">' + '</td><td>' + response.Result[i].Created + '</td></tr>';
                      }

                      tbl += '</table></div>';
                      return tbl;
                    };

                    var filter = $('<div style="padding-left:6px">' + _gtxt('ProfilePlugin.apiKeyFilterApply') + ': <input type="text" placeholder="' + _gtxt('ProfilePlugin.apiKeyFilter') + '"></div>').appendTo(akDialog);
                    filter.find('input[type="text"]').keyup(function (e) {
                      list.find('table').parent().remove();
                      list.mCustomScrollbar('destroy').append(createTbl($(this).val())).mCustomScrollbar();
                      apiKeyActivation();
                      keys = list.find('table');
                      resize(akDialog.parent().dialog("option", "width") - startW);
                    });
                    list.appendTo(akDialog).append($(createTbl())).mCustomScrollbar();
                    apiKeyActivation();

                    var header = list.before($(Handlebars.compile('<table border=0><tr><th>ключ</th><th>тип/сайт</th><th>активен</th><th>{{i "ProfilePlugin.apiKeyCreated"}}</th></tr></table>')())).prev(),
                        keys = list.find('table'),
                        resize = function resize(dif) {
                      var th = header.find('tr th');
                      var td = keys.find('tr:eq(0) td');
                      header.width(keys.width(514 + dif).width());
                      th.eq(0).width(td.eq(0).width(90).width());
                      th.eq(2).width(td.eq(2).width(70).width());
                      th.eq(3).width(td.eq(3).width(90).width());
                      th.eq(1).width(td.eq(1).width());
                    };

                    akDialog.parent().on("dialogresize", function (event, ui) {
                      resize(ui.size.width - startW);
                    });
                    resize(0);
                  }
                } else {
                  removeDialog(akDialog.parent()[0]);
                }
              });
            } else {
              var fordirect = dtype == 'Direct' ? '<div>{{{i "ProfilePlugin.directKeyPurpose1"}}}</div>' + '<div>{{i "ProfilePlugin.directKeyPurpose2"}}</div>' : '';
              var fordomain = dtype == 'Domain' ? '<div>{{i "ProfilePlugin.apiKeySite"}}<input type="text" tabindex="2" class="ApiKeySite ApiKeySiteEmpty ApiKeySiteInvalid" value="http://"></div>' : '';
              var akForm = $(Handlebars.compile('<div class="apiKeyDialog">' + '<div class="first">' + '<div>{{i "ProfilePlugin.apiKeyReadAgreement"}}<span class="showLicence hyperLink">{{i "ProfilePlugin.apiKeyConditions"}}</span></div>' + '<div><div style="float:left;margin:0"><input type="checkbox" tabindex="1" id="agree" class="agree"></div><div style="padding-left:10px"><label for="agree">{{i "ProfilePlugin.apiKeyAgreement"}} {{i "ProfilePlugin.apiKeyConditions"}}</div></div>' + fordomain + fordirect + '<div class="spacer"></div>' + '<div class="ErrorSummary"><span class="fail"></span><span class="success"></span><img class="wait" src="img/progress.gif"></div>' + '<div class="submit"><input tabindex="3" type="button" class="get" title="{{i "ProfilePlugin.apiKeyUrge"}}" value="{{i "ProfilePlugin.apiKeyGet"}}"/></div>' + '</div>' + '<div class="licence"></div>' + '<div class="submit"><input tabindex="1" type="button" class="accept" value="{{i "ProfilePlugin.apiKeyAccept"}}"/><input tabindex="2" type="button" class="cancel" value="{{i "ProfilePlugin.apiKeyCancel"}}"/></div>' + '</div>')());
              var licence = akForm.find('.licence'),
                  spacer = akForm.find('.spacer'),
                  startH;
              licence.hide().next().hide();
              if (dtype == 'Domain') spacer.height('20px');
              var summary = akForm.find('.ErrorSummary'),
                  wait = summary.children('.wait'),
                  site = akForm.find('.ApiKeySite'),
                  agree = akForm.find('.agree'),
                  getKey = akForm.find('.get').css('opacity', 0.5).click(function () {
                var respHandler = function respHandler(response) {
                  wait.css('visibility', 'hidden');

                  if (response.Status.toLowerCase() == 'ok' && response.Result) {
                    summary.children('span.success').text(_gtxt('ProfilePlugin.apiKeyReceive') + ' ' + response.Result.Key);
                  } else {
                    summary.children('span.fail').text(_gtxt('ProfilePlugin.Error' + response.Result.Message));
                    akForm.find('.' + response.Result.Message).addClass('error');
                  }
                };

                clearError();
                wait.css('visibility', 'visible');
                if (site.length) sendCrossDomainPostRequest(mykosmosnimki + "/Handler/CreateKey", {
                  WrapStyle: 'message',
                  domain: site.val(),
                  agree: agree.is(':checked')
                }, respHandler);else sendCrossDomainPostRequest(mykosmosnimki + "/Handler/CreateDirect", {
                  WrapStyle: 'message',
                  agree: agree.is(':checked')
                }, respHandler);
              });
              getKey.prop('disabled', true);
              site.prop('disabled', true).keydown(function (e) {
                if ($(this).is('.error')) clearError();
                if (e.which == 13) getKey.click();
              });

              var clearError = function clearError() {
                summary.children('span').text('');
                site.removeClass('error');
              };

              akForm.find('.showLicence').click(function () {
                clearError();
                licence.show().prev().hide();
                licence.next().show();
                if (licence.text() == '') licence.load(gmxCore.getModulePath('ProfilePlugin') + 'license.html', function () {
                  licence.mCustomScrollbar();
                });
              });
              licence.next('div').children('input').click(function () {
                licence.next().hide();
                licence.hide().prev().show();
              }).first().click(function () {
                agree[0].checked = true;
                agree.change();
              }).next('.cancel').click(function () {
                agree[0].checked = false;
                agree.change();
              });
              agree.change(function () {
                getKey.prop('disabled', !agree.is(':checked'));
                site.prop('disabled', !agree.is(':checked'));

                if (agree.is(':checked')) {
                  getKey.css('opacity', 1).focus().attr('title', _gtxt('ProfilePlugin.apiKeyGet'));
                } else {
                  getKey.css('opacity', 0.5).attr('title', _gtxt('ProfilePlugin.apiKeyUrge'));
                }
              });
              window.showDialog(_gtxt('ProfilePlugin.apiKey' + dtype + 'Cap'), akForm[0], 555, 320);
              akForm.parent('.ui-dialog-content').css('overflow', 'hidden');
              akForm.parent().on("dialogresizestart", function (event, ui) {
                startH = ui.size.height;
              }).on("dialogresize", function (event, ui) {
                licence.height(licence.height() + ui.size.height - startH);
                spacer.height(spacer.height() + ui.size.height - startH);
                startH = ui.size.height;
              });
            }
          };

          page3.find('.apiKeyDomain').click(function () {
            showApiKeyDialog('Domain');
          });
          page3.find('.apiKeyDirect').click(function () {
            showApiKeyDialog('Direct');
          });
          page3.find('.apiKeyList').click(function () {
            showApiKeyDialog('List');
          });
          ppPages.find('input[type="text"], input[type="password"]').keyup(function (e) {
            if (e.which == 13) {
              var submit = $(this).siblings('div.SubmitBlock').children('input[type="button"]');
              if (!submit.length) submit = $(this).parent().siblings('div.SubmitBlock').children('input[type="button"]');
              submit.click();
            } else clearInputErrors($(this));
          }).focusin(function (e) {
            closeApiKeyDialog();
            clearInputErrors($(this));
          }); // Error display

          var clearInputErrors = function clearInputErrors(input) {
            if (input.val().search(/\S/) != -1 && input.is('.error')) {
              var es = input.nextAll('.ErrorSummary');
              if (es.length == 0) es = input.parent().nextAll('.ErrorSummary');

              if (input.is('.NotMatch')) {
                var s = input.siblings('.NotMatch');

                if (s.val() === input.val()) {
                  input.removeClass('error');
                  s.removeClass('error');
                  es.slideUp(); //.hide();
                }
              } else {
                input.removeClass('error').addClass('correct');
                es.slideUp(); //.hide();
              }
            }
          };

          var clearPageErrors = function clearPageErrors(page) {
            page.find('.ErrorSummary').hide();
            page.find('.error').removeClass('error');
          };

          changePassForm.bind('onerror', function (e, m) {
            $(this).children('.ErrorSummary').text(_gtxt('ProfilePlugin.Error' + m)).slideDown('slow');
            $(this).find('.' + m).addClass('error');
            $(this).find(':password,:text').filter(function () {
              return $(this).val() == "";
            }).addClass('error');
            return false;
          });
          changePassForm.bind('onrender', function () {
            $(this).children('input[type="password"]').val('');
            clearPageErrors($(this));
            clearPageErrors(page1);
            return false;
          });
          ppPages.bind('onerror', function (e, m1, m2) {
            var m = _gtxt('ProfilePlugin.Error' + m1);

            if (m2) m += " " + m2;
            $(this).children('.ErrorSummary').text(m).slideDown('slow');
            $(this).find('.' + m1).removeClass('correct').addClass('error');
            return false;
          });
          ppPages.bind('onrender', function () {
            clearPageErrors($(this));
            changePassForm.hide();
            changePassControls.first().val(_gtxt('ProfilePlugin.getNew'));
            return false;
          });
          ppPages.first().show();
          ppScrollableContainer.hide().appendTo('#all').append(ppFrame); // Menu

          var menuEntryTemplate = '<div class="MenuEntry">{{text}}</div>';

          var showPage = function showPage(e, page) {
            closeApiKeyDialog();
            ppMenu.children('.MenuEntry').removeClass('selected');
            ppPages.hide();
            page.show();
            $(e.target).removeClass('targeted').addClass('selected');
            page.trigger('onrender');
          };

          $(Handlebars.compile(menuEntryTemplate)({
            text: _gtxt('ProfilePlugin.profile')
          })).appendTo(ppMenu).click(function (e) {
            showPage(e, page1);
          });
          $(Handlebars.compile(menuEntryTemplate)({
            text: _gtxt('ProfilePlugin.billing')
          })).appendTo(ppMenu).click(function (e) {
            showPage(e, page2);
          });
          $(Handlebars.compile(menuEntryTemplate)({
            text: _gtxt('ProfilePlugin.developer')
          })).appendTo(ppMenu).click(function (e) {
            showPage(e, page3);
          }); //wait.appendTo(ppMenu).hide();

          success.appendTo(ppMenu).hide();
          fail.appendTo(ppMenu).hide();
          ppMenu.hide().appendTo('#all');
          var ppMenuEntries = ppMenu.children('.MenuEntry');
          ppMenuEntries.first().addClass('selected');
          ppMenuEntries.mouseover(function (e) {
            if (!$(e.target).is('.selected')) $(e.target).addClass('targeted');
          });
          ppMenuEntries.mouseout(function (e) {
            if (!$(e.target).is('.selected')) $(e.target).removeClass('targeted');
          }); // All together

          ppMainParts = $([ppScrollableContainer, ppMenu]).map(function () {
            return this[0];
          });
          ppMainParts.data('ondataload', function () {
            if (ppBackScreen.is(':visible')) {
              ppPages.trigger('onrender');
              ppMainParts.show();
            }
          });
          $('body>div>div').mousedown(function (e) {
            if (!ppMainParts.is($(e.target)) && !ppMainParts.find($(e.target)).length) {
              ppBackScreen.hide();
              ppMainParts.hide();
              closeApiKeyDialog();

              if (!nsGmx.leafletMap.gmxControlsManager.get('layers')) {
                nsGmx.leafletMap.addControl(overlays);
              }
            }
          });
          ppScrollableContainer.mCustomScrollbar();
          $(window).resize(resizePanel);
        } // Show


        var overlays = nsGmx.leafletMap.gmxControlsManager.get('layers');
        ppBackScreen.show();
        fillProfile(ppMainParts.data('ondataload'), function () {
          ppBackScreen.hide();
        });
        resizePanel();
      };

      var fillProfile = function fillProfile(onsuccess, onerror) {
        sendCrossDomainJSONRequest(mykosmosnimki + "/currentuser.ashx", function (response) {
          if (parseResponse(response) && response.Result) {
            var content = $('.profilePanel-content');
            content.find('.Email').text(response.Result[0].Email);
            content.find('.PasswordState').text(_gtxt('ProfilePlugin.passwordSaved'));
            content.find('.Login').val(response.Result[0].Login);
            content.find('.FullName').val(response.Result[0].FullName);
            content.find('.Phone').val(response.Result[0].Phone);
            content.find('.Company').val(response.Result[0].Company);
            content.find('.CompanyProfile').val(response.Result[0].CompanyProfile);
            content.find('.CompanyPosition').val(response.Result[0].CompanyPosition);
            content.find('.Subscribe').prop('checked', response.Result[0].Subscribe);
            content.find('.IsCompany').prop('checked', response.Result[0].IsCompany);
            fillBillingPage(content, response);
            fillDeveloperPage(content, response);
            onsuccess();
          } else {
            onerror();
          }
        });
      };

      var fillBillingPage = function fillBillingPage(content, response) {
        content.find('.FileStorageUsed').text((response.Result[0].FileStorageUsed / 1000000).toFixed(2) + _gtxt('ProfilePlugin.megabyte'));
        content.find('.FileStorageRemain').text(response.Result[0].FileStorageAvailable == null ? '' : ((response.Result[0].FileStorageAvailable - response.Result[0].FileStorageUsed) / 1000000).toFixed(2) + _gtxt('ProfilePlugin.megabyte'));
        content.find('.VectorLayerStorageUsed').text((response.Result[0].VectorLayerStorageUsed / 1000000).toFixed(2) + _gtxt('ProfilePlugin.megabyte'));
        content.find('.VectorLayerStorageRemain').text(response.Result[0].VectorLayerStorageAvailable == null ? '' : ((response.Result[0].VectorLayerStorageAvailable - response.Result[0].VectorLayerStorageUsed) / 1000000).toFixed(2) + _gtxt('ProfilePlugin.megabyte'));
        content.find('.VectorLayers').text(response.Result[0].VectorLayers);
        content.find('.VectorLayerObjects').text(response.Result[0].VectorLayerObjects);
        content.find('.SmsAvailable').text(response.Result[0].SmsAvailable == null || response.Result[0].SmsAvailable > 0 ? _gtxt('ProfilePlugin.yes') : _gtxt('ProfilePlugin.no'));
        content.find('.SubscriptionUsed').text(response.Result[0].SubscriptionUsed != null ? response.Result[0].SubscriptionUsed : '');
        content.find('.SubscriptionRemain').text(response.Result[0].SubscriptionRemain != null ? response.Result[0].SubscriptionRemain : '');
      };

      var fillDeveloperPage = function fillDeveloperPage(content, response) {
        content.find('.AppName').val(response.Result[0].AppName);
        content.find('.ClientID').text(response.Result[0].ID);
        content.find('.ClientSecret').text(response.Result[0].ClientSecret);
        content.find('.RedirectUri').val(response.Result[0].RedirectUri);
      };

      var resizePanel = function resizePanel() {
        var h = $('#leftMenu').css('height');
        $('.profilePanel, .profilePanel-scrollable, .profilePanel-menu').height(h);
      }; // RegistrationForm


      var showRegistrationForm = function showRegistrationForm(afterRegistration) {
        var registrationForm = $(Handlebars.compile('<table style="width:100%;height:100%;" border="0"><tr><td>\
        <form>\
            <table class="registrationForm" border="0">\
            <tr><td colspan="2" class="header">{{i "ProfilePlugin.registrationPageAnnotation"}}</td></tr>\
			<tr><td colspan="2">\
			<table border="0"><tr>\
			<td>{{i "ProfilePlugin.firstName"}}</td><td align="right"><input type="text" tabindex="1" class="FirstName" id="RegFirstName" name="RegFirstName"/></td>\
			<td class="LastNameLbl">{{i "ProfilePlugin.lastName"}}</td><td align="right"><input type="text" tabindex="1" class="LastName" id="RegLastName" name="RegLastName"/></td>\
			</tr></table>\
			</td></tr>\
            <tr><td colspan="2"><table border="0"><tr><td>{{i "ProfilePlugin.email"}}</td><td align="right"><input type="text" tabindex="1" class="Login EmailEmpty WrongEmail EmailExists" id="RegEmail" name="RegEmail"/></td></tr></table></td></tr>\
            <tr>\
                <td>\
                    <table border="0"><tr><td>{{i "ProfilePlugin.password"}}</td><td align="right"><input tabindex="2" type="password" class="Password NewPassword NotMatch"/></td></tr></table>\
                </td>\
                <td>\
                    <table border="0"><tr><td>{{i "ProfilePlugin.repeat"}}</td><td align="right"><input type="password" tabindex="3" class="Repeat NotMatch"/></td></tr></table>\
                </td>\
            </tr>\
            <tr>\
                <td>\
                    <table border="0"><tr><td>{{i "ProfilePlugin.login"}}</td><td align="right"><input type="text" tabindex="4" class="NickName LoginEmpty LoginFormat LoginExists" id="RegNick" name="RegNick"/></td></tr></table>\
                </td>\
                <td>\
                    <table border="0"><tr><td>{{i "ProfilePlugin.capcha"}}</td><td align="right"><input type="text" tabindex="5" class="Capcha CapchaRequired WrongCapcha"/></td><td align="right">' + '<img src="' + mykosmosnimki + '/Account/Captcha?r=' + Math.round(Math.random() * Math.pow(10, 9)) + '">' + '</td></tr></table>\
            </tr>\
            <tr><td colspan="2" class="submit">\
                <div class="ErrorSummary"></div>\
                <div class="SubmitBlock">\
                <input tabindex="6" type="button" value="{{i "ProfilePlugin.register"}}"/>\
                <img src="img/progress.gif"></div>\
            </td></tr>\
            <tr><td colspan="2">\
            <div class="policy">\
            Нажимая на кнопку, вы соглашаетесь с <a target="blank" href="//my.kosmosnimki.ru/Docs/Политика конфиденциальности.pdf">политикой конфиденциальности</a>\
            и <a target="blank" href="//my.kosmosnimki.ru/Docs/Политика оператора в отношении обработки и защиты персональных данных.pdf">политикой оператора</a> в отношении обработки и защиты персональных данных\
            </td></tr>\
            </table>\
        </form>\
        </td></tr></table>')()),
            confirmScreen = $(Handlebars.compile('<div class="registrationConfirm"><div></div><div><input type="button" value="{{i "ProfilePlugin.close"}}"/></div></div>')()),
            //errorSummaryHeight = 0,
        submit = registrationForm.find('input[type="button"]').click(function () {
          var errorSummary = registrationForm.find('.ErrorSummary'),
              wait = submit.next('img').css('visibility', 'visible');
          registrationForm.find('form').submit();

          _mapHelper.createPermalink(function (id) {
            sendCrossDomainPostRequest(mykosmosnimki + "/Handler/RegistrationExt", {
              WrapStyle: 'message',
              firstName: registrationForm.find('.FirstName').val(),
              lastName: registrationForm.find('.LastName').val(),
              email: registrationForm.find('.Login').val(),
              login: registrationForm.find('.NickName').val(),
              password: registrationForm.find('.Password').val(),
              repeat: registrationForm.find('.Repeat').val(),
              captcha: registrationForm.find('.Capcha').val(),
              permalink: "http://" + window.location.host + window.location.pathname + "?permalink=" + id + (defaultMapID == globalMapName ? "" : "&" + globalMapName)
            }, function (response) {
              registrationForm.find('.Capcha').val("");
              registrationForm.find('input[type="button"]').focus();
              wait.css('visibility', 'hidden');

              if (response.Status.toLowerCase() == 'ok' && response.Result) {
                //afterRegistration();
                regFormDialog.style.height = errorSummaryHeight;
                registrationForm.fadeOut("slow", function () {
                  $(this).replaceWith(confirmScreen); //.fadeIn("slow");
                });
                confirmScreen.children('div').first().text(response.Result.Message);
                confirmScreen.find('input').click(function () {
                  removeDialog(regFormDialog);
                });
              } else {
                registrationForm.find('.error').removeClass('error');
                errorSummary.text('');
                registrationForm.find(':password,:text').filter(function () {
                  return $(this).val() == "";
                }).addClass('error');

                if (response.Result.length > 0 && response.Result[0].Key) {
                  errorSummaryHeight = errorSummary.text(_gtxt('ProfilePlugin.Error' + response.Result[0].Key) + " " + response.Result[0].Value.Errors[0].ErrorMessage).height();
                  registrationForm.find('.' + response.Result[0].Key).addClass('error');
                } else {
                  errorSummaryHeight = errorSummary.text(_gtxt('ProfilePlugin.Error' + response.Result.Message)).height();
                  registrationForm.find('.' + response.Result.Message).addClass('error');
                }

                errorSummary.slideDown();
                registrationForm.find('img').first().attr("src", mykosmosnimki + '/Account/Captcha/sort?r=' + Math.round(Math.random() * Math.pow(10, 9)));
              }
            });
          });
        });
        registrationForm.find('form').submit(function (e) {
          e.preventDefault();
        });
        var regFormDialog = window.showDialog(_gtxt('ProfilePlugin.registration'), registrationForm[0], 560, 272),
            dialogFrame = $(regFormDialog).dialog('option', 'resizable', false);
        regFormDialog.style.overflow = 'hidden';
        errorSummaryHeight = regFormDialog.style.height;
        regFormDialog.style.height = '';

        var clearError = function clearError() {
          registrationForm.find('.error').removeClass('error');
          registrationForm.find('.ErrorSummary').text('').slideUp();
        };

        registrationForm.find('input[type="text"], input[type="password"]').keydown(function (e) {
          if (e.which == 13) submit.click();
        }).focusin(clearError);
        return regFormDialog;
      };

      gmxCore.addModule('ProfilePlugin', {
        pluginName: 'ProfilePlugin',
        showProfile: showProfile,
        showRegistrationForm: showRegistrationForm,
        afterViewer: function afterViewer() {
          checkExist = setInterval(function () {
            if (nsGmx.widgets.authWidget && nsGmx.widgets.authWidget.getUserInfo() != null) {
              if (nsGmx.widgets.authWidget.getUserInfo().Login != null) {
                var a = $('a:contains("' + nsGmx.Translations.getText('auth.myAccount') + '")');
                a.attr({
                  'class': 'dropdownMenuWidget-dropdownItemAnchor'
                });
                a.siblings('div').remove();
                a.attr('href', 'javascript:void(0)');
                a.removeAttr('target');
                a.click(function (event) {
                  showProfile();
                  event.stopPropagation();
                });
              } else {
                var showLoginDialog = nsGmx.widgets.authWidget._authManager.login,
                    regForm;

                nsGmx.widgets.authWidget._authManager.login = function () {
                  if (regForm && $(regForm).is(':visible')) {
                    removeDialog(regForm);
                    regForm = false;
                  }

                  showLoginDialog();
                  var regLink = $(':ui-dialog .registration');
                  regLink.off("click").click(function () {
                    regLink.parents(':ui-dialog').dialog("close");
                    regForm = showRegistrationForm(function () {
                      window.location.reload();
                    });
                  });
                };
              }

              clearInterval(checkExist);
            }
          }, 100);
        }
      }, {
        // css: 'ProfilePlugin.css',
        init: function init(module, path) {
          initTranslations();
        }
      });
    })(jQuery);

    _translationsHash.addtext('rus', {
      LayerRCControl: {
        minZoom: 'Мин. зум',
        titleTemplate: 'Шаблон имени',
        pathTemplate: 'Шаблон тайлов',
        advancedLink: 'Дополнительно',
        layerTagTitle: 'Параметр слоя',
        attributeTitle: 'Атрибут объекта'
      }
    });

    _translationsHash.addtext('eng', {
      LayerRCControl: {
        minZoom: 'Min zoom',
        titleTemplate: 'Title template',
        pathTemplate: 'Path template',
        advancedLink: 'Advanced',
        layerTagTitle: 'Layer parameter',
        attributeTitle: 'Object Attribute'
      }
    });

    nsGmx$1.LayerRCProperties = Backbone.Model.extend({
      defaults: {
        IsRasterCatalog: false,
        RCMinZoomForRasters: 0,
        RCMaskForRasterTitle: '',
        RCMaskForRasterPath: '',
        ColumnTagLinks: {}
      },
      isAnyLinks: function isAnyLinks() {
        return window._.size(this.attributes.ColumnTagLinks) > 0;
      }
    });
    /**
    Контрол для задания параметров каталогов растров
    @memberOf nsGmx
    @class
    */

    nsGmx$1.LayerRasterCatalogWidget = function (container, rcProperties) {
      var advancedMode = !!(rcProperties.get('RCMaskForRasterPath') || rcProperties.get('RCMaskForRasterTitle') || rcProperties.isAnyLinks());

      var updateVisibility = function updateVisibility() {
        // var isRasterCatalog = rcProperties.get('IsRasterCatalog');
        $('.RCCreate-advanced', container).toggle(advancedMode);
        $('.RCCreate-advanced-link', container).toggle(!advancedMode);
        $('.RCCreate-tagContainer', container).toggle(advancedMode);
      };

      rcProperties.on('change:IsRasterCatalog', updateVisibility);
      var RCCheckbox = $('<input/>', {
        type: 'checkbox',
        'class': 'RCCreate-checkbox'
      }).change(function () {
        rcProperties.set('IsRasterCatalog', RCCheckbox[0].checked);
      });
      var advancedParamsLink = $(makeLinkButton$1(_gtxt('LayerRCControl.advancedLink'))).addClass('RCCreate-advanced-link').click(function () {
        advancedMode = !advancedMode;
        updateVisibility();
      });
      RCCheckbox[0].checked = rcProperties.get('IsRasterCatalog');
      var minZoomInput = $('<input/>', {
        'class': 'inputStyle RCCreate-zoom-input'
      }).val(rcProperties.get('RCMinZoomForRasters') || '').bind('keyup change', function () {
        rcProperties.set('RCMinZoomForRasters', parseInt(this.value));
      });
      var titleInput = $('<input/>', {
        'class': 'inputStyle'
      }).val(rcProperties.get('RCMaskForRasterTitle') || '').bind('keyup change', function () {
        rcProperties.set('RCMaskForRasterTitle', this.value);
      });
      var pathInput = $('<input/>', {
        'class': 'inputStyle'
      }).val(rcProperties.get('RCMaskForRasterPath') || '').bind('keyup change', function () {
        rcProperties.set('RCMaskForRasterPath', this.value);
      }); // var RCParamsTable =

      $('<table/>', {
        'class': 'RCCreate-params'
      }).append($('<tr/>').append($('<td/>').text(_gtxt('LayerRCControl.minZoom')).css('padding-right', '6px')).append($('<td/>').append(minZoomInput))).append($('<tr/>', {
        'class': 'RCCreate-advanced'
      }).append($('<td/>').text(_gtxt('LayerRCControl.titleTemplate'))).append($('<td/>').append(titleInput))).append($('<tr/>', {
        'class': 'RCCreate-advanced'
      }).append($('<td/>').text(_gtxt('LayerRCControl.pathTemplate'))).append($('<td/>').append(pathInput))).appendTo(container);
      nsGmx$1.TagMetaInfo.loadFromServer(function (realTagInfo) {
        var realTagsInfo = realTagInfo.getTagArrayExt();
        var fakeTagsInfo = {};

        for (var iT = 0; iT < realTagsInfo.length; iT++) {
          var info = realTagsInfo[iT];
          fakeTagsInfo[info.name] = {
            Type: 'String',
            Description: info.descr
          };
        }

        var fakeTagManager = new nsGmx$1.TagMetaInfo(fakeTagsInfo);
        var initTags = {};
        var columnTagLinks = rcProperties.get('ColumnTagLinks');

        for (var iP in columnTagLinks) {
          initTags[columnTagLinks[iP]] = {
            Value: iP
          };
        }

        var layerTags = new nsGmx$1.LayerTagsWithInfo(fakeTagManager, initTags);
        var tagContainer = $('<div/>', {
          'class': 'RCCreate-tagContainer RCCreate-advanced'
        }).addClass().appendTo(container);
        var tagsControl = new nsGmx$1.LayerTagSearchControl(layerTags, tagContainer, {
          inputWidth: 100,
          tagHeader: _gtxt('LayerRCControl.layerTagTitle'),
          valueHeader: _gtxt('LayerRCControl.attributeTitle')
        });
        $(layerTags).change(function () {
          var columnTagLinks = {};
          layerTags.eachValid(function (id, tag, value) {
            columnTagLinks[value] = tag;
          });
          rcProperties.set('ColumnTagLinks', columnTagLinks);
        });
        advancedParamsLink.appendTo(container);
        updateVisibility();
      });
    };

    /** Параметры мультивременного слоя, связанные со временем
      @class
      @extends Backbone.Model
      @prop {number} [minPeriod=1] Минимальный период создания тайлов
      @prop {number} [maxPeriod=1] Максимальный период создания тайлов
      @prop {number} [columnName=null]  Название мультивременной колонки
      @prop {number} [isTemporal=false] Является ли слой мультивременным
    */

    nsGmx$1.TemporalLayerParams = Backbone.Model.extend(
    /** @lends nsGmx.TemporalLayerParams.prototype */
    {
      defaults: {
        isTemporal: false,
        maxShowPeriod: 0,
        minPeriod: 1,
        maxPeriod: 256,
        columnName: null
      },

      /** Возвращает строчку с перечислением временнЫх периодов (для передачи серверу) */
      getPeriodString: function getPeriodString() {
        var periods = [1, 16, 256],
            minPeriod = Number(this.attributes.minPeriod),
            maxPeriod = Number(this.attributes.maxPeriod);
        minPeriod = minPeriod > 1 && minPeriod < 16 ? 16 : minPeriod;
        minPeriod = minPeriod > 16 && minPeriod < 256 ? 256 : minPeriod;
        maxPeriod = maxPeriod > 1 && maxPeriod < 16 ? 16 : maxPeriod;
        maxPeriod = maxPeriod > 16 && maxPeriod < 256 ? 256 : maxPeriod;
        return periods.splice(periods.indexOf(minPeriod), periods.indexOf(maxPeriod) + 1).join(',');
      }
    }, {
      PERIOD_STEP: 4
    });

    /** Связанные с квиклуками параметры векторных слоёв. Умеет сериализовать/десериализовать себя в строку для хранения на сервере.
     * @class
     * @memberOf nsGmx
     * @extends Backbone.Model
     * @property {String} template Шаблон URL квиклука
     * @property {Number} minZoom Минимальный зум показа квиклуков
     * @property {Number} X1-X4,Y1-Y4 Названия полей слоя, в которых хранятся координаты привязки 4 углов изображения. Если не указаны, будут использованы значения по умолчанию (поля "X1"-"X4", "Y1"-"Y4" или их аналоги в нижнем регистре)
     */

    nsGmx$1.QuicklookParams = Backbone.Model.extend({
      /** Загружает параметры из строки с сервера.
       * @param {String} quicklookString Строка с параметрами с сервера
       */
      fromServerString: function fromServerString(quicklookString) {
        if (quicklookString) {
          //раньше это была просто строка с шаблоном квиклука, а теперь стало JSON'ом
          if (quicklookString[0] === '{') {
            var p = JSON.parse(quicklookString);
            this.set({
              template: p.template,
              minZoom: p.minZoom || 8,
              X1: p.X1,
              Y1: p.Y1,
              X2: p.X2,
              Y2: p.Y2,
              X3: p.X3,
              Y3: p.Y3,
              X4: p.X4,
              Y4: p.Y4
            });
          } else {
            this.set({
              template: quicklookString,
              minZoom: 8
            });
          }
        } else {
          this.set({
            minZoom: 8
          });
        }
      },

      /** Сохраняет все параметры в строку, которую можно передать серверу.
       * @return {String}
       */
      toServerString: function toServerString() {
        //$.extend чтобы удалить undefined поля
        return this.attributes.template ? JSON.stringify($.extend({}, this.attributes)) : '';
      }
    });

    /** Объект, описывающий один атрибут слоя. Формат для передачи на сервер
     * @typedef {Object} nsGmx.LayerProperties.Column
     * @property {String} Name Имя атрибута
     * @property {String} OldName Исходное имя атрибута. Используется для переименования атрибутов. Для новых атрибутов это поле должно отсутствовать.
     * @property {String}  ColumnSimpleType Тип атрибута
     * @property {Boolean} IsPrimary
     * @property {Boolean} IsIdentity
     * @property {Boolean} IsComputed
    */

    var LatLngColumnsModel = Backbone.Model.extend({
      defaults: {
        XCol: null,
        YCol: null
      }
    });
    /** Расширенный набор свойства слоя. Используется для редактирования свойств. Умеет сохранять себя на сервере
     * @class
     * @memberOf nsGmx
     * @extends Backbone.Model
     * @property {String} Type Тип слоя. Vector/Raster/MultiLayer/Virtual
     * @property {Number} LayerID Серверный ID слоя
     * @property {String} Name Уникальный неитерируемый ID слоя
     * @property {String} Title Заголовок слоя
     * @property {String} Copyright Копирайт слоя
     * @property {String} Description Описание слоя
     * @property {Object} MetaProperties Метаданные слоя
     * @property {Object} ShapePath Имеет атрибут Path. Для векторных слоёв из файла - источник слоя. Для растровых - файл с границей растра
     * @property {Object} Geometry Граница растрового слоя

     * @property {String} Legend Легенда слоя. Только для растровых слоёв

     * @property {String} NameObject Шаблон названий объектов. Только для векторных слоёв
     * @property {String} GeometryType Тип геометрии слоя. Только для векторных слоёв (point/linestring/polygon)
     * @property {nsGmx.QuicklookParams} Quicklook Параметры квиклуков. Только для векторных слоёв
     * @property {Object} TilePath Имеет атрибут Path. Путь к файлу с тайлами. Только для векторных слоёв
     * @property {String} EncodeSource Кодировка источника данных слоя. Только для векторных слоёв
     * @property {nsGmx.LayerProperties.Column[]} Columns Описание типов и названий атрибутов слоя. Только для векторных слоёв
     * @property {String} TableName Название таблицы, если источник был таблицей. Только для векторных слоёв
     * @property {String} TableCS Система координат выбранной таблицы ("EPSG:4326"/"EPSG:3395"). Только для векторных слоёв
     * @property {String} SourceType Тип источника данных для слоя (file/table/manual/sql)
     * @property {String[]} Attributes Список имён атрибутов векторного слоя (не сохраняется)
     * @property {String[]} AttrTypes Список типов атрибутов векторного слоя (не сохраняется)
     * @property {nsGmx.LayerRCProperties} RC Параметры каталога растров. Только для векторных слоёв
     * @property {nsGmx.TemporalLayerParams} Temporal Параметры мультивременного слоя. Только для векторных слоёв
     * @property {LatLngColumnsModel} GeometryColumnsLatLng Описание выбранных в таблице колонок с геометрией
     * @property {String} ZIndexField Название поля для сортировки объектов внутри векторного слоя
    */

    var LayerProperties = Backbone.Model.extend(
    /** @lends nsGmx.LayerProperties.prototype */
    {
      initialize: function initialize(attrs) {
        this.attributes = _.clone(attrs || {});
      },
      initFromViewer: function initFromViewer(type, divProperties, layerProperties) {
        this.set({
          Type: type || divProperties && divProperties.type || layerProperties && layerProperties.type,
          Title: divProperties ? divProperties.title || '' : layerProperties.Title || '',
          Copyright: divProperties ? divProperties.Copyright || '' : layerProperties.Copyright || '',
          Legend: divProperties ? divProperties.Legend || '' : layerProperties.Legend || '',
          Description: divProperties ? divProperties.description || '' : layerProperties.Description || '',
          NameObject: divProperties ? divProperties.NameObject || '' : layerProperties.NameObject || '',
          GeometryType: divProperties ? divProperties.GeometryType : layerProperties.GeometryType,
          LayerID: divProperties ? divProperties.LayerID : layerProperties.LayerID,
          ZIndexField: divProperties ? divProperties.ZIndexField : layerProperties.ZIndexField,
          ContentID: divProperties ? divProperties.ContentID : layerProperties.ContentID,
          ShapePath: layerProperties.ShapePath || {},
          TilePath: layerProperties.TilePath || {},
          Name: layerProperties.name,
          EncodeSource: layerProperties.EncodeSource,
          Columns: layerProperties.Columns,
          TableName: layerProperties.TableName,
          TableCS: layerProperties.TableCS,
          SourceType: layerProperties.SourceType || 'file',
          Geometry: layerProperties.Geometry,
          Attributes: divProperties ? divProperties.attributes : [],
          AttrTypes: divProperties ? divProperties.attrTypes : []
        });
        var metaProperties = layerProperties.MetaProperties;
        var convertedTagValues = {};

        for (var mp in metaProperties) {
          var tagtype = metaProperties[mp].Type;
          convertedTagValues[mp] = {
            Type: tagtype,
            Value: nsGmx$1.Utils.convertFromServer(tagtype, metaProperties[mp].Value)
          };
        }

        this.set('MetaProperties', new nsGmx$1.LayerTags(convertedTagValues));
        this.set('RC', new nsGmx$1.LayerRCProperties({
          IsRasterCatalog: layerProperties.IsRasterCatalog,
          RCMinZoomForRasters: layerProperties.RCMinZoomForRasters,
          RCMaskForRasterTitle: layerProperties.RCMaskForRasterTitle,
          RCMaskForRasterPath: layerProperties.RCMaskForRasterPath,
          ColumnTagLinks: layerProperties.ColumnTagLinks
        }));
        divProperties = divProperties || {};
        var tempPeriods = divProperties.TemporalPeriods;
        this.set('Temporal', new nsGmx$1.TemporalLayerParams({
          isTemporal: !!divProperties.Temporal,
          minPeriod: tempPeriods && tempPeriods[0],
          maxPeriod: tempPeriods && tempPeriods[tempPeriods.length - 1],
          maxShownPeriod: divProperties.maxShownPeriod || 0,
          columnName: divProperties.TemporalColumnName
        }));
        this.set('GeometryColumnsLatLng', new LatLngColumnsModel({
          XCol: layerProperties.GeometryXCol,
          YCol: layerProperties.GeometryYCol
        }));

        if (layerProperties.Name) {
          this.set("Name", layerProperties.Name);
        }

        var quicklookString = divProperties.Quicklook || layerProperties.Quicklook,
            quicklookParams = new nsGmx$1.QuicklookParams();
        quicklookParams.fromServerString(quicklookString);
        this.set('Quicklook', quicklookParams);
      },

      /** Инициализирует класс, используя информацию о слое с сервера.
       * @param {String} layerName ID слоя, информацию о котором нужно получить
       * @return {jQuery.Deferred} Deferred, который будет заполнен после инициализации класса
       */
      initFromServer: function initFromServer(layerName) {
        var def = $.Deferred(),
            _this = this;

        sendCrossDomainJSONRequest$2(window.serverBase + "Layer/GetLayerInfo.ashx?NeedAttrValues=false&LayerName=" + encodeURIComponent(layerName), function (response) {
          if (!window.parseResponse(response)) {
            def.reject(response);
            return;
          }

          _this.initFromViewer(null, null, response.Result);

          def.resolve();
        });
        return def.promise();
      },

      /** Сохраняет изменения в слое или создаёт новый слой на сервере
       * @param {Boolean} geometryChanged Нужно ли передавать на сервер геометрию растрового слоя
       * @param {Function} [callback] Будет вызван после получения ответа от сервера
       * @return {jQuery.Deferred} Deferred, который будет заполнен после сохранения всей информации на сервере
       */
      save: function save(geometryChanged, callback, params) {
        var attrs = this.attributes,
            name = attrs.Name,
            stype = attrs.SourceType,
            def;
        var reqParams = {
          WrapStyle: "window",
          Title: attrs.Title,
          Description: attrs.Description,
          Copyright: attrs.Copyright
        };

        if (attrs.MetaProperties) {
          var metaProperties = {};
          attrs.MetaProperties.eachValid(function (id, tag, value, type) {
            //для неизвестных тегов присваиваем тип String
            var type = type || 'String';
            var value = nsGmx$1.Utils.convertToServer(type, value);

            if (value !== null) {
              metaProperties[tag] = {
                Value: value,
                Type: type
              };
            }
          }, true);
          reqParams.MetaProperties = JSON.stringify(metaProperties);
        }

        if (attrs.Type === 'Vector') {
          if (attrs.EncodeSource) reqParams.EncodeSource = attrs.EncodeSource;
          reqParams.NameObject = attrs.NameObject || '';
          reqParams.srs = nsGmx$1.leafletMap.options.srs || '';
          if (stype === 'table') reqParams.TableCS = attrs.TableCS;
          var rcProps = attrs.RC;
          reqParams.IsRasterCatalog = !!(rcProps && rcProps.get('IsRasterCatalog'));

          if (reqParams.IsRasterCatalog) {
            reqParams.RCMinZoomForRasters = rcProps.get('RCMinZoomForRasters');
            reqParams.RCMaskForRasterPath = rcProps.get('RCMaskForRasterPath');
            reqParams.RCMaskForRasterTitle = rcProps.get('RCMaskForRasterTitle');
            reqParams.ColumnTagLinks = JSON.stringify(rcProps.get('ColumnTagLinks'));
          }

          var tempProperties = attrs.Temporal;
          reqParams.TemporalLayer = !!(tempProperties && tempProperties.get('isTemporal') && tempProperties.get('columnName'));

          if (reqParams.TemporalLayer) {
            reqParams.TemporalColumnName = tempProperties.get('columnName');
            reqParams.TemporalPeriods = tempProperties.getPeriodString();
            reqParams.maxShownPeriod = tempProperties.get('maxShownPeriod');
          }
          /* отсылать на сервер колонки нужно только если это:
           * - уже созданный слой или тип слоя "Вручную",
           * - копия слоя
          */


          if (attrs.Columns && (name || stype === 'manual') || params && params.copy) {
            reqParams.Columns = JSON.stringify(attrs.Columns);
          }

          if (attrs.LayerID) reqParams.VectorLayerID = attrs.LayerID;

          if (attrs.Quicklook) {
            reqParams.Quicklook = attrs.Quicklook.toServerString();
            /*JSON.stringify({
                minZoom: attrs.MinZoomQuicklooks,
                template: attrs.Quicklook
            });*/
          } else {
            attrs.Quicklook = '';
          }

          reqParams.ZIndexField = attrs.ZIndexField || '';

          if (!name && stype === 'manual' && !(params && params.copy)) {
            reqParams.UserBorder = attrs.UserBorder ? JSON.stringify(attrs.UserBorder) : null;
            reqParams.geometrytype = attrs.GeometryType;
            def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/CreateVectorLayer.ashx", reqParams);
          } else if (!name && params && params.copy) {
            var copyParams = {},
                columnsList = [{
              Value: "[geomixergeojson]",
              Alias: "gmx_geometry"
            }],
                sqlString = params.buffer ? 'select Buffer([gmx_geometry], ' + (params.bufferSize || 0) + ') as gmx_geometry' : 'select [geomixergeojson] as gmx_geometry';

            for (var i = 0; i < attrs.Columns.length; i++) {
              var col = attrs.Columns[i];

              if (col.Name !== 'gmx_geometry') {
                columnsList.push({
                  Value: col.Name,
                  Alias: col.Name
                });
                var exp = col.expression || '"' + col.Name + '"';
                sqlString += ', ' + exp + ' as "' + col.Name + '"';
              }
            }

            sqlString += ' from [' + params.sourceLayerName + ']';

            if (params.query) {
              sqlString += ' WHERE ' + params.query;
            }

            copyParams.WrapStyle = "message";
            copyParams.Title = attrs.Title;
            copyParams.SourceType = attrs.SourceType;
            copyParams.Sql = sqlString;
            copyParams.srs = nsGmx$1.leafletMap.options.srs || '';
            def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/Insert.ashx", copyParams);
          } else {
            //Если нет колонки с геометрией, то нужно передавать выбранные пользователем колонки
            var parsedColumns = nsGmx$1.LayerProperties.parseColumns(attrs.Columns);
            var geomColumns = attrs.GeometryColumnsLatLng;

            if (parsedColumns.geomCount === 0 && geomColumns && geomColumns.get('XCol') && geomColumns.get('YCol')) {
              reqParams.ColX = geomColumns.get('XCol');
              reqParams.ColY = geomColumns.get('YCol');
            }

            if (stype !== 'manual') {
              reqParams.GeometryDataSource = stype === 'file' ? attrs.ShapePath.Path : attrs.TableName;
            }

            def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/" + (name ? "Update.ashx" : "Insert.ashx"), reqParams);
          }
        } else if (attrs.Type === 'Raster') {
          var curBorder = _mapHelper.drawingBorders.get(name);

          reqParams.Legend = attrs.Legend;
          reqParams.srs = nsGmx$1.leafletMap.options.srs || '';
          if (attrs.TilePath.Path) reqParams.TilePath = attrs.TilePath.Path;
          reqParams.GeometryChanged = geometryChanged;

          if (geometryChanged) {
            if (typeof curBorder === 'undefined') {
              if (attrs.ShapePath.Path) {
                reqParams.BorderFile = attrs.ShapePath.Path;
              } else if (typeof attrs.Geometry !== 'undefined') {
                //может быть как null (удалили), так и undefined (не поменялась)
                reqParams.BorderGeometry = JSON.stringify(attrs.Geometry);
              }
            } else {
              reqParams.BorderGeometry = JSON.stringify(L.gmxUtil.geoJSONtoGeometry(curBorder.toGeoJSON(), true));
            }
          }

          if (attrs.LayerID) reqParams.RasterLayerID = attrs.LayerID;
          def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "RasterLayer/" + (name ? "Update.ashx" : "Insert.ashx"), reqParams);
        } else if (attrs.Type === 'MultiLayer') {
          var multiLayerInfo = {
            LayersChanged: false,
            //изменение состава слоёв пока не поддерживается
            Properties: {
              Title: attrs.Title,
              Description: attrs.Description
            }
          };

          if ('MetaProperties' in reqParams) {
            multiLayerInfo.Properties.MetaProperties = JSON.parse(reqParams.MetaProperties);
          }

          if (attrs.LayerID) {
            multiLayerInfo.Properties.MultiLayerID = attrs.LayerID;
          }

          var multiReqParams = {
            WrapStyle: "window",
            MultiLayerInfo: JSON.stringify(multiLayerInfo)
          };
          def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "MultiLayer/" + (name ? "Update.ashx" : "Insert.ashx"), multiReqParams);
        } else if (attrs.Type === 'Virtual') {
          if (name) {
            reqParams.VectorLayerID = name;
          } else {
            reqParams.SourceType = 'Virtual';
          }

          if (attrs.ContentID) {
            reqParams.ContentID = attrs.ContentID;
          }

          reqParams.Legend = attrs.Legend || '';
          def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(window.serverBase + "VectorLayer/" + (name ? "Update.ashx" : "Insert.ashx"), reqParams);
        }

        callback && def.done(callback);
        return def.promise();
      }
    });

    LayerProperties.parseColumns = function (columns) {
      var geomCount = 0; //кол-во колонок с типом Геометрия

      var coordColumns = []; //колонки, которые могут быть использованы для выбора координат

      var dateColumns = []; //колонки, которые могут быть использованы для выбора временнОго параметра

      columns = columns || [];

      for (var f = 0; f < columns.length; f++) {
        var type = columns[f].ColumnSimpleType.toLowerCase();
        if (type === 'geometry') geomCount++;
        if ((type === 'string' || type === 'integer' || type === 'float') && !columns[f].IsIdentity && !columns[f].IsPrimary) coordColumns.push(columns[f].Name);
        if (type === 'date' || type === 'datetime') dateColumns.push(columns[f].Name);
      }

      return {
        geomCount: geomCount,
        coordColumns: coordColumns,
        dateColumns: dateColumns
      };
    };

    nsGmx$1.LayerProperties = LayerProperties;
    nsGmx$1.LatLngColumnsModel = LatLngColumnsModel;
    window.gmxCore.addModule('LayerProperties', {
      LayerProperties: LayerProperties,
      LatLngColumnsModel: LatLngColumnsModel
    });

    nsGmx$1.ShpEncodingWidget = function () {
      var _encodings = {
        'windows-1251': 'windows-1251',
        'utf-8': 'utf-8',
        'koi8-r': 'koi8-r',
        'utf-7': 'utf-7',
        'iso-8859-5': 'iso-8859-5',
        'koi8-u': 'koi8-u',
        'cp866': 'cp866'
      };
      var _DEFAULT_ENCODING = 'windows-1251';
      var _curEncoding = _DEFAULT_ENCODING;

      var _this = this;

      this.drawWidget = function (container, initialEncoding) {
        initialEncoding = initialEncoding || _DEFAULT_ENCODING;
        var select = $("<select></select>").addClass('selectStyle VectorLayerEncodingInput');
        select.change(function () {
          _curEncoding = $('option:selected', select).val();
          $(_this).change();
        });
        var isStandard = false;

        for (var enc in _encodings) {
          var opt = $('<option></option>').val(enc).text(enc);

          if (_encodings[enc] === initialEncoding) {
            opt.attr('selected', 'selected');
            _curEncoding = enc;
            isStandard = true;
          }

          select.append(opt);
        }

        var anotherCheckbox = $("<input></input>", {
          'class': 'box',
          type: 'checkbox',
          id: 'otherEncoding'
        });
        var anotherInput = $("<input></input>", {
          'class': 'VectorLayerEncodingInput'
        });

        if (!isStandard) {
          anotherCheckbox[0].checked = 'checked';
          anotherInput.val(initialEncoding);
          select.attr('disabled', 'disabled');
        } else {
          anotherInput.attr('disabled', 'disabled');
        }

        anotherInput.bind('keyup', function () {
          _curEncoding = this.value;
          $(_this).change();
        });
        anotherCheckbox.click(function () {
          if (this.checked) {
            select.attr('disabled', 'disabled');
            anotherInput.removeAttr('disabled');
            anotherInput.focus();
            _curEncoding = anotherInput.val();
          } else {
            select.removeAttr('disabled');
            anotherInput.attr('disabled', 'disabled');
            _curEncoding = $('option:selected', select).val();
          }

          $(_this).change();
        });
        var tr1 = $("<tr></tr>").append($("<td></td>").text(_gtxt("Кодировка"))).append($("<td></td>").append(select));
        var tr2 = $("<tr></tr>").append($("<td></td>").append(anotherCheckbox).append($("<label></label>", {
          'for': 'otherEncoding'
        }).text(_gtxt("Другая")))).append($("<td></td>").append(anotherInput));
        $(container).append($("<table></table>", {
          'class': 'VectorLayerEncoding'
        }).append(tr1).append(tr2));
      };

      this.getServerEncoding = function () {
        return _curEncoding;
      };
    };

    (function () {
      Handlebars.registerPartial('TemporalLayerWidgetOptions', '{{#periods}}<option name="{{.}}">{{.}}</option>{{/periods}}');

      _translationsHash.addtext('rus', {
        'Макс. период на экране': 'На экране не более',
        'Тайлы с': 'Тайлы с',
        'Тайлы по дням до': 'Тайлы по дням до',
        'дней': 'дней'
      });

      _translationsHash.addtext('eng', {
        'Макс. период на экране': 'Max period to show',
        'Тайлы с': 'Tiles from',
        'Тайлы по дням до': 'Max tiling period',
        'дней': 'days'
      });
      /** Создаёт виджет для задания мультивременных параметров слоя
      * @class
      * @param {HTMLNode} parentDiv контейнер для размещения виджета
      * @param {nsGmx.TemporalLayerParams} paramsModel начальные параметры
      * @param {String[]} columns массив имён колонок, из которых можно выбрать врменнУю
      */


      nsGmx$1.TemporalLayerParamsWidget = function (parentDiv, paramsModel, columns) {
        var PERIODS = [1, 16, 256]; // var optionsHtml = '{{#periods}}<option name="{{.}}">{{.}}</option>{{/periods}}';

        var template = Handlebars.compile('<table><tbody>' + '<tr>' + '<td>{{i "Макс. период на экране"}}</td>' + '<td><input id="maxShownPeriod" class="inputStyle temporal-maxshow"></input> <span>{{i "дней"}}</span> </td>' + '</tr>' + '<tr class="temporal-columns">' + '<td>{{i "Колонка даты"}}</td>' + '<td><select id="columnSelect" class="selectStyle"></select></td>' + '</tr>' + // '<tr class="temporal-advanced">' +
        //     '<td>{{i "Тайлы с"}}</td>' +
        //     '<td><select id="minPeriod" class="selectStyle">{{>TemporalLayerWidgetOptions}}</select></td>' +
        // '</tr>' +
        '<tr class="temporal-advanced">' + '<td>{{i "Тайлы по дням до"}}</td>' + '<td><select id="maxPeriod" class="selectStyle">{{>TemporalLayerWidgetOptions}}</select></td>' + '</tr>' + '</tbody></table>' + '<span class="buttonLink RCCreate-advanced-link">{{i "LayerRCControl.advancedLink"}}</span>');
        $(parentDiv).html(template({
          periods: PERIODS
        }));
        var _columns = columns;
        var isAdvancedMode = paramsModel.get('minPeriod') !== paramsModel.defaults.minPeriod || paramsModel.get('maxPeriod') !== paramsModel.defaults.maxPeriod;
        var wasInAdvancedMode = isAdvancedMode;

        var updateVisibility = function updateVisibility() {
          // var isTemporal = paramsModel.get('isTemporal');
          $('.temporal-advanced', parentDiv).toggle(isAdvancedMode);
          $('.RCCreate-advanced-link', parentDiv).toggle(!isAdvancedMode);
          $('.temporal-columns', parentDiv).toggle(_columns.length > 1);
        };

        var updateColumnsSelect = function updateColumnsSelect() {
          var selectDateColumn = $('#columnSelect', parentDiv);
          var curColumn = paramsModel.get('columnName');
          var foundOption = null;
          selectDateColumn.empty();

          for (var i = 0; i < _columns.length; i++) {
            var option = $('<option></option>').text(_columns[i]);
            selectDateColumn.append(option);

            if (curColumn === _columns[i]) {
              foundOption = option;
            }
          }

          if (foundOption) {
            foundOption.attr('selected', 'selected');
          } else if (_columns.length) {
            paramsModel.set('columnName', _columns[0]);
          }
        };

        updateVisibility();
        $('.RCCreate-advanced-link', parentDiv).click(function () {
          isAdvancedMode = !isAdvancedMode;
          wasInAdvancedMode = true;
          updateVisibility();
        });
        paramsModel.on('change:isTemporal', updateVisibility);
        updateColumnsSelect();
        $('#columnSelect', parentDiv).change(function () {
          paramsModel.set('columnName', $('option:selected', this).val());
        });
        $('#minPeriod>option[name=' + paramsModel.get('minPeriod') + ']', parentDiv).attr('selected', 'selected');
        $('#minPeriod', parentDiv).change(function () {
          paramsModel.set('minPeriod', $('option:selected', this).val());
        });
        $('#maxPeriod>option[name=' + paramsModel.get('maxPeriod') + ']', parentDiv).attr('selected', 'selected');
        $('#maxPeriod', parentDiv).change(function () {
          paramsModel.set('maxPeriod', $('option:selected', this).val());
        });
        $('#maxShownPeriod', parentDiv).val(paramsModel.get('maxShownPeriod') || '').bind('keyup', function () {
          var val = parseInt(this.value) || 0;
          var paramsToSet = {
            maxShownPeriod: Math.max(0, val)
          };

          if (!wasInAdvancedMode) {
            if (val > 0) {
              var index = Math.ceil(Math.log(val) / Math.log(4));
              paramsToSet.maxPeriod = PERIODS[Math.min(PERIODS.length - 1, index)];
            } else {
              paramsToSet.maxPeriod = paramsModel.defaults.maxPeriod;
            }

            $('#maxPeriod>option[name=' + paramsToSet.maxPeriod + ']', parentDiv).attr('selected', 'selected');
          }

          paramsModel.set(paramsToSet);
        });
        /**
            Обновляет список доступных для выбора колонок даты
            @param {String[]} columns массив имён колонок
        */

        this.updateColumns = function (columns) {
          _columns = columns;
          updateColumnsSelect();
          updateVisibility();
        };
      };
    })();

    var _$6 = nsGmx$1.Utils._;

    nsGmx$1.SuggestWidget = function (attrNames, textarea, textTemplate, func, valuesArr, addValueFlag, attrType) {
      var _this = this;

      this.textArea = textarea;
      this.func = func;
      this.currentTextArea = textarea[0] || textarea;

      if (valuesArr && !(valuesArr instanceof nsGmx$1.ILazyAttributeValuesProvider)) {
        valuesArr = new nsGmx$1.LazyAttributeValuesProviderFromArray(valuesArr);
      }

      var canvas = this.el = nsGmx$1.Utils._div(null, [['dir', 'className', 'suggest-helper']]);

      canvas.style.display = 'none';

      canvas.onmouseout = function (e) {
        var evt = e || window.event,
            target = evt.srcElement || evt.target,
            relTarget = evt.relatedTarget || evt.toElement;

        if (canvas.getAttribute('arr')) {
          try {
            while (relTarget && !$(relTarget).hasClass('suggest-helper-elem-group')) {
              if (relTarget === canvas) {
                return;
              }

              relTarget = relTarget.parentNode;
            }

            $(canvas).fadeOut(100, function () {
              $(this).remove();
            });
          } catch (ev) {
            if (target === canvas) {
              $(canvas).fadeOut(100, function () {
                $(this).remove();
              });
            }
          }
        }
      };

      attrNames.forEach(function (name) {
        var className;

        if (attrType === 'functions') {
          className = 'suggest-helper-elem suggest-helper-elem-custom-tooltip';
        } else {
          className = 'suggest-helper-elem';
        }

        if (_typeof(name) === 'object') {
          name = name.groupTag;

          var div = nsGmx$1.Utils._div([nsGmx$1.Utils._t(String(name))], [['dir', 'className', className], ['dir', 'className', 'suggest-helper-elem-group']]);

          $(div).css('margin-top', '3px');
          $(canvas).append(div);
        } else {
          var _div = nsGmx$1.Utils._div([nsGmx$1.Utils._t(String(name))], [['dir', 'className', className]]);

          var hasCustomTooltip = $(_div).hasClass('suggest-helper-elem-custom-tooltip');

          if (hasCustomTooltip) {
            var titleObj = nsGmx$1.sqlTemplates[name],
                isRus = window.language === 'rus',
                description = isRus ? titleObj.descRus : titleObj.descEng,
                title = titleObj["interface"] + ' - \n' + description;

            _title$1(_div, title);
          } else {
            _title$1(_div, name);
          }

          _div.onmouseover = function () {
            var _curDiv = this,
                attrType;

            $(this.parentNode).children('.suggest-helper-hover').removeClass('suggest-helper-hover');
            $(this).addClass('suggest-helper-hover');

            if (!valuesArr) {
              return;
            }

            $(canvas.parentNode).children('[arr]').each(function () {
              if (this.getAttribute('arr') !== name) {
                $(this).fadeOut(100, function () {
                  $(this).remove();
                });
              }
            });

            if (!valuesArr.isAttributeExists(name)) {
              return;
            }

            attrType = valuesArr.getAttributeType(name);

            if (!$(canvas.parentNode).children('[arr=\'' + name + '\']').length) {
              this.timer = setTimeout(function () {
                valuesArr.getValuesForAttribute(name, function (attrValues) {
                  if (!attrValues || !$(_curDiv).hasClass('suggest-helper-hover')) {
                    return;
                  }

                  var arrSuggestCanvas = new nsGmx$1.SuggestWidget(attrValues, [_this.currentTextArea], 'suggest', function () {
                    _this.func && _this.func();
                    $(canvasArr.parentNode.childNodes[2]).fadeOut(100);
                    canvasArr.removeNode(true);
                  }, false, addValueFlag, attrType);
                  var canvasArr = arrSuggestCanvas.el;
                  canvasArr.style.left = '86px';
                  canvasArr.style.height = '220px';
                  canvasArr.style.width = '100px';
                  $(canvasArr).children().css('width', '80px');
                  canvasArr.setAttribute('arr', name);
                  $(canvas.parentNode).append(canvasArr);
                  $(canvasArr).fadeIn(100);
                });
              }, 300);
            }
          };

          _div.onmouseout = function (e) {
            var evt = e || window.event,
                target = evt.srcElement || evt.target,
                relTarget = evt.relatedTarget || evt.toElement;

            if ($(target).hasClass('suggest-helper-hover') && relTarget === this.parentNode) {
              $(this).removeClass('suggest-helper-hover');
            }

            if (this.timer) {
              clearTimeout(this.timer);
            }
          };

          _div.onclick = function (e) {
            console.log(_div);
            var val = textTemplate.replace(/suggest/g, name);

            if (this.parentNode.getAttribute('arr') != null) {
              var isNumber = attrType === 'float' || attrType === 'integer';

              if (isNumber) {
                val = val.replace(/,/g, '.');
              } else {
                val = '\'' + val + '\'';
              }

              if (addValueFlag) {
                val = '"' + this.parentNode.getAttribute('arr') + '" = ' + val;
              }
            }

            insertAtCursor(_this.currentTextArea, val, this.parentNode.sel);
            $(canvas).fadeOut(100);

            if (this.timer) {
              clearTimeout(this.timer);
            }

            $(canvas.parentNode).children('[arr]').fadeOut(100, function () {
              $(this).remove();
            });
            _this.func && _this.func();
            stopEvent$1(e);
          };

          $(canvas).append(_div);
        }
      });
    };

    nsGmx$1.SuggestWidget.prototype.setActiveTextArea = function (textArea) {
      for (var i = 0; i < this.textArea.length; i++) {
        if (this.textArea[i] === textArea) {
          this.currentTextArea = this.textArea[i];
          break;
        }
      }
    };

    nsGmx$1.SuggestWidget.prototype.setCallback = function (func) {
      this.func = func;
    };
    /**
     * @param {domElement} targetTextarea textArea to append
     * @param {array} attrNames
     * @param {object} attrValuesProvider
     * @param {function} changeCallback
     * @param {array} selectors array of sub-widgets (attrs, operators, functions)
     */


    nsGmx$1.AttrSuggestWidget = function (targetTextarea, attrNames, attrValuesProvider, changeCallback, selectors) {
      this.changeCallback = changeCallback;
      this.targetTextarea = targetTextarea;
      var template = Handlebars.compile('<div class="suggest-container">' + '<table><tbody><tr>' + '{{#if attrs}}<td><div class="suggest-link-container selectStyle suggest-attr">{{i "Колонки"}}<span class="ui-icon ui-icon-triangle-1-s"></span></div></td>{{/if}}' + '{{#if operators}}<td><div class="suggest-link-container selectStyle suggest-op">{{i "Операторы"}}<span class="ui-icon ui-icon-triangle-1-s"></span></div></td>{{/if}}' + '{{#if functions}}<td><div class="suggest-link-container selectStyle suggest-func">{{i "Функции"}}<span class="ui-icon ui-icon-triangle-1-s"></span></div></td>{{/if}}' + '</tr></tbody></table>' + '</div>');
      var ui = this.el = $(template({
        attrs: selectors.indexOf('attrs') !== -1,
        functions: selectors.indexOf('functions') !== -1,
        operators: selectors.indexOf('operators') !== -1
      }));
      this.attrsSuggest = selectors.indexOf('attrs') !== -1 ? new nsGmx$1.SuggestWidget(attrNames, targetTextarea, '"suggest"', changeCallback, attrValuesProvider, true) : null;
      this.functionsSuggest = selectors.indexOf('functions') !== -1 ? new nsGmx$1.SuggestWidget(transformHash(nsGmx$1.sqlFunctions), targetTextarea, 'suggest()', this.changeCallback, null, false, 'functions') : null;
      this.operatorsSuggest = selectors.indexOf('operators') !== -1 ? new nsGmx$1.SuggestWidget(['=', '>', '<', '>=', '<=', '<>', 'AND', 'OR', 'NOT', 'IN', 'CONTAINS', 'CONTAINSIGNORECASE', 'BETWEEN', 'STARTSWITH', 'ENDSWITH'], targetTextarea, 'suggest', this.changeCallback) : null;
      this.attrsSuggest && ui.find('.suggest-attr').append(this.attrsSuggest.el);
      this.functionsSuggest && ui.find('.suggest-func').append(this.functionsSuggest.el);
      this.operatorsSuggest && ui.find('.suggest-op').append(this.operatorsSuggest.el);

      var clickFunc = function clickFunc(div) {
        if (document.selection) {
          targetTextarea.focus();
          var sel = document.selection.createRange();
          div.sel = sel;
          targetTextarea.blur();
        }

        ui.find('.attrsHelperCanvas').children('[arr]').fadeOut(100, function () {
          $(this).remove();
        });
      };

      ui.find('.suggest-link-container').click(function (e) {
        var evt = e || window.event,
            target = evt.srcElement || evt.target,
            relTarget = evt.relatedTarget || evt.toElement;

        if (!$(target).hasClass('suggest-helper-elem-group')) {
          var placeholder = $(this).children('.suggest-helper');
          clickFunc(placeholder[0]);
          ui.find('.suggest-helper').fadeOut(100);
          placeholder.fadeIn(100);
        }
      });
      $(targetTextarea).click(function () {
        ui.find('.suggest-helper').fadeOut(100);
        return true;
      });
      /**
       * SQLHASH TRANSFORM HELPER
       */

      function transformHash(hash) {
        var arr = [],
            res = [];

        for (var key in hash) {
          if (hash.hasOwnProperty(key)) {
            res.push({
              groupTag: key
            });
            arr = hash[key];

            for (var i = 0; i < arr.length; i++) {
              res.push(arr[i]);
            }
          }
        }

        return res;
      }
    };

    nsGmx$1.AttrSuggestWidget.prototype.setActiveTextArea = function (textArea) {
      this.attrsSuggest && this.attrsSuggest.setActiveTextArea(textArea);
      this.functionsSuggest && this.functionsSuggest.setActiveTextArea(textArea);
      this.operatorsSuggest && this.operatorsSuggest.setActiveTextArea(textArea);
    };

    nsGmx$1.AttrSuggestWidget.prototype.setCallback = function (callback) {
      this.attrsSuggest && this.attrsSuggest.setCallback(callback);
      this.functionsSuggest && this.functionsSuggest.setCallback(callback);
      this.operatorsSuggest && this.operatorsSuggest.setCallback(callback);
    };

    _translationsHash.addtext('rus', {
      LayerQuicklookWidget: {
        minZoom: 'Мин. зум',
        regTitle: 'Атрибуты привязки',
        title: 'Показать'
      }
    });

    _translationsHash.addtext('eng', {
      LayerQuicklookWidget: {
        minZoom: 'Min zoom',
        regTitle: 'Registration fields',
        title: 'Expand'
      }
    });

    var template = Handlebars.compile('<div>' + '{{#if isMinimized}}<span class="lqw-title buttonLink">{{i "LayerQuicklookWidget.title"}}</span>{{/if}}' + '<div class="lqw-container" {{#if isMinimized}}style="display:none"{{/if}}>' + '<div>{{i "LayerQuicklookWidget.minZoom"}}<input class="lqw-minzoom-input inputStyle" value="{{minZoom}}"></div>' + '<textarea class="inputStyle lqw-textarea">{{quicklook}}</textarea>' + '<div class="suggest-link-container">{{i "Атрибут >"}}</div>' + '<div class="lqw-registration-link">{{i "LayerQuicklookWidget.regTitle"}}</div>' + '<table class="lqw-registration-container">' + '{{#points}}' + '<tr><td>X{{idx}}{{../regSelect "X"}}</td><td>Y{{idx}}{{../regSelect "Y"}}</td></tr>' + '{{/points}}' + '</table>' + '</div>' + '</div>');
    var selectTemplate = Handlebars.compile('<select data-name="{{targetName}}" class="lqw-point-select selectStyle">' + '{{#opts}}' + '<option value="{{name}}"{{#if isDefault}} selected{{/if}}>{{name}}</option>' + '{{/opts}}' + '</select>');
    /**
    Виджет для задания параметров слоя, связанных с показом квиклуков
    @memberOf nsGmx
    @class
    */

    nsGmx$1.LayerQuicklookWidget = function (container, layerProperties) {
      var DEFAULT_OPTION = {
        name: '',
        isDefault: false
      };

      var layerColumns = window._.pluck(layerProperties.get('Columns'), 'Name'),
          quicklookParams = layerProperties.get('Quicklook');

      var ui = $(template({
        isMinimized: !quicklookParams.get('template'),
        minZoom: quicklookParams.get('minZoom'),
        quicklook: quicklookParams.get('template'),
        points: Array.apply(null, {
          length: 4
        }).map(function (elem, index) {
          return {
            idx: index + 1
          };
        }),
        regSelect: function regSelect(label) {
          var targetName = label + this.idx,
              initValue = (quicklookParams.get(targetName) || targetName).toLowerCase();
          return new Handlebars.SafeString(selectTemplate({
            targetName: targetName,
            opts: [].concat(DEFAULT_OPTION, layerColumns.map(function (column) {
              return {
                name: column,
                isDefault: column.toLowerCase() === initValue
              };
            }))
          }));
        }
      }));
      ui.find('.lqw-title').click(function () {
        ui.find('.lqw-title').hide();
        ui.find('.lqw-container').show();
      });

      var updateRegistrationStatus = function updateRegistrationStatus() {
        ui.find('td').each(function (index, td) {
          $(td).toggleClass('lqw-reg-error', !$(td).find('option:selected').val());
        });
      };

      ui.find('.lqw-minzoom-input').on('change keyup', function () {
        var minZoom = Number(this.value);
        quicklookParams.set('minZoom', minZoom);
      });
      ui.find('select').change(function () {
        updateRegistrationStatus();
        var name = $(this).data('name');
        quicklookParams.set(name, this.value || undefined);
      });
      updateRegistrationStatus();

      if (ui.find('.lqw-reg-error').length === 0) {
        ui.find('.lqw-registration-container').hide();
        ui.find('.lqw-registration-link').addClass('buttonLink').click(function () {
          $(this).removeClass('buttonLink');
          ui.find('.lqw-registration-container').show();
        });
      }

      var quicklookText = ui.find('.lqw-textarea');

      var setQuicklook = function setQuicklook() {
        layerProperties.get('Quicklook').set('template', quicklookText.val());
      };

      var suggestWidget = new nsGmx$1.SuggestWidget(layerProperties.get('Attributes') || [], quicklookText[0], '[suggest]', setQuicklook, ['attrs', 'operators']);
      quicklookText.on('focus', function () {
        $(suggestWidget.el).hide();
      });
      ui.find('.suggest-link-container').append(suggestWidget.el).click(function () {
        if (suggestWidget.el.style.display === 'none') {
          $(suggestWidget.el).fadeIn(500);
        }
      });
      quicklookText.on('keyup change', setQuicklook);
      ui.appendTo(container);
    };

    function capitaliseFirstLetter(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    } //events: newAttribute, delAttribute, updateAttribute, updateExpression, moveAttribute, change


    nsGmx$1.ManualAttrModel = function (isRCLayer) {
      var _attributes = [];
      this.expressions = [];

      this.addAttribute = function (type, name) {
        _attributes.push({
          type: type,
          name: name,
          IsPrimary: false,
          IsIdentity: false,
          IsComputed: false,
          expression: '"' + name + '"'
        });

        this.expressions.push({
          name: name,
          expression: '"' + name + '"'
        });
        $(this).triggerHandler('newAttribute');
        $(this).triggerHandler('change');
        return _attributes.length - 1;
      };

      this.changeName = function (idx, newName) {
        _attributes[idx].name = newName;
        $(this).triggerHandler('updateAttribute');
        $(this).triggerHandler('change');
      };

      this.changeType = function (idx, newType) {
        _attributes[idx].type = newType;
        $(this).triggerHandler('updateAttribute');
        $(this).triggerHandler('change');
      };

      this.changeExpression = function (name, newExp) {
        var obj = this.expressions.find(function (obj) {
          return obj.name === name;
        });
        obj.expression = newExp;
        $(this).triggerHandler('updateExpression');
        $(this).triggerHandler('change');
      };

      this.deleteAttribute = function (idx) {
        _attributes.splice(idx, 1);

        $(this).triggerHandler('delAttribute');
        $(this).triggerHandler('change');
      };

      this.getAttribute = function (idx) {
        return _attributes[idx];
      };

      this.getCount = function () {
        return _attributes.length;
      };

      this.each = function (callback, addInternalColumns, params) {
        for (var k = 0; k < _attributes.length; k++) {
          var column = _attributes[k];
          var isInternal = column.IsPrimary || column.IsIdentity || column.IsComputed || column.type.server === 'geometry' || isRCLayer && column.name === 'GMX_RasterCatalogID';

          if (!isInternal || addInternalColumns) {
            callback(column, k, params);
          }
        }
      };

      this.moveAttribute = function (oldIdx, newIdx) {
        if (newIdx > oldIdx) {
          newIdx--;
        }

        if (oldIdx !== newIdx) {
          _attributes.splice(newIdx, 0, _attributes.splice(oldIdx, 1)[0]);

          $(this).triggerHandler('moveAttribute');
          $(this).triggerHandler('change');
        }
      };

      this.initFromServerFormat = function (serverColumns) {
        var _this = this;

        _attributes = [];
        $.each(serverColumns || [], function (i, column) {
          var type = window._.find(nsGmx$1.ManualAttrModel.TYPES, function (elem) {
            return elem.server === column.ColumnSimpleType.toLowerCase();
          });

          var obj = _this.expressions.find(function (obj) {
            return obj.name === column.Name;
          });

          if (!obj) {
            _this.expressions.push({
              name: column.Name,
              expression: '"' + column.Name + '"'
            });
          }

          _attributes.push({
            type: type || {
              server: column.ColumnSimpleType.toLowerCase()
            },
            name: column.Name,
            oldName: column.Name,
            IsPrimary: column.IsPrimary,
            IsIdentity: column.IsIdentity,
            IsComputed: column.IsComputed
          });
        });
        $(this).triggerHandler('newAttribute');
        $(this).triggerHandler('change');
      };

      this.toServerFormat = function () {
        var _this = this;

        var res = [];
        $.each(_attributes, function (i, attr) {
          var obj = _this.expressions.find(function (obj) {
            return obj.name === attr.name;
          });

          res.push({
            Name: attr.name,
            OldName: attr.oldName,
            ColumnSimpleType: capitaliseFirstLetter(attr.type.server),
            IsPrimary: attr.IsPrimary,
            IsIdentity: attr.IsIdentity,
            IsComputed: attr.IsComputed,
            expression: obj ? obj.expression : '"' + attr.name + '"'
          });
        });
        return res;
      };

      this.replaceString = function (string) {
        if (!string) return;

        _attributes.forEach(function (attr) {
          if (attr.name) {
            var re = new RegExp('\\"' + attr.name + '\\"', "g");

            if (!string.match(re)) {
              string = string.replace(attr.name, '"' + attr.name + '"');
            }
          }
        });

        return string;
      };
    };

    nsGmx$1.ManualAttrModel.TYPES = {
      DOUBLE: {
        user: 'Float',
        server: 'float'
      },
      INTEGER: {
        user: 'Integer',
        server: 'integer'
      },
      STRING: {
        user: 'String',
        server: 'string'
      },
      TIME: {
        user: 'Time',
        server: 'time'
      },
      DATE: {
        user: 'Date',
        server: 'date'
      },
      DATETIME: {
        user: 'DateTime',
        server: 'datetime'
      },
      BOOL: {
        user: 'Boolean',
        server: 'boolean'
      }
    };

    var utils = nsGmx$1.Utils;

    _translationsHash.addtext('rus', {
      ManualAttrView: {
        headerName: 'Название',
        headerType: 'Тип',
        headerExp: 'Выражение'
      }
    });

    _translationsHash.addtext('eng', {
      ManualAttrView: {
        headerName: 'Name',
        headerType: 'Type',
        headerExp: 'Expression'
      }
    });

    var selectorTemplate = Handlebars.compile('<select class="selectStyle customAttr-typesselect">' + '{{#each types}}' + '<option value="{{server}}" id="{{server}}"{{#if @root.isSelected}} selected{{/if}}>{{user}}</option>' + '{{/each}}' + '</select>');

    nsGmx$1.ManualAttrView = function () {
      var _parent = null;
      var _model = null;
      var _params = null;
      var _trs = [];
      var _isActive = true;

      var _this = this;

      var isAddingNew = false;

      var createTypeSelector = function createTypeSelector(selectedType) {
        return $(selectorTemplate({
          types: nsGmx$1.ManualAttrModel.TYPES,
          isSelected: function isSelected() {
            return this.server === selectedType;
          }
        }));
      };

      var createRow = function createRow(attr, i, params) {
        var sqlSelector, cellsArr;
        var typeSelector = createTypeSelector(attr.type.server)[0];
        $(typeSelector).data('idx', i);
        $(typeSelector).change(function () {
          var serverType = $('option:selected', this).val(),
              attrType = window._.findWhere(nsGmx$1.ManualAttrModel.TYPES, {
            server: serverType
          });

          _model.changeType($(this).data('idx'), attrType);
        });
        var nameSelectorLength = params.copy ? 90 : 120;

        var nameSelector = utils._input(null, [['attr', 'class', 'customAttrNameInput inputStyle'], ['css', 'width', nameSelectorLength + 'px']]);

        $(nameSelector).data('idx', i).val(attr.name);
        var deleteIcon = utils.makeImageButton('img/recycle.png', 'img/recycle_a.png');

        if (params.copy) {
          var obj = _model.expressions.find(function (obj) {
            return obj.name === attr.name;
          });

          var expression = obj ? obj.expression : '';
          sqlSelector = utils._input(null, [['attr', 'class', 'manualSqlAttrInput inputStyle'], ['css', 'width', '100px']]);
          $(sqlSelector).data('idx', i).val(_model.replaceString(expression));
          $(sqlSelector).on('keyup', function () {
            var idx = $(this).data('idx');
            var exp = $(this).val();

            if (idx >= 0) {
              _model.changeExpression(attr.name, exp);
            }
          });
          cellsArr = [utils._td([nameSelector]), utils._td([typeSelector]), utils._td([sqlSelector]), utils._td([deleteIcon])];
        } else {
          // sqlSelector =
          cellsArr = [utils._td([nameSelector]), utils._td([typeSelector]), utils._td([deleteIcon])];
        }

        var tr = utils._tr(cellsArr);

        $(nameSelector).on('keyup', function () {
          var idx = $(this).data('idx');
          var name = $(this).val();

          if (idx >= 0) {
            _model.changeName(idx, name);
          } else if (name) {
            isAddingNew = true;
            $(tr).find('td:gt(0)').show();
            $(tr).removeClass('customAttributes-new');

            var newIdx = _model.addAttribute(nsGmx$1.ManualAttrModel.TYPES.STRING, name);

            $([nameSelector, typeSelector, deleteIcon]).data('idx', newIdx);
            isAddingNew = false;
          }
        });
        $(deleteIcon).addClass('removeIcon').data('idx', i);

        deleteIcon.onclick = function () {
          _model.deleteAttribute($(this).data('idx'));
        };

        return tr;
      };

      var redraw = function redraw() {
        if (!_model || isAddingNew) {
          return;
        }

        $(_parent).empty();
        _trs = [];

        _model.each(function (attr, i) {
          _trs.push(createRow(attr, i, _params));
        });

        var newAttr = createRow({
          name: '',
          type: nsGmx$1.ManualAttrModel.TYPES.STRING
        }, -1, _params);
        $(newAttr).find('td:gt(0)').hide();
        $(newAttr).addClass('customAttributes-new');

        _trs.push(newAttr);

        var tbody = nsGmx$1.Utils._tbody(_trs);

        var theader = $(Handlebars.compile('<thead>' + '<tr>' + '<th>{{i "ManualAttrView.headerName"}}</th>' + '<th>{{i "ManualAttrView.headerType"}}</th>' + '{{#if copy}}<th>{{i "ManualAttrView.headerExp"}}</th>{{/if}}' + '</tr>' + '</thead>')({
          copy: _params.copy
        }));
        $(_parent).append($('<fieldset/>').css('border', 'none').append(nsGmx$1.Utils._table([theader[0], tbody], [['dir', 'className', 'customAttributes']])));

        _this.setActive(_isActive);
      };

      this.setActive = function (isActive) {
        _isActive = isActive;
        var fieldset = $(_parent).children('fieldset');

        if (isActive) {
          fieldset.removeAttr('disabled');
        } else {
          fieldset.attr('disabled', 'disabled');
        }

        $('.removeIcon, .customAttributes-new', fieldset).toggle(isActive);
      };

      this.init = function (parent, model, params) {
        _parent = parent;
        _model = model;
        _params = params;
        $(_model).on('newAttribute delAttribute moveAttribute', redraw);
        $(_model).on('newAttribute', function () {
          if (!$(_parent).find('.customAttributes-new').length) {
            var newAttr = createRow({
              name: '',
              type: nsGmx$1.ManualAttrModel.TYPES.STRING
            }, -1, params);
            $(newAttr).find('td:gt(0)').hide();
            $(newAttr).addClass('customAttributes-new');
            $(_parent).find('tbody').append(newAttr);
          }
        });
        redraw();
      };
    };

    var _$7 = nsGmx$1.Utils._;
    /** 
    * @class Веб браузер для выбора и загрузки файлов на сервер
    */

    var fileBrowser = function fileBrowser() {
      var _this = this;

      this.parentCanvas = null;
      this._homeDir = '';
      this._status = {
        _state: false,
        start: function start() {
          this._state = true;
          var me = this;
          setTimeout(function () {
            if (me._state) {
              $(_this.statusContainer).show();
            }
          }, 100);
        },
        stop: function stop() {
          $(_this.statusContainer).hide();
          this._state = false;
        }
      };

      this._path = function () {
        var path;
        var alternativePath;
        return {
          set: function set(newPath, newAlternativePath) {
            path = newPath + (newPath.charAt(newPath.length - 1) === _this.slash ? '' : _this.slash);

            if (newAlternativePath) {
              alternativePath = newAlternativePath + (newAlternativePath.charAt(newAlternativePath.length - 1) === _this.slash ? '' : _this.slash);
            } else {
              alternativePath = undefined;
            }

            $(this).change();
          },
          get: function get() {
            return path;
          },
          getAlternative: function getAlternative() {
            return alternativePath;
          },
          isRoot: function isRoot() {
            return path && path.indexOf(_this.slash) === path.length - 1;
          },
          isInited: function isInited() {
            return typeof path !== 'undefined';
          },
          isInHome: function isInHome() {
            return path && path.indexOf(_this._homeDir) === 0;
          },
          getRoot: function getRoot() {
            var index = String(path).indexOf(_this.slash);
            return newPath = String(path).substr(0, index + 1);
          },
          getParentFolder: function getParentFolder() {
            var index = String(path).lastIndexOf(_this.slash, path.length - 2);
            return String(path).substr(0, index + 1);
          }
        };
      }();

      this.currentFiles = [];
      this.slash = "\\";
      this.fileCanvas = null;
      this.fileHeader = null;
      this.fileUpload = null;
      this.sortFuncs = {
        name: [function (_a, _b) {
          var a = String(_a.Name).toLowerCase(),
              b = String(_b.Name).toLowerCase();
          if (a > b) return 1;else if (a < b) return -1;else return 0;
        }, function (_a, _b) {
          var a = String(_a.Name).toLowerCase(),
              b = String(_b.Name).toLowerCase();
          if (a < b) return 1;else if (a > b) return -1;else return 0;
        }],
        ext: [function (_a, _b) {
          var a = String(_a.Name).toLowerCase(),
              b = String(_b.Name).toLowerCase(),
              index1 = a.lastIndexOf('.'),
              ext1 = a.substr(index1 + 1, a.length),
              index2 = b.lastIndexOf('.'),
              ext2 = b.substr(index2 + 1, b.length);
          if (ext1 > ext2) return 1;else if (ext1 < ext2) return -1;else return 0;
        }, function (_a, _b) {
          var a = String(_a.Name).toLowerCase(),
              b = String(_b.Name).toLowerCase(),
              index1 = a.lastIndexOf('.'),
              ext1 = a.substr(index1 + 1, a.length),
              index2 = b.lastIndexOf('.'),
              ext2 = b.substr(index2 + 1, b.length);
          if (ext1 < ext2) return 1;else if (ext1 > ext2) return -1;else return 0;
        }],
        size: [function (a, b) {
          return a.Size - b.Size;
        }, function (a, b) {
          return b.Size - a.Size;
        }],
        date: [function (a, b) {
          return a.Date - b.Date;
        }, function (a, b) {
          return b.Date - a.Date;
        }]
      };
      this.currentSortType = 'name';
      this.currentSortIndex = {
        name: 0,
        ext: 0,
        size: 0,
        date: 0
      };
      this.shownPathScroll = false;
      this.returnMask = ['noname'];
      this._discs = null;
      this._params = null;
      this.ext7z = ['7Z', 'ZIP', 'GZIP', 'BZIP2', 'TAR', 'ARJ', 'CAB', 'CHM', 'CPIO', 'DEB', 'DMG', 'HFS', 'ISO', 'LZH', 'LZMA', 'MSI', 'NSIS', 'RAR', 'RPM', 'UDF', 'WIM', 'XAR', 'Z'];
    };

    fileBrowser.MAX_UPLOAD_SIZE = 500 * 1024 * 1024;
    /**
     Показать браузер пользователю. Если браузер уже показывается, он будет закрыт и открыт новый
     @param {String} title Заголовок окна браузера
     @param {String[]} mask Массив допустимых для выбора разрешений файлов. Если массив пустой, то выбираются директории, а не отдельные файлы
     @param {function(path)} closeFunc Функция, которая будет вызвана при выборе файла/директории (если браузер просто закрыли, не вызовется)
     @param {Object} params Параметры браузера
     @param {String} params.restrictDir Ограничивающая директория (поддерево). Нельзя посмотреть файлы вне этой директории (даже для админов)
     @param {String} params.startDir Начальная директория. Если нет, то будет открыто в том же месте, где и закрыт в прошлый раз.
    */

    fileBrowser.prototype.createBrowser = function (title, mask, closeFunc, params) {
      this._params = $.extend({
        restrictDir: null,
        startDir: null
      }, params);
      if (this._params.startDir !== null) this._path.set(this._params.startDir);

      if ($('#fileBrowserDialog').length) {
        $('#fileBrowserDialog').parent().dialog("destroy");
        $('#fileBrowserDialog').parent().remove();
      }

      var canvas = _div$1(null, [['attr', 'id', 'fileBrowserDialog']]);

      var oDialog = showDialog$1(title, canvas, 800, 400, false, false, this.resize);
      this.returnMask = mask;
      this.parentCanvas = canvas;
      this.closeFunc = closeFunc;
      this._homeDir = nsGmx$1.AuthManager.getUserFolder();
      if (this._discs === null) // && nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_FILE_STRUCTURE )
        this.loadInfo();else this.loadInfoHandler();
      return oDialog;
    };

    fileBrowser.prototype.resize = function () {
      if (!$("#fileBrowserDialog").find(".fileCanvas").length) return;
      var container = $('#fileBrowserDialog')[0];
      var titleHeight = container.parentNode.parentNode.firstChild.offsetHeight;
      container.childNodes[1].lastChild.style.height = container.parentNode.parentNode.offsetHeight - titleHeight - 6 - container.lastChild.offsetHeight - container.firstChild.offsetHeight - container.childNodes[1].firstChild.offsetHeight - 20 + 'px';
    };

    fileBrowser.prototype.close = function (path) {
      this.closeFunc(path);
      var canvas = $('#fileBrowserDialog')[0];
      $(canvas.parentNode).dialog("destroy");
      canvas.parentNode.removeNode(true);
    };

    fileBrowser.prototype.loadInfo = function () {
      var _this = this;

      sendCrossDomainJSONRequest$2(window.serverBase + "FileBrowser/GetDrives.ashx?WrapStyle=func", function (response) {
        if (!parseResponse$1(response)) return;
        _this._discs = response.Result;

        _this.loadInfoHandler();
      });
    };

    fileBrowser.prototype._showWarningDialog = function () {
      var canvas = _div$1([_t$1(_gtxt("FileBrowser.ExceedLimitMessage"))], [['dir', 'className', 'CustomErrorText']]);

      showDialog$1(_gtxt("Ошибка!"), canvas, 220, 100);
    };

    fileBrowser.prototype._uploadFilesAjax = function (formData) {
      var _this = this;

      this.progressBar.progressbar('option', 'value', 0);
      this.progressBar.show();
      formData.append('WrapStyle', 'None');
      var xhr = new XMLHttpRequest();
      xhr.upload.addEventListener("progress", function (e) {
        _this.progressBar.progressbar('option', 'value', e.loaded / e.total * 100);
      }, false);
      xhr.open('POST', window.serverBase + 'FileBrowser/Upload.ashx');
      xhr.withCredentials = true;

      xhr.onload = function () {
        _this.progressBar.hide();

        if (xhr.status === 200) {
          response = JSON.parse(xhr.responseText);
          if (!parseResponse$1(response)) return;

          if (typeof response.Result == 'string') {
            var indexSlash = String(response.Result).lastIndexOf(_this.slash),
                fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
            _this.shownPath = fileName;
          }

          _this.getFiles();
        }
      };

      xhr.send(formData);
    };

    fileBrowser.prototype.loadInfoHandler = function () {
      var _this = this;

      if (!this._path.isInited()) {
        var mapFolder = _layersTree.treeModel.getMapProperties().LayersDir;

        if (mapFolder) {
          this._path.set(_layersTree.treeModel.getMapProperties().LayersDir, nsGmx$1.AuthManager.getUserFolder());
        } else {
          this._path.set(nsGmx$1.AuthManager.getUserFolder());
        }
      }

      this.currentSortFunc = this.sortFuncs['name'][0];
      this.fileUpload = _div$1(null, [['dir', 'className', 'fileUpload']]);
      this.fileHeader = _div$1(null, [['css', 'height', '24px']]);
      this.fileCanvas = _div$1(null, [['dir', 'className', 'fileCanvas']]);
      $(this.parentCanvas).bind('dragover', function () {
        return false;
      });
      $(this.parentCanvas).bind('drop', function (e) {
        if (!window.FormData) return false;
        var files = e.originalEvent.dataTransfer.files;
        var formData = new FormData();
        var totalSize = 0;

        for (var f = 0; f < files.length; f++) {
          totalSize += files[f].size;
        }

        if (totalSize > fileBrowser.MAX_UPLOAD_SIZE) {
          _this._showWarningDialog();

          return false;
        }

        for (var f = 0; f < files.length; f++) {
          formData.append('rawdata', files[f]);
        }

        formData.append('ParentDir', _this._path.get());

        _this._uploadFilesAjax(formData);

        return false;
      });

      _$7(this.parentCanvas, [this.fileHeader, this.fileCanvas, this.fileUpload]);

      this.createHeader();
      this.createUpload();

      this._updateUploadVisibility();

      this.getFiles();
    };

    fileBrowser.prototype._updateUploadVisibility = function () {
      $([this.fileUpload, this.tdAddFolder]).toggle(nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN) || this._path.isInHome());
    };

    fileBrowser.prototype.createHeader = function () {
      var reloadButton = makeImageButton$1("img/reload.png"),
          homeButton = makeImageButton$1("img/home.png"),
          discButtonTds = [],
          _this = this;

      reloadButton.style.margin = '0px 5px 0px 10px';
      homeButton.style.margin = '0px 10px 0px 5px';
      reloadButton.style.width = '14px';
      reloadButton.style.height = '15px';
      homeButton.style.width = '15px';
      homeButton.style.height = '15px';

      _title$1(reloadButton, _gtxt("Обновить"));

      _title$1(homeButton, _gtxt("Домашняя директория"));

      reloadButton.onclick = function () {
        _this.getFiles();
      };

      homeButton.onclick = function () {
        _this._path.set(_layersTree.treeModel.getMapProperties().LayersDir, _this._homeDir);

        _this.getFiles(_layersTree.treeModel.getMapProperties().LayersDir);
      }; //if ( nsGmx.AuthManager.canDoAction(nsGmx.ACTION_SEE_FILE_STRUCTURE ) )
      //{


      for (var i = 0; i < this._discs.length; i++) {
        var discButtons = makeButton(this._discs[i]);

        (function (i) {
          discButtons.onclick = function () {
            _this.getFiles(_this._discs[i]);
          };
        })(i);

        discButtonTds.push(_td$1([discButtons]));
      } //}


      discButtonTds.push(_td$1([reloadButton], [['attr', 'vAlign', 'top']]));
      discButtonTds.push(_td$1([homeButton], [['attr', 'vAlign', 'top']]));

      var newFolderName = _input$1(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '150px']]),
          showFolderButton = makeImageButton$1("img/newfolder.png"),
          newFolderButton = makeButton(_gtxt("Создать")),
          createFolder = function createFolder() {
        _this._status.start();

        sendCrossDomainJSONRequest$2(window.serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(_this._path.get() + newFolderName.value), function (response) {
          _this._status.stop();

          if (!parseResponse$1(response)) return;
          _this.shownPath = newFolderName.value;
          newFolderName.value = '';

          _this.getFiles();
        });
      };

      showFolderButton.style.width = '16px';
      showFolderButton.style.height = '13px';
      newFolderName.style.margin = '0px 3px';

      _title$1(showFolderButton, _gtxt("Новая папка"));

      showFolderButton.style.marginRight = '10px';

      showFolderButton.onclick = function () {
        $(newFolderName).toggle().focus();
        $(newFolderButton).toggle();
      };

      newFolderName.style.display = 'none';
      newFolderButton.style.display = 'none';
      $(newFolderName).on('keydown', function (e) {
        if (e.keyCode === 13) {
          if (newFolderName.value != '') createFolder();else inputError(newFolderName);
          return false;
        }
      });

      newFolderButton.onclick = function () {
        if (newFolderName.value != '') createFolder();else inputError(newFolderName);
      };

      this.tdAddFolder = _td$1([_table$1([_tbody$1([_tr$1([_td$1([showFolderButton], [['attr', 'vAlign', 'top']]), _td$1([newFolderName]), _td$1([newFolderButton])])])])], [['attr', 'vAlign', 'top'], ['css', 'height', '20px']]);
      discButtonTds.push(this.tdAddFolder);

      _$7(this.fileHeader, [_table$1([_tbody$1([_tr$1(discButtonTds)])])]);
    };

    fileBrowser.prototype.createUpload = function () {
      var div = _div$1(null, [['css', 'height', '30px']]),
          _this = this;

      var formFile = _form(null, [['attr', 'enctype', 'multipart/form-data'], ['dir', 'method', 'post'], ['dir', 'action', window.serverBase + 'FileBrowser/Upload.ashx?WrapStyle=message'], ['attr', 'target', 'fileBrowserUpload_iframe']]);

      var attach = _input$1(null, [['attr', 'type', 'file'], ['dir', 'name', 'rawdata'], ['css', 'width', '200px'], ['attr', 'multiple', 'multiple']]);

      _$7(formFile, [attach]);

      attach.onchange = function () {
        if (attach.files && attach.files[0] && attach.files[0].size > fileBrowser.MAX_UPLOAD_SIZE) {
          _this._showWarningDialog();

          return;
        } //если можем послать через AJAX, посылаем - будет работать прогресс-бар


        if (window.FormData) {
          var formData = new FormData(formFile);
          formData.append('ParentDir', _this._path.get());

          _this._uploadFilesAjax(formData);

          return;
        }

        sendCrossDomainPostRequest$1(window.serverBase + 'FileBrowser/Upload.ashx', {
          WrapStyle: 'message',
          ParentDir: _this._path.get()
        }, function (response) {
          if (!parseResponse$1(response)) return;
          var indexSlash = String(response.Result).lastIndexOf(_this.slash),
              fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
          _this.shownPath = fileName;

          _this.getFiles();
        }, formFile);
      };

      var dropInfoDiv = window.FormData ? _div$1([_t$1(_gtxt('FileBrowser.DropInfo'))], [['dir', 'className', 'fileBrowser-dragFileMessage']]) : _div$1();

      _$7(div, [dropInfoDiv, _table$1([_tbody$1([_tr$1([_td$1([formFile], [['css', 'paddingTop', '18px']])])])])]);

      this.progressBar = $('<div/>').addClass('fileBrowser-progressBar').progressbar({
        value: 100
      }).hide();

      _$7(this.fileUpload, [this.progressBar[0], div]);
    };

    fileBrowser.prototype.getFiles = function (path) {
      var path = typeof path != 'undefined' ? path : this._path.get();

      var alternativePath = this._path.getAlternative();

      var _this = this;

      if (this._isRestrictedPath(path)) return;

      var doProcessResponce = function doProcessResponce(response) {
        _this._status.stop();

        if (!parseResponse$1(response)) return;

        _this.getFilesHandler(response.Result, path);
      };

      this._status.start();

      sendCrossDomainJSONRequest$2(window.serverBase + "FileBrowser/GetDirectoryContent.ashx?WrapStyle=func&root=" + encodeURIComponent(path), function (response) {
        if (response.Status !== 'ok' && alternativePath) {
          path = alternativePath;

          _this._path.set(alternativePath);

          sendCrossDomainJSONRequest$2(window.serverBase + "FileBrowser/GetDirectoryContent.ashx?WrapStyle=func&root=" + encodeURIComponent(alternativePath), doProcessResponce);
        } else {
          doProcessResponce(response);
        }
      });
    };

    fileBrowser.prototype.getFilesHandler = function (files, path) {
      this._path.set(path);

      this.currentFiles = files;

      this._updateUploadVisibility();

      this.reloadFiles();
    };

    fileBrowser.prototype.pathWidget = function () {
      var shortPath = this._path.get();

      var _this = this;

      var parent = $('<span/>', {
        'class': 'fileBrowser-pathWidget'
      });
      var pathElements = [];

      var highlightPath = function highlightPath(index) {
        for (var e = 0; e < pathElements.length; e++) {
          if (e <= index) pathElements[e].addClass('fileBrowser-activePathElem');else pathElements[e].removeClass('fileBrowser-activePathElem');
        }
      };

      var appendElem = function appendElem(text, path) {
        var elemIndex = pathElements.length;
        var newElem = $('<span/>', {
          'class': 'fileBrowser-pathElem'
        }).text(text + _this.slash).click(function () {
          _this.getFiles(path[path.legnth - 1] === _this.slash ? path : path + _this.slash);
        }).hover(function () {
          highlightPath(elemIndex);
        }, function () {
          highlightPath(-1);
        });
        pathElements.push(newElem);
        parent.append(newElem); //.append( $('<span/>').text(_this.slash) );
      };

      var curFolder = '';

      while (shortPath.length) {
        var index = shortPath.indexOf(this.slash);
        if (index == 0) break;

        if (index < 0) {
          appendElem(shortPath, curFolder + shortPath);
          break;
        }

        var curText = shortPath.substr(0, index);
        curFolder += curText + this.slash;
        shortPath = shortPath.substr(index + 1);
        appendElem(curText, curFolder.substr(0, curFolder.length - 1));
      }

      return parent[0];
    };

    fileBrowser.prototype.quickSearch = function () {
      var input = _input$1(null, [['dir', 'className', 'inputStyle'], ['css', 'width', '200px']]),
          _this = this;

      input.onkeyup = function () {
        if (this.value != "") {
          var scroll = _this.findContent(this.value);

          if (scroll >= 0) _this.fileCanvas.lastChild.scrollTop = scroll;
        }
      };

      return input;
    };

    fileBrowser.prototype.findContent = function (value) {
      var tbody = this.fileCanvas.lastChild.firstChild.lastChild;

      for (var i = 0; i < tbody.childNodes.length; ++i) {
        var text = tbody.childNodes[i].textContent.toLowerCase();
        if (text != "[..]" && text.indexOf(value.toLowerCase()) == 0) return tbody.childNodes[i].offsetTop;
      }

      return -1;
    };

    fileBrowser.prototype.reloadFiles = function () {
      $(this.fileCanvas).empty();
      this.statusContainer = _div$1(null, [['dir', 'className', 'fileBrowser-progress'], ['css', 'display', 'none']]);

      _$7(this.fileCanvas, [_div$1([this.pathWidget(), _br$1(), _t$1(_gtxt("Фильтр")), this.quickSearch(), this.statusContainer], [['dir', 'className', 'currentDir'], ['css', 'color', '#153069'], ['css', 'fontSize', '12px']])]);

      _$7(this.fileCanvas, [this.draw(this.currentFiles)]);

      this.resize();

      if (this.shownPathScroll) {
        this.fileCanvas.lastChild.scrollTop = this.shownPathScroll.offsetTop;
        this.shownPathScroll = false;
      }
    };

    fileBrowser.prototype._getParentFolder = function (path) {
      var index = String(path).lastIndexOf(this.slash),
          newPath = String(path).substr(0, index);
      if (new RegExp(/^[a-z]:$/i).test(newPath)) newPath += this.slash;
      return newPath;
    };

    fileBrowser.prototype._isRestrictedPath = function (path) {
      return this._params.restrictDir !== null && path.indexOf(this._params.restrictDir) != 0;
    };

    fileBrowser.prototype.draw = function (files) {
      var nameSort = makeLinkButton$1(_gtxt("Имя")),
          extSort = makeLinkButton$1(_gtxt("Тип")),
          sizeSort = makeLinkButton$1(_gtxt("Размер")),
          dateSort = makeLinkButton$1(_gtxt("Дата")),
          _this = this;

      nameSort.sortType = 'name';
      extSort.sortType = 'ext';
      sizeSort.sortType = 'size';
      dateSort.sortType = 'date';

      nameSort.onclick = extSort.onclick = sizeSort.onclick = dateSort.onclick = function () {
        _this.currentSortType = this.sortType;
        _this.currentSortIndex[_this.currentSortType] = 1 - _this.currentSortIndex[_this.currentSortType];

        _this.reloadFiles();
      };

      var tdRoot = _td$1(null, [['css', 'width', '20px']]);

      if (nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_FILE_STRUCTURE)) {
        var rootButton = makeButton(this.slash);

        _$7(tdRoot, [rootButton]);

        rootButton.onclick = function () {
          _this.getFiles(_this._path.getRoot());
        };
      }

      var tableHeaderTr = _tr$1([tdRoot, _td$1([nameSort], [['css', 'textAlign', 'left']]), _td$1([extSort], [['css', 'width', '10%'], ['css', 'textAlign', 'center']]), _td$1([sizeSort], [['css', 'width', '15%'], ['css', 'textAlign', 'center']]), _td$1([dateSort], [['css', 'width', '25%'], ['css', 'textAlign', 'center']])]),
          prevDirTr = _tr$1([_td$1(), _td$1([_t$1("[..]")]), _td$1(), _td$1(), _td$1()]),
          tableFilesTrs = [];

      var parentFolder = _this._path.getParentFolder();

      if (parentFolder && !this._isRestrictedPath(parentFolder)) {
        tableFilesTrs.push(prevDirTr);
        attachEffects$1(prevDirTr, 'hover');

        prevDirTr.onclick = function () {
          _this.getFiles(parentFolder);
        };
      }

      tableFilesTrs = tableFilesTrs.concat(this.drawFolders(files));
      tableFilesTrs = tableFilesTrs.concat(this.drawFiles(files));
      return _div$1([_table$1([_thead([tableHeaderTr]), _tbody$1(tableFilesTrs)], [['css', 'width', '100%']])], [['css', 'overflowY', 'scroll']]);
    };

    fileBrowser.prototype.getCurrentSortFunc = function () {
      return this.sortFuncs[this.currentSortType][this.currentSortIndex[this.currentSortType]];
    };

    fileBrowser.prototype.formatDate = function (sec) {
      var sysDate = new Date(sec * 1000),
          date = [];
      date[0] = sysDate.getDate(), date[1] = sysDate.getMonth() + 1, date[2] = sysDate.getFullYear(), date[3] = sysDate.getHours(), date[4] = sysDate.getMinutes(), date[5] = sysDate.getSeconds();

      for (var i = 0; i < 6; i++) {
        if (date[i] < 10) date[i] = '0' + date[i];
      }

      return date[0] + '.' + date[1] + '.' + date[2] + ' ' + date[3] + ':' + date[4] + ':' + date[5];
    };

    fileBrowser.prototype.drawFolders = function (arr) {
      var folders = [],
          trs = [],
          _this = this;

      for (var i = 0; i < arr.length; i++) {
        if (arr[i].Directory) folders.push(arr[i]);
      }

      if (this.currentSortType == 'name' || this.currentSortType == 'date') folders = folders.sort(this.getCurrentSortFunc());

      for (var i = 0; i < folders.length; i++) {
        var tdReturn = _td$1();

        if (!this.returnMask.length) {
          var returnButton = makeImageButton$1("img/choose.png", "img/choose_a.png");
          returnButton.style.cursor = 'pointer';
          returnButton.style.marginLeft = '5px';

          _title$1(returnButton, _gtxt("Выбрать"));

          (function (i) {
            returnButton.onclick = function (e) {
              _this.close(_this._path.get() + folders[i].Name + _this.slash);
            };
          })(i);

          _$7(tdReturn, [returnButton]);
        }

        var tr = _tr$1([tdReturn, _td$1([_div$1(null, [['dir', 'className', 'fileCanvas-folder-icon']]), this.createFolderActions(folders[i].Name)]), _td$1(), _td$1([_t$1(_gtxt("Папка"))], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']]), _td$1([_t$1(this.formatDate(folders[i].Date))], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']])]);

        (function (i) {
          tr.onclick = function () {
            _this.getFiles(_this._path.get() + folders[i].Name);
          };
        })(i);

        attachEffects$1(tr, 'hover');

        if (this.shownPath && folders[i].Name == this.shownPath) {
          $(tr).children("td").css('backgroundColor', '#CEEECE');
          this.shownPath = null;
          this.shownPathScroll = tr;
        }

        trs.push(tr);
      }

      return trs;
    };

    fileBrowser.prototype.drawFiles = function (arr) {
      var files = [],
          trs = [],
          _this = this;

      for (var i = 0; i < arr.length; i++) {
        if (!arr[i].Directory) files.push(arr[i]);
      }

      files = files.sort(this.getCurrentSortFunc());

      for (var i = 0; i < files.length; i++) {
        var index = String(files[i].Name).lastIndexOf('.'),
            name = String(files[i].Name).substr(0, index),
            ext = String(files[i].Name).substr(index + 1, files[i].Name.length),
            tdReturn = _td$1();

        tdSize = _td$1([_t$1(this.makeSize(files[i].Size))], [['attr', 'size', files[i].Size], ['css', 'textAlign', 'right'], ['dir', 'className', 'invisible']]);

        if (this.returnMask.length && valueInArray(this.returnMask, ext.toLowerCase())) {
          var returnButton = makeImageButton$1("img/choose.png", "img/choose_a.png");
          returnButton.style.cursor = 'pointer';
          returnButton.style.marginLeft = '5px';

          _title$1(returnButton, _gtxt("Выбрать"));

          (function (i) {
            returnButton.onclick = function (e) {
              _this.close(_this._path.get() + files[i].Name);
            };
          })(i);

          _$7(tdReturn, [returnButton]);
        }

        var tr = _tr$1([tdReturn, _td$1([this.createFileActions(name, ext)]), _td$1([_t$1(ext)], [['css', 'textAlign', 'right'], ['css', 'fontSize', '12px']]), tdSize, _td$1([_t$1(this.formatDate(files[i].Date))], [['css', 'textAlign', 'center'], ['dir', 'className', 'invisible']])]);

        attachEffects$1(tr, 'hover');

        if (this.shownPath && files[i].Name == this.shownPath) {
          $(tr).children("td").css('backgroundColor', '#CEEECE');
          this.shownPath = null;
          this.shownPathScroll = tr;
        }

        trs.push(tr);
      }

      return trs;
    };

    fileBrowser.prototype.createFolderActions = function (name) {
      var span = _span$1([_t$1(name)], [['css', 'fontSize', '12px']]),
          spanParent = _div$1([span], [['css', 'display', 'inline-block'], ['css', 'position', 'relative']]),
          _this = this;

      nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'FileBrowserFolder', function () {
        return _this._path.isInHome() || nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_FILE_STRUCTURE);
      }, {
        fullPath: this._path.get() + name + this.slash,
        fileBrowser: this,
        enableZip: true
      });
      return spanParent;
    };

    fileBrowser.prototype.createFileActions = function (name, ext) {
      var span = _span$1([_t$1(name)], [['css', 'fontSize', '12px']]),
          spanParent = _div$1([span], [['css', 'display', 'inline-block'], ['css', 'position', 'relative']]),
          _this = this;

      nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'FileBrowserFile', function () {
        return _this._path.isInHome() || nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_FILE_STRUCTURE);
      }, {
        fullPath: this._path.get() + name + '.' + ext,
        fileBrowser: this,
        enableUnzip: valueInArray(_this.ext7z, ext.toUpperCase())
      });
      return spanParent;
    }; //TODO: translate


    fileBrowser.prototype.makeSize = function (size) {
      if (size > 1024 * 1024 * 1024) return (size / (1024 * 1024 * 1024)).toFixed(2) + ' Гб';else if (size > 1024 * 1024) return (size / (1024 * 1024)).toFixed(2) + ' Мб';else if (size > 1024) return (size / 1024).toFixed(2) + ' Кб';
      return size + ' б';
    };

    window.fileBrowser = fileBrowser;
    window._fileBrowser = new fileBrowser(); ///////////////////////////////////////////////////////////////////////////////
    ////////////////////////// Контекстное меню браузера //////////////////////////
    ///////////////////////////////////////////////////////////////////////////////
    //фабрика, которая может возвращать элементы меню для архивирования (isZip=true) и разархивирования (isZip=false)

    var zipUnzipActionFactory = function zipUnzipActionFactory(isZip) {
      return {
        title: function title() {
          return isZip ? _gtxt("Упаковать") : _gtxt("Извлечь");
        },
        clickCallback: function clickCallback(context) {
          context.fileBrowser._status.start();

          sendCrossDomainJSONRequest$2(window.serverBase + (context.enableUnzip ? 'FileBrowser/Unzip.ashx' : 'FileBrowser/Zip.ashx') + '?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function (response) {
            context.fileBrowser._status.stop();

            if (!parseResponse$1(response)) return;
            var indexSlash = String(response.Result).lastIndexOf('\\'),
                fileName = String(response.Result).substring(indexSlash + 1, response.Result.length);
            context.fileBrowser.shownPath = fileName;
            context.fileBrowser.getFiles();
          });
        },
        isVisible: function isVisible(context) {
          return isZip ? !context.enableUnzip : context.enableUnzip; //XOR
        }
      };
    };

    nsGmx$1.ContextMenuController.addContextMenuElem({
      title: function title() {
        return _gtxt("Скачать");
      },
      clickCallback: function clickCallback(context) {
        var form = _form([_input$1(null, [['attr', 'name', 'FullName'], ['attr', 'value', context.fullPath]])], [['css', 'display', 'none'], ['attr', 'method', 'POST'], ['attr', 'action', window.serverBase + "FileBrowser/Download.ashx"]]);

        _$7(document.body, [form]);

        form.submit();
        form.removeNode(true);
      }
    }, ['FileBrowserFolder', 'FileBrowserFile']);
    nsGmx$1.ContextMenuController.addContextMenuElem({
      title: function title() {
        return _gtxt("Удалить");
      },
      clickCallback: function clickCallback(context) {
        context.fileBrowser._status.start();

        sendCrossDomainJSONRequest$2(window.serverBase + 'FileBrowser/Delete.ashx?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function (response) {
          context.fileBrowser._status.stop();

          if (!parseResponse$1(response)) return;
          context.fileBrowser.getFiles();
        });
      }
    }, ['FileBrowserFolder', 'FileBrowserFile']);
    nsGmx$1.ContextMenuController.addContextMenuElem({
      title: function title() {
        return _gtxt("Очистить");
      },
      clickCallback: function clickCallback(context) {
        context.fileBrowser._status.start();

        sendCrossDomainJSONRequest$2(window.serverBase + 'FileBrowser/CleanFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(context.fullPath), function (response) {
          context.fileBrowser._status.stop();

          if (!parseResponse$1(response)) return;
          context.fileBrowser.getFiles();
        });
      }
    }, 'FileBrowserFolder'); //упаковываем и файлы и папки

    nsGmx$1.ContextMenuController.addContextMenuElem(zipUnzipActionFactory(true), ['FileBrowserFolder', 'FileBrowserFile']); //распаковываем только файлы

    nsGmx$1.ContextMenuController.addContextMenuElem(zipUnzipActionFactory(false), 'FileBrowserFile');

    var _$8 = nsGmx$1.Utils._; //Создание интерфейса редактирования свойств слоя

    /** Виджет для выбора полей для X и Y координат из списка полей
    * @function
    * @param parent {DOMElement} - контейнер для размещения виджета
    * @param columns {LatLngColumnsModel} - модель для сохранения выбранных колонок
    * @param sourceColumns {Array} - доступные для выбора колонки
    */

    var SelectLatLngColumnsWidget = function SelectLatLngColumnsWidget(parent, columns, sourceColumns) {
      var updateWidget = function updateWidget() {
        var parsedColumns = nsGmx$1.LayerProperties.parseColumns(sourceColumns);
        $(parent).empty();

        if (!parsedColumns.geomCount && parsedColumns.coordColumns.length) {
          var fields = parsedColumns.coordColumns;

          var selectLat = nsGmx$1.Utils._select(null, [['attr', 'selectLat', true], ['dir', 'className', 'selectStyle'], ['css', 'width', '150px'], ['css', 'margin', '0px']]),
              selectLon = nsGmx$1.Utils._select(null, [['attr', 'selectLon', true], ['dir', 'className', 'selectStyle'], ['css', 'width', '150px'], ['css', 'margin', '0px']]);

          selectLat.onchange = function () {
            columns.set('YCol', this.value);
          };

          selectLon.onchange = function () {
            columns.set('XCol', this.value);
          };

          for (var i = 0; i < fields.length; i++) {
            var opt = _option$1([_t$1(fields[i])], [['attr', 'value', fields[i]]]);

            _$8(selectLat, [opt.cloneNode(true)]);

            _$8(selectLon, [opt.cloneNode(true)]);
          }

          _$8(parent, [_table$1([_tbody$1([_tr$1([_td$1([_span$1([_t$1(_gtxt("Y (широта)"))], [['css', 'margin', '0px 3px']])], [['css', 'width', '73px'], ['css', 'border', 'none']]), _td$1([selectLat], [['css', 'width', '150px'], ['css', 'border', 'none']])]), _tr$1([_td$1([_span$1([_t$1(_gtxt("X (долгота)"))], [['css', 'margin', '0px 3px']])], [['css', 'width', '73px'], ['css', 'border', 'none']]), _td$1([selectLon], [['css', 'width', '150px'], ['css', 'border', 'none']])])])])]);

          if (columns.get('XCol')) {
            selectLon = switchSelect(selectLon, columns.get('XCol'));
          }

          if (columns.get('YCol')) {
            selectLat = switchSelect(selectLat, columns.get('YCol'));
          }

          columns.set({
            XCol: selectLon.value,
            YCol: selectLat.value
          });
        }
      };

      updateWidget();

      this.updateColumns = function (newFields) {
        sourceColumns = newFields;
        updateWidget();
      };
    };

    var getSourceColumns = function getSourceColumns(name) {
      var deferred = $.Deferred();
      sendCrossDomainJSONRequest$2(window.serverBase + "VectorLayer/GetSourceColumns.ashx?SourceName=" + encodeURIComponent(name), function (response) {
        if (!parseResponse$1(response)) {
          deferred.reject();
          return;
        }

        deferred.resolve(response.Result);
      });
      return deferred.promise();
    };

    var getFileExt = function getFileExt(path) {
      return String(path).substr(String(path).lastIndexOf('.') + 1, path.length);
    };
    /**
     Диалог редактирования свойств слоя с вкладками (tabs) и кнопкой "Сохранить" под ними
     @memberOf nsGmx
     @param {DOMElement} div Элемент дерева слоёв, соответствующий редактируемому слою
     @param {String} type тип слоя ("Vector" или "Raster")
     @param {DOMElement} parent контейнер, в которым нужно разместить диалог
     @param {Object} properties Параметры слоя. В том формате, в котором они приходят с сервера.
     @param {Object} [params] Дополнительные параметры
     @param {String[]} [params.standardTabs] Массив с названиями стандартных вкладок, которые нужно показывать. По умолчанию показывать все (main, attrs, metadata, advanced)
     @param {Object[]} [params.additionalTabs] Массив дополнительных вкладок со следующими полями:

       - {String} title Что будет написано но вкладке
       - {String} name Уникальный идентификатор вкладки
       - {DOMElement} container Контент вкладки

     @param {String} [params.selected] Идентификатор вкладки, которую нужно сделать активной
     @param {Function(controller)} [params.createdCallback] Ф-ция, которая будет вызвана после того, как диалог будет создан.
            В ф-цию передаётся объект со следующими свойствами:

       - {function(tabName)} selectTab Активизировать вкладку с идентификатором tabName

      @param {Object} [params.additionalUI] Хеш массивов с доп. UI во вкладках. Ключ хеша - ID вкладки (main, attrs, metadata, advanced)
      @param {Boolean} [params.copy] Является ли создаваемый слой копией
    */


    var LayerEditor = function LayerEditor(div, type, parent, properties, params) {
      /** Генерируется перед изменением/добавлением слоя. Может быть использован для сохранения в свойствах объекта каких-то внешних данных.
       * @event nsGmx.LayerEditor#premodify
       */
      var _params = $.extend({
        addToMap: true,
        doneCallback: null,
        standardTabs: ['main', 'attrs', 'metadata', 'advanced'],
        additionalUI: {}
      }, params); // меняем тип источника на 'Sql', если слой является копией


      if (_params.copy) {
        properties = JSON.parse(JSON.stringify(properties));
        properties.SourceType = 'Sql';
      }

      var _this = this;

      this._originalTabs = [];
      this._saveButton = null;

      this.selectTab = function (tabName) {
        var selectedTab = $(tabMenu).tabs('option', 'active');
        $.each(tabs, function (i, tab) {
          if (tab.name === tabName && i !== selectedTab) {
            $(tabMenu).tabs('option', 'active', i);
          }
        });
      };

      params = params || {};

      var genPageDiv = function genPageDiv() {
        return _div$1([_div$1(null, [['dir', 'className', 'layer-container-inner']])], [['dir', 'className', 'layer-container-outer']]);
      };

      var isReadonly = div && _queryMapLayers.layerRights(div.gmxProperties.content.properties.name) !== 'edit' && div.gmxProperties.content.properties.Access !== 'edit';

      var createUI = function createUI() {
        var divProperties = div ? div.gmxProperties.content.properties : !_params.copy ? {} : false,
            layerProperties = new nsGmx$1.LayerProperties(); // tabs = [];

        layerProperties.initFromViewer(type, divProperties, properties);
        _params = LayerEditor.applyInitHooks(_this, layerProperties, _params);
        var mainContainer = genPageDiv();
        var metadataContainer = genPageDiv();
        var advancedContainer = genPageDiv();
        var attrContainer = genPageDiv();

        if (_params.standardTabs.indexOf('main') >= 0) {
          _this._originalTabs.push({
            title: _gtxt('Общие'),
            name: 'main',
            container: mainContainer
          });
        }

        if (type === 'Vector' && _params.standardTabs.indexOf('attrs') >= 0) {
          _this._originalTabs.push({
            title: _gtxt('Колонки'),
            name: 'attrs',
            container: attrContainer
          });
        }

        if (!isReadonly) {
          if (_params.standardTabs.indexOf('metadata') >= 0) {
            _this._originalTabs.push({
              title: _gtxt('Метаданные'),
              name: 'metadata',
              container: metadataContainer
            });
          }

          if (type === 'Vector' && _params.standardTabs.indexOf('advanced') >= 0) {
            _this._originalTabs.push({
              title: _gtxt('Дополнительно'),
              name: 'advanced',
              container: advancedContainer
            });
          }
        }

        _this._saveButton = null;
        _this._saveButton = makeLinkButton$1(div ? _gtxt("Изменить") : _gtxt("Создать"));
        var origLayerProperties = layerProperties.clone();

        _this._createPageMain(mainContainer.firstChild, layerProperties, isReadonly, _params);

        _this._createPageMetadata(metadataContainer.firstChild, layerProperties, isReadonly, _params);

        if (type === 'Vector') {
          _this._createPageAdvanced(advancedContainer.firstChild, layerProperties, isReadonly, _params);

          _this._createPageAttributes(attrContainer.firstChild, layerProperties, isReadonly, _params);
        }

        for (var i in _params.additionalUI) {
          var tab = _$8.findWhere(_this._originalTabs, {
            name: i
          });

          if (tab) {
            var container = tab.container.firstChild;

            _params.additionalUI[i].forEach(function (ui) {
              $(container).append(ui);
            });
          }
        }

        if (div) {
          layerProperties.on({
            'change:Title': function changeTitle() {
              var title = layerProperties.get('Title');
              var span = $(div).find(".layer")[0];
              $(span).empty();

              _$8(span, [_t$1(title)]);

              divProperties.title = title;
            },
            'change:Copyright': function changeCopyright() {
              var copyright = layerProperties.get('Copyright');
              nsGmx$1.gmxMap.layersByID[layerProperties.get('Name')].options.attribution = copyright;

              nsGmx$1.leafletMap.gmxControlIconManager.get('copyright')._redraw();

              divProperties.Copyright = copyright;
            },
            'change:Description': function changeDescription() {
              var description = layerProperties.get('Description');
              var span = $(div).find(".layerDescription")[0];
              $(span).empty();
              span.innerHTML = description;
              divProperties.description = description;
            },
            'change:Legend': function changeLegend() {
              divProperties.Legend = layerProperties.get('Legend');
            },
            'change:NameObject': function changeNameObject() {
              divProperties.NameObject = layerProperties.get('NameObject');
            }
          });
        }

        _this._saveButton.onclick = function () {
          $(_this).trigger('premodify');

          var name = layerProperties.get('Name'),
              curBorder = _mapHelper.drawingBorders.get(name),
              oldDrawing = origLayerProperties.get('Geometry'),
              isVector = layerProperties.get('Type') === 'Vector',
              needRetiling = false; // если изменились поля с геометрией, то нужно тайлить заново и перегрузить слой в карте


          if (isVector || layerProperties.get('ShapePath').Path != origLayerProperties.get('ShapePath').Path || layerProperties.get('TilePath').Path != origLayerProperties.get('TilePath').Path || oldDrawing && typeof curBorder != 'undefined' || !oldDrawing && typeof curBorder != 'undefined' || oldDrawing && typeof curBorder == 'undefined') {
            needRetiling = true;
          }

          var def = layerProperties.save(needRetiling, null, _params),
              layerTitle = layerProperties.get('Title'); //doneCallback вызываем при первом progress notification - признаке того, что вызов непосредственно скрипта модификации слоя прошёл успешно

          var onceCallback = _$8.once(function () {
            _params.doneCallback && _params.doneCallback(def, layerTitle);
          });

          def.always(parseResponse$1);
          def.then(onceCallback, null, onceCallback);

          if (isVector && !name && layerProperties.get('SourceType') === 'manual') {
            if (_params.addToMap) {
              def.done(function (response) {
                var mapProperties = _layersTree.treeModel.getMapProperties(),
                    targetDiv = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0],
                    gmxProperties = {
                  type: 'layer',
                  content: response.Result
                };

                gmxProperties.content.properties.mapName = mapProperties.name;
                gmxProperties.content.properties.hostName = mapProperties.hostName;
                gmxProperties.content.properties.visible = true;
                gmxProperties.content.properties.styles = [{
                  MinZoom: 1,
                  MaxZoom: 21,
                  RenderStyle: gmxProperties.content.properties.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[gmxProperties.content.properties.GeometryType] : _mapHelper.defaultStyles[gmxProperties.content.properties.GeometryType]
                }];

                _layersTree.copyHandler(gmxProperties, targetDiv, false, true);
              });
            }
          } else {
            if (name) {
              _queryMapLayers.asyncUpdateLayer(def, properties, true);
            } else {
              if (_params.addToMap) {
                _queryMapLayers.asyncCreateLayer(def, layerTitle);
              }
            }
          }
        };
      };

      createUI();
      var id = 'layertabs' + (div ? div.gmxProperties.content.properties.name : '');
      var tabs = this._originalTabs;

      if (!isReadonly) {
        tabs = tabs.concat(params.additionalTabs || []);
      }

      var lis = [],
          containers = [];

      for (var t = 0; t < tabs.length; t++) {
        lis.push(_li$1([_a([_t$1(tabs[t].title)], [['attr', 'href', '#' + tabs[t].name + id]])]));
        containers.push(tabs[t].container);
        $(tabs[t].container).attr('id', tabs[t].name + id);
      }

      var tabMenu = _div$1([_ul$1(lis)].concat(containers));

      var saveMenuCanvas;

      if (isReadonly) {
        saveMenuCanvas = _div$1([_t$1(_gtxt("Недостаточно прав для редактирования настроек слоя"))], [['css', 'padding', '5px 0px 5px 5px'], ['css', 'color', 'red']]);
      } else {
        saveMenuCanvas = _div$1([this._saveButton]);
      }

      $(parent).empty().append(_table$1([_tr$1([_td$1([tabMenu])], [['css', 'height', '100%'], ['css', 'verticalAlign', 'top']]), _tr$1([_td$1([_div$1(null, [['css', 'height', '1px']]), saveMenuCanvas])])], [['css', 'height', '100%'], ['css', 'width', '100%'], ['css', 'position', 'relative']]));

      var getTabIndex = function getTabIndex(tabName) {
        for (var i = 0; i < tabs.length; i++) {
          if (tabs[i].name === tabName) return i;
        }

        return -1;
      };

      var selectIndex = getTabIndex(params.selected);
      $(tabMenu).tabs({
        active: selectIndex > -1 ? selectIndex : 0,
        activate: function activate(event, ui) {
          var activeIndex = $(tabMenu).tabs('option', 'active');
          $(saveMenuCanvas).toggle(activeIndex < _this._originalTabs.length);
        }
      });
      $(saveMenuCanvas).toggle(selectIndex < this._originalTabs.length);
      params.createdCallback && params.createdCallback(this);
    };

    LayerEditor.prototype._createPageMain = function (parent, layerProperties, isReadonly, params) {
      var title = _input$1(null, [['attr', 'fieldName', 'title'], ['attr', 'value', layerProperties.get('Title')], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

      title.onkeyup = function () {
        layerProperties.set('Title', this.value);
        return true;
      };

      layerProperties.on('change:Title', function () {
        var newTitle = layerProperties.get('Title');

        if (newTitle !== title.value) {
          title.value = newTitle;
        }
      });

      var copyright = _input$1(null, [['attr', 'fieldName', 'copyright'], ['attr', 'value', layerProperties.get('Copyright')], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

      copyright.onkeyup = function () {
        layerProperties.set('Copyright', this.value);
        return true;
      };

      var legend = _input$1(null, [['attr', 'fieldName', 'Legend'], ['attr', 'value', layerProperties.get('Legend')], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

      legend.onkeyup = legend.onchange = function () {
        layerProperties.set('Legend', this.value);
        return true;
      };

      var descr = _textarea$1(null, [['attr', 'fieldName', 'description'], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px'], ['css', 'height', '50px']]);

      descr.onkeyup = function () {
        layerProperties.set('Description', this.value);
        return true;
      };

      descr.value = layerProperties.get('Description');
      var currentGeometryType = layerProperties.get('GeometryType');
      var geometryTitle = null;
      var geometryTypes = [{
        title: _gtxt('полигоны'),
        type: 'polygon'
      }, {
        title: _gtxt('линии'),
        type: 'linestring'
      }, {
        title: _gtxt('точки'),
        type: 'point'
      }];

      for (var i = 0; i < geometryTypes.length; i++) {
        if (currentGeometryType === geometryTypes[i].type) {
          geometryTitle = geometryTypes[i].title;
        }
      }

      var geometryType = _input$1(null, [['attr', 'fieldName', 'geom_type'], ['attr', 'value', geometryTitle], ['attr', 'disabled', 'disabled'], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

      var shownProperties = [];
      shownProperties.push({
        name: _gtxt("Имя"),
        field: 'Title',
        elem: title
      });
      shownProperties.push({
        name: _gtxt("Копирайт"),
        field: 'Copyright',
        elem: copyright
      });

      if (layerProperties.get('Name')) {
        shownProperties.push({
          name: _gtxt("ID"),
          field: 'Name'
        });
      }

      shownProperties.push({
        name: _gtxt("Описание"),
        field: 'Description',
        elem: descr
      });

      if (layerProperties.get('Type') === "Vector" && layerProperties.get('Geometry') !== undefined) {
        shownProperties.push({
          name: _gtxt("Геометрия"),
          field: 'geometryType',
          elem: geometryType
        });
      }

      if (layerProperties.get('Type') != "Vector") {
        var selectImage = new mapHelper$1.ImageSelectionWidget();
        selectImage.on('selected', function (url) {
          var imgHtml = '<img src="' + url + '"></img>';
          legend.value = imgHtml;
          layerProperties.set('Legend', imgHtml);
        });
        var tr = $(Handlebars.compile('<tr>' + '<td class="propertiesTable-title">{{i "Легенда"}}<span class="layer-editor-legend-image"></span></td>' + '<td class="layer-editor-legend"></td>' + '</tr>')());
        tr.find('.layer-editor-legend-image').append(selectImage.el);
        tr.find('.layer-editor-legend').append(legend);
        shownProperties.push({
          tr: tr[0]
        });
      }

      if (!isReadonly) {
        if (layerProperties.get('Type') === "Vector") {
          shownProperties = shownProperties.concat(!params.copy ? this._createPageVectorSource(layerProperties, params) : []);
        } else if (layerProperties.get('Type') === "Raster") {
          shownProperties = shownProperties.concat(this._createPageRasterSource(layerProperties));
        }
      }

      var trs = _mapHelper.createPropertiesTable(shownProperties, layerProperties.attributes, {
        leftWidth: 70
      });

      _$8(parent, [_table$1([_tbody$1(trs)], [['dir', 'className', 'propertiesTable']])]);

      if (isReadonly) {
        $(parent).find('input, textarea').prop('disabled', true);
      }
    };

    LayerEditor.prototype._createPageVectorSource = function (layerProperties, params) {
      var _this = this;

      var LatLngColumnsModel = new gmxCore$1.getModule('LayerProperties').LatLngColumnsModel;
      var shownProperties = [];
      var layerName = layerProperties.get('Name');
      var sourceType = layerProperties.get('SourceType');
      /*------------ Источник: файл ------------*/

      var shapePath = layerProperties.get('ShapePath');

      var shapePathInput = _input$1(null, [['attr', 'fieldName', 'ShapePath.Path'], ['attr', 'value', shapePath.Path || ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '200px']]),
          shapeFileLink = makeImageButton$1("img/choose2.png", "img/choose2_a.png"),
          encodingParent = _div$1(),
          xlsColumnsParent = _div$1();

      shapePathInput.onkeyup = shapePathInput.onchange = function () {
        layerProperties.set('ShapePath', {
          Path: this.value
        });
      };

      var fileSourceColumns = sourceType === 'file' ? layerProperties.get('Columns') : [];
      var fileSelectedColumns = sourceType === 'file' ? layerProperties.get('GeometryColumnsLatLng') : new LatLngColumnsModel();
      var fileColumnsWidget = !params.copy ? new SelectLatLngColumnsWidget(xlsColumnsParent, fileSelectedColumns, fileSourceColumns) : null;
      shapeFileLink.style.marginLeft = '3px';
      var encodingWidget = new nsGmx$1.ShpEncodingWidget();
      shapePathInput.oldValue = shapePathInput.value;
      $(encodingWidget).change(function () {
        layerProperties.set('EncodeSource', encodingWidget.getServerEncoding());
      });

      if (getFileExt(shapePathInput.value) === 'shp') {
        encodingWidget.drawWidget(encodingParent, layerProperties.get('EncodeSource'));
      }

      if (shapePath && shapePath.Path != null && shapePath.Path != '' && !shapePath.Exists) {
        $(shapePathInput).addClass('error');
      } //TODO: использовать события модели


      shapeFileLink.onclick = function () {
        window._fileBrowser.createBrowser(_gtxt("Файл"), ['shp', 'tab', 'xls', 'xlsx', 'xlsm', 'mif', 'gpx', 'kml', 'csv', 'sxf', 'gdbtable', 'geojson', 'kmz', 'sqlite'], function (path) {
          shapePathInput.value = path;
          layerProperties.set('ShapePath', {
            Path: path
          });
          var index = String(path).lastIndexOf('.'),
              ext = String(path).substr(index + 1, path.length);

          if (layerProperties.get('Title') == '') {
            var indexSlash = String(path).lastIndexOf('\\'),
                fileName = String(path).substring(indexSlash + 1, index);
            layerProperties.set('Title', fileName);
          }

          getSourceColumns(path).done(function (sourceColumns) {
            layerProperties.set('Columns', sourceColumns);
            fileSourceColumns = sourceColumns;
          });
          $(encodingParent).empty();

          if (ext === 'shp') {
            encodingWidget.drawWidget(encodingParent);
          }
        });
      };

      var sourceFile = _div$1(null, [['dir', 'id', 'fileSource' + layerName]]);

      _$8(sourceFile, [shapePathInput, shapeFileLink, encodingParent, xlsColumnsParent
      /*, fileAddAttribute, fileColumnsContainer*/
      ]);
      /*------------ Источник: таблица ------------*/


      var tableLink = makeImageButton$1("img/choose2.png", "img/choose2_a.png"),
          tableColumnsParent = _div$1();

      var tableSourceColumns = sourceType === 'table' ? layerProperties.get('Columns') : [];
      var tableSelectedColumns = sourceType === 'table' ? layerProperties.get('GeometryColumnsLatLng') : new LatLngColumnsModel();
      var tableColumnsWidget = new SelectLatLngColumnsWidget(tableColumnsParent, tableSelectedColumns, tableSourceColumns);

      var tablePathInput = _input$1(null, [['attr', 'fieldName', 'TableName'], ['attr', 'value', layerProperties.get('TableName') || ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '200px']]);

      tablePathInput.onkeyup = tablePathInput.onchange = function () {
        layerProperties.set('TableName', this.value);
      };

      tableLink.onclick = function () {
        _tableBrowser.createBrowser(function (name) {
          tablePathInput.value = name;
          layerProperties.set('TableName', name);

          if (layerProperties.get('Title') == '') {
            layerProperties.set('Title', name);
          }

          getSourceColumns(name).done(function (sourceColumns) {
            layerProperties.set('Columns', sourceColumns);
            tableSourceColumns = sourceColumns;
          });
        });
      };

      tableLink.style.marginLeft = '3px';

      var TableCSParent = _div$1();

      var TableCSSelect = $('<select/>', {
        'class': 'selectStyle'
      }).css('width', '165px').append($('<option>').val('EPSG:4326').text(_gtxt('Широта/Долгота (EPSG:4326)'))).append($('<option>').val('EPSG:3395').text(_gtxt('Меркатор (EPSG:3395)'))).change(function () {
        layerProperties.set('TableCS', $(this).find(':selected').val());
      });

      if (layerProperties.get('TableCS')) {
        TableCSSelect.find('[value="' + layerProperties.get('TableCS') + '"]').attr('selected', 'selected');
      }

      $(TableCSParent).append($('<span/>').text(_gtxt('Проекция')).css('margin', '3px')).append(TableCSSelect);

      var sourceTable = _div$1([tablePathInput, tableLink, TableCSParent, tableColumnsParent], [['dir', 'id', 'tableSource' + layerName]]);
      /*------------ Источник: вручную ------------*/


      var geometryTypes = [{
        title: _gtxt('полигоны'),
        type: 'polygon',
        className: 'manual-polygon'
      }, {
        title: _gtxt('линии'),
        type: 'linestring',
        className: 'manual-linestring'
      }, {
        title: _gtxt('точки'),
        type: 'point',
        className: 'manual-point'
      }];

      var RadioButtonsWidget = function RadioButtonsWidget(container, buttons, activeType) {
        var _this = this;

        var _activeType = activeType || buttons[0].type;

        $(container).empty().addClass('manual-type-widget');

        for (var b = 0; b < buttons.length; b++) {
          $('<div/>').addClass(buttons[b].className).toggleClass('manual-active-type', _activeType === buttons[b].type).attr('title', buttons[b].title).appendTo(container).data('type', buttons[b].type);
        }

        $('div', container).click(function () {
          $(this).siblings().removeClass('manual-active-type');
          $(this).addClass('manual-active-type');
          _activeType = $(this).data('type');
          $(_this).change();
        });

        this.getActiveType = function () {
          return _activeType;
        };
      };

      var geometryTypeContainer = $('<div/>').css({
        'display': 'inline-block',
        'vertical-align': 'middle'
      });
      var geometryTypeWidget = new RadioButtonsWidget(geometryTypeContainer, geometryTypes, layerProperties.get('GeometryType'));
      $(geometryTypeWidget).change(function () {
        layerProperties.set('GeometryType', geometryTypeWidget.getActiveType());
      });
      layerProperties.set('GeometryType', geometryTypeWidget.getActiveType());
      var editAttributeLink = $('<span/>').addClass('buttonLink').text(_gtxt('Редактировать колонки')).click(function () {
        _this.selectTab('attrs');
      });

      var attrViewParent = _div$1();

      var geometryTypeTitle = _span$1([_t$1(_gtxt('Геометрия') + ': ')], [['css', 'height', '20px'], ['css', 'verticalAlign', 'middle']]);

      var attrContainer = _div$1([_div$1([layerName ? _div$1() : _div$1([geometryTypeTitle, geometryTypeContainer[0]]), editAttributeLink[0]]), _div$1([attrViewParent], [['css', 'margin', '3px']])], [['css', 'marginLeft', '3px']]);

      var sourceManual = _div$1([attrContainer], [['dir', 'id', 'manualSource' + layerName]]);
      /*------------ Общее ------------*/


      layerProperties.on({
        'change:Columns': function changeColumns() {
          var columns = layerProperties.get('Columns');
          tableColumnsWidget.updateColumns(columns);
          fileColumnsWidget && fileColumnsWidget.updateColumns(columns);
        }
      });
      /*------------ Переключалка источника слоя ------------*/

      var sourceContainers = [sourceFile, sourceTable, sourceManual];
      var template = Handlebars.compile('<form>' + '<label><input type="radio" name="sourceCheckbox" id="chxFileSource" data-container-idx="0" checked>{{i "Файл"}}</label><br/>' + '{{#unless copy}}' + '{{#if admin}}<label><input type="radio" name="sourceCheckbox" id="chxTableSource" data-container-idx="1">{{i "Таблица"}}</label><br/>{{/if}}' + '<label><input type="radio" name="sourceCheckbox" id="chxManualSource" data-container-idx="2">{{i "Вручную"}}</label>' + '{{/unless}}' + '</form>');
      var sourceCheckbox = $(template({
        admin: nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN),
        copy: params.copy
      }));
      sourceCheckbox.find('input, label').css({
        verticalAlign: 'middle'
      });
      sourceCheckbox.find('input').css({
        marginRight: 2
      });
      sourceCheckbox.find('input').click(function () {
        var activeIdx = $(this).data('containerIdx');
        $(sourceTab).tabs('option', 'active', activeIdx);
      });
      var activeCheckboxID = {
        'file': 'chxFileSource',
        'table': 'chxTableSource',
        'manual': 'chxManualSource'
      }[sourceType];
      $('#' + activeCheckboxID, sourceCheckbox).attr('checked', 'checked');

      var sourceTab = _div$1([_ul$1([_li$1([_a([_t$1(_gtxt('Файл'))], [['attr', 'href', '#fileSource' + layerName]])]), _li$1([_a([_t$1(_gtxt('Таблица'))], [['attr', 'href', '#tableSource' + layerName]])]), _li$1([_a([_t$1(_gtxt('Вручную'))], [['attr', 'href', '#manualSource' + layerName]])])], [['css', 'display', 'none']])]);

      var selectedSource = {
        'file': 0,
        'table': 1,
        'manual': 2
      }[sourceType];

      _$8(sourceTab, sourceContainers);

      $(sourceTab).tabs({
        active: selectedSource,
        activate: function activate(event, ui) {
          var selectedSource = $(sourceTab).tabs('option', 'active');

          if (selectedSource == 0) {
            layerProperties.set('Columns', fileSourceColumns);
            layerProperties.set('SourceType', 'file');
            layerProperties.set('GeometryColumnsLatLng', fileSelectedColumns);
          } else if (selectedSource == 1) {
            layerProperties.set('Columns', tableSourceColumns);
            layerProperties.set('SourceType', 'table');
            layerProperties.set('GeometryColumnsLatLng', tableSelectedColumns);
            layerProperties.set('TableCS', TableCSSelect.find(':selected').val());
          } else if (selectedSource == 2) {
            layerProperties.set('SourceType', 'manual');
          }
        }
      });
      var sourceTr2;

      if (!layerName) {
        sourceTr2 = _tr$1([_td$1([sourceCheckbox[0]], [['css', 'padding', '5px'], ['css', 'verticalAlign', 'top'], ['css', 'lineHeight', '18px']]), _td$1([_div$1([sourceTab])])]);
      } else {
        var sourceTitle = {
          'file': _gtxt('Файл'),
          'table': _gtxt('Таблица'),
          'manual': _gtxt('Вручную')
        }[sourceType];
        var sourceControls = {
          'file': sourceFile,
          'table': sourceTable,
          'manual': sourceManual
        }[sourceType];
        sourceTr2 = _tr$1([_td$1([_t$1(_gtxt("Источник") + ': ' + sourceTitle)], [['css', 'padding', '5px'], ['css', 'verticalAlign', 'top'], ['css', 'lineHeight', '18px']]), _td$1([sourceControls])]);
      }

      if (!layerName || sourceType !== 'manual') {
        shownProperties.push({
          tr: sourceTr2
        });
      }

      return shownProperties;
    };

    LayerEditor.prototype._createPageRasterSource = function (layerProperties) {
      var shapePath = layerProperties.get('ShapePath');
      var tilePath = layerProperties.get('TilePath');
      var name = layerProperties.get('Name');

      var shapePathInput = _input$1(null, [['attr', 'fieldName', 'ShapePath.Path'], ['attr', 'value', shapePath.Path || ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]),
          tilePathInput = _input$1(null, [['attr', 'fieldName', 'TilePath.Path'], ['attr', 'value', tilePath.Path || ''], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]),
          tileCatalogLink = makeImageButton$1("img/choose2.png", "img/choose2_a.png"),
          tileFileLink = makeImageButton$1("img/choose2.png", "img/choose2_a.png"),
          shapeLink = makeImageButton$1("img/choose2.png", "img/choose2_a.png"),
          drawingBorderLink = makeImageButton$1("img/choose2.png", "img/choose2_a.png"),
          drawingBorderDescr = _span$1(null, [['attr', 'id', 'drawingBorderDescr' + name], ['css', 'color', '#215570'], ['css', 'marginLeft', '3px']]),
          removeBorder = makeImageButton$1('img/closemin.png', 'img/close_orange.png'),
          divBorder = _div$1([drawingBorderDescr, removeBorder]),
          isAdmin = nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN),
          catalogPathElems = [_t$1(_gtxt("Каталог")), tileCatalogLink, _br$1()],
          filePathElems = [_t$1(_gtxt("Файл")), tileFileLink],
          trPath = _tr$1([_td$1(isAdmin ? catalogPathElems.concat(filePathElems) : filePathElems, [['css', 'paddingLeft', '5px'], ['css', 'fontSize', '12px']]), _td$1([tilePathInput])]),
          trShape = _tr$1([_td$1([_t$1(_gtxt("Граница")), shapeLink], [['css', 'paddingLeft', '5px'], ['css', 'fontSize', '12px']]), _td$1([shapePathInput, divBorder])]),
          shapeVisible = function shapeVisible(flag) {
        if (flag) {
          shapePathInput.style.display = '';
          divBorder.style.display = 'none';
        } else {
          shapePathInput.style.display = 'none';
          divBorder.style.display = '';
        }
      };

      divBorder.style.cssText = "height:22px; padding-top:3px;";
      removeBorder.style.cssText = "height:16px;padding:0;width:16px;cursor:pointer;margin:-1px 0px -3px 5px;";

      _title$1(removeBorder, _gtxt("Удалить"));

      tilePathInput.onchange = tilePathInput.oninput = function () {
        layerProperties.set('TilePath', {
          Path: this.value
        });
      };

      shapePathInput.onchange = shapePathInput.oninput = function () {
        layerProperties.set('ShapePath', {
          Path: this.value
        });
      };

      removeBorder.onclick = function () {
        shapeVisible(true);

        _mapHelper.drawingBorders.removeRoute(name, true);

        layerProperties.set('Geometry', null);
      };

      if (name) {
        _$8(trShape.firstChild, [_br$1(), _t$1(_gtxt("Контур")), drawingBorderLink]);

        if (shapePath.Path) shapeVisible(true);else {
          shapeVisible(false);
          var geometry = layerProperties.get('Geometry');
          var geom = L.gmxUtil.geometryToGeoJSON(geometry, true);
          var drawingBorder = nsGmx$1.leafletMap.gmxDrawing.addGeoJSON(geom)[0];

          _mapHelper.drawingBorders.set(name, drawingBorder);

          _mapHelper.drawingBorders.updateBorder(name, drawingBorderDescr);
        }
      } else {
        shapeVisible(true);
      }

      if (shapePath && shapePath.Path != null && shapePath.Path != '' && !shapePath.Exists) $(shapePathInput).addClass('error');
      if (tilePath.Path != null && tilePath.Path != '' && !tilePath.Exists) $(tilePathInput).addClass('error');

      tileCatalogLink.onclick = function () {
        _fileBrowser.createBrowser(_gtxt("Каталог"), [], function (path) {
          tilePathInput.value = path;
          layerProperties.set('TilePath', {
            Path: path
          });

          if (!layerProperties.get('Title')) {
            path = path.substring(0, path.length - 1); //убираем слеш на конце

            var indexSlash = String(path).lastIndexOf('\\'),
                fileName = String(path).substring(indexSlash + 1, path.length);
            layerProperties.set('Title', fileName);
          }
        });
      };

      var appendMetadata = function appendMetadata(data) {
        var layerTags = layerProperties.get('MetaProperties');
        if (!data || !layerTags) return; // var convertedTagValues = {};

        for (var mp in data) {
          var tagtype = data[mp].Type;
          layerTags.addNewTag(mp, nsGmx$1.Utils.convertFromServer(tagtype, data[mp].Value), tagtype);
        }

        if (!layerProperties.get('Title')) {
          var platform = layerTags.getTagByName('platform');
          var dateTag = layerTags.getTagByName('acqdate');
          var timeTag = layerTags.getTagByName('acqtime');

          if (typeof platform !== 'undefined' && typeof dateTag !== 'undefined' && typeof timeTag !== 'undefined') {
            var timeOffset = new Date().getTimezoneOffset() * 60 * 1000;
            var dateInt = nsGmx$1.Utils.convertToServer('Date', dateTag.value);
            var timeInt = nsGmx$1.Utils.convertToServer('Time', timeTag.value);
            var date = new Date((dateInt + timeInt) * 1000 + timeOffset);
            var dateString = $.datepicker.formatDate('yy.mm.dd', date);
            var timeString = $.datepicker.formatTime('HH:mm', {
              hour: date.getHours(),
              minute: date.getMinutes()
            });
            layerProperties.set('Title', platform.value + '_' + dateString + '_' + timeString + '_UTC');
          }
        }
      };

      tileFileLink.onclick = function () {
        _fileBrowser.createBrowser(_gtxt("Файл"), ['jpeg', 'jpg', 'tif', 'tiff', 'bmp', 'png', 'img', 'tiles', 'cpyr', 'mbtiles'], function (path) {
          tilePathInput.value = path;
          layerProperties.set('TilePath', {
            Path: path
          });
          sendCrossDomainJSONRequest$2(window.serverBase + 'Layer/GetMetadata.ashx?basepath=' + encodeURIComponent(path), function (response) {
            if (!parseResponse$1(response)) return;
            appendMetadata(response.Result.MetaProperties);

            if (!layerProperties.get('Title')) {
              var indexExt = String(path).lastIndexOf('.');
              var indexSlash = String(path).lastIndexOf('\\'),
                  fileName = String(path).substring(indexSlash + 1, indexExt);
              layerProperties.set('Title', fileName);
            }
          });
        });
      };

      shapeLink.onclick = function () {
        _fileBrowser.createBrowser(_gtxt("Граница"), ['mif', 'tab', 'shp', 'geojson', 'kmz'], function (path) {
          shapePathInput.value = path;
          layerProperties.set('ShapePath', {
            Path: path
          });

          _mapHelper.drawingBorders.removeRoute(name, true);

          shapeVisible(true);
          sendCrossDomainJSONRequest$2(window.serverBase + 'Layer/GetMetadata.ashx?geometryfile=' + encodeURIComponent(path), function (response) {
            if (!parseResponse$1(response)) return;
            appendMetadata(response.Result.MetaProperties);
          });
        });
      };

      drawingBorderLink.onclick = function () {
        nsGmx$1.Controls.chooseDrawingBorderDialog(name, function (polygon) {
          _mapHelper.drawingBorders.set(name, polygon);

          _mapHelper.drawingBorders.updateBorder(name);

          shapeVisible(false);
        }, {
          geomType: 'POLYGON',
          errorMessage: _gtxt("$$phrase$$_17")
        });
      };

      tileCatalogLink.style.marginLeft = '3px';
      tileFileLink.style.marginLeft = '3px';
      shapeLink.style.marginLeft = '3px';
      drawingBorderLink.style.marginLeft = '3px';
      var shownProperties = [{
        tr: trPath
      }, {
        tr: trShape
      }];
      return shownProperties;
    };

    LayerEditor.prototype._createPageAttributes = function (parent, props, isReadonly, params) {
      var isNewLayer = !props.get('Name');

      var fileColumnsContainer = _div$1();

      var fileAttrModel = new nsGmx$1.ManualAttrModel(props.get('RC').get('IsRasterCatalog'));
      var type = props.get('SourceType');

      if (isNewLayer) {
        props.on('change:Columns', function () {
          if (props.get('SourceType') !== 'manual' && props.get('SourceType') !== 'Sql') {
            fileAttrModel.initFromServerFormat(props.get('Columns'));
          }
        });
      }

      fileAttrModel.initFromServerFormat(props.get('Columns'));
      var fileAttrView = new nsGmx$1.ManualAttrView();
      fileAttrView.init(fileColumnsContainer, fileAttrModel, {
        copy: params.copy
      });
      var allowEdit = !isReadonly && (type === 'manual' || !isNewLayer && type === 'file' || params.copy);
      fileAttrView.setActive(allowEdit);
      $(fileAttrModel).change(function () {
        var isManual = props.get('SourceType') === 'manual';
        props.set('Columns', fileAttrModel.toServerFormat());
      });

      _$8(parent, [fileColumnsContainer]);

      props.on('change:SourceType', function () {
        var type = props.get('SourceType');
        var allowEdit = type === 'manual' || !isNewLayer && type === 'file';
        fileAttrModel.initFromServerFormat(props.get('Columns'));
        fileAttrView.setActive(allowEdit);
      });
    };

    LayerEditor.prototype._createPageMetadata = function (parent, layerProperties) {
      nsGmx$1.TagMetaInfo.loadFromServer(function (tagsInfo) {
        var layerTags = layerProperties.get('MetaProperties');
        nsGmx$1.LayerTagsWithInfo.call(layerTags, tagsInfo);
        new nsGmx$1.LayerTagSearchControl(layerTags, parent);
      });
    };

    LayerEditor.prototype._createPageAdvanced = function (parent, layerProperties) {
      //мультивременной слой
      var temporalLayerParent = _div$1(null, [['dir', 'className', 'TemporalLayer']]);

      var temporalProperties = layerProperties.get('Temporal');
      var temporalLayerView = new nsGmx$1.TemporalLayerParamsWidget(temporalLayerParent, temporalProperties, []);
      var isTemporalCheckbox = $('<input/>').attr({
        type: 'checkbox'
      }).change(function () {
        temporalProperties.set('isTemporal', this.checked);
      });

      var updateTemporalVisibility = function updateTemporalVisibility() {
        var isTemporal = temporalProperties.get('isTemporal');

        if (isTemporal) {
          temporalFieldset.children('fieldset').removeAttr('disabled');
        } else {
          temporalFieldset.children('fieldset').attr('disabled', 'disabled');
        }

        if (isTemporalCheckbox[0].checked != isTemporal) {
          isTemporalCheckbox[0].checked = isTemporal;
        }
      };

      var updateTemporalColumns = function updateTemporalColumns() {
        var parsedColumns = nsGmx$1.LayerProperties.parseColumns(layerProperties.get('Columns'));
        temporalLayerView.updateColumns(parsedColumns.dateColumns);

        if (parsedColumns.dateColumns.length === 0) {
          isTemporalCheckbox.attr('disabled', 'disabled');
          $('legend label', temporalFieldset).css('color', 'gray');
          $('legend', temporalFieldset).attr('title', _gtxt("Отсутствует временной атрибут"));
          temporalProperties.set('isTemporal', false);
        } else {
          isTemporalCheckbox.removeAttr('disabled');
          $('legend label', temporalFieldset).css('color', '');
          $('legend', temporalFieldset).removeAttr('title');
        }
      };

      temporalProperties.on('change:isTemporal', updateTemporalVisibility);
      layerProperties.on('change:Columns', updateTemporalColumns);
      var temporalFieldset = $('<fieldset/>').addClass('layer-fieldset').append($('<legend/>').append($('<label/>').append(isTemporalCheckbox).append(_gtxt("Данные с датой"))), $('<fieldset/>').append(temporalLayerParent) //вложенный fieldset нужен из-за бага в Opera
      ).appendTo(parent);
      updateTemporalVisibility();
      updateTemporalColumns(); //каталог растров

      var RCTemplate = Handlebars.compile('<fieldset class="layer-fieldset">' + '<legend><label>' + '<input type="checkbox" id="rc-params-isRC" {{#isRC}}checked{{/isRC}}>{{i "Каталог растров"}}' + '</label></legend>' + //вложенный fieldset нужен из-за бага в Opera
      '<fieldset {{^isRC}}disabled="disabled"{{/isRC}}><div id="rc-params-div"></div></fieldset>' + '</fieldset>');
      var rcFieldset = $(RCTemplate({
        isRC: layerProperties.get('RC').get('IsRasterCatalog')
      })).appendTo(parent);
      var rasterCatalogControl = new nsGmx$1.LayerRasterCatalogWidget($('#rc-params-div', rcFieldset), layerProperties.get('RC'));
      var quicklookTemplate = Handlebars.compile('<fieldset class="layer-fieldset">' + '<legend>{{i "Накладываемое изображение"}}</legend>' + '<div class="layer-editor-quicklooks"></div>' + '</fieldset>');
      var quicklookFieldset = $(quicklookTemplate()).appendTo(parent);
      var quicklookWidget = new nsGmx$1.LayerQuicklookWidget($('.layer-editor-quicklooks', quicklookFieldset), layerProperties);
      $('#rc-params-isRC', rcFieldset).change(function () {
        layerProperties.get('RC').set('IsRasterCatalog', this.checked);
        rcFieldset.children('fieldset').prop('disabled', !this.checked);
      }); //Шаблон имени

      var nameObjectInput = _input$1(null, [['attr', 'fieldName', 'NameObject'], ['attr', 'value', layerProperties.get('NameObject')], ['dir', 'className', 'inputStyle'], ['css', 'width', '220px']]);

      nameObjectInput.onkeyup = function () {
        layerProperties.set('NameObject', this.value);
        return true;
      };

      $('<div/>').append($('<span/>').text(_gtxt("Шаблон названий объектов")).css('margin-left', '5px'), nameObjectInput).appendTo(parent);
    };

    LayerEditor._initHooks = [];

    LayerEditor.addInitHook = function (hook) {
      LayerEditor._initHooks.push(hook);
    };

    LayerEditor.applyInitHooks = function (layerEditor, layerProperties, params) {
      LayerEditor._initHooks.forEach(function (hook) {
        params = hook(layerEditor, layerProperties, params) || params;
      });

      return params;
    };

    var createLayerEditor = function createLayerEditor(div, type, parent, properties, params) {
      var def = $.Deferred();
      params = $.extend(true, {}, params);

      params.createdCallback = function () {
        def.resolve(layerEditor);
      };

      var layerEditor = new LayerEditor(div, type, parent, properties, params);
      return def;
    };

    nsGmx$1.LayerEditor = LayerEditor;
    gmxCore$1.addModule('LayerEditor', {
      createLayerEditor: createLayerEditor,
      LayerEditor: LayerEditor
    }, {
      require: ['LayerProperties']
    });

    var nsMapCommon = function ($) {
      var publicInterface = {
        generateWinniePermalink: function generateWinniePermalink() {
          var mapProps = nsGmx.gmxMap.properties,
              lmap = nsGmx.leafletMap,
              center = lmap.getCenter(),
              layersState = {
            expanded: {},
            visible: {}
          };

          _layersTree.treeModel.forEachNode(function (elem) {
            var props = elem.content.properties;

            if (elem.type == 'group') {
              var groupId = props.GroupID;

              if ($("div[GroupID='" + groupId + "']").length || props.changedByViewer) {
                layersState.expanded[groupId] = props.expanded;
              }
            } else {
              if (props.changedByViewer) {
                layersState.visible[props.name] = props.visible;
              }
            }
          });

          var config = {
            app: {
              gmxMap: {
                mapID: mapProps.name,
                apiKey: window.apiKey
              }
            },
            state: {
              map: {
                position: {
                  x: center.lng,
                  y: center.lat,
                  z: lmap.getZoom()
                }
              },
              calendar: nsGmx.widgets.commonCalendar.getDateInterval().saveState(),
              baseLayersManager: lmap.gmxBaseLayersManager.saveState(),
              layersTree: layersState
            }
          };
          return nsGmx.Utils.TinyReference.create(config, false);
        },

        /**
        * Выбирает данные из дерева слоёв по описанию слоёв и групп
        * @param {FlashMapObject} map - текущая карта
        * @param {object} mapTree - дерево, в котором нужно искать
        * @param {array} description - массив с описанием нужных слоёв. Каждый элемент массива может быть либо строкой (имя слоя), либо объектом {group: '<groupName>'} - выбрать все слои из группы
        */
        selectLayersFromTree: function selectLayersFromTree(map, mapTree, description) {
          var _array = [];
          var _hash = {};

          var _getLayersInGroup = function _getLayersInGroup(map, mapTree, groupTitle) {
            var res = {};

            var visitor = function visitor(treeElem, isInGroup) {
              if (treeElem.type === "layer" && isInGroup) {
                res[treeElem.content.properties.name] = map.layers[treeElem.content.properties.name];
              } else if (treeElem.type === "group") {
                isInGroup = isInGroup || treeElem.content.properties.title == groupTitle;
                var a = treeElem.content.children;

                for (var k = a.length - 1; k >= 0; k--) {
                  visitor(a[k], isInGroup);
                }
              }
            };

            visitor({
              type: "group",
              content: {
                children: mapTree.children,
                properties: {}
              }
            }, false);
            return res;
          };

          for (var k = 0; k < description.length; k++) {
            if (typeof description[k] === "string") {
              _hash[description[k]] = map.layers[description[k]];

              _array.push(map.layers[description[k]]);
            } else if ('group' in description[k]) {
              var groupHash = _getLayersInGroup(map, mapTree, description[k].group);

              for (var l in groupHash) {
                _hash[l] = groupHash[l];

                _array.push(groupHash[l]);
              }
            }
          }

          return {
            asArray: function asArray() {
              return _array;
            },
            asHash: function asHash() {
              return _hash;
            },
            names: function names() {
              var res = [];

              for (var l in _hash) {
                res.push(l);
              }

              return res;
            }
          };
        }
      };

      if (typeof gmxCore !== 'undefined') {
        gmxCore.addModule('MapCommon', publicInterface);
      }

      return publicInterface;
    }(jQuery);

    (function () {
      //Интерфейс для провайдеров значений параметров
      nsGmx$1.ILazyAttributeValuesProvider = function () {
        this.isAttributeExists = function (attrName) {};

        this.getValuesForAttribute = function (attrName, callback) {};
      }; //Простая обёртка над массивами для обратной совместимости


      nsGmx$1.LazyAttributeValuesProviderFromArray = function (attributes) {
        var _attrs = attributes;

        this.isAttributeExists = function (attrName) {
          return attrName in _attrs;
        };

        this.getValuesForAttribute = function (attrName, callback) {
          if (attrName in _attrs) callback(_attrs[attrName]);else callback();
        };
      };

      nsGmx$1.LazyAttributeValuesProviderFromArray.prototype = new nsGmx$1.ILazyAttributeValuesProvider();
      /** При необходимости этот провайдер будет запрашивать значения аттрибутов у сервера
       * @class
       * @memberOf nsGmx
       * @param {Object} attributes Хеш имён атрибутов, значения которых хочется иметь
       * @param {String} layerName ID слоя
      */

      nsGmx$1.LazyAttributeValuesProviderFromServer = function (attributes, layerName) {
        var _attrs = attributes;
        var _isInited = false;
        var _isProcessing = false; //в процессе ожидания ответа от сервера мы можем получать запросы на разные аттрибуты
        //важно все их правильно сохранить и выхвать при получении данных

        var _callbacks = {};
        /** Проверить, есть ли такой атрибут
            @param {String} attrName Имя атрибута
            @return {Boolean} Есть ли такой атрибут среди атрибутов
        */

        this.isAttributeExists = function (attrName) {
          return attrName in _attrs;
        };
        /** Получить доступные значения атрибута
            @param {String} attrName Имя атрибута
            @param {Function} callback Ф-ция, которая будет вызвана со списком атрибутов, когда он станет доступным
        */


        this.getValuesForAttribute = function (attrName, callback) {
          if (!(attrName in _attrs)) //вообще нет такого имени
            callback();else if (_attrs[attrName].length) //есть вектор значений!
            callback(_attrs[attrName]);else if (_isInited) //вектора значений всё ещё нет и уже ходили на сервер - второй раз пробовать не будем...
            callback();else {
            if (!(attrName in _callbacks)) _callbacks[attrName] = [];

            _callbacks[attrName].push(callback);

            if (_isProcessing) return; //идём на сервер и запрашиваем значения аттрибутов!

            _isProcessing = true;
            sendCrossDomainJSONRequest$2(window.serverBase + "VectorLayer/GetVectorAttrValues.ashx?WrapStyle=func&LayerName=" + layerName, function (response) {
              _isInited = true;
              _isProcessing = false;

              if (!parseResponse(response)) {
                for (var n in _callbacks) {
                  for (var k = 0; k < _callbacks[n].length; k++) {
                    _callbacks[n][k]();
                  }
                }

                return;
              }

              _attrs = response.Result;

              for (var n in _callbacks) {
                for (var k = 0; k < _callbacks[n].length; k++) {
                  _callbacks[n][k](_attrs[n]);
                }
              }
            });
          }
        };

        this.getAttributesTypesHash = function (layerName) {
          var layer = nsGmx$1.gmxMap.layersByID[layerName],
              props = layer.getGmxProperties && layer.getGmxProperties(),
              res = {};

          if (props) {
            var attrTypes = props.attrTypes,
                attributes = props.attributes;

            for (var i = 0; i < attributes.length; i++) {
              res[attributes[i]] = attrTypes[i];
            }
          }

          return res;
        };

        var _attrsTypes = this.getAttributesTypesHash(layerName);

        this.getAttributeType = function (attr) {
          return _attrsTypes[attr];
        };
      };

      nsGmx$1.LazyAttributeValuesProviderFromServer.prototype = new nsGmx$1.ILazyAttributeValuesProvider();
    })();

    /** ГеоМиксер активно использует {@link http://jquery.com/|jQuery}
     * @namespace jQuery
     */

    /** Официальная документация: {@link http://api.jquery.com/category/deferred-object/|jQuery Deferred}
     * @name Deferred
     * @memberOf jQuery
     */

    /** Библиотека для формализации понятия модели и представления: {@link http://backbonejs.org/|Backbone}
     * @namespace Backbone
     */

    /** Официальная документация: {@link http://backbonejs.org/#Model| Backbone Model}
     * @name Model
     * @memberOf Backbone
     */

    /**
        Основное пространство имён ГеоМиксера
        @namespace
    */

    nsGmx$1.widgets = nsGmx$1.widgets || {}; // var gmxJSHost = window.gmxJSHost || '';

    if (!window.mapHostName && window.gmxJSHost) {
      window.mapHostName = /https?:\/\/(.*)\/api\//.exec(window.gmxJSHost)[1];
    }

    var _mapHostName; //откуда грузить API


    var protocol = window.location.protocol;

    if (window.mapHostName) {
      _mapHostName = protocol + '//' + window.mapHostName + '/api/';
    } else {
      var curUri = L.gmxUtil.parseUri(window.location.href);
      _mapHostName = protocol + '//' + curUri.host + curUri.directory;
    }

    var _serverBase = window.serverBase || new RegExp('(.*)\/[^\/]*\/').exec(_mapHostName)[1] + '/'; // //подставляет к локальному имени файла хост (window.gmxJSHost) и, опционально, рандомное поле для сброса кэша (window.gmxDropBrowserCache)
    // var _getFileName = function(localName) {
    //     return gmxJSHost + localName + (window.gmxDropBrowserCache ? '?' + Math.random() : '');
    // }


    nsGmx$1.initGeoMixer = function () {
      var oSearchLeftMenu = new leftMenu$1();
      window.searchLogic = new nsGmx$1.SearchLogic(); //для синхронизации меню и тулбара при включении/выключении сетки координат

      nsGmx$1.gridManager = {
        state: false,
        gridControl: null,
        options: null,
        menu: null,
        setState: function setState(state) {
          var isActive = state.isActive,
              options = state.options;

          if (this.state == isActive) {
            return;
          } //lazy instantantion


          this.gridControl = this.gridControl || new L.GmxGrid();
          nsGmx$1.leafletMap[isActive ? 'addLayer' : 'removeLayer'](this.gridControl);

          if (options) {
            this.restoreOptions(options);
          }

          this.state = isActive;
          nsGmx$1.leafletMap.gmxControlIconManager.get('gridTool').setActive(isActive);

          _menuUp.checkItem('mapGrid', isActive);

          _mapHelper$1.gridView = isActive; //можно удалить?

          if (this.state) {
            this.configureGrid();
          } else if (this.menu) {
            this.menu.Unload();
          }
        },
        saveOptions: function saveOptions() {
          this.options = this.gridControl.options;
        },
        restoreOptions: function restoreOptions(options) {
          this.gridControl.setUnits(options.units);

          if (options.customStep) {
            this.gridControl.setStep(options.customStep.x, options.customStep.y);
          }

          this.gridControl.setColor(options.color);
          this.gridControl.setTitleFormat(options.titleFormat);
        },
        configureGrid: function configureGrid() {
          var _this = this;

          gmxCore$1.loadModule('GridPlugin', 'src/GridPlugin.js').then(function (def) {
            _this.menu = new def.ConfigureGridMenu(nsGmx$1.gridManager);

            _this.menu.Load();
          });
        }
      };

      var createMenuNew = function createMenuNew() {
        //формирует описание элемента меню для включения/выключения плагина
        var getPluginToMenuBinding = function getPluginToMenuBinding(pluginName, menuItemName, menuTitle) {
          var plugin = nsGmx$1.pluginsManager.getPluginByName(pluginName);

          if (!plugin) {
            return null;
          }

          var sel = function sel() {
            nsGmx$1.pluginsManager.setUsePlugin(pluginName, true);
            nsGmx$1.pluginsManager.done(function () {
              var paramsClone = $.extend(true, {}, plugin.params);
              plugin.body.afterViewer && plugin.body.afterViewer(paramsClone, nsGmx$1.leafletMap);

              _mapHelper$1.mapPlugins.addPlugin(pluginName, plugin.params);
            });
          };

          var unsel = function unsel() {
            nsGmx$1.pluginsManager.setUsePlugin(pluginName, false);
            nsGmx$1.pluginsManager.done(function () {
              _mapHelper$1.mapPlugins.remove(pluginName);

              plugin.body.unload && plugin.body.unload();
            });
          };

          return {
            id: menuItemName,
            title: menuTitle,
            onsel: sel,
            onunsel: unsel,
            checked: plugin.isUsed()
          };
        };

        var isMapEditor = _queryMapLayers.currentMapRights() === 'edit',
            isLogined = nsGmx$1.AuthManager.isLogin();
        _menuUp.submenus = [];

        _menuUp.addItem({
          id: 'mapsMenu',
          title: _gtxt('Карта'),
          childs: [].concat(isLogined ? [{
            id: 'mapList',
            title: _gtxt('Открыть'),
            func: function func() {
              _queryMapLayers.getMaps();
            }
          }] : [], [{
            id: 'mapCreate',
            title: _gtxt('Создать'),
            func: function func() {
              _queryMapLayers.createMapDialog(_gtxt('Создать карту'), _gtxt('Создать'), _queryMapLayers.createMap);
            }
          }, {
            id: 'mapSave',
            title: _gtxt('Сохранить'),
            func: _queryMapLayers.saveMap
          }, {
            id: 'mapSaveAs',
            title: _gtxt('Сохранить как'),
            func: function func() {
              _queryMapLayers.createMapDialog(_gtxt('Сохранить карту как'), _gtxt('Сохранить'), _queryMapLayers.saveMapAs);
            },
            delimiter: true
          }, {
            id: 'export',
            title: _gtxt('Экспорт'),
            func: function func() {
              mapExportMenu();
            },
            disabled: !isLogined
          }, {
            id: 'shareMenu',
            title: _gtxt('Поделиться'),
            func: function func() {
              _mapHelper$1.showPermalink();
            }
          }, // {id: 'codeMap',      title: _gtxt('Код для вставки'),   func: function(){_mapHelper.createAPIMapDialog()}, disabled: true},
          {
            id: 'mapTabsNew',
            title: _gtxt('Добавить закладку'),
            func: function func() {
              mapHelp$1.tabs.load('mapTabs');

              _queryTabs.add();
            }
          }, {
            id: 'printMap',
            title: _gtxt('Печать'),
            func: function func() {
              _mapHelper$1.print();
            },
            delimiter: true
          }, {
            id: 'mapProperties',
            title: _gtxt('Свойства'),
            func: function func() {
              var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
              nsGmx$1.createMapEditor(div);
            },
            disabled: !isMapEditor
          }, {
            id: 'createGroup',
            title: _gtxt('Добавить подгруппу'),
            func: function func() {
              var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
              nsGmx$1.addSubGroup(div, _layersTree);
            },
            disabled: !isMapEditor
          }, {
            id: 'mapSecurity',
            title: _gtxt('Права доступа'),
            func: function func() {
              var securityDialog = new nsGmx$1.mapSecurity(),
                  props = _layersTree.treeModel.getMapProperties();

              securityDialog.getRights(props.MapID, props.title);
            },
            disabled: !isMapEditor
          }])
        });

        _menuUp.addItem({
          id: 'dataMenu',
          title: _gtxt('Данные'),
          childs: [{
            id: 'layerList',
            title: _gtxt('Открыть слой'),
            func: function func() {
              _queryMapLayers.getLayers();
            },
            disabled: !isMapEditor
          }, {
            id: 'createLayer',
            title: _gtxt('Создать слой'),
            childs: [{
              id: 'createRasterLayer',
              title: _gtxt('Растровый'),
              func: _mapHelper$1.createNewLayer.bind(_mapHelper$1, 'Raster'),
              disabled: !isMapEditor
            }, {
              id: 'createVectorLayer',
              title: _gtxt('Векторный'),
              func: _mapHelper$1.createNewLayer.bind(_mapHelper$1, 'Vector'),
              disabled: !isMapEditor
            }, {
              id: 'createMultiLayer',
              title: _gtxt('Мультислой'),
              func: _mapHelper$1.createNewLayer.bind(_mapHelper$1, 'Multi'),
              disabled: !isMapEditor
            }, {
              id: 'createVirtualLayer',
              title: 'Виртуальный',
              func: function func() {
                gmxCore$1.loadModule('LayerEditor').then(function () {
                  nsGmx$1.LayerEditor.addInitHook(function (layerEditor, layerProperties, params) {
                    if (layerProperties.get('Type') !== 'Virtual') {
                      return;
                    }

                    $(layerEditor).on('premodify', function () {
                      layerProperties.set('ContentID', ui.find('.vlayer-contentid').val());
                    });
                    var template = Handlebars.compile('<div type="vlayer-container">' + '<span class="vlayer-label">Тип слоя</span>' + '<input class="vlayer-contentid inputStyle" value="{{ContentID}}">' + '</div>');
                    var ui = $(template({
                      ContentID: layerProperties.get('ContentID')
                    }));
                    params.additionalUI = params.additionalUI || {};
                    params.additionalUI.main = params.additionalUI.advanced || [];
                    params.additionalUI.main.push(ui);
                  });

                  var parent = _div$1(null, [['attr', 'id', 'newVirtualLayer'], ['css', 'height', '100%']]),
                      properties = {
                    Title: '',
                    Description: '',
                    Date: ''
                  };

                  var dialogDiv = showDialog$1('Создать виртуальный слой', parent, 340, 340, false, false);
                  nsGmx$1.createLayerEditor(false, 'Virtual', parent, properties, {
                    doneCallback: function doneCallback() {
                      removeDialog$1(dialogDiv);
                    }
                  });
                });
              },
              disabled: !isMapEditor
            }],
            disabled: !isMapEditor
          }, {
            id: 'baseLayers',
            title: _gtxt('Базовые слои'),
            func: function func() {
              var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
              nsGmx$1.createMapEditor(div, 1);
            },
            delimiter: true,
            disabled: !isMapEditor
          }, {
            id: 'loadFile',
            title: _gtxt('Загрузить объекты'),
            func: drawingObjects.loadShp.load,
            delimiter: true
          }, {
            id: 'loadPhotos',
            title: _gtxt('Загрузить фотографии'),
            func: function func() {
              PhotoLayerDialog();
            },
            delimiter: true,
            disabled: !isMapEditor
          }, {
            id: 'wms',
            title: _gtxt('Подключить WMS'),
            func: loadServerData.WMS.load
          }, {
            id: 'wfs',
            title: _gtxt('Подключить WFS'),
            func: loadServerData.WFS.load
          }]
        });

        _menuUp.addItem({
          id: 'viewMenu',
          title: _gtxt('Вид'),
          childs: [{
            id: 'externalMaps',
            title: _gtxt('Дополнительные карты'),
            func: mapHelp$1.externalMaps.load
          }, {
            id: 'mapTabs',
            title: _gtxt('Закладки'),
            func: mapHelp$1.tabs.load
          }, {
            id: 'DrawingObjects',
            title: _gtxt('Объекты'),
            func: window.oDrawingObjectGeomixer.Load // {id:'searchView',     title: _gtxt('Результаты поиска'),    func: oSearchControl.Load}

          }]
        });

        _menuUp.addItem({
          id: 'instrumentsMenu',
          title: _gtxt('Инструменты'),
          childs: [{
            id: 'mapGrid',
            title: _gtxt('Координатная сетка'),
            onsel: nsGmx$1.gridManager.setState.bind(nsGmx$1.gridManager, {
              isActive: true
            }),
            onunsel: nsGmx$1.gridManager.setState.bind(nsGmx$1.gridManager, {
              isActive: false
            }),
            checked: _mapHelper$1.gridView
          }, {
            id: 'mapIndexGrid',
            title: _gtxt('Индексная сетка'),
            func: function func() {
              indexGridMenu();
            }
          }, {
            id: 'buffer',
            title: _gtxt('Создание буферных зон'),
            func: function func() {
              BufferZonesMenu();
            },
            disabled: !isLogined
          }, {
            id: 'shift',
            title: _gtxt('Ручная привязка растров'),
            func: function func() {},
            disabled: true
          }, {
            id: 'crowdsourcing',
            title: _gtxt('Краудсорсинг данных'),
            func: function func() {},
            disabled: true
          }, {
            id: 'geocoding',
            title: _gtxt('Пакетный геокодинг'),
            func: function func() {},
            disabled: true
          }, {
            id: 'directions',
            title: _gtxt('Маршруты'),
            func: function func() {},
            disabled: true
          }]
        });

        function fillPluginsMenu() {
          var plugins = window.menuPlugins || []; // для локальной версии Геомиксера покажем плагины кадастра и Викимапии

          if (!window.menuPlugins) {
            if (nsGmx$1.pluginsManager.getPluginByName('Cadastre')) {
              plugins.push({
                pluginName: 'Cadastre',
                menuItemName: 'cadastre',
                menuTitle: 'Кадастр Росреестра'
              });
            }
          }

          if (plugins.length) {
            var childs = [];

            for (var p = 0; p < plugins.length; p++) {
              childs.push(getPluginToMenuBinding(plugins[p].pluginName, plugins[p].menuItemName, window._gtxt(plugins[p].menuTitle)));
            }

            _menuUp.addItem({
              id: 'pluginsMenu',
              title: _gtxt('Сервисы'),
              childs: childs
            });
          }
        }

        fillPluginsMenu();

        _menuUp.addItem({
          id: 'helpMenu',
          title: _gtxt('Справка'),
          childs: nsGmx$1.gmxMap.properties.MapID !== '31RJS' ? [{
            id: 'about',
            title: _gtxt('О проекте'),
            func: _mapHelper$1.version
          }].concat(window.mapsSite ? [{
            id: 'usage',
            title: _gtxt('Руководство пользователя'),
            func: function func() {
              window.open('http://geomixer.ru/index.php/docs/', '_blank');
            }
          }, {
            id: 'api',
            title: _gtxt('GeoMixer API'),
            func: function func() {
              window.open('https://geomixer.ru/docs/dev-manual/rest-api/get-started/', '_blank');
            }
          }, {
            id: 'pluginsUsage',
            title: _gtxt('Использование плагинов'),
            func: function func() {
              window.open('http://geomixer.ru/index.php/docs/manual/plugins', '_blank');
            }
          }] : []) : [{
            id: 'usage',
            title: _gtxt('Руководство'),
            func: function func() {
              window.open(window.location.protocol + '//kosmosnimki.ru/downloads/%D1%86%D1%81%D0%BC%D1%81.pdf', '_blank');
            }
          }]
        });
      };

      var createToolbar = function createToolbar() {
        var lmap = nsGmx$1.leafletMap;
        var SliderControl = L.Control.extend({
          options: {
            position: 'topleft'
          },
          onAdd: function onAdd() {
            var sliderContainer = $('<div class="gmx-slider-control"></div>');
            this._widget = new nsGmx$1.TransparencySliderWidget(sliderContainer);
            $(this._widget).on('slide slidechange', function (event, ui) {
              _queryMapLayers.applyOpacityToRasterLayers(ui.value * 100, _queryMapLayers.buildedTree);
            });
            return sliderContainer[0];
          },
          onRemove: function onRemove() {},
          isCollapsed: function isCollapsed() {
            return this._widget.isCollapsed();
          }
        });
        var sliderControl = new SliderControl();
        lmap.addControl(sliderControl); //пополняем тулбар

        var uploadFileIcon = L.control.gmxIcon({
          id: 'uploadFile',
          title: _gtxt('Загрузить объекты')
        }).on('click', drawingObjects.loadShp.load.bind(drawingObjects.loadShp));
        lmap.gmxControlIconManager.get('drawing').addIcon(uploadFileIcon); // выпадающие группы иконок наезжают на слайдер прозрачности.
        // Эта ф-ция разруливает этот конфликт, скрывая слайдер в нужный момент

        var resolveToolConflict = function resolveToolConflict(iconGroup) {
          iconGroup.on('collapse', function () {
            $('.gmx-slider-control').removeClass('invisible');
          }).on('expand', function () {
            sliderControl.isCollapsed() || $('.gmx-slider-control').addClass('invisible');
          });
        };

        if (_queryMapLayers.currentMapRights() === 'edit') {
          var saveMapIcon = L.control.gmxIcon({
            id: 'saveMap',
            title: _gtxt('Сохранить карту'),
            addBefore: 'drawing'
          });
          saveMapIcon.addTo(lmap);
          saveMapIcon.on('click', _queryMapLayers.saveMap.bind(_queryMapLayers)); //группа создания слоёв

          var createVectorLayerIcon = L.control.gmxIcon({
            id: 'createVectorLayer',
            title: _gtxt('Создать векторный слой'),
            addBefore: 'drawing'
          });
          createVectorLayerIcon.on('click', function () {
            _mapHelper$1.createNewLayer('Vector');

            createVectorLayerIcon.setActive(true);
            createRasterLayerIcon.setActive(false);
          });
          var createRasterLayerIcon = L.control.gmxIcon({
            id: 'createRasterLayer',
            title: _gtxt('Создать растровый слой'),
            addBefore: 'drawing'
          });
          createRasterLayerIcon.on('click', function () {
            _mapHelper$1.createNewLayer('Raster');

            createRasterLayerIcon.setActive(true);
            createVectorLayerIcon.setActive(false);
          });
          var createLayerIconGroup = L.control.gmxIconGroup({
            id: 'createLayer',
            isSortable: true,
            //isCollapsible: false,
            items: [createVectorLayerIcon, createRasterLayerIcon],
            addBefore: 'drawing'
          });
          createLayerIconGroup.addTo(lmap);
          var bookmarkIcon = L.control.gmxIcon({
            id: 'bookmark',
            title: _gtxt('Добавить закладку'),
            addBefore: 'drawing'
          });
          bookmarkIcon.on('click', function () {
            mapHelp$1.tabs.load('mapTabs');

            _queryTabs.add();
          });
          bookmarkIcon.addTo(lmap);
          resolveToolConflict(createLayerIconGroup);
        } else {
          resolveToolConflict(lmap.gmxControlIconManager.get('drawing'));
        }

        var printIcon = L.control.gmxIcon({
          id: 'gmxprint',
          title: _gtxt('Печать'),
          addBefore: 'drawing'
        });
        printIcon.addTo(lmap);
        printIcon.on('click', _mapHelper$1.print.bind(_mapHelper$1));
        var permalinkIcon = L.control.gmxIcon({
          id: 'permalink',
          title: _gtxt('Ссылка на карту'),
          addBefore: 'drawing'
        });
        permalinkIcon.addTo(lmap);
        permalinkIcon.on('click', _mapHelper$1.showPermalink.bind(_mapHelper$1));

        if (window.mapsSite) {
          var shareIconControl = new nsGmx$1.ShareIconControl({
            className: 'shareIcon',
            id: 'share',
            text: 'Share',
            style: {
              width: 'auto'
            },
            togglable: true,
            permalinkManager: {
              save: function save() {
                return $.when(_mapHelper$1.createPermalink(), nsMapCommon.generateWinniePermalink());
              }
            },
            permalinkUrlTemplate: '{{href}}?permalink={{permalinkId}}',
            embeddedUrlTemplate: window.location.protocol + '//winnie.kosmosnimki.ru/2.0/?config={{winnieId}}',
            winnieUrlTemplate: window.location.protocol + '//winnie.kosmosnimki.ru/2.0/?config={{winnieId}}&edit=1',
            previewUrlTemplate: 'iframePreview.html?width={{width}}&height={{height}}&permalinkUrl={{{embeddedUrl}}}'
          });
          lmap.addControl(shareIconControl);
        }

        var gridIcon = L.control.gmxIcon({
          id: 'gridTool',
          title: _gtxt('Координатная сетка'),
          togglable: true,
          addBefore: 'drawing'
        });
        gridIcon.addTo(lmap);
        gridIcon.on('click', function () {
          var state = {
            isActive: gridIcon.options.isActive
          };
          nsGmx$1.gridManager.setState(state);
        });

        _mapHelper$1.customParamsManager.addProvider({
          name: 'GridManager',
          loadState: function loadState(state) {
            nsGmx$1.gridManager.setState(state);
          },
          saveState: function saveState() {
            return {
              version: '1.0.0',
              isActive: gridIcon.options.isActive,
              options: nsGmx$1.gridManager.options
            };
          }
        });

        lmap.addControl(L.control.gmxIcon({
          id: 'boxzoom-dashed-rounded',
          toggle: true,
          addBefore: 'drawing',
          title: 'Увеличение',
          onAdd: function onAdd(control) {
            var map = control._map,
                _onMouseDown = map.boxZoom._onMouseDown;

            map.boxZoom._onMouseDown = function (e) {
              _onMouseDown.call(map.boxZoom, {
                clientX: e.clientX,
                clientY: e.clientY,
                which: 1,
                shiftKey: true
              });
            };

            map.on('boxzoomend', function () {
              map.dragging.enable();
              map.boxZoom.removeHooks();
              control.setActive(false);
            });
          },
          stateChange: function stateChange(control) {
            var map = control._map;

            if (control.options.isActive) {
              map.dragging.disable();
              map.boxZoom.addHooks();
            } else {
              map.dragging.enable();
              map.boxZoom.removeHooks();
            }
          }
        }));
        /**
         * seachParams
         */

        var osmProvider = new nsGmx$1.searchProviders.Osm2DataProvider({
          showOnMap: true,
          serverBase: '//maps.kosmosnimki.ru',
          limit: 10
        });
        var searchProviders = [];
        searchProviders.push(osmProvider);
        osmProvider.addEventListener('fetch', function (e) {
          window.searchLogic.showResult(e.detail);
        });
        window.searchControl = new main_4({
          id: 'searchcontrol',
          placeHolder: 'Поиск по векторным слоям и адресной базе',
          position: 'topright',
          limit: 10,
          retrieveManyOnEnter: true,
          providers: searchProviders,
          style: {
            editable: false,
            map: true,
            pointStyle: {
              size: 8,
              weight: 1,
              opacity: 1,
              color: '#00008B'
            },
            lineStyle: {
              fill: false,
              weight: 3,
              opacity: 1,
              color: '#008B8B'
            }
          }
        });
        window.searchLogic.searchControl = window.searchControl;
        lmap.addControl(window.searchControl);
        lmap.gmxControlsManager.add(window.searchControl); // shitty trick
        // 'cause Aryunov doesn't use controls id

        window.searchControl._container._id = 'searchcontrol';
        var searchContainer = window.searchControl._widget._container;
        var stop = L.DomEvent.stopPropagation;
        L.DomEvent.on(searchContainer, 'mousemove', stop).on(searchContainer, 'touchstart', stop).on(searchContainer, 'mousedown', stop).on(searchContainer, 'dblclick', stop).on(searchContainer, 'contextmenu', stop).on(searchContainer, 'click', stop);
        var gmxLayers = new L.control.gmxLayers2(null, null, {
          title: window._gtxt('Панель оверлеев'),
          collapsed: true,
          togglable: true,
          addBefore: 'searchcontrol',
          direction: '',
          placeHolder: window._gtxt("оверлеи отсутствуют")
        });
        lmap.addControl(gmxLayers);
        lmap.gmxControlsManager.add(gmxLayers);
      };

      var createDefaultMenu = function createDefaultMenu() {
        _menuUp.submenus = [];

        _menuUp.addItem({
          id: 'mapsMenu',
          title: _gtxt('Карта'),
          childs: [{
            id: 'mapCreate',
            title: _gtxt('Создать'),
            func: function func() {
              _queryMapLayers.createMapDialog(_gtxt('Создать карту'), _gtxt('Создать'), _queryMapLayers.createMap);
            }
          }, {
            id: 'mapList',
            title: _gtxt('Открыть'),
            func: function func() {
              _queryMapLayers.getMaps();
            }
          }]
        });

        _menuUp.addItem({
          id: 'helpMenu',
          title: _gtxt('Справка'),
          childs: [{
            id: 'usage',
            title: _gtxt('Использование'),
            onsel: mapHelp$1.mapHelp.load,
            onunsel: mapHelp$1.mapHelp.unload
          }, {
            id: 'serviceHelp',
            title: _gtxt('Сервисы'),
            onsel: mapHelp$1.serviceHelp.load,
            onunsel: mapHelp$1.serviceHelp.unload
          }, {
            id: 'about',
            title: _gtxt('О проекте'),
            func: _mapHelper$1.version
          }]
        });
      };

      var parseURLParams = function parseURLParams() {
        var q = window.location.search,
            kvp = q.length > 1 ? q.substring(1).split('&') : [];

        for (var i = 0; i < kvp.length; i++) {
          kvp[i] = kvp[i].split('=');
        }

        var params = {},
            givenMapName = false;

        for (var j = 0; j < kvp.length; j++) {
          if (kvp[j].length == 1) {
            if (!givenMapName) givenMapName = decodeURIComponent(kvp[j][0]);
          } else {
            params[kvp[j][0]] = kvp[j][1];
          }
        }

        return {
          params: params,
          givenMapName: givenMapName
        };
      };

      $(function () {
        var virtualLayerManager = new nsGmx$1.VirtualLayerManager();
        L.gmx.addLayerClassLoader(virtualLayerManager.loader);
        $('body').on('keyup', function (event) {
          if ((event.target === document.body || $(event.target).hasClass('leaflet-container')) && event.keyCode === 79) {
            _queryMapLayers.getMaps();

            return false;
          }
        });
        var languageFromSettings = translationsHash.getLanguageFromCookies() || window.defaultLang;
        window.language = languageFromSettings || 'rus';
        window.shownTitle = window.pageTitle || _gtxt('ScanEx Web Geomixer - просмотр карты');
        document.title = window.shownTitle;
        window.serverBase = _serverBase;
        addParseResponseHook('*', function (response) {
          if (response.Warning) {
            //мы дожидаемся загрузки дерева слоёв, чтобы не добавлять notification widget слишком рано (до инициализации карты в контейнере)
            _queryMapLayers.loadDeferred.then(function () {
              nsGmx$1.widgets.notifications.stopAction(null, 'warning', response.Warning, 0);
            });
          }
        });
        var customErrorTemplate = Handlebars.compile('<div class="CustomErrorText">{{description}}</div>'),
            commonErrorTemplate = Handlebars.compile('<div class="CommonErrorText"><table class="CommonErrorTable">' + '<tr><td>{{message}}</td></tr>' + '<tr class="StacktraceContainer"><td class="StacktraceContainer">{{#if stacktrace}}<textarea class="inputStyle error StacktraceErrorText">{{stacktrace}}</textarea>{{/if}}</td></tr>' + '</table></div>'); //при каждой ошибке от сервера будем показывать диалог с ошибкой и стектрейсом.

        addParseResponseHook('error', function (response, customErrorDescriptions) {
          var errInfo = response.ErrorInfo;

          if (errInfo.ErrorMessage && !(errInfo.ErrorMessage in _mapHelper$1.customErrorsHash)) {
            if (customErrorDescriptions && errInfo.ExceptionType in customErrorDescriptions) {
              var canvas = $(customErrorTemplate({
                description: customErrorDescriptions[errInfo.ExceptionType]
              }));
              showDialog$1(_gtxt('Ошибка!'), canvas[0], 220, 100);
            } else {
              var stackTrace = response.ErrorInfo.ExceptionType && response.ErrorInfo.StackTrace;

              var _canvas = $(commonErrorTemplate({
                message: errInfo.ErrorMessage,
                stacktrace: stackTrace
              }));

              showDialog$1(_gtxt('Ошибка сервера'), _canvas[0], 220, 170, false, false);
              return false;
            }
          }
        });

        _translationsHash.addErrorHandler(function (text) {
          showErrorMessage$1('Не найдено тектовое описание для "' + text + '"');
        });

        nsGmx$1.pluginsManager = new (gmxCore$1.getModule('PluginsManager').PluginsManager)(); //будем сохранять в пермалинке все активные плагины

        _mapHelper$1.customParamsManager.addProvider({
          name: 'PluginManager',
          loadState: function loadState(state) {
            for (var p in state.usage) {
              var plugin = nsGmx$1.pluginsManager.getPluginByName(p);
              plugin && plugin.setUsage(state.usage[p] ? 'used' : 'notused');
            }
          },
          saveState: function saveState() {
            var usage = {};
            nsGmx$1.pluginsManager.forEachPlugin(function (plugin) {
              if (plugin.pluginName) {
                usage[plugin.pluginName] = plugin.isUsed();
              }
            });
            return {
              version: '1.0.0',
              usage: usage
            };
          }
        }); //сейчас подгружаются все глобальные плагины + все плагины карт, у которых нет имени в конфиге


        nsGmx$1.pluginsManager.done(function () {
          nsGmx$1.AuthManager.checkUserInfo(function () {
            nsGmx$1.pluginsManager.beforeMap();
            var parsedURL = parseURLParams();
            parseReferences(parsedURL.params, parsedURL.givenMapName);
          }, function () {//TODO: обработка ошибок
          });
        });
      });

      function parseReferences(params, givenMapName) {
        window.documentHref = window.location.href.split('?')[0];

        if (params['permalink']) {
          eraseCookie('TinyReference');
          createCookie$1('TinyReference', params['permalink']);

          if (location.search.indexOf('debug=1') === -1) {
            window.location.replace(window.documentHref + (givenMapName ? '?' + givenMapName : ''));
          } else {
            var tinyRef = readCookie('TinyReference');

            _mapHelper$1.restoreTinyReference(tinyRef, function (obj) {
              if (obj.mapName) {
                window.globalMapName = obj.mapName;
              }

              loadMap(obj);
            });
          }

          return;
        }

        var defaultState = {
          isFullScreen: params['fullscreen'] == 'true' || params['fullscreen'] == 'false' ? params['fullscreen'] : 'false'
        };
        if ('x' in params && 'y' in params && 'z' in params && !isNaN(Number(params.x)) && !isNaN(Number(params.y)) && !isNaN(Number(params.z))) defaultState.position = {
          x: Number(params.x),
          y: Number(params.y),
          z: Number(params.z)
        };
        if ('mx' in params && 'my' in params && !isNaN(Number(params.mx)) && !isNaN(Number(params.my))) defaultState.marker = {
          mx: Number(params.mx),
          my: Number(params.my),
          mt: 'mt' in params ? params.mt : false
        };
        if ('mode' in params) defaultState.mode = params.mode;

        if ('dt' in params) {
          defaultState.dt = params.dt;
        }

        window.defaultMapID = typeof window.defaultMapID !== 'undefined' ? window.defaultMapID : 'DefaultMap';
        var mapName = window.defaultMapID && !givenMapName ? window.defaultMapID : givenMapName;
        window.globalMapName = mapName;

        if (!window.globalMapName) {
          // нужно прописать дефолтную карту в конфиге
          alert(_gtxt('$$phrase$$_1'));
          return;
        } else {
          checkUserInfo(defaultState);
        }
      }

      function checkUserInfo(defaultState) {
        var tinyRef = readCookie('TinyReference');

        if (tinyRef) {
          eraseCookie('TinyReference');

          _mapHelper$1.restoreTinyReference(tinyRef, function (obj) {
            if (obj.mapName) {
              window.globalMapName = obj.mapName;
            }

            loadMap(obj);
          }, function () {
            loadMap(defaultState); //если пермалинк какой-то не такой, просто открываем дефолтное состояние
          });

          var tempPermalink = readCookie('TempPermalink');

          if (tempPermalink && tempPermalink == tinyRef) {
            nsGmx$1.Utils.TinyReference.remove(tempPermalink);
            eraseCookie('TempPermalink');
          }
        } else {
          loadMap(defaultState);
        }
      }

      window.layersShown = true;

      window.resizeAll = function () {
        if (window.printMode) {
          return;
        }

        var top = 0,
            bottom = 0,
            right = 0,
            left,
            headerHeight = $('#header').outerHeight(),
            mainDiv = $('#flash')[0];

        if (window.exportMode) {
          left = 0;
        } else if (window.iconSidebarWidget) {
          left = window.iconSidebarWidget.getWidth();
        } else {
          left = window.layersShown ? 400 : 40;
        }

        mainDiv.style.left = left + 'px';
        mainDiv.style.top = top + 'px';
        mainDiv.style.width = getWindowWidth() - left - right + 'px';
        mainDiv.style.height = getWindowHeight() - top - headerHeight - bottom + 'px';
        nsGmx$1.leafletMap && nsGmx$1.leafletMap.invalidateSize();

        if (window.layersShown) {
          $('#leftMenu').show();
          var mapNameHeight = $('.mainmap-title').outerHeight();
          var baseHeight = getWindowHeight() - top - bottom - headerHeight;
          $('#leftMenu')[0].style.height = baseHeight + 'px';
          var leftContentContainer = $('#leftContent')[0];

          if (leftContentContainer) {
            leftContentContainer.style.top = $('#leftPanelHeader')[0].offsetHeight + mapNameHeight + 'px';
            leftContentContainer.style.height = baseHeight - $('#leftPanelHeader')[0].offsetHeight - $('#leftPanelFooter')[0].offsetHeight - mapNameHeight + 'px';
          }
        } else {
          $('#leftMenu').hide();
        }
      };

      var editUIInited = false;

      var initEditUI = function initEditUI() {
        if (editUIInited) {
          return;
        }

        var isEditableLayer = function isEditableLayer(layer) {
          var props = layer.getGmxProperties(),
              layerRights = _queryMapLayers.layerRights(props.name);

          return props.type === 'Vector' && (layerRights === 'edit' || layerRights === 'editrows');
        };

        var hasEditableLayer = false;

        for (var iL = 0; iL < nsGmx$1.gmxMap.layers.length; iL++) {
          if (isEditableLayer(nsGmx$1.gmxMap.layers[iL])) {
            hasEditableLayer = true;
            break;
          }
        }

        if (!hasEditableLayer) return; //добавляем пункт меню к нарисованным объектам

        nsGmx$1.ContextMenuController.addContextMenuElem({
          title: _gtxt('EditObject.drawingMenuTitle'),
          isVisible: function isVisible() {
            var active = $(_queryMapLayers.treeCanvas).find('.active'); //должен быть векторный слой

            if (!active[0] || !active[0].parentNode.getAttribute('LayerID') || !active[0].parentNode.gmxProperties.content.properties.type === 'Vector') {
              return false;
            } //TODO: проверить тип геометрии


            var layer = nsGmx$1.gmxMap.layersByID[active[0].parentNode.gmxProperties.content.properties.name]; //слой поддерживает редактирование и у нас есть права на это

            return isEditableLayer(layer);
          },
          clickCallback: function clickCallback(context) {
            var active = $(_queryMapLayers.treeCanvas).find('.active');
            var layerName = active[0].parentNode.gmxProperties.content.properties.name;
            new nsGmx$1.EditObjectControl(layerName, null, {
              drawingObject: context.obj
            });
          }
        }, 'DrawingObject'); //добавляем пункт меню ко всем слоям

        nsGmx$1.ContextMenuController.addContextMenuElem({
          title: _gtxt('EditObject.menuTitle'),
          isVisible: function isVisible(context) {
            var layer = nsGmx$1.gmxMap.layersByID[context.elem.name];
            return !context.layerManagerFlag && isEditableLayer(layer);
          },
          clickCallback: function clickCallback(context) {
            new nsGmx$1.EditObjectControl(context.elem.name);
          }
        }, 'Layer'); //добавляем тул в тублар карты

        var listeners = {}; // var pluginPath = gmxCore.getModulePath('EditObjectPlugin');

        var editIcon = L.control.gmxIcon({
          id: 'editTool',
          title: _gtxt('Редактировать'),
          togglable: true,
          addBefore: 'gmxprint'
        }).addTo(nsGmx$1.leafletMap);
        editIcon.on('statechange', function () {
          if (editIcon.options.isActive) {
            var clickHandler = function clickHandler(event) {
              var layer = event.target,
                  props = layer.getGmxProperties(),
                  id = event.gmx.properties[props.identityField];
              layer.bringToTopItem(id);
              new nsGmx$1.EditObjectControl(props.name, id, {
                event: event
              });
              return true; // TODO: как oтключить дальнейшую обработку события
            };

            for (var _iL = 0; _iL < nsGmx$1.gmxMap.layers.length; _iL++) {
              var layer = nsGmx$1.gmxMap.layers[_iL],
                  props = layer.getGmxProperties();

              if (layer.disableFlip && layer.disablePopup) {
                layer.disableFlip();
                layer.disablePopup();
              }

              listeners[props.name] = clickHandler.bind(null); //bind чтобы были разные ф-ции

              if (layer instanceof L.gmx.VectorLayer) {
                layer.on('click', listeners[props.name]);
              }
            }
          } else {
            for (var layerName in listeners) {
              // let pt = listeners[layerName];
              var _layer = nsGmx$1.gmxMap.layersByID[layerName];

              if (_layer && _layer instanceof L.gmx.VectorLayer) {
                _layer.off('click', listeners[layerName]);

                if (_layer.getGmxProperties().type !== 'Virtual') {
                  _layer.enableFlip();

                  _layer.enablePopup();
                }
              }
            }

            listeners = {};
          }
        });
        editUIInited = true;
      };

      function initAuthWidget() {
        var registrationCallback = function registrationCallback() {
          gmxCore$1.loadModule('ProfilePlugin').then(function (AccountModule) {
            AccountModule.showRegistrationForm(function () {
              window.location.reload();
            });
          });
        };

        var nativeAuthWidget = new nsGmx$1.GeoMixerAuthWidget($('<div/>')[0], nsGmx$1.AuthManager, function () {
          _mapHelper$1.reloadMap();
        }, {
          registrationCallback: registrationCallback
        }); // прокси между nsGmx.AuthManager редактора и AuthManager'а из общей библиотеки

        var authManagerProxy = {
          getUserInfo: function getUserInfo() {
            var def = $.Deferred();
            nsGmx$1.AuthManager.checkUserInfo(function () {
              var auth = nsGmx$1.AuthManager;
              def.resolve({
                Status: 'ok',
                Result: {
                  Login: auth.getLogin(),
                  Nickname: auth.getNickname(),
                  FullName: auth.getFullname()
                }
              });
            });
            return def;
          },
          login: function login() {
            nativeAuthWidget.showLoginDialog();
          },
          logout: function logout() {
            var def = $.Deferred();
            nsGmx$1.AuthManager.logout(function () {
              def.resolve({
                Status: 'ok',
                Result: {}
              });

              _mapHelper$1.reloadMap();
            });
            return def;
          },
          getNative: function getNative() {
            return nativeAuthWidget;
          }
        };
        nsGmx$1.widgets.authWidget = new nsGmx$1.AuthWidget({
          authManager: authManagerProxy,
          showAccountLink: !!window.mapsSite,
          accountLink: null,
          showMapLink: !!window.mapsSite,
          changePassword: !window.mapsSite,
          isAdmin: nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN),
          callbacks: {
            'authWidget-usergroupMenuItem': showUserList
          }
        });
        var authPlaceholder = nsGmx$1.widgets.header.getAuthPlaceholder();
        nsGmx$1.widgets.authWidget.appendTo(authPlaceholder);
        authPlaceholder.on('click', '#AuthWidgetAccountLink', function () {
          gmxCore$1.loadModule('ProfilePlugin').then(function (AccountModule) {
            AccountModule.showProfile();
          });
        }); //ugly hack

        nsGmx$1.widgets.authWidget.showLoginDialog = nativeAuthWidget.showLoginDialog.bind(nativeAuthWidget);
      }

      function loadMap(state) {
        //при переходе на новое API мы изменили место хранения мапплетов карты
        //раньше мапплеты хранились в свойстве onLoad карты
        //теперь - внутри клиентских данных (UserData)
        nsGmx$1.mappletLoader = {
          _script: '',
          //UserObjectsManager interface
          collect: function collect() {
            return this._script;
          },
          load: function load(data) {
            this._script = data;
          },
          //self public interface
          execute: function execute() {// if (this._script) {
            //     var evalStr = '(' + this._script + ')';
            //     try {
            //         eval(evalStr)();
            //     } catch (e) {
            //         console.error(e);
            //     }
            // }
          },
          get: function get() {
            return this._script;
          },
          set: function set(data) {
            this._script = data;
          }
        };
        nsGmx$1.userObjectsManager.addDataCollector('mapplet_v2', nsGmx$1.mappletLoader);
        window.layersShown = state.isFullScreen == 'false';

        if (state.language) {
          window.language = state.language;
          translationsHash.updateLanguageCookies(window.language);
        }

        window.onresize = window.resizeAll;
        window.resizeAll();
        L.Icon.Default.imagePath = (window.gmxJSHost || '') + 'img';
        var iconUrl = L.Icon.Default.imagePath + '/flag_blau1.png';

        if (L.version !== '0.7.7') {
          L.Icon.Default = L.Icon.Default.extend({
            _getIconUrl: function _getIconUrl(name) {
              return L.Icon.prototype._getIconUrl.call(this, name);
            }
          });
        }

        L.Marker = L.Marker.extend({
          options: {
            icon: new L.Icon.Default({
              iconUrl: iconUrl,
              iconSize: [36, 41],
              iconAnchor: [7, 37],
              popupAnchor: [3, -25],
              shadowUrl: iconUrl,
              shadowSize: [0, 0],
              shadowAnchor: [0, 0],
              iconRetinaUrl: L.Icon.Default.imagePath + '/marker-icon.png'
            })
          }
        });

        L.marker = function (latlng, options) {
          return new L.Marker(latlng, options);
        };

        var hostName = L.gmxUtil.normalizeHostname(window.serverBase),
            apiKey = window.mapsSite ? window.apiKey : null; //передаём apiKey только если не локальная версия ГеоМиксера
        //мы явно получаем описание карты, но пока что не начинаем создание слоёв
        //это нужно, чтобы получить список плагинов и загрузить их до того, как начнутся создаваться слои

        var skipTiles = (window.mapOptions ? window.mapOptions.skipTiles : '') || window.gmxSkipTiles || '';
        var srs = window.mapOptions ? window.mapOptions.srs : '';

        if (!srs) {
          var arr = location.href.match(/[?&][cs]rs=(\d+)/);

          if (arr) {
            srs = arr[1];
          }
        }

        var isGeneralized = window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true;
        L.gmx.gmxMapManager.loadMapProperties({
          srs: srs,
          serverHost: hostName,
          apiKey: apiKey,
          mapName: window.globalMapName,
          skipTiles: skipTiles,
          isGeneralized: isGeneralized
        }).then(function (mapInfo) {
          var userObjects = state.userObjects || mapInfo && mapInfo.properties.UserData;
          userObjects && nsGmx$1.userObjectsManager.setData(JSON.parse(userObjects)); //в самом начале загружаем только данные о плагинах карты.
          //Остальные данные будем загружать чуть позже после частичной инициализации вьюера
          //О да, формат хранения данных о плагинах часто менялся!
          //Поддерживаются все предыдущие форматы из-за старых версий клиента и сложности обновления базы данных

          nsGmx$1.userObjectsManager.load('mapPlugins');
          nsGmx$1.userObjectsManager.load('mapPlugins_v2');
          nsGmx$1.userObjectsManager.load('mapPlugins_v3'); //вызываем сразу после загрузки списка плагинов ГеоМиксера,
          //так как в state может содержаться информация о включённых плагинах

          if (state.customParamsCollection) {
            _mapHelper$1.customParamsManager.loadParams(state.customParamsCollection);
          } //после загрузки списка плагинов карты начали загружаться не глобальные плагины,
          //у которых имя плагина было прописано в конфиге. Ждём их загрузки.


          nsGmx$1.pluginsManager.done(function () {
            nsGmx$1.pluginsManager.preloadMap();
            L.gmx.loadMap(window.globalMapName, {
              srs: srs,
              skipTiles: skipTiles,
              hostName: window.serverBase,
              apiKey: apiKey,
              setZIndex: true,
              isGeneralized: isGeneralized
            }).then(processGmxMap.bind(null, state));
          });
        }, function (resp) {
          initHeader();
          initAuthWidget();
          _menuUp.defaultHash = 'usage';

          _menuUp.createMenu = function () {
            createDefaultMenu();
            nsGmx$1.pluginsManager.addMenuItems(_menuUp);
          };

          _menuUp.go(nsGmx$1.widgets.header.getMenuPlaceholder()[0]);

          $('#left_usage').hide();

          _menuUp.checkView();

          var str = resp && resp.ErrorInfo && resp.ErrorInfo.ErrorMessage ? resp.ErrorInfo.ErrorMessage : 'У вас нет прав на просмотр данной карты';
          nsGmx$1.widgets.notifications.stopAction(null, 'failure', _gtxt(str) || str, 0);
          window.onresize = window.resizeAll;
          window.resizeAll();
          state.originalReference && createCookie$1('TinyReference', state.originalReference);
          nsGmx$1.widgets.authWidget.showLoginDialog();
        });
      } //создаём подложки в BaseLayerManager по описанию из config.js


      function initDefaultBaseLayers() {
        var lang = L.gmxLocale.getLanguage(),
            iconPrefix = 'img/baseLayers/',
            blm = nsGmx$1.leafletMap.gmxBaseLayersManager,
            zIndexOffset = 2000000,
            defaultMapID = window.baseMap.defaultMapID,
            promises = [],
            defaultHostName;

        if (window.baseMap.defaultHostName) {
          defaultHostName = window.baseMap.defaultHostName === '/' ? _serverBase : window.baseMap.defaultHostName;
        } else {
          defaultHostName = 'maps.kosmosnimki.ru';
        }

        if (window.baseMap.baseLayers) {
          var promise;

          (function () {
            var baseLayers = window.baseMap.baseLayers,
                bl; // проставляем дефолтным слоям свойства, зависящие от путей, языка, zIndex

            for (var i = 0; i < baseLayers.length; i++) {
              bl = baseLayers[i]; // у Спутника в конфиге нет иконки и копирайта

              if (bl.id === 'sputnik') {
                bl.icon = iconPrefix + 'basemap_sputnik_ru.png';
                bl.layers[0].attribution = '<a href="http://maps.sputnik.ru">Спутник</a> © ' + (lang === 'rus' ? 'Ростелеком' : 'Rostelecom') + ' | © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';
              } // у ОСМ в конфиге нет иконки и урл


              if (bl.id === 'OSM') {
                bl.icon = iconPrefix + 'basemap_osm_' + (lang === 'rus' ? 'ru' : 'eng') + '.png';
                bl.layers[0].urlTemplate = 'http://{s}.tile.osm.kosmosnimki.ru/kosmo' + (lang === 'rus' ? '' : '-en') + '/{z}/{x}/{y}.png';
              } // у гибрида в конфиге нет урл


              if (bl.id === 'OSMHybrid') {
                bl.layers[0].urlTemplate = 'http://{s}.tile.osm.kosmosnimki.ru/kosmohyb' + (lang === 'rus' ? '' : '-en') + '/{z}/{x}/{y}.png'; // bl.layers[0].setZIndex(zIndexOffset);
              } // у спутника нет иконки


              if (bl.id === 'satellite') {
                bl.icon = iconPrefix + 'basemap_satellite.png';
              }
            }

            for (var _i = 0; _i < baseLayers.length; _i++) {
              var _bl = baseLayers[_i];

              if (_bl.layers && _bl.layers.length) {
                var l = _bl.layers;

                for (var j = 0; j < l.length; j++) {
                  if (l[j].urlTemplate) {
                    // заменяем в подложках с айди описания слоев на L.tileLayers
                    l[j] = L.tileLayer(l[j].urlTemplate, l[j]);
                  } else {
                    // let currentTl = bl,
                    var layerID = l[j].layerID,
                        hostName = l[j].hostName || defaultHostName,
                        mapID = l[j].mapID || defaultMapID,
                        skipTiles = (window.mapOptions ? window.mapOptions.skipTiles : '') || window.gmxSkipTiles || '',
                        srs = window.mapOptions ? window.mapOptions.srs : '',
                        isGeneralized = window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true;

                    if (!srs) {
                      var arr = location.href.match(/[?&][cs]rs=(\d+)/);

                      if (arr) {
                        srs = arr[1];
                      }
                    } // resolve promise -> заменяем в подложках с айди описания слоев на gmxLayers


                    promise = L.gmx.loadLayer(mapID, layerID, {
                      hostName: hostName,
                      srs: srs,
                      isGeneralized: isGeneralized,
                      skipTiles: skipTiles
                    }).then(function (layer) {
                      var id = layer.getGmxProperties().name;

                      for (var k = 0; k < baseLayers.length; k++) {
                        var _bl2 = baseLayers[k];

                        if (_bl2.layers && _bl2.layers.length) {
                          var l = _bl2.layers;

                          for (var m = 0; m < l.length; m++) {
                            if (l[m].layerID && l[m].layerID === id) {
                              l[m] = layer;
                            }
                          }
                        }
                      }
                    });
                    promises.push(promise);
                  }
                }
              }
            }
          })();
        }

        return L.gmx.Deferred.all.apply(null, promises).then(function () {
          if (window.baseMap.baseLayers) {
            var layers = window.baseMap.baseLayers,
                layersToLoad = {};
            layers.forEach(function (bl) {
              layersToLoad[bl.id] = bl;
            }); // добавим в гибрид снимок

            if (layersToLoad.satellite && layersToLoad.OSMHybrid) {
              layersToLoad.OSMHybrid.layers[0].setZIndex(zIndexOffset);
              layersToLoad.OSMHybrid.layers.push(layersToLoad.satellite.layers[0]);
            }

            _$1.each(layersToLoad, function (l, name) {
              blm.add(name, l);
            });
          }
        });
      }

      function showUserList() {
        gmxCore$1.loadModule('UserGroupWidget').then(function (module) {
          var canvas = $('<div/>');
          new module.UserGroupListWidget(canvas);
          canvas.dialog({
            width: 400,
            height: 400,
            title: _gtxt('Управление группами пользователей')
          });
        });
      } // Инициализации шапки. Будем оттягивать с инициализацией до последнего момента, так как при инициализации
      // требуется знать текущий язык, а он становится известен только после загрузки карты


      function initHeader() {
        // var rightLinks = [];
        nsGmx$1.widgets.header = new nsGmx$1.HeaderWidget({
          logo: window.gmxViewerUI && window.gmxViewerUI.logoImage || 'img/geomixer_transpar_small.svg'
        });
        nsGmx$1.widgets.header.appendTo($('.header'));
      }

      function processGmxMap(state, gmxMap) {
        var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;
        var defCenter = [55.7574, 37.5952],
            mapProps = gmxMap.properties,
            defZoom = mapProps.DefaultZoom || 5,
            data = gmxMap.rawTree;

        if (mapProps.DefaultLat && mapProps.DefaultLong) {
          defCenter = [mapProps.DefaultLat, mapProps.DefaultLong];
        } else {
          //подсчитаем общий extend всех видимых слоёв
          var visBounds = L.latLngBounds([]);

          for (var l = 0; l < gmxMap.layers.length; l++) {
            var layer = gmxMap.layers[l];

            if (layer.getGmxProperties().visible && layer.getBounds) {
              visBounds.extend(layer.getBounds());
            }
          }

          if (visBounds.isValid()) {
            //вычислям центр и максимальный zoom по bounds (map.fitBounds() использовать не можем, так как ещё нет карты)
            var proj = L.Projection.Mercator;
            var mercBounds = L.bounds([proj.project(visBounds.getNorthWest()), proj.project(visBounds.getSouthEast())]);
            var ws = 2 * proj.project(L.latLng(0, 180)).x,
                screenSize = [$('#flash').width(), $('#flash').height()];
            var zoomX = Math.log(ws * screenSize[0] / (mercBounds.max.x - mercBounds.min.x)) / Math.log(2) - 8;
            var zoomY = Math.log(ws * screenSize[1] / (mercBounds.max.y - mercBounds.min.y)) / Math.log(2) - 8;
            defZoom = Math.floor(Math.min(zoomX, zoomY, 17));
            defCenter = proj.unproject(mercBounds.getCenter());
          }
        } //если информации о языке нет ни в куках ни в config.js, то используем данные о языке из карты


        if (!translationsHash.getLanguageFromCookies() && !window.defaultLang && data) {
          window.language = data.properties.DefaultLanguage;
        }

        initHeader();

        if (!window.gmxViewerUI || !window.gmxViewerUI.hideLanguage) {
          var langContainer = nsGmx$1.widgets.header.getLanguagePlaceholder();
          nsGmx$1.widgets.languageWidget = new nsGmx$1.LanguageWidget();
          nsGmx$1.widgets.languageWidget.appendTo(langContainer);
        }

        var mapOptions = L.extend(window.mapOptions ? window.mapOptions : {}, {
          contextmenu: true,
          // если есть пермалинк, центрируем и зумируем карту сразу по его параметрам
          center: state.position ? [state.position.y, state.position.x] : defCenter,
          zoom: state.position ? state.position.z : defZoom,
          // boxZoom: false,
          zoomControl: false,
          attributionControl: false,
          trackResize: true,
          fadeAnimation: !window.gmxPhantom,
          // отключение fadeAnimation при запуске тестов
          zoomAnimation: !window.gmxPhantom,
          // отключение zoomAnimation при запуске тестов
          distanceUnit: mapProps.DistanceUnit,
          squareUnit: mapProps.SquareUnit,
          minZoom: mapProps.MinZoom || undefined,
          maxZoom: mapProps.MaxZoom || undefined,
          maxPopupCount: mapProps.maxPopupContent
        });
        var lmap = new L.Map($('#flash')[0], mapOptions); // update layers zIndexes

        var currentZoom = lmap.getZoom(),
            layerOrder = gmxMap.rawTree.properties.LayerOrder;
        updateZIndexes();
        lmap.on('zoomend', function () {
          currentZoom = lmap.getZoom();
          updateZIndexes();
        }); //clip polygons

        if (mapProps.MinViewX && mapProps.MinViewY && mapProps.MaxViewX && mapProps.MaxViewY) {
          lmap.on('layeradd', function (e) {
            if (e.layer.addClipPolygon) {
              _mapHelper$1.clipLayer(e.layer, mapProps);
            }
          });
        } // bind clusters to photoLayers


        for (var _l = 0; _l < gmxMap.layers.length; _l++) {
          var _layer2 = gmxMap.layers[_l],
              props = _layer2.getGmxProperties();

          if (props.IsPhotoLayer) {
            _layer2.bindClusters({
              iconCreateFunction: function iconCreateFunction(cluster) {
                var photoClusterIcon = L.divIcon({
                  html: '<img src="' + (window.serverBase ? window.serverBase + _mapHelper$1.defaultPhotoIconStyles.point.marker.image : _mapHelper$1.defaultPhotoIconStyles.point.marker.image) + '" class="photo-icon"/><div class="marker-cluster-photo">' + cluster.getChildCount() + '</div>',
                  className: 'photo-div-icon',
                  iconSize: [14, 12],
                  iconAnchor: [0, 0]
                });
                return photoClusterIcon;
              },
              maxClusterRadius: 40,
              spiderfyOnMaxZoom: true,
              spiderfyZoom: 14,
              spiderfyDistanceMultiplier: 1.2,
              disableClusteringAtZoom: 19,
              maxZoom: 19
            });
          }
        }

        lmap.contextmenu.insertItem({
          text: _gtxt('Поставить маркер'),
          callback: function callback(event) {
            lmap.gmxDrawing.addGeoJSON({
              type: 'Point',
              coordinates: [event.latlng.lng, event.latlng.lat]
            });
          }
        });
        lmap.contextmenu.insertItem({
          text: _gtxt('Центрировать'),
          callback: function callback(event) {
            lmap.setView(event.latlng);
          }
        });

        function updateZIndexes() {
          for (var l = 0; l < gmxMap.layers.length; l++) {
            var layer = gmxMap.layers[l],
                props = layer.getGmxProperties();

            switch (layerOrder) {
              case 'VectorOnTop':
                if (props.type === 'Vector' && layer.setZIndexOffset) {
                  var minZoom = void 0,
                      rcMinZoom = void 0,
                      quickLookMinZoom = void 0,
                      defaultMinZoom = 6;

                  if (props.IsRasterCatalog || props.Quicklook && props.Quicklook !== 'null') {
                    rcMinZoom = props.IsRasterCatalog ? props.RCMinZoomForRasters : null;
                    quickLookMinZoom = props.Quicklook && nsGmx$1.Utils.isJSON(props.Quicklook) ? JSON.parse(props.Quicklook).minZoom : null;

                    if (props.IsRasterCatalog && !props.Quicklook) {
                      minZoom = nsGmx$1.Utils.checkForNumber(rcMinZoom) ? rcMinZoom : defaultMinZoom;
                    } else if (!props.IsRasterCatalog && props.Quicklook) {
                      minZoom = nsGmx$1.Utils.checkForNumber(quickLookMinZoom) ? quickLookMinZoom : defaultMinZoom;
                    } else if (props.IsRasterCatalog && props.Quicklook) {
                      rcMinZoom = nsGmx$1.Utils.checkForNumber(rcMinZoom) ? rcMinZoom : defaultMinZoom;
                      quickLookMinZoom = nsGmx$1.Utils.checkForNumber(quickLookMinZoom) ? quickLookMinZoom : defaultMinZoom;
                      minZoom = Math.min(rcMinZoom, quickLookMinZoom);
                    }

                    layer.setZIndexOffset(currentZoom < rcMinZoom ? DEFAULT_VECTOR_LAYER_ZINDEXOFFSET : 0);
                  } else {
                    layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                  }
                }

                break;
            }
          }
        } // Begin: запоминание текущей позиции карты


        function saveMapPosition(key) {
          window.localStorage.setItem('lastMapPosiotion_' + key, JSON.stringify({
            zoom: lmap.getZoom(),
            center: lmap.getCenter()
          }));
        }

        function getMapPosition(key) {
          return JSON.parse(localStorage.getItem('lastMapPosiotion_' + key));
        }

        lmap.on('boxzoomstart', function () {
          saveMapPosition('z');
        });
        L.DomEvent.on(document, 'keydown', function (ev) {
          var key = ev.key;

          if (lmap.gmxMouseDown === 1) {
            var pos = getMapPosition(key);

            if (pos && (key === 'z' || Number(key) >= 0)) {
              lmap.setView(pos.center, pos.zoom);
            }
          } else if (lmap.gmxMouseDown > 1) {
            if (Number(key) >= 0) {
              saveMapPosition(key);
            }
          }
        }, lmap); // End: запоминание текущей позиции карты

        lmap.gmxControlsManager.init(window.controlsOptions); // lmap.addControl(new L.Control.gmxLayers(lmap.gmxBaseLayersManager, {
        //     // position: 'topleft',
        //     collapsed: true,
        //     hideBaseLayers: true
        // }));

        nsGmx$1.leafletMap = lmap;
        var loc = nsGmx$1.leafletMap.gmxControlsManager.get('location');
        loc.setCoordinatesFormat(gmxMap.properties.coordinatesFormat);
        loc.on('coordinatesformatchange', function (ev) {
          nsGmx$1.leafletMap.options.coordinatesFormat = ev.coordinatesFormat;
        });
        var baseLayerDef = 'baseMap' in window ? initDefaultBaseLayers() : lmap.gmxBaseLayersManager.initDefaults({
          hostName: window.mapHostName,
          apiKey: window.apiKey,
          srs: lmap.options.srs,
          skipTiles: lmap.options.skipTiles,
          isGeneralized: lmap.options.isGeneralized
        });
        baseLayerDef.then(function () {
          nsGmx$1.gmxMap = gmxMap;
          window.gmxAPI.layersByID = gmxMap.layersByID; // слои по layerID

          var mapProp = gmxMap.rawTree.properties || {};
          var baseLayers = mapProp.BaseLayers ? JSON.parse(mapProp.BaseLayers) : [window.language === 'eng' ? 'mapbox' : 'sputnik', 'OSMHybrid', 'satellite'];
          lmap.gmxBaseLayersManager.setActiveIDs(baseLayers);
          var baseLayersControl = new L.Control.GmxIconLayers(lmap.gmxBaseLayersManager, {
            id: 'iconLayers'
          });
          lmap.gmxControlsManager.add(baseLayersControl);
          lmap.addControl(baseLayersControl);
          nsGmx$1.widgets.commonCalendar = new nsGmx$1.CommonCalendarWidget(); // добавление временных слоев в commonCalendar
          // добавление происходит безопасно, в клон объекта со списком слоев

          var initTemporalLayers = function initTemporalLayers(layers) {
            layers = layers || nsGmx$1.gmxMap.layers;
            var attrs = nsGmx$1.widgets.commonCalendar.model.toJSON(),
                showCalendar = undefined,
                dateInterval,
                dateBegin,
                dateEnd;

            for (var i = 0; i < layers.length; i++) {
              var layer = layers[i],
                  props = layer.getGmxProperties(),
                  // isVisible = props.visible,
              isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.setDateInterval;

              if (isTemporalLayer) {
                // показываем виджет календаря, если в карте есть хоть один мультивременной слой
                showCalendar = true;
                dateInterval = layer.getDateInterval ? layer.getDateInterval() : new nsGmx$1.DateInterval();

                if (dateInterval.beginDate && dateInterval.endDate) {
                  dateBegin = dateInterval.beginDate;
                  dateEnd = dateInterval.endDate;
                } else {
                  dateInterval = new nsGmx$1.DateInterval();
                  dateBegin = dateInterval.get('dateBegin');
                  dateEnd = dateInterval.get('dateEnd');
                }

                if (!(props.name in attrs.unbindedTemporalLayers)) {
                  nsGmx$1.widgets.commonCalendar.bindLayer(props.name);
                  layer.setDateInterval(dateBegin, dateEnd);

                  if (props.LayerID in attrs.dailyFiltersHash) {
                    nsGmx$1.widgets.commonCalendar.applyDailyFilter([layer]);
                  }
                } //подписка на изменение dateInterval


                if (layer.getDateInterval) {
                  layer.on('dateIntervalChanged', nsGmx$1.widgets.commonCalendar.onDateIntervalChanged, nsGmx$1.widgets.commonCalendar);
                }
              }
            }

            nsGmx$1.widgets.commonCalendar.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);

            if (showCalendar && !attrs.isAppended) {
              nsGmx$1.widgets.commonCalendar.show();
            }
          }; // привяжем изменение активной ноды к календарю


          $(_layersTree).on('activeNodeChange', function (e, p) {
            var layerID = $(p).attr('layerid'); // calendar = nsGmx.widgets.commonCalendar.model.get('calendar'),
            // synchronyzed = nsGmx.widgets.commonCalendar.model.get('synchronyzed');

            lmap.fireEvent('layersTree.activeNodeChange', {
              layerID: layerID
            });
          });
          $(_layersTree).on('layerVisibilityChange', function (event, elem) {
            var props = elem.content.properties,
                attrs = nsGmx$1.widgets.commonCalendar.model.toJSON(),
                visible = props.visible,
                layerID = props.LayerID,
                // calendar = attrs.calendar,
            currentLayer = attrs.currentLayer,
                synchronyzed = attrs.synchronyzed;

            if (synchronyzed) {
              return;
            } else if (layerID) {
              var _layer3 = nsGmx$1.gmxMap.layersByID[layerID],
                  _props = _layer3.getGmxProperties(),
                  isTemporalLayer = _layer3 instanceof L.gmx.VectorLayer && _props.Temporal || _props.type === 'Virtual' && _layer3.getDateInterval,
                  visibleTemporalLayers,
                  index;

              if (isTemporalLayer) {
                if (visible) {
                  if (currentLayer) {
                    return;
                  } else {
                    var dateInterval = _layer3.getDateInterval();

                    if (dateInterval.beginDate && dateInterval.endDate) {
                      nsGmx$1.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, _layer3);
                    }
                  }
                } else if (currentLayer) {
                  if (layerID !== currentLayer) {
                    return;
                  } else {
                    visibleTemporalLayers = getLayersListWithTarget(nsGmx$1.gmxMap.layers, _layer3);
                    index = visibleTemporalLayers.indexOf(_layer3);

                    if (visibleTemporalLayers.length === 1) {
                      nsGmx$1.widgets.commonCalendar.model.set('currentLayer', null);
                    } else if (index === 0) {
                      var targetLayer = visibleTemporalLayers[index + 1],
                          // targetLayerID = targetLayer.getGmxProperties().LayerID,
                      _dateInterval = targetLayer.getDateInterval();

                      nsGmx$1.widgets.commonCalendar.setDateInterval(_dateInterval.beginDate, _dateInterval.endDate, targetLayer); // nsGmx.widgets.commonCalendar.model.set('currentLayer', targetLayerID)
                    } else {
                      var _targetLayer = visibleTemporalLayers[index - 1],
                          // targetLayerID = targetLayer.getGmxProperties().LayerID,
                      _dateInterval2 = _targetLayer.getDateInterval();

                      nsGmx$1.widgets.commonCalendar.setDateInterval(_dateInterval2.beginDate, _dateInterval2.endDate, _targetLayer); // nsGmx.widgets.commonCalendar.model.set('currentLayer', targetLayerID)
                    }
                  }
                } else {
                  return;
                }
              }
            }

            nsGmx$1.widgets.commonCalendar.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);

            function getLayersListWithTarget(layers, targetLayer) {
              var visibleTemporalLayers = [];

              for (var i = 0; i < layers.length; i++) {
                var _layer4 = layers[i],
                    _props2 = _layer4.getGmxProperties && _layer4.getGmxProperties(),
                    _isTemporalLayer = void 0,
                    isVisible = void 0;

                if (_props2) {
                  _isTemporalLayer = _layer4 instanceof L.gmx.VectorLayer && _props2.Temporal || _props2.type === 'Virtual' && _layer4.getDateInterval;
                  isVisible = _props2.visible;

                  if (_isTemporalLayer && isVisible || _layer4 === targetLayer) {
                    visibleTemporalLayers.push(_layer4);
                  }
                }
              }

              return visibleTemporalLayers;
            }
          });
          $(_layersTree).on('styleVisibilityChange', function (event, styleVisibilityProps) {
            var it = nsGmx$1.gmxMap.layersByID[styleVisibilityProps.elem.name],
                styles = it.getStyles(),
                st = styles[styleVisibilityProps.styleIndex];
            var div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + styleVisibilityProps.elem.LayerID + "']")[0],
                elemProperties = div.gmxProperties.content.properties,
                treeStyles = window.newStyles ? elemProperties.gmxStyles.styles : elemProperties.styles,
                treeSt = treeStyles[styleVisibilityProps.styleIndex];

            if (typeof treeSt._MinZoom === 'undefined') {
              treeSt._MinZoom = treeSt.MinZoom;
            }

            if (styleVisibilityProps.show) {
              treeSt.MinZoom = treeSt._MinZoom;
              st.MinZoom = treeSt._MinZoom;
              treeSt.disabled = false;
            } else {
              treeSt.disabled = true;
            }

            st.disabled = treeSt.disabled;
            it.setStyles(styles);
          });

          _mapHelper$1.customParamsManager.addProvider({
            name: 'commonCalendar',
            loadState: function loadState(state) {
              if (!('version' in state)) {
                var tmpDateInterval = new nsGmx$1.DateInterval({
                  dateBegin: new Date(state.dateBegin),
                  dateEnd: new Date(state.dateEnd)
                });
                nsGmx$1.widgets.commonCalendar.getDateInterval().loadState(tmpDateInterval.saveState());
              } else if (state.version === '1.0.0') {
                nsGmx$1.widgets.commonCalendar.model.set('synchronyzed', typeof state.synchronyzed !== 'undefined' ? state.synchronyzed : true);
                nsGmx$1.widgets.commonCalendar.model.set('currentLayer', typeof state.currentLayer !== 'undefined' ? state.currentLayer : null);
                nsGmx$1.widgets.commonCalendar.getDateInterval().loadState(state.dateInterval);
                nsGmx$1.widgets.commonCalendar.model.set('dailyFilter', typeof state.dailyFilter !== 'undefined' ? state.dailyFilter : true);
              } else {
                throw 'Unknown params version';
              }
            },
            saveState: function saveState() {
              return {
                version: '1.0.0',
                dateInterval: nsGmx$1.widgets.commonCalendar.getDateInterval().saveState(),
                currentLayer: nsGmx$1.widgets.commonCalendar.model.get('currentLayer'),
                synchronyzed: nsGmx$1.widgets.commonCalendar.model.get('synchronyzed'),
                dailyFilter: nsGmx$1.widgets.commonCalendar.model.get('dailyFilter')
              };
            }
          });

          $('#flash').bind('dragover', function () {
            return false;
          });
          $('#flash').bind('drop', function (e) {
            if (!e.originalEvent.dataTransfer) {
              return;
            }

            _queryLoadShp.loadAndShowFiles(e.originalEvent.dataTransfer.files);

            return false;
          });

          if (state.dt) {
            try {
              var dateLocal = $.datepicker.parseDate('dd.mm.yy', state.dt);
              var dateBegin = nsGmx$1.CalendarWidget.fromUTC(dateLocal);
              var dateEnd = new Date(dateBegin.valueOf() + 24 * 3600 * 1000);
              var dateInterval = nsGmx$1.widgets.commonCalendar.getDateInterval();
              dateInterval.set({
                dateBegin: dateBegin,
                dateEnd: dateEnd
              });
            } catch (e) {
              console.log(e);
            }
          }

          nsGmx$1.pluginsManager.beforeViewer(); //для каждого ответа сервера об отсутствии авторизации (Status == 'auth') сообщаем об этом пользователю или предлагаем залогиниться

          addParseResponseHook('auth', function () {
            if (nsGmx$1.AuthManager.isLogin()) {
              showErrorMessage$1(_gtxt('Недостаточно прав для совершения операции'), true);
            } else {
              nsGmx$1.widgets.authWidget.showLoginDialog();
            }

            return false;
          });
          initAuthWidget(); //инициализация контролов пользовательских объектов
          //соответствующий модуль уже загружен
          // let oDrawingObjectsModule = gmxCore.getModule('DrawingObjects');

          window.oDrawingObjectGeomixer = new DrawingObjectGeomixer();
          window.oDrawingObjectGeomixer.Init(nsGmx$1.leafletMap, nsGmx$1.gmxMap); //для всех слоёв должно выполняться следующее условие: если хотя бы одна групп-предков невидима, то слой тоже невидим.

          (function fixVisibilityConstrains(o) {
            // o.content.properties.visible = o.content.properties.visible;
            if (o.type === 'group') {
              var a = o.content.children;
              var isAnyVisibleChild = false;

              for (var k = a.length - 1; k >= 0; k--) {
                var childrenVisibility = fixVisibilityConstrains(a[k]);
                isAnyVisibleChild = isAnyVisibleChild || childrenVisibility;
              } // если внутри группы есть включенные слои, группа тоже включается
              // если же ни одного включенного слоя нет, то группа выключается


              o.content.properties.visible = isAnyVisibleChild ? true : false;
            }

            return o.content.properties.visible;
          })({
            type: 'group',
            content: {
              children: data.children,
              properties: {
                visible: true
              }
            }
          });

          window.oldTree = JSON.parse(JSON.stringify(data));
          window.defaultLayersVisibility = {};

          for (var k = 0; k < gmxMap.layers.length; k++) {
            var _props3 = gmxMap.layers[k].getGmxProperties();

            window.defaultLayersVisibility[_props3.name] = _props3.visible;
          } //основная карта всегда загружена с того-же сайта, что и серверные скрипты


          data.properties.hostName = window.serverBase.slice(7).slice(0, -1); //DEPRICATED. Do not use it!

          _mapHelper$1.mapProperties = data.properties; //DEPRICATED. Do not use it!

          _mapHelper$1.mapTree = data;

          if (window.copyright && typeof window.copyright === 'string') {
            lmap.gmxControlsManager.get('copyright').setMapCopyright(window.copyright);
          }

          var condition = false,
              mapStyles = false,
              LayersTreePermalinkParams = false;

          if (state.condition) {
            condition = state.condition;
          }

          if (state.mapStyles) {
            mapStyles = state.mapStyles;
          }

          if (state.LayersTreePermalinkParams) {
            LayersTreePermalinkParams = state.LayersTreePermalinkParams;
          }
          /**
           *
           * SIDEBAR
           *
           */


          window.iconSidebarWidget = new IconSidebarWidget(document.getElementById('leftMenu'), {
            collapsedWidth: 40,
            extendedWidth: 400,
            position: 'left'
          });
          window.iconSidebarWidget.addEventListener('opened', window.resizeAll);
          window.iconSidebarWidget.addEventListener('closed', window.resizeAll);

          window.createTabFunction = function (options) {
            return function (state) {
              var el = document.createElement("div"),
                  tabEl = document.createElement("div"),
                  href = '#' + options.icon.toLowerCase(),
                  symbol = document.querySelector(href);
              $(el).addClass("tab-icon");
              if (symbol) $(symbol).addClass("sidebar-icon");
              tabEl.innerHTML = '<svg role="img" class="svgIcon">\
                    <use xlink:href="' + href + '" href="' + href + '"></use>\
                    </svg>';
              el.appendChild(tabEl);
              options.hint && el.setAttribute("title", options.hint);
              $(tabEl).addClass(options.icon);

              if (state === "active") {
                $(tabEl).addClass(options.active);
                $(el).addClass("tab-icon-active");
                if (symbol) $(symbol).addClass("sidebar-active-icon");
              } else {
                if (symbol && $(symbol).hasClass("sidebar-active-icon")) {
                  $(symbol).removeClass("sidebar-active-icon");
                }

                $(tabEl).addClass(options.inactive);
              }

              return el;
            };
          }; // init tab


          window.iconSidebarWidget._activeTabId = "layers-tree";
          var leftMainContainer = nsGmx$1.layersTreePane = window.iconSidebarWidget.setPane("layers-tree", {
            createTab: window.createTabFunction({
              icon: "s-tree",
              active: "sidebar-icon-active",
              inactive: "sidebar-icon-inactive",
              hint: "Слои"
            })
          });
          leftMainContainer.innerHTML = '<div class="leftMenu">' + '<div class="mainmap-title">' + data.properties.title + '</div>' + '<div id="leftPanelHeader" class="leftPanelHeader"></div>' + '<div id="leftContent" class="leftContent">' + '<div id="leftContentInner" class="leftContentInner"></div>' + '</div>' + '<div id="leftPanelFooter" class="leftPanelFooter"></div>' + '</div>';
          window.iconSidebarWidget.open("layers-tree"); // $('.leftContent').mCustomScrollbar();
          // function handleSidebarResize (e) {
          //     var sidebarWidth = window.iconSidebarWidget.getWidth(),
          //         lmap = nsGmx.leafletMap,
          //         newBottomLeft,
          //         newBounds;
          //     var c = lmap.getContainer();
          //     var pBounds = lmap.getPixelBounds(),
          //         bl = pBounds.getBottomLeft(),
          //         tr = pBounds.getTopRight(),
          //         blll = L.latLng(lmap.unproject(bl)),
          //         trll = L.latLng(lmap.unproject(tr));
          //     if (e.type === 'sidebar:opened') {
          //         newBottomLeft = L.point(bl.x + sidebarWidth, bl.y);
          //     } else {
          //         newBottomLeft = L.point(bl.x - sidebarWidth, bl.y);
          //     }
          //     newBounds = L.latLngBounds(L.latLng(lmap.unproject(newBottomLeft)), trll);
          // }

          /**
           *
           * SIDEBAR END
           *
           */

          _queryMapLayers.addLayers(data, condition, mapStyles, LayersTreePermalinkParams); // переписать на вкладку с деревом


          var headerDiv = $('.mainmap-title'); // special for steppe Project

          if (data.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
            $(headerDiv).toggle();
          }

          nsGmx$1.ContextMenuController.bindMenuToElem(headerDiv[0], 'Map', function () {
            return _queryMapLayers.currentMapRights() == 'edit';
          }, function () {
            return {
              div: $(_layersTree._treeCanvas).find('div[MapID]')[0],
              tree: _layersTree
            };
          }); // _menuUp.defaultHash = 'layers';

          window.mapLayers.mapLayers.load(); //создаём тулбар
          // var iconContainer = _div(null, [
          //     ['css', 'borderLeft', '1px solid #216b9c']
          // ]);
          // var searchContainer = nsGmx.widgets.header.getSearchPlaceholder()[0];

          window.searchLogic.init({
            oMenu: oSearchLeftMenu
          }); //инициализация контролов поиска (модуль уже загружен)
          // var oSearchModule = gmxCore.getModule('search');
          // window.oSearchControl = new oSearchModule.SearchGeomixer();
          // if (document.getElementById('searchCanvas')) {
          // window.oSearchControl.Init({
          //     Menu: oSearchLeftMenu,
          //     ContainerInput: searchContainer,
          //     ServerBase: window.serverBase,
          //     layersSearchFlag: true,
          //     Map: lmap,
          //     gmxMap: gmxMap
          // });

          _menuUp.createMenu = function () {
            createMenuNew();
          };

          _menuUp.go(nsGmx$1.widgets.header.getMenuPlaceholder()[0]);

          var headerLinks = nsGmx$1.addHeaderLinks();

          if (headerLinks.length) {
            _menuUp.addItem({
              id: 'linksMenu',
              title: _gtxt('Ссылки'),
              childs: headerLinks
            });
          } // Загружаем все пользовательские данные


          nsGmx$1.userObjectsManager.load(); // выставляет правильные z-indexes слоям-вьюхам

          _layersTree.updateZIndexes(); //выполняем мапплет карты нового формата


          nsGmx$1.mappletLoader.execute(); //динамически добавляем пункты в меню. DEPRICATED.

          nsGmx$1.pluginsManager.addMenuItems(_menuUp);
          _mapHelper$1.gridView = false;

          var updateLeftPanelVis = function updateLeftPanelVis() {
            // $('.leftCollapser-icon')
            //     .toggleClass('leftCollapser-right', !layersShown)
            //     .toggleClass('leftCollapser-left', !!layersShown);
            window.resizeAll();
          }; // $('#leftCollapser').click(function() {
          //     layersShown = !layersShown;
          //     updateLeftPanelVis();
          // });


          updateLeftPanelVis();
          createToolbar();
          var controls = lmap.gmxControlsManager.getAll();

          for (var key in controls) {
            var ctrl = controls[key],
                cntr = ctrl.getContainer();
            cntr.addEventListener('click', function (e) {
              _menuUp.hideOnClick(e);
            });
          }

          if (state.mode) {
            lmap.gmxBaseLayersManager.setCurrentID(lmap.gmxBaseLayersManager.getIDByAlias(state.mode) || state.mode);
          } else if (baseLayers.length && !lmap.gmxBaseLayersManager.getCurrentID()) {
            lmap.gmxBaseLayersManager.setCurrentID(baseLayers[0]);
          }

          if (state.drawings) {
            lmap.gmxDrawing.loadState(state.drawings);
          } else if (state.drawnObjects) {
            state.drawnObjects.forEach(function (objInfo) {
              //старый формат - число, новый - строка
              var lineStyle = {};

              if (objInfo.color) {
                lineStyle.color = typeof objInfo.color === 'number' ? '#' + L.gmxUtil.dec2hex(objInfo.color) : objInfo.color;
              }

              if (objInfo.thickness) {
                lineStyle.weight = objInfo.thickness;
              }

              if (objInfo.opacity) {
                lineStyle.opacity = objInfo.opacity / 100;
              }

              var featureOptions = $.extend(true, {}, objInfo.properties, {
                lineStyle: lineStyle
              });
              var drawingFeature = lmap.gmxDrawing.addGeoJSON(L.gmxUtil.geometryToGeoJSON(objInfo.geometry), featureOptions)[0];

              if (objInfo.isBalloonVisible) {
                drawingFeature.openPopup();
              }
            });
          } else if (state.marker) {
            nsGmx$1.leafletMap.gmxDrawing.addGeoJSON({
              type: 'Feature',
              geometry: {
                type: 'Point',
                coordinates: [state.marker.mx, state.marker.my]
              },
              properties: {
                title: state.marker.mt
              }
            });
          }

          if (state.openPopups) {
            for (var _l2 in state.openPopups) {
              var _layer5 = nsGmx$1.gmxMap.layersByID[_l2];

              if (_layer5 && _layer5.addPopup) {
                state.openPopups[_l2].forEach(_layer5.addPopup.bind(_layer5));
              }
            }
          }

          _menuUp.checkView();

          if (nsGmx$1.AuthManager.isLogin()) {
            _queryMapLayers.addUserActions();
          }

          if (state.dateIntervals) {
            for (var lid in gmxMap.layersByID) {
              if (lid in state.dateIntervals) {
                var _l3 = gmxMap.layersByID[lid],
                    beginDate = new Date(state.dateIntervals[lid].beginDate),
                    endDate = new Date(state.dateIntervals[lid].endDate);

                _l3.setDateInterval(beginDate, endDate);
              }
            }
          }

          if (state.filters) {
            for (var _key in state.filters) {
              var _l4 = nsGmx$1.gmxMap.layersByID[_key],
                  filtersArr = state.filters[_key];

              for (var i = 0; i < filtersArr.length; i++) {
                if ('filterById' in filtersArr[i]) {
                  (function () {
                    var filteredId = filtersArr[i]['filterById'];

                    _l4.addLayerFilter(function (it) {
                      return it.id === filteredId;
                    });
                  })();
                }
              }
            }
          }

          initEditUI();
          initTemporalLayers();
          gmxMap.addLayersToMap(lmap);
          nsGmx$1.leafletMap.on('layeradd', function (event) {
            var layer = event.layer;

            if (layer.getGmxProperties) {
              // var layerProps = layer.getGmxProperties();
              initEditUI();
              initTemporalLayers([layer]);
            }
          }); // if (mapProp.MapID !== 'ATTBP') {

          nsGmx$1.gmxMap.on('onRemoveLayer', function (event) {
            var layer = event.layer;

            if (!layer.getGmxProperties()) {
              return;
            }

            var props = layer.getGmxProperties(),
                isTemporalLayer = layer instanceof L.gmx.VectorLayer && props.Temporal || props.type === 'Virtual' && layer.getDateInterval;

            if (isTemporalLayer && !(props.name in nsGmx$1.widgets.commonCalendar._unbindedTemporalLayers)) {
              nsGmx$1.widgets.commonCalendar.unbindLayer(props.name);
              nsGmx$1.widgets.commonCalendar.updateTemporalLayers();
              delete nsGmx$1.widgets.commonCalendar._unbindedTemporalLayers[props.name];
            }
          }); // special for steppe project

          if (nsGmx$1.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
            nsGmx$1.widgets.commonCalendar.show();
          }

          nsGmx$1.pluginsManager.afterViewer(); // обработка специальных параметров плагинов

          nsGmx$1.pluginsManager.forEachPlugin(function (plugin) {
            if (plugin.moduleName === "gmxTimeLine" && nsGmx$1.timeLineControl) {
              var treeLayers = $(window._layersTree);
              nsGmx$1.timeLineControl.on('layerRemove', function (e) {
                treeLayers.triggerHandler('layerTimelineRemove', e);
              }).on('layerAdd', function (e) {
                treeLayers.triggerHandler('layerTimelineAdd', e);
              }).saveState().dataSources.forEach(function (it) {
                treeLayers.triggerHandler('layerTimelineAdd', {
                  type: 'layerAdd',
                  layerID: it.layerID
                });
              });
            }
          }); // экспорт карты

          if (state.exportMode) {
            _mapHelper$1.exportMap(state);
          }
        });
      }

      function mapExportMenu() {
        gmxCore$1.loadModule('MapExport', 'src/MapExport/MapExport.js').then(function (def) {
          var menu = new def.MapExportMenu();
          menu.Load();
        });
      }

      function BufferZonesMenu() {
        gmxCore$1.loadModule('BufferZones', 'src/BufferZones/BufferZones.js').then(function (def) {
          var menu = new def.BufferZonesMenu();
          menu.Load();
        });
      }

      function indexGridMenu() {
        gmxCore$1.loadModule('IndexGrid', 'src/IndexGrid/IndexGrid.js').then(function (def) {
          var menu = new def.IndexGridMenu();
          menu.Load();
        });
      }

      function PhotoLayerDialog() {
        gmxCore$1.loadModule('PhotoLayer', 'src/PhotoLayer/PhotoLayer.js').then(function (def) {
          var dialog = new def.PhotoLayer();
          dialog.Load();
        });
      }

      function promptFunction(title, value) {
        var ui = $(Handlebars.compile('<div class="gmx-prompt-canvas">' + '<input class="inputStyle gmx-prompt-input" value="{{value}}">' + '</div>')({
          value: value
        }));
        ui.find('input').on('keydown', function (e) {
          // var evt = e || window.event;
          if (e.which === 13) {
            var coord = L.gmxUtil.parseCoordinates(this.value);
            nsGmx$1.leafletMap.panTo(coord);
            return false;
          }
        });
        showDialog$1(title, ui[0], 300, 80, false, false);
      }

      window.prompt = promptFunction;
    };

    nsGmx$1.initGeoMixer();

}());
