(function () {
    'use strict';

    let nsGmx$1 = {};
    window.nsGmx = nsGmx$1;

    /** Загрузчик модулей ГеоМиксера
    Позволяет загружать модули из разных файлов.
    Модуль - единица кода, имеющая уникальное имя и зависящая от других модулей и скриптов.
    @namespace
    */

    var gmxCore$1 = function()
    {
        var _callbacks = [];
        var _modules = {}; //null - файл модуля уже загружается, но сам модуль пока не доступен
        var _globalNamespace = this;
    	var _modulesDefaultHost = "";
    	var _modulePathes = {/*#buildinclude<modules_path.txt>*/};
    	var _moduleFiles = {/*#buildinclude<module_files.txt>*/};

        var getScriptURL = function(scriptName)
    	{
            scriptName = scriptName.toLowerCase();
    		var scripts1 = document.getElementsByTagName("script");
    		for (var i = 0; i < scripts1.length; i++)
    		{
    			var src = scripts1[i].getAttribute("src");
    			if (src && (src.toLowerCase().indexOf(scriptName) != -1))
    				return src;
    		}
    		return false;
    	};

        //производится регистронезависимое сравнение
    	var getScriptBase = function(scriptName)
    	{
            scriptName = scriptName.toLowerCase();
    		var url = getScriptURL(scriptName);
    		return url ? url.toLowerCase().substring(0, url.toLowerCase().indexOf(scriptName)) : "";
    	};

        var invokeCallbacks = function()
        {
            for (var k = 0; k < _callbacks.length; k++)
            {
                var isAllModules = true;
                var curModules = _callbacks[k].modules;
    			var modules = [];
                for (var m = 0; m < curModules.length; m++)
    			{
                    if ( !_modules[curModules[m]] )
                    {
                        isAllModules = false;
                        break;
                    }
    				modules.push(_modules[curModules[m]]);
    			}

                if (isAllModules)
                {
                    var curCallback = _callbacks[k].callback;

                    //first delete, then callback!
                    _callbacks.splice(k, 1);
                    k = k - 1;
                    curCallback.apply(null, modules);
                }
            }
        };
        var LABjsDeferred = null;
        var lazyLoadLABjs = function()
        {
            if (!LABjsDeferred) {
                LABjsDeferred = $.Deferred();

                //load LAB.js (snippest from its website)
                (function(g,b,d){var c=b.head||b.getElementsByTagName("head"),D="readyState",E="onreadystatechange",F="DOMContentLoaded",G="addEventListener",H=setTimeout;
                H(function(){if("item"in c){if(!c[0]){H(arguments.callee,25);return}c=c[0];}var a=b.createElement("script"),e=false;a.onload=a[E]=function(){if((a[D]&&a[D]!=="complete"&&a[D]!=="loaded")||e){return false}a.onload=a[E]=null;e=true;LABjsDeferred.resolve();};

                a.src = ( getScriptBase('gmxcore.js') || window.gmxJSHost || "" ) + 'LAB.min.js';

                c.insertBefore(a,c.firstChild);},0);if(b[D]==null&&b[G]){b[D]="loading";b[G](F,d=function(){b.removeEventListener(F,d,false);b[D]="complete";},false);}})(this,document);

            }

            return LABjsDeferred.promise();
        };

        var cssLoader = null;

        var withCachePostfix = function(filename) {
            var sym = filename.indexOf('?') === -1 ? '?' : '&';
            if (window.gmxDropBrowserCache) {
                filename += sym + Math.random();
            } else if (window.nsGmx && nsGmx.buildGUID){
                filename += sym + nsGmx.buildGUID;
            }

            return filename;
        };

        var publicInterface =
        /** @lends gmxCore */
        {
            /** Добавить новый модуль
            * @param {String} moduleName Уникальное имя модуля
            * @param {Object|Function} moduleObj Тело модуля или ф-ция, возвращающая тело. Аргумент ф-ции - путь к модулю. Будет вызвана после загрузки всех зависимостей.
            * @param {Object} [options] Дополнительные параметры модуля
            * @param {String[]} [options.require] Какие модули должны быть загрежены перед данным
            * @param {Function} [options.init] Ф-ция для инициализации модуля. Сигнатура: function (moduleObj, modulePath)->{void|{@link jQuery.Deferred}}. Если ф-ция возвращает {@link jQuery.Deferred}, загрузчик будет ждать его для окончания инициализации.
            * @param {String|String[]} [options.css] CSS файлы для загрузки. Пути к CSS указываются относительно файла текущего модуля.
            */
            addModule: function(moduleName, moduleObj, options)
            {
                var requiredModules = (options && 'require' in options) ? options.require : [];
                var initDeferred = null;
                var _this = this;

                for (var r = 0; r < requiredModules.length; r++)
                    this.loadModule( requiredModules[r] );

                this.addModulesCallback( requiredModules, function()
                {

                    if (options && 'init' in options)
    				{
                        initDeferred = options.init(moduleObj, _modulePathes[moduleName]);
    				}

                    if (options && 'css' in options)
    				{
                        var cssFiles = typeof options.css === 'string' ? [options.css] : options.css;
                        var path = _modulePathes[moduleName] || window.gmxJSHost || "";

                        for (var iF = 0; iF < cssFiles.length; iF++)
                            _this.loadCSS(withCachePostfix(path + cssFiles[iF]));
    				}

                    var doAdd = function() {
                        if (typeof moduleObj === 'function') {
                            moduleObj = moduleObj( _modulePathes[moduleName] );
                        }
                        _modules[moduleName] = moduleObj;
                        invokeCallbacks();
                    };

                    if (initDeferred) {
                        initDeferred.done(doAdd);
                    } else {
                        doAdd();
                    }
                });
            },

            /** Загрузить модуль
            * @param { String } moduleName Имя модуля для загрузки
            * @param { String } [moduleSource] Имя файла, откуда загружать модуль. Если не указан, будет сформирован в виде (defaultHost + moduleName + '.js')
            * @param { Function } [callback] Ф-ция, которая будет вызвана после загрузки и инициализации. В ф-цию первым параметром передаётся тело модуля
            * @return { jQuery.Deferred } Promise, который будет resolve при загрузке модуля (параметр - модуль).
            */
            loadModule: function(moduleName, moduleSource, callback)
            {
                var def = $.Deferred();

                if (typeof moduleSource === 'function') {
                    callback = moduleSource;
                    moduleSource = undefined;
                }

                this.addModulesCallback([moduleName], function(module)
                {
                    callback && callback(module);
                    def.resolve(module);
                });

                if ( ! (moduleName in _modules) )
                {
                    _modules[moduleName] = null;

                    var headElem = document.getElementsByTagName("head")[0];
                    var newScript = document.createElement('script');

                    var path;
                    if (typeof moduleSource != 'undefined')
                    {
                        path = moduleSource.match(/^https?:\/\//i) ? moduleSource : (window.gmxJSHost || "") + moduleSource;
                    }
                    else
                    {
                        path = (moduleName in _moduleFiles) ? _moduleFiles[moduleName] : (_modulesDefaultHost || window.gmxJSHost || "") + moduleName + '.js';
                    }

                    var pathRegexp = /(.*)\/[^\/]+/;
                    if ( typeof _modulePathes[moduleName] === 'undefined' )
                        _modulePathes[moduleName] = pathRegexp.test(path) ? path.match(pathRegexp)[1] + "/" : "";

                    newScript.onerror = function() {
                        def.reject();
                    };

                    newScript.type = 'text/javascript';
                    newScript.src = withCachePostfix(path);
                    newScript.charset = "utf-8";
                    headElem.appendChild(newScript);
                }

                return def;
            },

            /** Добавить callback, который будет вызван после загрузки моделей
            *
            * Если модули уже загружены, callback будет вызван сразу же
            *
            * @param {Array} moduleNames Массив имён модулей
            * @param {Function} callback Ф-ция, которую нужно вызвать после загрузки. В качестве аргументов в ф-цию передаются загруженные модули
            */
            addModulesCallback: function( moduleNames, callback )
            {
                _callbacks.push({modules: moduleNames, callback: callback});
                invokeCallbacks();
            },

            /** Получить модуль по имени.
            *
            * @param {String} moduleName Имя модуля
            * @return {Object} Тело модуля. Если модуль не загружен, вернётся null.
            */
            getModule: function(moduleName)
            {
                return _modules[moduleName] || null;
            },

            /** Установить дефольный путь к модулям. Используется если указан локальный файл модуля.
            * @param {String} defaultHost Дефолтный путь у модулям.
            */
    		setDefaultModulesHost: function( defaultHost )
    		{
    			_modulesDefaultHost = defaultHost;
    		},

            /** Явно задать полный путь к модулю
            * @param {String} moduleName Имя модуля
            * @param {String} defaultHost Путь к файлу модулю. При загрузке модуля будет загружен файл по указанному пути
            */
            setModuleFile: function(moduleName, moduleFile)
            {
                _moduleFiles[moduleName] = moduleFile;
            },

            pushModule2GlobalNamespace: function(moduleName)
            {
                if ( !_modules[moduleName] ) return;
                var module = _modules[moduleName];

                for (var p in module)
                    _globalNamespace[p] = module[p];
            },

            /** Получить путь к директории, из которой был загружен модуль.
            * @param {String} moduleName Имя модуля
            * @returns {String} Путь к директории, из которой был загружен модуль. Для не загруженных модулей ничего не возвращает
            */
    		getModulePath: function(moduleName)
    		{
    			return _modulePathes[moduleName];
    		},

            /** Возвращает ф-цию, которая делает следующее:
            *
            *  - Если модуль moduleName не загружен, загружает его
            *  - Потом просто вызывает ф-цию с именем functionName из этого модуля, передав ей все свои параметры
            *
            *  - Возвращённая ф-ция при вызове возвращает jQuery.Promise, который будет resolve с параметрами, возвращёнными исходной ф-цией из модуля
            * @param {String} moduleName Имя модуля
            * @param {String} functionName Название ф-ции внутри модуля
            * @param {Function} callback Ф-ция, которая будет вызвана после того, как отработает ф-ция модуля. В callback будет передан ответ исходной ф-ции.
            */
            createDeferredFunction: function(moduleName, functionName, callback)
            {
                var _this = this;
                return function()
                {
                    var deferred = $.Deferred();
                    var args = arguments;
                    _this.loadModule(moduleName).done(function(module)
                    {
                        var res = module[functionName].apply(this, args);
                        callback && callback(res);
                        deferred.resolve(res);
                    });

                    return deferred.promise();
                }
            },

            /** Загружает скрипт после предвариетельной проверки условий.
            *
            * @param {Array} filesInfo Массив объектов со следующими свойствами:
            *
            *   * check: function() -> Bool. Если возвращает true, ни js ни css не будет загружены
            *   * script: String. Не обязательно. Скрипт для загрузки, если провалится проверка
            *   * css: String | String[]. Не обязательно. CSS файл(ы) для загрузки, если провалится проверка
            *   @returns {jQuery.Deferred} Deferred, который будет разрешён когда все скрипты выполнятся (окончание загрузки css не отслеживается)
            */
            loadScriptWithCheck: function(filesInfo)
            {
                var _this = this;
                var localFilesInfo = filesInfo.slice(0);
                var def = $.Deferred();

                var doLoad = function(info)
                {
                    if (localFilesInfo.length > 0)
                    {
                        var curInfo = localFilesInfo.shift();
                        if (curInfo.check())
                            doLoad();
                        else
                        {
                            var css = curInfo.css || [];
                            if (typeof css === 'string') {
                                css = [css];
                            }
                            css.forEach(_this.loadCSS);

                            if (curInfo.script)
                                _this.loadScript(curInfo.script).then(doLoad);
                            else
                                doLoad();
                        }
                    }
                    else
                        def.resolve();
                };

                doLoad();
                return def.promise();
            },

            /**
            * Загружает отдельный скрипт
            * @param {String} fileName Имя файла скрипта
            * @param {function} [callback] Ф-ция, которая будет вызвана после загрузки
            * @param {String} [charset=utf-8] Кодировка загружаемого файла
            * @returns {jQuery.Deferred}
            */
            loadScript: function(fileName, callback, charset)
            {
                var def = $.Deferred();
                lazyLoadLABjs().done(function()
                {
                    var descr = {src: withCachePostfix(fileName)};
                    if (charset) {
                        descr.charset = charset;
                    }

                    $LAB.script(descr).wait(function()
                    {
                        def.resolve();
                        callback && callback();
                    });
                });
                return def.promise();
            },

            /** Загрузить отдельный css файл
            * @param {String} cssFilename Имя css файла.
            */
            loadCSS: function(cssFilename)
            {
                var doLoadCss = function()
                {
                    $.getCSS(withCachePostfix(cssFilename));
                };

                if ('getCSS' in $)
                {
                    doLoadCss();
                }
                else
                {
                    if (!cssLoader)
                    {
                        var path = getScriptBase('gmxcore.js') || window.gmxJSHost || "";
                        cssLoader = $.getScript(path + "jquery/jquery.getCSS.js");
                    }

                    cssLoader.done(doLoadCss);
                }
            }
        };

        return publicInterface;
    }();

    window.gmxCore = gmxCore$1;

    nsGmx$1.Utils = nsGmx$1.Utils || {};
    var domManipulation = {
        // _el(nodeName, [childs], [attrs])
        _el: function(str, childs, attributes)
        {
            var el = document.createElement(str),
                children = childs,
                attrs = attributes;

            if (children)
                domManipulation._childs(el, children);

            if (attrs && attrs.length)
                domManipulation._attr(el, attrs);

            return el;
        },
        // _t("some text")
        _t: function(str)
        {
            return document.createTextNode(String(str));
        },
        // children - всегда массив
        _childs: function(el, children)
        {
            for (var i = 0; i < children.length; ++i)
                el.appendChild(children[i]);
        },
        //[['css','width','100%']]
        //[['dir','className','name']]
        //[['attr','colSpan',2]]
        _attr: function(el, attrs)
        {
            for (var i = 0; i < attrs.length; ++i)
            {
                var atr = attrs[i],
                    type = atr[0];

                switch(type)
                {
                    case 'css':
                        (el.style[atr[1]] = atr[2]);
                        break;
                    case 'dir':
                        el[atr[1]] = atr[2];
                        break;
                    case 'attr':
                        el.setAttribute(atr[1], atr[2]);
                        break;
                }
            }
        },
        _table: function(children,attrs){return _el('TABLE',children,attrs)},
        _caption: function(children,attrs){return _el('CAPTION',children,attrs)},
        _thead: function(children,attrs){return _el('THEAD',children,attrs)},
        _tbody: function(children,attrs){return _el('TBODY',children,attrs)},
        _tfoot: function(children,attrs){return _el('TFOOT',children,attrs)},
        _textarea: function(children,attrs){return _el('TEXTAREA',children,attrs)},
        _th: function(children,attrs){return _el('TH',children,attrs);} ,
        _tr: function(children,attrs){return _el('TR',children,attrs);},
        _td: function(children,attrs){return _el('TD',children,attrs);},
        _span: function(children,attrs){return _el('SPAN',children,attrs);},
        _label: function(children,attrs){return _el('LABEL',children,attrs);},
        _li: function(children,attrs){return _el('LI',children,attrs);},
        _ul: function(children,attrs){return _el('UL',children,attrs);},
        _div: function(children,attrs){return _el('DIV',children,attrs);},
        _radio: function(attrs){return _el('INPUT',null,(attrs&&attrs.concat([['attr','type','radio']]))||[['attr','type','radio']])},
        _button: function(children,attrs){return _el('BUTTON',children,attrs)},
        _a: function(children,attrs){return _el('A',children,attrs)},
        _select: function(children,attrs){return _el('SELECT',children,attrs)},
        _option: function(children,attrs){return _el('OPTION',children,attrs);},
        _form: function(children,attrs){return _el('FORM',children,attrs)},
        _iframe: function(children,attrs){return _el('IFRAME',children,attrs)},
        _image: function(children,attrs){return _el('IMG',children,attrs)},
        _img: function(children,attrs){return _el('IMG',children,attrs)},
        _br: function(){return _el('BR')},
        _hr: function(){return _el('HR')},
        _p: function(children,attrs){return _el('P',children,attrs)},
        _b: function(children,attrs){return _el('B',children,attrs)},
        _i: function(children,attrs){return _el('I',children,attrs)},
        _input: function(children,attrs){return _el('INPUT',children,attrs)}
    };

    var _el = domManipulation._el;

    // _(elem, [childs], [attrs])
    var _$1 = function(ent,childs,attributes)
    {
        var el = ent,
            children = childs,
            attrs = attributes;

        if (children)
            domManipulation._childs(el, children);

        if (attrs && attrs.length)
            domManipulation._attr(el, attrs);

        return el;
    };

    var prevGlobals = {};
    for (var k in domManipulation) {
        prevGlobals[k] = window[k];
    }

    /** Удаляет из глобальной видимости часть методов, записанных туда при загрузке utilities.js
    * @memberOf nsGmx.Utils
    */
    nsGmx$1.Utils.noConflicts = function() {
        for (var k in domManipulation) {
            window[k] = prevGlobals[k];
        }
        return nsGmx$1.Utils;
    };

    jQuery.extend(window, domManipulation);      //для обратной совместимости
    jQuery.extend(nsGmx$1.Utils, domManipulation);
    nsGmx$1.Utils._ = _$1;

    if (window.Node && window.Node.prototype)
    {
    	Node.prototype.removeNode = function()
    	{
    		var parent = this.parentNode;
    		parent && parent.removeChild(this);
    	};
    }
    function hide$1(elem)
    {
    	elem.style.display = 'none';
    }
    function hidden(elem)
    {
    	elem.style.visibility = 'hidden';
    }
    function visible(elem)
    {
    	elem.style.visibility = 'visible';
    }
    function switchSelect(sel, value)
    {
    	if (!sel.options || !sel.options.length)
    		return sel;

    	for (var i = 0; i < sel.options.length; i++)
    	{
    		if (value == sel.options[i].value)
    		{
    			sel.options[i].selected = true;

    			sel.selectedIndex = i;

    			break;
    		}
    	}

    	return sel;
    }
    function objLength$1(obj)
    {
    	var cnt = 0;
    	for (var field in obj) cnt++;

    	return cnt;
    }
    function getOffsetRect$1(elem)
    {
        var box = elem.getBoundingClientRect(),
        	body = document.body,
        	docElem = document.documentElement,
        	scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop,
        	scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
        	clientTop = docElem.clientTop || body.clientTop || 0,
        	clientLeft = docElem.clientLeft || body.clientLeft || 0,
        	top  = box.top +  scrollTop - clientTop,
        	left = box.left + scrollLeft - clientLeft;

        return { top: Math.round(top), left: Math.round(left) }
    }
    function attachEffects$1(elem, className)
    {
    	elem.onmouseover = function()
    	{
    		jQuery(this).addClass(className);
    	};
    	elem.onmouseout = function(e)
    	{
    		var evt = e || window.event,
    			target = evt.srcElement || evt.target,
    			relTarget = evt.relatedTarget || evt.toElement;

    		try
    		{
    			while (relTarget)
    			{
    				if (relTarget == elem)
    					return;
    				relTarget = relTarget.parentNode;
    			}

    			jQuery(elem).removeClass(className);
    		}
    		catch (e)
    		{
    			jQuery(elem).removeClass(className);
    		}
    	};
    }
    function makeButton$1(value, id)
    {
    	var inp = _input$1(null, [['dir','className','btn'],['attr','type','submit'],['attr','value',value]]);
    	if (typeof id != 'undefined' && id != null)
    		inp.id = id;

    	inp.style.padding = '0px 5px';

    	return inp;
    }
    function makeImageButton$1(url, urlHover)
    {
    	var btn = _img();
    	btn.setAttribute('src',url);
    	btn.style.cursor = 'pointer';
    	btn.style.border = 'none';

    	if (urlHover)
    	{
    		btn.onmouseover = function()
    		{
    			this.setAttribute('src', urlHover);
    		};
    		btn.onmouseout = function()
    		{
    			this.setAttribute('src', url);
    		};
    	}

    	return btn;
    }
    function makeLinkButton$1(text)
    {
    	var span = _span$1([_t$1(String(text))],[['dir','className','buttonLink']]);

    	attachEffects$1(span, 'buttonLinkHover');

    	return span;
    }

    //Показывает диалог (на основе jQuery UI dialog)
    //Параметры можно передавать явно и в виде объекта params:
    //1. showDialog(title, content, width, height, ?posX, ?posY, ?resizeFunc, ?closeFunc)
    //2. showDialog(title, content, params)
    //Параметры:
    // - title {string} Заголовок диалога
    // - content {HTMLDomElement} контент диалога
    // - width, height {int} высота и ширина диалога (обязательные параметры!)
    // - posX, posY {int} положение диалога относительно экрана. Если не задано - по центру
    // - resizeFunc {function} будет вызываться при изменении размера диалога. Аргумент ф-ции - объект с атриубтами width и height
    // - closeFunc {function} будет вызываться при закрытии диалога
    // - setMinSize {bool} если true (по умолчанию), будут заданы минимальная ширина и высота, равные начальным размерам (width, height)
    function showDialog$1(title, content, width, height, posX, posY, resizeFunc, closeFunc)
    {
        var params = null;
        if (arguments.length == 3)
        {
            params = $.extend({
                posX: false,
                posY: false,
                setMinSize: true
            }, width);
        }
        else
        {
            params = {
                width: width,
                height: height,
                posX: posX,
                posY: posY,
                resizeFunc: resizeFunc,
                closeFunc: closeFunc,
                setMinSize: true
            };
        }
    	var canvas = _div$1([content]);

    	document.body.appendChild(canvas);

    	var dialogParams = {
            width: params.width,
            height: params.height,
            title: title,
            position: params.posX == false ? 'center' : [params.posX, params.posY],
            resizable: true,
            resize: function(event, ui)
            {
                params.resizeFunc && params.resizeFunc(ui.size);
            },
            close: function(ev, ui)
            {
                if (params.closeFunc && params.closeFunc())
                    return;

                removeDialog$1(canvas);
            },
            open: function (ev, ui) {
            },
            closeText: null
        };

        if (params.setMinSize)
        {
            dialogParams.minWidth = params.width;
            dialogParams.minHeight = params.height;
        }

        jQuery(canvas).dialog(dialogParams);

    	var dialog = canvas.parentNode;
    	dialog.style.overflow = '';

        $(dialog).focusout(function (event) {

            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
            jQuery.support.focusinBubbles = false;
            var ui = $('.ui-dialog-content', this);
                ui.context.st = $(ui).scrollTop();

        });

        $(dialog).focusin(function() {
            var uis = $('.ui-dialog-content');

            $(uis).each(function(index) {
                var st = $(this).context.st;
                $(this).scrollTop(st);
            });

        });


    	jQuery(dialog).children("div.ui-resizable-se").removeClass("ui-icon")
    				.removeClass("ui-icon-gripsmall-diagonal-se")
    				.removeClass("ui-icon-grip-diagonal-se");

    	return canvas;
    }

    function removeDialog$1(canvas)
    {
    	jQuery(canvas).dialog('destroy').remove();
    }

    function showErrorMessage$1(message, removeFlag, title)
    {
    	var canvas = _div$1([_t$1(message)],[['dir','className','errorDialog']]);
        var jQueryDiv = showDialog$1(title || "Ошибка!", canvas, {
                width: 250,
                height: 150,
                closeFunc: function(){
                    canvas = null;
                }
            });

    	if (removeFlag)
    	{
    		setTimeout(function()
    		{
    			if (canvas)
    			{
                    jQuery(jQueryDiv).dialog("destroy");
    				jQuery(canvas.parentNode).remove();
    			}
    		}, 2500);
    	}
    }

    function _checkbox$1(flag, type, name)
    {
    	var box = _input$1(null, [['attr','type',type]]);
        box.checked = flag;

        if (name)
            box.setAttribute('name', name);

    	return box;
    }

    nsGmx$1.Utils.uniqueGlobalName = (function()
    {
        var freeid = 0;
        return function(thing)
        {
            var id = 'gmx_unique_' + freeid++;
            window[id] = thing;
            return id;
        }
    })();

    /** Посылает кросс-доменный GET запрос к серверу с использованием транспорта JSONP.
     *
     * @memberOf nsGmx.Utils
     * @param {String} url URL сервера.
     * @param {Function} callback Ф-ция, которая будет вызвана при получении от сервера результата.
     * @param {String} [callbackParamName=CallbackName] Имя параметра для задания имени ф-ции ответа.
     * @param {Function} [errorCallback] Ф-ция, которая будет вызвана в случае ошибки запроса к серверу
     */
    function sendCrossDomainJSONRequest$1(url, callback, callbackParamName, errorCallback)
    {
    	callbackParamName = callbackParamName || 'CallbackName';

        var script = document.createElement("script");
    	script.setAttribute("charset", "UTF-8");
    	var callbackName = nsGmx$1.Utils.uniqueGlobalName(function(obj)
    	{
    		callback && callback(obj);
    		window[callbackName] = false;
    		document.getElementsByTagName("head").item(0).removeChild(script);
    	});

        var sepSym = url.indexOf('?') == -1 ? '?' : '&';

        if (errorCallback) {
            script.onerror = errorCallback;
        }

    	script.setAttribute("src", url + sepSym + callbackParamName + "=" + callbackName + "&" + Math.random());
    	document.getElementsByTagName("head").item(0).appendChild(script);
    }
    nsGmx$1.Utils.sendCrossDomainJSONRequest = sendCrossDomainJSONRequest$1;

    function createCookie$1(name, value, days)
    {
    	if (days)
    	{
    		var date = new Date();
    		date.setTime(date.getTime() + (days*24*60*60*1000));
    		var expires = "; expires=" + date.toGMTString();
    	}
    	else
    		var expires = "";
    	document.cookie = name + "=" + value + expires + "; path=/";
    }

    function readCookie(name)
    {
    	var nameEQ = name + "=";
    	var ca = document.cookie.split(';');
    	for(var i = 0; i < ca.length; i++)
    	{
    		var c = ca[i];
    		while (c.charAt(0)==' ')
    			c = c.substring(1, c.length);
    		if (c.indexOf(nameEQ) == 0)
    			return c.substring(nameEQ.length, c.length);
    	}
    	return null;
    }

    function eraseCookie$1(name)
    {
    	createCookie$1(name, "", -1);
    }

    function getWindowWidth()
    {
    	var myWidth = 0;

    	if (typeof (window.innerWidth) == 'number')
    		myWidth = window.innerWidth;
    	else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight))
    		myWidth = document.documentElement.clientWidth;
    	else if (document.body && (document.body.clientWidth || document.body.clientHeight))
    	{
    		myWidth = document.body.clientWidth;
    	}

    	return myWidth;
    }

    function getWindowHeight()
    {
    	var myHeight = 0;

    	if (typeof (window.innerWidth) == 'number' )
    		myHeight = window.innerHeight;
    	else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight))
    		myHeight = document.documentElement.clientHeight;
    	else if (document.body && (document.body.clientWidth || document.body.clientHeight))
    		myHeight = document.body.clientHeight;

    	return myHeight;
    }

    (function() {
        var replacements = {};
        var temp;
        for (var rus in (temp = {
            "qwertyuiopasdfghjklzxcvbnm_1234567890" :
            "qwertyuiopasdfghjklzxcvbnm_1234567890",
            "абвгдезийклмнопрстуфыэ ":
            "abvgdeziyklmnoprstufye_",
            "ёжчхцшщюя":
            "yozhchkhtsshshyuya",
            "ьъ":
            "",
            ".":
            "."
        }))
        {
            var eng = temp[rus],
                k = eng.length/rus.length;
            for (var i = 0; i < rus.length; i++)
            {
                var r = rus.substring(i, i + 1),
                    e = eng.substring(i*k, (i + 1)*k);
                replacements[r] = e;
                replacements[r.toUpperCase()] = e.toUpperCase();
            }
        }

        nsGmx$1.Utils.translit = function(name)
        {
            var result = "";
            for (var i = 0; i < name.length; i++)
                result += (replacements[name.substring(i, i + 1)] || "");

            return result;
        };
    })();

    !function() {
        var requests = {},
            lastRequestId = 0,
            uniquePrefix = 'id' + Math.random();

        var processMessage = function(e) {
            if (!(e.origin in requests)) {
                return;
            }

            var dataStr = decodeURIComponent(e.data.replace(/\n/g,'\n\\'));
            try {
                var dataObj = JSON.parse(dataStr);
            } catch (e) {
                request.callback && request.callback({Status:"error", ErrorInfo: {ErrorMessage: "JSON.parse exeption", ExceptionType: "JSON.parse", StackTrace: dataStr}});
            }

            // console.log(dataObj);
            var request = requests[e.origin][dataObj.CallbackName];
            if(!request) return;    // message от других запросов

            delete requests[e.origin][dataObj.CallbackName];
            delete dataObj.CallbackName;

            request.iframe.parentNode.removeChild(request.iframe);
            request.callback && request.callback(dataObj);
        };

        //совместимость с IE8
        if (window.addEventListener) {
            window.addEventListener('message', processMessage);
        } else {
            window.attachEvent('onmessage', processMessage);
        }

        //скопирована из API для обеспечения независимости от него
        var parseUri = function (str) {
            var	o   = parseUri.options,
                m   = o.parser[o.strictMode ? 'strict' : 'loose'].exec(str),
                uri = {},
                i   = 14;

            while (i--) {
                uri[o.key[i]] = m[i] || '';
            }

            uri[o.q.name] = {};
            uri[o.key[12]].replace(o.q.parser, function ($0, $1, $2) {
                if ($1) { uri[o.q.name][$1] = $2; }
            });

            uri.hostOnly = uri.host;
            uri.host = uri.authority; // HACK

            return uri;
        };

        parseUri.options = {
            strictMode: false,
            key: ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'],
            q:   {
                name:   'queryKey',
                parser: /(?:^|&)([^&=]*)=?([^&]*)/g
            },
            parser: {
                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                loose:  /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
            }
        };

        function createPostIframe2(id, callback, url)
        {
            var uniqueId = uniquePrefix + (lastRequestId++);

            iframe = document.createElement("iframe");
            iframe.style.display = 'none';
            iframe.setAttribute('id', id);
            iframe.setAttribute('name', id);
            iframe.src = 'javascript:true';
            iframe.callbackName = uniqueId;
            //iframe.onload = window[callbackName];

            var parsedURL = parseUri(url);
            var origin = (parsedURL.protocol ? (parsedURL.protocol + ':') : window.location.protocol) + '//' + (parsedURL.host || window.location.host);

            requests[origin] = requests[origin] || {};
            requests[origin][uniqueId] = {callback: callback, iframe: iframe};

            return iframe;
        }

        window.createPostIframe2 = createPostIframe2;

    }();

    /** Посылает кроссдоменный POST запрос
    *
    * @memberOf nsGmx.Utils
    * @param {String} url URL запроса
    * @param {Object} params Хэш параметров-запросов
    * @param {Function} [callback] Callback, который вызывается при приходе ответа с сервера. Единственный параметр ф-ции - собственно данные
    * @param {DOMElement} [baseForm] базовая форма запроса. Используется, когда нужно отправить на сервер файл.
    *                                В функции эта форма будет модифицироваться, но после отправления запроса будет приведена к исходному виду.
    */
    function sendCrossDomainPostRequest$1(url, params, callback, baseForm)
    {
    	var form,
    		rnd = String(Math.random()),
    		id = '$$iframe_' + url + rnd;

    	var iframe = createPostIframe2(id, callback, url),
            originalFormAction;

    	if (baseForm)
    	{
    		form = baseForm;
            originalFormAction = form.getAttribute('action');
    		form.setAttribute('action', url);
    		form.target = id;

    	}
    	else
    	{
    		try {
    			form = document.createElement('<form id=' + id + '" enctype="multipart/form-data" style="display:none" target="' + id + '" action="' + url + '" method="post"></form>');
            }
    		catch (e)
    		{
    			form = document.createElement("form");
    			form.style.display = 'none';
    			form.setAttribute('enctype', 'multipart/form-data');
    			form.target = id;
    			form.setAttribute('method', 'POST');
    			form.setAttribute('action', url);
    			form.id = id;
    		}
    	}

        var hiddenParamsDiv = document.createElement("div");
        hiddenParamsDiv.style.display = 'none';

        if (params.WrapStyle === 'window') {
            params.WrapStyle = 'message';
        }

        if (params.WrapStyle === 'message') {
            params.CallbackName = iframe.callbackName;
        }

    	for (var paramName in params)
    	{
    		var input = document.createElement("input");

            var value = typeof params[paramName] !== 'undefined' ? params[paramName] : '';

    		input.setAttribute('type', 'hidden');
    		input.setAttribute('name', paramName);
    		input.setAttribute('value', value);

    		hiddenParamsDiv.appendChild(input);
    	}

        form.appendChild(hiddenParamsDiv);

    	if (!baseForm)
    		document.body.appendChild(form);

    	document.body.appendChild(iframe);

    	form.submit();

        if (baseForm)
        {
            form.removeChild(hiddenParamsDiv);
            if (originalFormAction !== null)
                form.setAttribute('action', originalFormAction);
            else
                form.removeAttribute('action');
        }
        else
        {
            form.parentNode.removeChild(form);
        }
    }

    (function() {

        var hooks = {};

        /** Добавляет "хук", который будет вызван при ответе сервера соответвующего типа
        * @param type {object} - тип хука (соответствует полю "Status" ответа сервера) или '*' - добавить к любому ответу
        * @param hookFunction {function(response, customErrorDescriptions)} - собственно хук
        */
        window.addParseResponseHook = function(type, hookFunction) {
            hooks[type] = hooks[type] || [];
            hooks[type].push(hookFunction);
        };

        /** Обрабатывает результат выполнения серверного скрипта.
        * Для выполнения действий вызывает "хуки" соответствующиего типа, добавленные через addParseResponseHook()
        * @function
        * @global
        * @param {object} response JSON, вернувшийся с сервера
        * @param {object} customErrorDescriptions хэш "тип ошибки" -> "кастомное сообщение пользователям".
        * @return true, если статус ответа "ok", иначе false
        */
        window.parseResponse = function(response, customErrorDescriptions)
        {
            var responseHooks = (hooks[response.Status] || []).concat(hooks['*'] || []);
            for (var h = 0; h < responseHooks.length; h++)
                responseHooks[h](response, customErrorDescriptions);

            return response.Status == 'ok';
        };

    })();

    function _title$1(elem, title)
    {
    	elem.setAttribute('title', title);
    }

    function disableSelection(target)
    {
    	if (typeof target.onselectstart != "undefined")
    	    target.onselectstart = function(){return false};
    	else if (typeof target.style.MozUserSelect != "undefined")
    	    target.style.MozUserSelect = "none";
    	else
    	    target.onmousedown = function(){return false};
    }

    function stringDate(msec, isUtc)
    {
    	var date = new Date(msec);
    		excDate = isUtc ? date.getUTCDate() : date.getDate(),
    		excMonth = (isUtc ? date.getUTCMonth() : date.getMonth()) + 1,
    		excYear = isUtc ? date.getUTCFullYear() : date.getFullYear();

    	return (excDate < 10 ? '0' + excDate : excDate) + '.' + (excMonth < 10 ? '0' + excMonth : excMonth) + '.' + excYear;
    }

    function stringTime(msec, isUtc)
    {
    	var date = new Date(msec);
    		excHour = isUtc ? date.getUTCHours() : date.getHours(),
    		excMin = isUtc ? date.getUTCMinutes() : date.getMinutes(),
    		excSec = isUtc ? date.getUTCSeconds() : date.getSeconds();

    	return (excHour < 10 ? '0' + excHour : excHour) + ':' + (excMin < 10 ? '0' + excMin : excMin) + ':' + (excSec < 10 ? '0' + excSec : excSec);
    }

    function stringDateTime(msec, isUtc)
    {
    	return stringDate(msec, isUtc) + ' ' + stringTime(msec, isUtc);
    }

    /**
        @namespace nsGmx.Utils
        @description Разнообразные вспомогательные ф-ции
    */
    $.extend(nsGmx$1.Utils, {

        /**
            Возвращает уникальную строку (16 символов из букв и латинских цифр)
            @function
            @memberOf nsGmx.Utils
        */
        generateUniqueID: function()
        {
            var chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz",
                randomstring = '';

            for (var i = 0; i < 16; i++)
            {
                var rnum = Math.floor(Math.random() * chars.length);
                randomstring += chars.charAt(rnum);
            }

            return randomstring;
        },
        /**
            Преобразует цвет, заданный в виде числа (0xaabbcc) в строку вида #aabbcc
            @function
            @memberOf nsGmx.Utils
        */
        convertColor: function(intColor)
        {
            var r,g,b;

            b = (intColor % 256).toString(16);
            if (b.length == 1)
                b = '0' + b;

            intColor = Math.floor(intColor / 256);
            g = (intColor % 256).toString(16);
            if (g.length == 1)
                g = '0' + g;

            intColor = Math.floor(intColor / 256);
            r = (intColor % 256).toString(16);
            if (r.length == 1)
                r = '0' + r;

            return '#' + r + g + b;
        },
        /**
            Преобразует цвет, заданный в виде строки rgb(255, 255, 255) в строку вида #aabbcc
            @function
            @memberOf nsGmx.Utils
        */
        rgb2hex: function(intColor)
        {
            var str,
                arr = intColor.substring(4, intColor.length-1).split(', ');

            arr = arr.map(function(c){
                var hex = Number(c).toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            });

            str = "#" + arr.join('');

            return str;
        },

        checkForNumber: function (number) {
            return !(isNaN(number) || typeof(number) === 'undefined' || number === null || number === '');
        },

        isJSON: function(str) {
            try {
                JSON.parse(str);
            } catch (e) {
                return false;
            }
            if (str === '' || str === 'null' || str === 'undefined' || typeof(str) === 'Number') {
                return false;
            } else {
                return true;
            }
        },

    	/** Возвращает позицию окна такую, чтобы окно не мешало текущему элементу
            @memberOf nsGmx.Utils
        */
    	getDialogPos: function(div, offsetFlag, height)
    	{
    		var pos = getOffsetRect$1(div),
    			left = pos.left + 30,
    			top = pos.top - 10,
    			windowHeight = getWindowHeight();

    		if (offsetFlag)
    		{
    			$(div).children('div,img').each(function()
    			{
    				if (!this.getAttribute('multiStyle'))
    					left += this.offsetWidth;
    			});
    		}

    		if (top + 15 + height > windowHeight)
    			top -= (top + 15 + height - windowHeight);

    		return {left: left, top: top}
    	},

    	/** Устанавливает обычный стиль и генерит похожий стиль при наведении мышки
        @memberOf nsGmx.Utils
    	@param layer {L.gmxVectorLayer} Слой
    	@param styleIndex {Number} Номер стиля слоя
    	@param templateStyle {Style} Стиль, похожий на который надо установить*/
    	setMapObjectStyle: function(layer, styleIndex, templateStyle)
    	{
            var hoverStyle = $.extend(true, {}, templateStyle);
            var style = layer.getStyle(styleIndex);

            if (templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined')
                hoverStyle.outline.thickness = Number(templateStyle.outline.thickness) + 1;

            if (templateStyle.fill && typeof templateStyle.fill.opacity != 'undefined' && templateStyle.fill.opacity > 0)
                hoverStyle.fill.opacity = Math.min(Number(templateStyle.fill.opacity + 20), 100);

            var newStyle = $.extend(true, {}, style);
            newStyle.RenderStyle = L.gmxUtil.fromServerStyle(templateStyle);
            newStyle.HoverStyle = L.gmxUtil.fromServerStyle(hoverStyle);

            if (templateStyle.labelTemplate) {
              newStyle.RenderStyle.labelTemplate = templateStyle.labelTemplate;
            }
            if (hoverStyle.labelTemplate) {
              newStyle.HoverStyle.labelTemplate = hoverStyle.labelTemplate;
            }

            if (templateStyle.labelAnchor) {
              newStyle.RenderStyle.labelAnchor = templateStyle.labelAnchor;
            }
            if (hoverStyle.labelAnchor) {
              newStyle.HoverStyle.labelAnchor = hoverStyle.labelAnchor;
            }
            layer.setStyle(newStyle, styleIndex);
    	},

        // берёт стиль в формате сервера, добавляет в него hover-подсветку
        // и возвращает этот стиль в новом формате Leafelt-Geomixer
        prepareGmxLayerStyle: function(style)
    	{
            var templateStyle = style.RenderStyle,
                newStyle = $.extend(true, {}, style),
                hoverStyle = $.extend(true, {}, templateStyle);


            if (templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined')
                hoverStyle.outline.thickness = Number(templateStyle.outline.thickness) + 1;

            if (templateStyle.fill && typeof templateStyle.fill.opacity != 'undefined' && templateStyle.fill.opacity > 0)
                hoverStyle.fill.opacity = Math.min(Number(templateStyle.fill.opacity + 20), 100);

            newStyle.RenderStyle = L.gmxUtil.fromServerStyle(templateStyle);
            newStyle.HoverStyle = L.gmxUtil.fromServerStyle(hoverStyle);

            return newStyle;
    	},
        /** Конвертация данных между форматами сервера и клиента. Используется в тегах слоёв и в атрибутах объектов векторных слоёв.
        *
        * Форматы сервера:
        *
        *  * datetime - unix timestamp
        *  * date - unix timestamp, кратный 24*3600 секунд
        *  * time - кол-во секунд с полуночи
        *
        * Форматы клиента:
        *
        *  * все числа превращаются в строки
        *  * дата - строка в формате dd.mm.yy
        *  * время - строка в формате hh:mm:ss
        *  * дата-время - dd.mm.yy hh:mm:ss
        *
        * @memberOf nsGmx.Utils
        */
        convertFromServer: function(type, value)
        {
            //if (value === null) return "null";

            if (!type) {
                return value;
            }

            var lowerCaseType = type.toLowerCase();

            if (lowerCaseType == 'string')
            {
                return value !== null ? value : ''; //все null интерпретируем как пустые строки!
            }
            else if (lowerCaseType == 'integer' || lowerCaseType == 'float' || lowerCaseType == 'number')
            {
                return value !== null ? String(value) : '';
            }
            else if (lowerCaseType == 'date')
            {
                if (value === null) return '';

                return stringDate(value*1000, true);
            }
            else if (lowerCaseType == 'time')
            {
                if (value === null) return '';
                return stringTime(value*1000, true);
            }
            else if (lowerCaseType == 'datetime')
            {
                if (value === null) return '';
                return stringDateTime(value*1000, true);
            }

            return value;
        },

        /** Конвертация данных между форматами сервера и клиента. Используется в тегах слоёв и в атрибутах объектов векторных слоёв.
        * Описание форматов см. в {@link nsGmx.Utils.convertFromServer}
        * Если конвертация невозможна для данного типа, возвращает null
        * @memberOf nsGmx.Utils
        */
        convertToServer: function(type, value)
        {
            if (!type) {
                return value;
            }

            var lowerCaseType = type.toLowerCase();

            if (lowerCaseType == 'string')
            {
                return value;
            }
            else if (lowerCaseType == 'integer' || lowerCaseType == 'float' || lowerCaseType == 'number')
            {
                if (value === '') return null;
                var num = Number(value);
                return isNaN(num) ? null : num;
            }
            else if (lowerCaseType == 'date')
            {
                var localDateValue = $.datepicker.parseDate('dd.mm.yy', value);
                if (localDateValue === null) return null;

                var localValue = localDateValue.valueOf()/1000;
                var timeOffset = (new Date(localValue*1000)).getTimezoneOffset()*60;
                return localValue - timeOffset;
            }
            else if (lowerCaseType == 'time')
            {
                var resTime = $.datepicker.parseTime('HH:mm:ss', value);
                if (!resTime) return null;

                return resTime.hour*3600 + resTime.minute*60 + resTime.second;
            }
            else if (lowerCaseType == 'datetime')
            {
                var localDateValue = $.datepicker.parseDateTime('dd.mm.yy', 'HH:mm:ss', value);
                if (localDateValue === null) return null;

                var localValue = localDateValue.valueOf()/1000;
                var timeOffset = (new Date(localValue*1000)).getTimezoneOffset()*60;
                return localValue - timeOffset;
            }

            return value;
        },


    	login: function(redirect_uri, authServerBase, callback, authServer, isHidden){
    		var oAuthServer = authServer || 'MyKosmosnimki';
    		window.gmxGetServerBase = function(){
    			return authServerBase
    		};
    		var redirectUri = redirect_uri + (redirect_uri.indexOf('?')>0 ? '&' : '?') + 'authServer=' + oAuthServer;
    		window.gmxProcessAuthentication = function(userInfo){
    			callback && callback(userInfo);
    		};
    		var features, w = 600, h = 350;
    		var handlerName = 'LoginDialog';
    		if (oAuthServer != 'MyKosmosnimki') {
    			handlerName += oAuthServer;
    			h = 400;
    		}
    		var url = authServerBase + handlerName + '.ashx?redirect_uri=' + escape(redirectUri);

    		if (!isHidden){
    			var top = (screen.height - h)/2, left = (screen.width - w)/2;
    			features = 'location=0,menubar=0,resizable=0,status=0,toolbar=0,width='+w+',height='+h+',left='+left+',top='+top ;

    			window.open(url, '_blank', features);
    		}else{
    			$('<iframe />', {
    				 'src': url
    				,'style': 'display: block !important; position: absolute; left: -99999px;'
    			}).appendTo('body'); //стиль такой кривой иначе будет бага в FF
    		}
        },

        /** Загружает пользовательский shp файл.
        * Проверяет на ошибки, выводит предупреждения и ошибки в виде стандартных диалогов.
        * @memberof nsGmx.Utils
        * @function
        * @param {File|Form} shpSource Либо форма с полем file, в которой пользователь выбрал файл, либо HTML5 File. Форма должна иметь атрибуты method="post" и enctype="multipart/form-data"
        * @return {jQuery.Deferred} Возвращает promise (аргумент ф-ции - массив объектов из shp файла)
        */
        parseShpFile: (function() //приватные данные
        {
            var translationsAdded = false;
            var addTranslationsLazy = function()
            {
                if (translationsAdded) return;
                _translationsHash.addtext("rus", {
                                    "loadShape.Errors.FileTooBigException" : "Файл слишком большой. Ограничение на размер файла 1000 Кб.",
                                    "loadShape.Errors.ErrorUploadExeption" : "Произошла ошибка при попытке загрузить файл.",
                                    "loadShape.Errors.NoGeometryFile"      : "Загруженный файл не содержит геометрических данных.",
                                    "loadShape.Errors.ErrorUploadNoDependentFiles" : "Не найдено необходимых зависимых файлов. Запакуйте все файлы в ZIP архив и повторите загрузку."
                                 });

                _translationsHash.addtext("eng", {
                                    "loadShape.Errors.FileTooBigException" : "Too big file. File size limit is 1000 Kb.",
                                    "loadShape.Errors.ErrorUploadExeption" : "Error during file uploading.",
                                    "loadShape.Errors.NoGeometryFile"      : "There are no geometry in uploaded file.",
                                    "loadShape.Errors.ErrorUploadNoDependentFiles" : "Not found the necessary dependent files. Add all files in a ZIP archive and upload it again."
                                 });

                translationsAdded = true;
            };

            //непосредственно ф-ция
            return function(shpFileForm) {
                var def = $.Deferred();

                addTranslationsLazy();

                var errorMessages = {
                    "CommonUtil.FileTooBigException" : _gtxt("loadShape.Errors.FileTooBigException"),
                    "CommonUtil.ErrorUploadExeption" : _gtxt("loadShape.Errors.ErrorUploadExeption"),
                    "CommonUtil.NoGeometryFile"      : _gtxt("loadShape.Errors.NoGeometryFile"),
                    "CommonUtil.ErrorUploadNoDependentFiles": _gtxt("loadShape.Errors.ErrorUploadNoDependentFiles")
                };

                if (window.File && shpFileForm instanceof window.File) {
                    if (!window.FormData) {
                        def.reject();
                        return false;
                    }

                    var formData = new FormData();
                    formData.append('file', shpFileForm);
                    var xhr = new XMLHttpRequest();
                    xhr.open('POST', serverBase + 'ShapeLoader');
                    xhr.onload = function () {
                        if (xhr.status === 200) {
                            response = JSON.parse(xhr.responseText.substr(1, xhr.responseText.length-2));

                            if (parseResponse(response, errorMessages)) {
                                def.resolve(response.Result);
                            } else {
                                def.reject(response);
                            }
                        }
                    };

                    xhr.send(formData);
                } else {
                    sendCrossDomainPostRequest$1(serverBase + "ShapeLoader", {WrapStyle: "window"}, function(response)
                    {
                        if (parseResponse(response, errorMessages))
                            def.resolve(response.Result);
                        else
                            def.reject(response);
                    }, shpFileForm);
                }

                return def.promise();
            }

        })(),

        /** Позволяет скачать в браузере геометрию в одном из форматов (упакованный в zip архив).
        * @memberof nsGmx.Utils
        * @function
        * @param {Object[]} geoJSONFeatures Массив GeoJSON Features. К сожалению, другие типы GeoJSON объектов не поддерживаются.
        * @param {Object} [options] Доп. параметры
        * @param {String} [options.fileName=markers] Имя файла для скачивания
        * @param {String} [options.format=Shape] В каком формате скачать (Shape, Tab, gpx или несколько через запятую)
        */
        downloadGeometry: function(geoJSONFeatures, options) {
            var objectsByType = {},
                markerIdx = 1;

            options = $.extend({
                fileName: 'markers',
                format: 'Shape'
            }, options);

            geoJSONFeatures.forEach(function(item) {
                var geom = item.geometry,
                    type = geom.type;

                objectsByType[type] = objectsByType[type] || [];

                var title = item.properties && item.properties.title || '';

                if (type == "Point" && !title) {
                    title = "marker " + markerIdx++;
                }

                objectsByType[type].push({
                    geometry: {
                        type: type.toUpperCase(),
                        coordinates: geom.coordinates
                    },
                    properties: {text: title}
                });
            });

            sendCrossDomainPostRequest$1(serverBase + "Shapefile", {
                name:     options.fileName,
                format:   options.format,
                points:   JSON.stringify(objectsByType["Point"] || []),
                lines:    JSON.stringify([].concat(objectsByType["LineString"] || [], objectsByType["MultiLineString"] || [])),
                polygons: JSON.stringify([].concat(objectsByType["Polygon"] || [], objectsByType["MultiPolygon"] || []))
            });
        },

        /** Объединяет массив полигонов/мультиполигонов в новый полигон/мультиполигон
        * @memberof nsGmx.Utils
        */
        joinPolygons: function(objs)
        {
            var polygonObjects = [];
            for (var i = 0; i < objs.length; i++)
            {
                var geom = objs[i];
                if (geom.type == 'POLYGON')
                {
                    polygonObjects.push(geom.coordinates);
                }
                else if (geom.type == 'MULTIPOLYGON')
                {
                    for (var iC = 0; iC < geom.coordinates.length; iC++)
                        polygonObjects.push(geom.coordinates[iC]);
                }
            }

            if (polygonObjects.length > 1)
                return {type: "MULTIPOLYGON", coordinates: polygonObjects}
            else if (polygonObjects.length == 1)
            {
                return {type: "POLYGON", coordinates: polygonObjects[0]}
            }
            else
                return null;
        },

        joinClippedPolygon: function(polygon) {

            if (polygon.type !== 'MULTIPOLYGON') {
                return polygon;
            }

            var origData = [],
                segmentsToJoin = [],
                joinedSegments = [],
                crossPoints = [],
                finalPolygon = [];

            var equal = function(a, b) {return Math.abs(a - b) < 1e-5;};

            var coords = polygon.coordinates;
            for (var c = 0; c < coords.length; c++) {
                for (var r = 0; r < coords[c].length; r++) {
                    coords[c][r].length = coords[c][r].length - 1;
                }
            }

            var parseRing = function(origRing) {
                var ring = origRing.coords,
                    len = ring.length;

                var getNextSegment = function(i) {
                    var il = (i - 1 + len) % len,
                        points = [];

                    while (i != il) {
                        if (equal(Math.abs(ring[i][0]), 180) && equal(Math.abs(ring[(i+1)%len][0]), 180) ) {
                            return [i, points];
                        }

                        points.push(ring[i]);
                        i = (i + 1) % len;
                    }

                    return [i, points];
                };

                var segment = getNextSegment(0);

                var lastI = segment[0];

                if (!equal(Math.abs(ring[segment[0]][0]), 180)) {
                    origRing.regularRing = ring;
                    return;
                }

                do {
                    startI = (segment[0] + 1) % len;
                    segment = getNextSegment((startI + 1) % len);
                    var nextSegment = {
                        points: [].concat([ring[startI]], segment[1], [ring[segment[0]]])
                    };
                    segmentsToJoin.push(nextSegment);
                    origRing.segments.push(nextSegment);
                } while (segment[0] !== lastI);
            };

            var findSegment = function(y, joinedSeg) {
                for (var s = 0; s < segmentsToJoin.length; s++) {
                    var seg = segmentsToJoin[s];
                    if (equal(seg.points[0][1], y) || equal(seg.points[seg.points.length - 1][1], y)) {
                        segmentsToJoin.splice(s, 1);
                        seg.joinedSeg = joinedSeg;
                        var isReg = equal(seg.points[0][1], y);
                        return {
                            points: isReg ? seg.points.slice(1, seg.points.length - 1) : seg.points.slice(1, seg.points.length - 1).reverse(),
                            lastY: isReg ? seg.points[seg.points.length - 1][1] : seg.points[0][1]
                        };
                    }
                }
            };

            var joinSegment = function(y0) {
                var res = {},
                    seg = findSegment(y0, res),
                    points = seg.points,
                    crossPoints = [y0];

                while (seg.lastY !== y0) {
                    crossPoints.push(seg.lastY);
                    seg = findSegment(seg.lastY);
                    points = points.concat(seg.points);
                }
                res.points = points,
                res.crossPoints = crossPoints,
                res.minCrossPoint = Math.min.apply(Math, crossPoints);

                return res;
            };

            var parseGeometry = function(geom) {
                for (var c = 0; c < geom.coordinates.length; c++) {
                    var origComp = [];
                    origData.push(origComp);
                    var comp = geom.coordinates[c];
                    for (var r = 0; r < comp.length; r++) {
                        var origRing = {
                            coords: comp[r],
                            segments: []
                        };
                        origComp.push(origRing);
                        parseRing(origRing);
                    }
                }
            };

            parseGeometry(polygon);

            segmentsToJoin.forEach(function(segment) {
                if (segment.points[0][0] < 0) {
                    segment.points = segment.points.map(function(c) { return [c[0] + 360, c[1]];});
                }
            });

            while (segmentsToJoin.length) {
                var y0 = segmentsToJoin[0].points[0][1];
                var joinedSeg = joinSegment(y0);
                joinedSegments.push(joinedSeg);
                crossPoints = crossPoints.concat(joinedSeg.crossPoints);
            }

            crossPoints = crossPoints.sort();

            joinedSegments = joinedSegments.sort(function(s1, s2) {
                return s1.minCrossPoint - s2.minCrossPoint;
            });

            joinedSegments.forEach(function(s, i) {
                s.isExternal = (crossPoints.indexOf(s.minCrossPoint) % 2) === 0;
            });

            //собираем объединённые сегменты в мультиполигон
            joinedSegments.forEach(function(s) {
                if (s.isExternal) {
                    finalPolygon.push([s.points]);
                } else {
                    finalPolygon[finalPolygon.length-1].push(s.points);
                }
                s.finalComponent = finalPolygon[finalPolygon.length-1];
            });

            //добавляем компоненты, которые не пересекались со 180 градусом
            for (var c = 0; c < origData.length; c++) {
                if (origData[c][0].regularRing) {
                    console.log('external component', c);
                    var geomToCopy = [];
                    for (var r = 0; r < origData[c].length; r++) {
                        geomToCopy.push(origData[c][r].regularRing);
                    }
                    finalPolygon.push(geomToCopy);
                    continue;
                }
                for (var r = 1; r < origData[c].length; r++) {
                    if (origData[c][r].regularRing) {
                        console.log('internal component', c, r, origData[c][0].segments);
                        for (var s = 0; s < origData[c][0].segments.length; s++) {
                            var joinedSeg = origData[c][0].segments[s].joinedSeg;
                            if (joinedSeg.isExternal) {
                                joinedSeg.finalComponent.push(origData[c][r].regularRing);
                                break;
                            }
                        }
                    }
                }
            }

            if (finalPolygon.length === 1) {
                return {type: 'POLYGON', coordinates: finalPolygon[0]};
            } else {
                return {type: 'MULTIPOLYGON', coordinates: finalPolygon};
            }
        },

        /** Методы для работы с сохранёнными на сервере данными.
        * Сервер позволяет сохранять произвольный текст на сервере и получить ID, по которому можно этот текст получить.
        * Используется для формирования пермалинков (сохранение состояния)
        * @namespace
        * @memberOf nsGmx.Utils
        */
        TinyReference: {
            /** Создать новую ссылку
            * @param {String} data Данные, которые нужно сохранить
            * @return {jQuery.Deferred} Промис, который будет resolve при сохранении данных. Параметр при ресолве: ID, по которому можно получить данные обратно
            */
            create: function(data, tempFlag) {
                var def = $.Deferred();
                sendCrossDomainPostRequest$1(serverBase + "TinyReference/Create.ashx", {
                    WrapStyle: 'message',
                    content: JSON.stringify(data),
                    temp: tempFlag
                },
                function(response) {
                    if (parseResponse(response)) {
                        def.resolve(response.Result);
                    } else {
                        def.reject();
                    }
                });

                return def.promise();
            },

            /** Получить ранее сохранённые данные по ID
            * @param {String} id полученный при сохранении ID данных
            * @return {jQuery.Deferred} Промис, который будет resolve при получении данных. Параметр при ресолве: данные с сервера
            */
            get: function(id) {
                var def = $.Deferred();
                sendCrossDomainJSONRequest$1(serverBase + "TinyReference/Get.ashx?id=" + id, function(response){
                    //если пермалинк не найден, сервер не возвращает ошибку, а просто пустой результат
                    if (parseResponse(response) && response.Result) {
                        def.resolve(JSON.parse(response.Result));
                    } else {
                        def.reject();
                    }
                });

                return def.promise();
            },

            /** Удалить данные по ID
            * @param {String} id полученный при сохранении ID данных
            * @return {jQuery.Deferred} Промис, который будет resolve при удалении данных
            */
            remove: function(id) {
                var def = $.Deferred();
                sendCrossDomainJSONRequest$1(serverBase + "TinyReference/Delete.ashx?id=" + id, function(response){
                    if (parseResponse(response)) {
                        def.resolve();
                    } else {
                        def.reject();
                    }
                });

                return def.promise();
            }
        },
        isIpad: function() {
            return navigator.userAgent.match(/iPad/i) != null;
        },

        getLatLngBounds: function (layer) {
            var gmxBounds = layer._gmx.layerID ? L.gmxUtil.getGeometryBounds(layer._gmx.geometry) : layer._gmx.dataManager.getItemsBounds(),
                srs = layer._gmx.srs,
                array = [],
                projection;

                console.log(gmxBounds);


            if (srs) {
                for (var proj in L.CRS) {
                    if (proj.indexOf(srs) !== -1) {
                        projection = L.CRS[proj];
                        break;
                    }
                }
            } else {
                projection = L.CRS['EPSG:3395'];
            }

            array.push(L.Projection.Mercator.unproject(gmxBounds.min));
            array.push(L.Projection.Mercator.unproject(gmxBounds.max));
            return L.latLngBounds(array);
        },

        showDialog: showDialog$1,
    	removeDialog: removeDialog$1,
        makeImageButton: makeImageButton$1,
    	makeLinkButton: makeLinkButton$1,
    	makeButton: makeButton$1,
    	_title: _title$1,
    	_checkbox: _checkbox$1
    });

    window.gmxCore && window.gmxCore.addModule('utilities', nsGmx$1.Utils);

    const {
        _br: _br$1,
        _div: _div$1,
        _input: _input$1,
        _li: _li$1,
        _option: _option$1,
        _span: _span$1,
        _t: _t$1,
        _tr: _tr$1,
        _ul: _ul$1
    } = domManipulation;

    !function(){

    var DEFAULT_LANGUAGE = 'rus';

    //Для запоминания выбора языка пользователем используются куки. 
    //Запоминается выбор для каждого pathname, а не только для домена целиком
    //Формат куки: pathname1=lang1&pathname2=lang2&...
    var _parseLanguageCookie = function()
    {
        var text = readCookie("language");
        
        if (!text) 
            return {};
        
        var items = text.split('&');

        //поддержка старого формата кук (просто названия взыка для всех pathname)
        if (items % 2) items = [];
        
        var langs = {};
        for (var i = 0; i < items.length; i++)
        {
            var elems = items[i].split('=');
            langs[decodeURIComponent(elems[0])] = decodeURIComponent(elems[1]);
        }
        
        return langs;
    };

    var _saveLanguageCookie = function(langs)
    {
        var cookies = [];
        
        for (var h in langs)
        {
            cookies.push(encodeURIComponent(h) + '=' + encodeURIComponent(langs[h]));
        }
        
        eraseCookie("language");
        createCookie("language", cookies.join('&'));
    };

    var TranslationsManager = function() {
        this.flags = {};
        this.titles = {};
        this.hash = {};
        this._errorHandlers = [];
    };

    TranslationsManager.prototype._language = null;

    TranslationsManager.prototype._addTextWithPrefix = function(prefix, lang, newHash) {
        var res = true,
            hash = this.hash;

        if (!(lang in hash)) {
            hash[lang] = {};
        }

        for (var k in newHash) {
            var fullKey = prefix + k;
            if (fullKey in hash[lang]) {
                res = false;
            } else {
                if (typeof newHash[k] === 'string') {
                    hash[lang][fullKey] = newHash[k];
                } else {
                    this._addTextWithPrefix(fullKey + '.', lang, newHash[k]);
                }
            }
        }

        return res;
    };

    /** Добавить строки в словарь локализации
     @func addText
     @memberOf nsGmx.Translations
     @param {String} lang Язык, к которому добавляются строки
     @param {Object} strings Список добавляемых строк. Должен быть объектом, в котором атрибуты являются ключами перевода.
                     Если значение атрибута - строка, то она записывается как результат локализации данного ключа.
                     Если значение атрибута - другой объект, то название текущего атрибута будет добавлено с точкой 
                     к названию атрибутов в этом объекте. Например: {a: {b: 'бэ', c: 'це'}} сформируют ключи локализации 'a.b' и 'a.c'.
    */
    TranslationsManager.prototype.addText = function(lang, newHash) {
        this._addTextWithPrefix('', lang, newHash);
    };

    /** Получить локализованный текст по ключу для текущего языка
     @func getText
     @memberOf nsGmx.Translations
     @param {String} key Ключ локализации
     @return {String} Локализованный текст
    */
    TranslationsManager.prototype.getText = function(dictKey) {
        var lang = this.getLanguage(),
            args = arguments,
            getArg = function(i) {
                return args[i + 1] || '';
            };

        if (!this.hash[lang] || !this.hash[lang][dictKey]) {
            this._errorHandlers.forEach(function(handler) {handler(dictKey, lang);});
            return '';
        } else {
            return this.hash[lang][dictKey].replace(/\[value(\d)\]/g, function(match, argIndex) {
                return getArg(Number(argIndex))
            })
        }
    };

    /** Установить текущий язык
     @func setLanguage
     @memberOf nsGmx.Translations
     @param {String} lang Текущий язык (eng/rus/...)
    */
    TranslationsManager.prototype.setLanguage = function(lang) {
        TranslationsManager.prototype._language = lang;
    };

    /** Получить текущий язык локализации
     @func getLanguage
     @memberOf nsGmx.Translations
     @return {String} Текущий язык (eng/rus/...)
    */
    TranslationsManager.prototype.getLanguage = function() {
        return TranslationsManager.prototype._language || 
               (typeof window !== 'undefined' && window.language) || 
               DEFAULT_LANGUAGE;
    };

    /** Добавить обработчик ошибок локализации. 
        При возникновении ошибок (не определён язык, не найден перевод) будет вызываться каждый из обработчиков
     @func addErrorHandler
     @memberOf nsGmx.Translations
     @param {function(text, lang)} Обработчик ошибки. В ф-цию передаётся текст и язык
    */
    TranslationsManager.prototype.addErrorHandler = function(handler) {
        this._errorHandlers.push(handler);
    };

    /** Считать из кук текущий язык локализации.
     * В куках отдельно записываются языки для каждого pathname, а не только для домена целиком
     @func getLanguageFromCookies
     @memberOf nsGmx.Translations
     @param {String} [pathname] Идентификатор проекта, для которого нужно запомнить куку. По умолчанию `window.location.pathname`.
     @return {String} Язык, записанный в куках для данного pathname
    */
    TranslationsManager.prototype.getLanguageFromCookies = function(pathname) {
        return _parseLanguageCookie()[pathname || window.location.pathname];
    };

    /** Записать в куки текущий язык локализации.
     * В куках отдельно записываются языки для каждого pathname, а не только для домена целиком
     @func updateLanguageCookies
     @memberOf nsGmx.Translations
     @param {String} lang Язык, который нужно записать в куку
     @param {String} [pathname] Идентификатор проекта, для которого нужно запомнить куку. По умолчанию `window.location.pathname`.
    */
    TranslationsManager.prototype.updateLanguageCookies = function(lang, pathname) {
        var langs = _parseLanguageCookie();
        langs[pathname || window.location.pathname] = lang;
        _saveLanguageCookie(langs);
    };

    /** Ф-ции для локализации пользовательского интерфейса
     @namespace nsGmx.Translations
    */

    var commonTranslationsManager = new TranslationsManager();
    TranslationsManager.commonManager = commonTranslationsManager;

    //хелпер для вставки локализованных констант в шаблоны. Например: {{i "layerEditor.dialogTitle"}}
    var addHanlebarsHelper = function(Handlebars) {
        Handlebars.registerHelper('i', function(dictKey) {
            return commonTranslationsManager.getText(dictKey);
        });
    };

    addHanlebarsHelper(Handlebars);

    nsGmx$1.Translations = commonTranslationsManager;

    //Поддерживаем обратную совместимость - глобальные объекты _gtxt, _translationsHash, translationsHash
    var prev_gtxt = window._gtxt,
        prev_translationsHash = window._translationsHash,
        prevTranslationsHash = window.translationsHash;
        
    /** Убирает из глобальной видимости все объекты и ф-ции, связанные с локализацией
     @name noConflicts
     @memberOf nsGmx.Translations
    */
    TranslationsManager.prototype.noConflicts = function() {
        window._gtxt = prev_gtxt;
        window._translationsHash = prev_translationsHash;
        window.translationsHash = prevTranslationsHash;
    };

    //Явно добавляем объекты в глобальную видимость
    var DumpClass = function(){};
    DumpClass.prototype = commonTranslationsManager;

    window._translationsHash = new DumpClass();
    _translationsHash.gettext = commonTranslationsManager.getText.bind(commonTranslationsManager),
    _translationsHash.addtext = commonTranslationsManager.addText.bind(commonTranslationsManager),
    _translationsHash.showLanguages = function() {
        var langCanvas = _div(null, [['dir','className','floatRight'],['css','margin',' 7px 10px 0px 0px']]);
        
        for (var lang in this.hash)
        {
            if (lang != window.language)
            {
                var button = makeLinkButton(_translationsHash.titles[lang]);
                
                button.style.marginLeft = '5px';
                button.style.fontSize = '11px';

                button.onclick = function(lang) {
                    window.translationsHash.updateLanguageCookies(lang);

                    if (nsGmx$1 && nsGmx$1.GeomixerFramework) {
                        window.language = lang;
                        _mapHelper.reloadMap();
                    } else {
                        window.location.reload();
                    }
                }.bind(null, lang);
                
                _title(button, this.titles[lang]);
                
                langCanvas.appendChild(button);
            }
            else 
            {
                langCanvas.appendChild(_span([_t(_translationsHash.titles[lang])], [['css','marginLeft','5px'], ['css','color','#fc830b']]));
            }
        }

        document.getElementById("headerLinks").appendChild(langCanvas);
    };

    window._gtxt = function() {
        return commonTranslationsManager.getText.apply(commonTranslationsManager, arguments);
    };

    window.translationsHash = {
        getLanguageFromCookies: commonTranslationsManager.getLanguageFromCookies.bind(commonTranslationsManager),
        updateLanguageCookies: commonTranslationsManager.updateLanguageCookies.bind(commonTranslationsManager)
    };

    gmxCore$1 && gmxCore$1.addModule('translations',
    {
        _translationsHash: window._translationsHash
    });

    }();

    _translationsHash.flags["rus"] = "img/flag_ru.png";

    _translationsHash.titles["rus"] = "Русский";

    _translationsHash.hash["rus"] = {
    	"Да": "Да",
    	"Нет": "Нет",
    	"Карта" : "Карта",
    	"Создать" : "Создать",
    	"Создать карту" : "Создать карту",
    	"Сохранить" : "Сохранить",
    	"Сохранить как" : "Сохранить как",
    	"Сохранить карту как" : "Сохранить карту как",
    	"Сохранить карту" : "Сохранить карту",
    	"Экспорт" : "Экспорт",
    	"Ссылки" : "Ссылки",

        "Карта пожаров": "Карта пожаров",
        "Поиск снимков": "Поиск снимков",
        "Платформа Геомиксер": "Веб-ГИС GeoMixer",
        "http://fires.ru": "http://fires.ru",
        "https://search.kosmosnimki.ru": "https://search.kosmosnimki.ru",

        "Данные": "Данные",
        "Сервисы": "Сервисы",
        "Поделиться": "Поделиться",
        "Открыть слой": "Открыть слой",
        "Создать слой": "Создать слой",
        "Растровый": "Растровый",
        "Векторный": "Векторный",
        "Создать группу": "Создать группу",
        "Базовые слои": "Базовые слои",
        "Подключить WMS": "Подключить WMS",
        "Подключить WFS": "Подключить WFS",
        "Объекты": "Объекты",
        "Результаты поиска": "Результаты поиска",
        "Буфер": "Буфер",
        "Создание буферных зон": "Создание буферных зон",
        "Ручная привязка растров": "Ручная привязка растров",
        "Поиск слоев на карте": "Поиск слоев на карте",
        "Краудсорсинг данных": "Краудсорсинг данных",
        "Пакетный геокодинг": "Пакетный геокодинг",
        "Маршруты": "Маршруты",
        "Кадастр Росреестра": "Кадастр Росреестра",
        "Выбрать кадастровый объект": "Выбрать кадастровый объект",
        "Викимапиа": "Викимапиа",
        "Каталог СКАНЭКС": "Поиск снимков",
        "Космоснимки-пожары": "Космоснимки-пожары",
        "GIBS NASA": "Съёмка MODIS (NASA)",
        "Руководство пользователя": "Документация",
        "Руководство": "Руководство пользователя",
        "GeoMixer API": "GeoMixer API",
        "Использование плагинов": "Использование плагинов",
    	"копия": "копия",

    	"Открыть" : "Открыть",
    	"Слой" : "Слой",
    	"Создать векторный слой" : "Создать векторный слой",
    	"Создать растровый слой" : "Создать растровый слой",
    	"Создать мультислой" : "Создать мультислой",
    	"Вид" : "Вид",
    	"Дерево слоев" : "Дерево слоев",
    	"Объекты на карте" : "Объекты на карте",
    	"Результаты поиска" : "Результаты поиска",
    	"Координатная сетка" : "Координатная сетка",
    	"Индексная сетка" : "Индексная сетка",
    	"Панель оверлеев" : "Панель оверлеев",
    	"Сервисы" : "Сервисы",
    	"Загрузить объекты" : "Загрузить объекты",
    	"Загрузить фотографии" : "Загрузить фотографии",
    	"Загрузить данные" : "Загрузить данные",
    		"WFS сервер" : "WFS сервер",
    		"WMS сервер" : "WMS сервер",
    		"Кадастровые данные" : "Кадастровые данные",
    	"Ссылка на карту" : "Ссылка на карту",
    	"Код для вставки" : "Код для вставки карты",
    	"Печать" : "Печать",
    	"Привязать изображение" : "Привязать изображение",
    	"Сообщить об ошибке на карте" : "Сообщить об ошибке на карте",
    	"Справка" : "Справка",
    	"Использование" : "Использование",
    	"Сервисы" : "Сервисы",
    	"О проекте" : "О проекте/Контакты",
    	"$$phrase$$_1" : "Укажите карту в параметре defaultMapID в файле config.js",
    	"У вас нет прав на просмотр данной карты" : "У вас нет прав на просмотр данной карты",
    	"Access error" : "У вас нет прав на просмотр данной карты",
    	"Map not found" : "Данная карта не существует",
    	"Unable to locate EXIF content" : "отсутствуют координаты в EXIF",
    	"Развернуть карту" : "Развернуть карту",
    	"Свернуть карту" : "Свернуть карту",
    	"Точки на изображении:" : "Точки на изображении:",
    	"Точки на карте:" : "Точки на карте:",
    	"Координаты" : "Координаты",
    	"Нарисовать" : "Нарисовать",
    	"Восстановить" : "Восстановить",
    	"Прозрачность" : "Прозрачность",
    	"Видимость" : "Видимость",
    	"Привязка изображения" : "Привязка изображения",
    	"$$phrase$$_2" : "Точка [value0] находится за пределами изображения",
    	"$$phrase$$_3" : "Не задана точка [value0] на карте",
    	"Соответствие точек" : "Соответствие точек",
    	"$$phrase$$_4" : "Точки 1 и 2 на изображении совпадают",
    	"$$phrase$$_5" : "Точки 1 и 3 на изображении совпадают",
    	"$$phrase$$_6" : "Точки 2 и 3 на изображении совпадают",
    	"$$phrase$$_7" : "Точки 1 и 2 на карте совпадают",
    	"$$phrase$$_8" : "Точки 1 и 3 на карте совпадают",
    	"$$phrase$$_9" : "Точки 2 и 3 на карте совпадают",
    	"$$phrase$$_10" : "Точки на изображении лежат на одной прямой",
    	"Создать экскурсию" : "Создать экскурсию",
    	"Чтобы пользоваться этим сайтом, установите Flash Player" : "Чтобы пользоваться этим сайтом, установите Flash Player",
    	"из Интернет" : "из Интернет",
    	"или с локального диска " : "или с локального диска ",
    	"для Internet Explorer" : "для Internet Explorer",
    	" или " : " или ",
    	"для Internet Firefox" : "для Internet Firefox",
    	"Скачать shp-файл" : "Скачать shp-файл",
    	"shp-файл" : "shp-файл",
    	"gpx-файл" : "gpx-файл",
    	"Скачать фрагмент растра" : "Скачать фрагмент растра",
    	"Очистить" : "Очистить",
    	"точка" : "точка",
    	"линия" : "линия",
    	"прямоугольник" : "прямоугольник",
    	"многоугольник" : "многоугольник",
    	"Скачать" : "Скачать",
    	"Введите имя файла для скачивания" : "Введите имя файла для скачивания",
    	"Выберите область рамкой на карте" : "Выберите область рамкой на карте",
    	"Вырезать фрагмент растра" : "Вырезать фрагмент растра",
    	"К прямоугольнику не подходит ни одного растрового слоя" : "К прямоугольнику не подходит ни одного растрового слоя",
    	"Загруженный shp-файл пуст" : "Загруженный shp-файл пуст",
    	"Ошибка скачивания" : "Ошибка скачивания",
    	"Обновить" : "Обновить",
    	"Домашняя директория" : "Директория проекта",
    	"Имя папки" : "Имя папки",
    	"Имя" : "Имя",
    	"Тип" : "Тип",
    	"Размер" : "Размер",
    	"Дата" : "Дата",
        "Дата создания": "Дата создания",
    	"Снять выделение" : "Снять выделение",
    	"Скопировать" : "Скопировать",
    	"Удалить" : "Удалить",
    	"Извлечь" : "Извлечь",
    	"Упаковать" : "Упаковать",
    	"Загрузить" : "Загрузить",
        "Параметр" : "Параметр",
        "Значение" : "Значение",
        "VALUE" : "VALUE",
        "WHERE" : "WHERE",
        "Колонки" : "Колонки",
        "Операторы" : "Операторы",
        "Функции" : "Функции",
        "Метаданные": "Метаданные",
        "Редактировать колонки": "Редактировать колонки",
    	"URL сервера" : "URL сервера",
    	"Формат изображения" : "Формат изображения",
    	"Введите имя gml-файла для скачивания:" : "Введите имя gml-файла для скачивания:",
    	"точки" : "точки",
    	"линии" : "линии",
    	"полигоны" : "полигоны",
    	"(ссылка)" : "(ссылка)",
    	"Сохранить состояние карты" : "Сохранить состояние карты",
    	"Ссылка на текущее состояние карты" : "Ссылка на текущее состояние карты",
    	"Добавить стиль" : "Добавить стиль",
    	"Атрибут >" : "Атрибут >",
    	"Значение >" : "Значение >",
    	"Операция >" : "Операция >",
    	"Накладываемое изображение" : "Накладываемое изображение",
    	"Цвет" : "Цвет",
    	"Прозрачность" : "Прозрачность",
    	"Авторизуйтесь для редактирования фильтров" : "Авторизуйтесь для редактирования фильтров",
    	"Имя фильтра" : "Имя фильтра",
    	"Переместить фильтр вверх" : "Переместить фильтр вверх",
    	"Переместить фильтр вниз" : "Переместить фильтр вниз",
    	"Удалить фильтр" : "Удалить фильтр",
    	"Размер шрифта" : "Размер шрифта",
    	"Смещение" : "Смещение",
    	"Смещение по x" : "Смещение по x",
    	"Смещение по y" : "Смещение по y",
    	"Имя атрибута" : "Имя атрибута",
    	"Граница обрезки" : "Граница обрезки",
    	"Граница" : "Граница",
    	"Толщина линии" : "Толщина линии",
    	"Заливка" : "Заливка",
        "Заливка цветом": "Заливка цветом",
        "Заливка штриховкой": "Заливка штриховкой",
        "Заливка рисунком": "Заливка рисунком",
        "Ширина паттерна": "Ширина паттерна",
        "Ширина отступа": "Ширина отступа",
        "URL рисунка": "URL рисунка",
    	"Маркер URL" : "Маркер URL",
    	"URL изображения" : "URL изображения",
        "Изображение" : "Изображение",
    	"Размер точек" : "Размер точек",
    	"Редактировать стили" : "Редактировать стили",
    	"Авторизуйтесь для редактирования настроек слоя" : "Авторизуйтесь для редактирования настроек слоя",
    	"Недостаточно прав для редактирования настроек слоя" : "Недостаточно прав для редактирования настроек слоя",
    	"Недостаточно прав для редактирования объектов слоя" : "Недостаточно прав для редактирования объектов слоя",
    	"ID" : "ID",
    	"Описание" : "Описание",
    	"Файл" : "Файл",
    	"Таблица" : "Таблица",
    	"Каталог с тайлами" : "Каталог с тайлами",
    	"Каталог растров" : "Каталог растров",
        "Источник": "Источник",
        "Данные с датой": "Разбить по датам",

        "Дополнительно": "Дополнительно",
        "Шаблон названий объектов": "Шаблон названий объектов",
    	"Y (широта)" : "Y (широта)",
    	"X (долгота)" : "X (долгота)",
    	"Каталог" : "Каталог",
    	"Изменить" : "Изменить",
    	"Создать" : "Создать",
    	"Вид вложенных элементов" : "Вид вложенных элементов",
    	"Использовать KosmosnimkiAPI" : "Загрузить подложки Kosmosnimki",
    	"Использовать OpenStreetMap" : "Использовать OpenStreetMap",
    	"Язык по умолчанию" : "Язык по умолчанию",
        "Единицы длины": "Единицы длины",
        "Единицы площади": "Единицы площади",
    	"Формат координат": "Формат координат",
        "units.auto": "авто",
        "units.m": "м",
        "units.km": "км",
        "units.nm": "м. мили",
        "units.m2": "м<sup>2",
        "units.ha": "га",
        "units.km2": "км<sup>2",
    	"coords.dd" : "dd.dddd",
    	"coords.dms" : "dd°mm′ss″",
    	"Генерализация" : "Генерализация",
    	"gereralization.on": "включить",
    	"gereralization.off": "выключить",
    	"gereralization.disable": "использовать настройки слоев",
    	"Количество информационных окошек" : "Количество информационных окошек",
        "layerOrder.title": "Порядок слоёв",
        "layerOrder.native": "Стандартный",
        "layerOrder.vectorOnTop": "Вектора сверху",
    	"Разрешить поиск в векторных слоях" : "Разрешить поиск в векторных слоях",
    	"Начальная позиция" : "Начальная позиция",
    	"Широта" : "Широта",
    	"Долгота" : "Долгота",
    	"placeholder degrees": "dd.dddd",
    	"placeholder zoom": "1-21",
    	"placeholder minZoom": "1",
    	"placeholder maxZoom": "21",
    	"Зум" : "Зум",
    	"Ссылка (permalink)" : "Ссылка (permalink)",
    	"Разрешить скачивание" : "Разрешить скачивание",
    	"Векторных слоев" : "Векторных слоев",
    	"Растровых слоев" : "Растровых слоев",
    	"Масштабирование в миникарте" : "Масштабирование в миникарте",
    	"Показывать всплывающие подсказки" : "Показывать всплывающие подсказки",
    	"Свойства" : "Свойства",
    	"Создать копию слоя" : "Создать копию слоя",
    	"Стили" : "Стили",
    	"Изображение на карте" : "Изображение на карте",
    	"Слой [value0]" : "Слой [value0]",
        "Стили слоя [value0]" : "Стили слоя [value0]",
    	"Мультислой [value0]" : "Мультислой [value0]",
    	"Группа [value0]" : "Группа [value0]",
    	"Карта [value0]" : "Карта [value0]",
    	"Редактировать стиль" : "Редактировать стиль",
    	"Редактирование стилей объекта" : "Редактирование стилей объекта",
    	"Стили слоя" : "Стили слоя",
    	"Навигация по карте и инструменты" : "Навигация по карте и инструменты",
    	"Список слоев" : "Список слоев",
    	"Стиль векторного слоя" : "Стиль векторного слоя",
    	"Управление содержанием карты" : "Управление содержанием карты",
    	"Пользовательские инструменты" : "Пользовательские инструменты",
    	"$$help$$_1" : "Держите нажатой левую клавишу мыши – перетаскивайте карту курсором. Для приближения и удаления используйте колесико мыши (карта зуммируется к точке под курсором). Для перецентровки по координатам – введите их в строке поиска.",
    	"$$help$$_2" : "В левой панели отображается список слоев в виде дерева. Для перецентровки карты по экстенту слоя – кликните по его названию в списке. Если данная опция включена администратором карты, вы можете скачивать векторные слои и вырезать и скачивать фрагменты растровых слоев.",
    	"$$help$$_3" : "Для редактирования стиля векторного слоя кликните на иконку перед названием слоя.",
    	"$$help$$_4" : "Карта представляет собой набор слоев, отображение которого задается с помощью списка слоев. Чтобы иметь возможность редактировать набор слоев (создавать группы, изменять порядок отображения и т.д.) и сохранять изменения – необходимо авторизоваться. Более подробно см ",
    	" - Руководство пользователя" : " - Руководство пользователя",
    	"$$help$$_5" : "Пользовательские инструменты одновременно служат для создания объектов на карте, которые затем можно сохранять через «ссылку на карту», и для выполнения простых аналитических функций. ",
    	"В режиме маркеров: " : "В режиме маркеров: ",
    	"$$help$$_6" : "одиночный клик - добавить маркер. Двойной клик по маркеру - удалить. Клик на маркер – открыть всплывающее окошко (балун), клик по балуну – добавить надпись.",
    	"В режиме линейка/измерения расстояния, полигон/измерение площади: " : "В режиме линейка/измерения расстояния, полигон/измерение площади: ",
    	"$$help$$_7" : "одиночный клик - добавить вершину. Двойной клик - завершить фигуру. Клик на линию - добавить вершину. Двойной клик по вершине - удалить.",
    	"$$help$$_8" : "Кликните по объекту в списке «объектов на карте», чтобы перецентровать карту на него. Вы можете скачать контуры объектов в shp/tab/kml формате.",
    	"$$about$$_1" : "это веб-приложение для интерактивного просмотра геоданных и доступа к источникам базовых геоданных в интернете, таким как: ",
    	"$$about$$_2" : "С помощью GeoMixer можно публиковать собственные геоданные во внутренней сети предприятий или в интернет, накладывать их поверх базовых источников и предоставлять к ним доступ для совместной работы сколь угодно большому числу пользователей, разграничивая права доступа.",
    	"$$about$$_3" : "GeoMixer также включает компонент API, который позволяет встраивать созданные проекты в сторонние веб-сайты и приложения и программно управлять фукционалом интерактивной карты.",
    	" - Общее описание" : " - Общее описание",
    	" - Руководство разработчика" : " - Руководство разработчика",
    	"Создать" : "Создать",
    	"Получить API-ключ" : "Получить API-ключ",
    	"Введите API-ключ" : "Введите API-ключ",
    	"Печать карты" : "Печать карты",
    	"$$serviceHelp$$_1" : "Позволяет на лету загрузить shp/tab/kml файл небольшого размера в виде пользовательских объектов. После загрузки пользователь может редактировать геометрию объектов и скачивать объекты в том же наборе форматов.",
    	"$$serviceHelp$$_2" : "По ссылке запоминается текущее положение карты, а так же пользовательские объекты и надписи.",
    	"$$serviceHelp$$_3" : "Отправляет на печать текущий фрагмент карты.",
    	"Редактировать" : "Редактировать",
        "Удалить объект?": "Удалить объект?",
        "Удалить отмеченные объекты?": "Удалить отмеченные объекты?",
    	"Координаты" : "Координаты",
    	"Длина" : "Длина",
    	"Площадь" : "Площадь",
    	"Добавить подгруппу" : "Добавить группу",
    	"Введите имя группы" : "Создание новой группы",
    	"Имя группы" : "Имя группы",
    	"Включая вложенные слои" : "Включая вложенные слои",
    	"Удаление группы [value0]" : "Удаление группы [value0]",
    	"Сохранено" : "Сохранено",
    	"Прозрачность выбранного слоя/группы/карты" : "Прозрачность выбранного слоя/группы/карты",
    	"$$updateInfo$$_1" : "Для отображения нового слоя необходимо сохранить и перезагрузить карту",
    	"Любой" : "Любой",
    	"Векторный" : "Векторный",
    	"Растровый" : "Растровый",
    	"Название" : "Название",
    	"Владелец" : "Владелец",
    	"Последнее изменение": "Последнее изменение",
    	"Список слоев" : "Список слоев",
    	"Вы действительно хотите удалить этот слой?" : "Вы действительно хотите удалить этот слой?",
    	"Ошибка!" : "Ошибка!",
    	"Ошибка" : "Ошибка",
    	"Выберите колонку" : "Выберите колонку",
    	"Список карт" : "Список карт",
    	"Показать" : "Показать",
    	"загрузка..." : "загрузка...",
    	"удаление..." : "удаление...",
    	"Вы действительно хотите удалить эту карту?" : "Вы действительно хотите удалить эту карту?",
        "maplist.hint": "Группы и слои можно перетащить в текущую карту",
    	"Слоя нет в базе" : "Слоя нет в базе",
    	"ScanEx Web Geomixer - просмотр карты" : "ScanEx Web Geomixer - просмотр карты",
    	"Изменить параметры поиска" : "Изменить параметры поиска",
    	"$$search$$_1" : "Поиск по векторным слоям и адресной базе",
    	"$$search$$_2" : "Поиск по адресной базе",
    	"Поиск не дал результатов" : "Поиск не дал результатов",
    	"Очистить" : "Очистить",
    	"Регистрация" : "Регистрация",
    	"Восстановление пароля" : "Восстановление пароля",
    	"Вход" : "Вход",
    	"Выход" : "Выход",
    	"Логин" : "Логин",
    	"Пароль" : "Пароль",
    	"пароль" : "пароль",
        "Псевдоним": "Псевдоним",
        "Полное имя": "Полное имя",
    	"Пожалуйста, авторизуйтесь" : "Пожалуйста, авторизуйтесь",
        "адрес электронной почты": "адрес электронной почты",
    	"Ошибка сервера" : "Ошибка сервера",
    	"Папка" : "Папка",
    	" и " : " и ",
    	"Название" : "Название",
    	"Рейтинг" : "Рейтинг",
    	"Автор" : "Автор",
    	"Тематика" : "Тематика",
    	"Развлекательная" : "Развлекательная",
    	"Спортивная" : "Спортивная",
    	"Историческая" : "Историческая",
    	"Экологическая" : "Экологическая",
    	"Любая" : "Любая",
    	"Создать новую тему" : "Создать новую тему",
    	"Начало периода" : "Начало периода",
    	"Окончание периода" : "Окончание периода",
    	"Накладываемые тайлы" : "Накладываемые тайлы",
    	"Отображать с зума" : "Отображать с зума",
    	"По" : "по",
    	"Фильтр" : "Фильтр",
    	"Подпись" : "Подпись",
    	"Балун" : "Подсказка при наведении и клике",
    	"По умолчанию" : "По умолчанию",
    	"Показывать при клике": "Показывать при клике",
    	"Показывать при наведении": "Показывать при наведении",
    	"Символика" : "Символика",
        "Библиотека стилей": "Библиотека стилей",
        "Настройка стилей": "Настройка стилей",
    	"скопировать": "скопировать",
    	"применить везде": "применить везде",
    	"Применить": "Применить",
    	"Кластеризация" : "Кластеризация",
    	"Минимальный" : "Минимальный",
    	"Максимальный" : "Максимальный",
    	"Мин. зум" : "Мин. зум",
    	"Макс. зум" : "Макс. зум",
    	"Тип" : "Тип",
    	"Пешеходная" : "Пешеходная",
    	"Велосипедная" : "Велосипедная",
    	"Автомобильная" : "Автомобильная",
    	"Речная" : "Речная",
    	"Места" : "Места",
    	"Маршрут" : "Маршрут",
    	"Редактировать экскурсию" : "Редактировать экскурсию",
    	"Добавьте маршрут" : "Добавьте маршрут",
    	"Выберете темы на пути следования" : "Выберете темы на пути следования",
    	"$$phrase$$_11" : "Добавьте маршрут при помощи инструмента \"Линия\" на панели инструментов",
    	"$$phrase$$_12" : "Нет подходящих объектов на карте",
    	"Выбор маршрута" : "Выбор маршрута",
    	"Выбор мест" : "Выбор мест",
    	"$$phrase$$_13" : "У вас нет опубликованных тем на карте. Вы можете добавить тему в разделе Вид-Обсуждения",
    	"Обсуждения" : "Обсуждения",
    	"Экскурсии" : "Экскурсии",
    	"$$phrase$$_14" : "Невозможно удалить карту, использующуюся в качестве карты по умолчанию",
    	"$$phrase$$_15" : "Невозможно удалить загруженную карту",
    	"Назад" : "Назад",
    	"Вперед" : "Вперед",
    	"$$phrase$$_16" : "Альбома с указанным ID изображения не существует",
    	"Редактировать альбом" : "Редактировать альбом",
    	"Оценить" : "Оценить",
    	"Поставьте маркер" : "Поставьте маркер",
    	"на карту и переместите его в нужное место." : "на карту и переместите его в нужное место.",
    	"Недостаточно прав для совершения операции" : "Недостаточно прав для совершения операции",
    	"Новая папка" : "Новая папка",
    	"Выбрать" : "Выбрать",
    	"Добавить" : "Добавить",
    	"$$serviceHelp$$_4" : "Пользователь может встроить созданную карту в другой сайт, скопировав код и вставив его внутрь HTML. Требуется указать api-ключ для сайта, на котором будет использоваться данный код.",
    	"Масштаб" : "Масштаб",
    	"Угол поворота" : "Угол поворота",
    	"Диаграммы" : "Диаграммы",
    	"График по времени" : "График по времени",
    	"Круговая" : "Круговая",
    	"Маска атрибутов" : "Маска атрибутов",
    	"Закладки" : "Закладки",
    	"Добавить закладку" : "Добавить закладку",
    	"Имя закладки" : "Имя закладки",
    	"Дерево" : "Дерево",
    	"Поиск слоев" : "Поиск слоев",
    	"Пример выражения": "[Атрибут1]\n[Атрибут2]\nпроизвольный текст",
    	"Шкала прозрачности" : "Шкала прозрачности",
    	"Цвет заливки" : "Цвет заливки",
    	"Цвет обводки" : "Цвет обводки",
    	"Цвет шрифта" : "Цвет шрифта",
    	"Легенда" : "Легенда",
    	"Событие загрузки карты" : "Событие загрузки карты",
    	"Мин" : "Мин",
    	"Макс" : "Макс",
    	"График" : "График",
    	"Гистограмма" : "Гистограмма",
    	"Столбчатая" : "Столбчатая",
    	"Временная" : "Временная",
    	"Круговая" : "Круговая",
    	"Копировать стиль" : "Копировать стиль",
    	"Применить стиль" : "Применить стиль",
    	"Не выбран стиль" : "Не выбран стиль",
    	"Невозможно применить стиль к другому типу геометрии" : "Невозможно применить стиль к другому типу геометрии",
    	"Общие" : "Общие",
    	"Доступ" : "Доступ",
    	"Окно карты" : "Окно карты",
    	"Загрузка" : "Загрузка",
    	"Копирайт" : "Копирайт",
    	"Инструменты" : "Инструменты",
    	"Загрузить KML" : "Загрузить KML",
    	"URL файла" : "URL файла",
    	"Поиск" : "Поиск",
        "Подложки": "Подложки",
        "Доступные подложки": "Доступные подложки",
        "Подложки карты": "Подложки карты",
        "Выберите слои для поиска по атрибутам": "Выберите слои для поиска по атрибутам",
    	"Включить синхронизацию слоев": "Включить синхронизацию слоев",
    	"Выключить синхронизацию слоев": "Выключить синхронизацию слоев",

    	"Редактирование прав доступа карты [value0]" : "Редактирование прав доступа карты [value0]",
    	"Редактирование прав доступа слоя [value0]" : "Редактирование прав доступа слоя [value0]",
    	"Редактирование прав доступа слоев карты [value0]" : "Редактирование прав доступа слоев карты [value0]",
    	"Состав группы [value0]" : "Состав группы [value0]",
    	"Роль" : "Роль",
    	"Добавить пользователя" : "Добавить пользователя",
    	"Права доступа" : "Права доступа",
    	"Права доступа к слоям" : "Права доступа к слоям",
    	"Пользователи без прав доступа:" : "Пользователи без прав доступа:",
    	"Пользователи с правами доступа:" : "Пользователи с правами доступа:",
    	"Выберите нового владельца" : "Выберите нового владельца",
    	"Сменить владельца" : "Сменить владельца",

    	"Объекты RuMap" : "Данные RuMap",
    	"Объекты пользователей" : "Данные пользователей",


    	"Контакты" : "Контакты",
    	"Фотографии" : "Фотографии",
    	"Момент съемки" : "Момент съемки",
    	"Видео" : "Видео",
    	"Сообщения" : "Сообщения",
    	"Ссылка на место" : "Ссылка на место",
    	"Ссылка на экскурсию" : "Ссылка на экскурсию",
    	"Ссылка на событие" : "Ссылка на событие",
    	"Создать новое событие" : "Создать новое событие",
    	"События" : "События",
    	"Календарь" : "Календарь",
    	"Новости" : "Новости",
    	"Мероприятия" : "Мероприятия",
    	"Отмена" : "Отмена",
    	"Пропустить" : "Пропустить",
    	"Время" : "Время",
    	"Альбом OpenPhotoVR" : "Фотоальбом",
    	"Встраиваемый код" : "Встраиваемое видео",

    	"Объекты экологического риска" : "Объекты экологического риска",
    		"Санкционированные свалки" : "Санкционированные свалки",
    		"Несанкционированные свалки" : "Несанкционированные свалки",
    		"Полигоны отходов" : "Полигоны отходов",
    		"Предприятия переработки отходов" : "Предприятия переработки отходов",
    		"Факельные установки, ТЭЦ, трубы" : "Факельные установки, ТЭЦ, трубы",
    		"Закрытые свалки" : "Закрытые свалки",
    		"Пункты приема отходов" : "Пункты приема отходов",
    		"Оползни" : "Оползни",
    		"Карстовые явления" : "Карстовые явления",
    		"Суффозионные явления" : "Суффозионные явления",

    	"Государство и общество" : "Государство и общество",
    		"Радио" : "Радиостанции",
    		"Правительственные учреждения" : "Правительственные учреждения",
    		"Оптики" : "Оптики",
    		"Охранные агенства" : "Охранные агенства",
    		"Травмпункты" : "Травмпункты",
    		"Таможня" : "Таможня",
    		"Ветеринарные клиники" : "Ветеринарные клиники",
    		"ЗАГС" : "ЗАГС",
    		"Больницы" : "Больницы",
    		"Аптеки" : "Аптеки",
    		"Поликлиники" : "Поликлиники",
    		"Колледжи" : "Колледжи",
    		"Университеты" : "Университеты",
    		"ОВИР" : "ОВИР",
    		"Посольства" : "Посольства",
    		"Почтовые отделения" : "Почтовые отделения",
    		"Суды" : "Суды",
    		"Банки" : "Банки",
    		"Родильные дома" : "Родильные дома",
    		"Дома престарелых" : "Дома престарелых",
    		"Детские сады" : "Детские сады",
    		"Школы" : "Школы",
    		"Инспекции" : "Инспекции",
    		"Адвокаты" : "Адвокаты",
    		"МЧС" : "МЧС",
    		"Муниципальные учреждения" : "Муниципальные учреждения",
    		"Администрация" : "Администрация",

    	"Культура и отдых" : "Культура и отдых",
    		"Боулинг" : "Боулинг",
    		"Аквапарки" : "Аквапарки",
    		"Парки развлечений" : "Парки развлечений",
    		"Библиотеки" : "Библиотеки",
    		"Памятники" : "Памятники",
    		"Лагери отдыха" : "Лагери отдыха",
    		"Кинотеатры" : "Кинотеатры",
    		"Цирки" : "Цирки",
    		"Галереи" : "Галереи",
    		"Отели" : "Отели",
    		"Мотели" : "Мотели",
    		"Музеи" : "Музеи",
    		"Концертные залы" : "Концертные залы",
    		"Ночные клубы" : "Ночные клубы",
    		"Театры" : "Театры",
    		"Санатории" : "Санатории",
    		"Зоопарки" : "Зоопарки",

    	"Общественное питание" : "Общественное питание",
    		"Кафе" : "Кафе",
    		"Фастфуды" : "Фастфуды",
    		"Рестораны" : "Рестораны",
    		"Кафе-мороженое" : "Кафе-мороженое",
    		"Столовые" : "Столовые",

    	"Природные достопримечательности" : "Природные достопримечательности",
    		"Ботанический сад" : "Ботанические сады",
    		"Пещеры" : "Пещеры",
    		"Водопады" : "Водопады",
    		"Парки" : "Парки",
    		"Источники" : "Источники",
    		"Заповедники" : "Заповедники",
    		"Прочие архитектурные и природные достопримечательности" : "Архитектурные достопримечательности",

    	"Религия" : "Религия",
    		"Культовые сооружения" : "Культовые сооружения",
    		"Мечети" : "Мечети",
    		"Монастыри" : "Монастыри",
    		"Церкви других христианских конфессий" : "Церкви других христианских конфессий",
    		"Православные церкви" : "Православные церкви",
    		"Синагоги" : "Синагоги",

    	"Спорт" : "Спорт",
    		"Стадионы" : "Стадионы",
    		"Теннисные корты" : "Теннисные корты",
    		"Катки" : "Катки",
    		"Ипподромы" : "Ипподромы",
    		"Фитнес" : "Фитнес",
    		"Бассейны" : "Бассейны",
    		"Прокат спортинвентаря" : "Прокат спортинвентаря",

    	"Торговля и услуги" : "Торговля и услуги",
    		"Солярии" : "Солярии",
    		"Интернет-кафе" : "Интернет-кафе",
    		"Рынки" : "Рынки",
    		"Стоматологические клиники" : "Стоматологические клиники",
    		"Магазины одежды" : "Магазины одежды",
    		"Парикмахерские" : "Парикмахерские",
    		"Бани" : "Бани",
    		"Магазины обуви" : "Магазины обуви",
    		"Магазины" : "Магазины",
    		"Ателье" : "Ателье",
    		"Такси" : "Такси",
    		"Туризм" : "Туризм",

    	"Транспорт и услуги" : "Транспорт и услуги",
    		"Аэропорты" : "Аэропорты",
    		"Автосервисы" : "Автосервисы",
    		"Автовокзалы" : "Автовокзалы",
    		"ДПС" : "ДПС",
    		"ГИБДД" : "ГИБДД",
    		"Шиномонтаж" : "Шиномонтаж",
    		"Парковки бесплатные" : "Парковки бесплатные",
    		"Парковки платные" : "Парковки платные",
    		"АЗС" : "АЗС",
    		"Автомойки" : "Автомойки",

    	"Экстренные службы" : "Экстренные службы",
    		"Пожарные/спасатели" : "Пожарные/спасатели",
    		"Милиция" : "Милиция",
    		"Скорая помощь" : "Скорая помощь",

    	"Другие темы" : "Другие темы",
    		"Разное" : "Разное",

    	"Изменение пароля" : "Изменение пароля",
    	"Новый пароль" : "Новый пароль",
    	"Старый пароль" : "Старый пароль",
    	"Подтвердите пароль" : "Подтвердите пароль",
    	"Контур" : "Контур",
    	"$$phrase$$_17" : "Добавьте контур при помощи инструмента \"Полигон\" на панели инструментов",
    	"Выбор контура" : "Выбор контура",
    	"Таблица атрибутов слоя [value0]" : "Таблица атрибутов слоя [value0]",
    	"Показать параметры поиска" : "Показать параметры поиска",
    	"Скрыть параметры поиска" : "Скрыть параметры поиска",
    	"Скрыть" : "Скрыть",
    	"SQL-условие WHERE" : "SQL-условие WHERE",
        "Искать внутри полигона" : "Искать внутри полигона",
        "Искать по пересечению с объектом" : "Искать по пересечению с объектом",
    	"Колонки" : "Колонки",
    	"Показывать колонки" : "Показывать колонки",
    	"Скрыть колонки" : "Скрыть колонки",
    	"Найти" : "Найти",
    	"Нет полей" : "Нет полей",
    	"Нет данных" : "Нет данных",
    	"Таблица атрибутов" : "Таблица атрибутов",
    	"Разрешить поиск" : "Разрешить поиск",
    	"Произвольный" : "Произвольный",
    	"День" : "День",
    	"Неделя" : "Неделя",
    	"Месяц" : "Месяц",
    	"Год" : "Год",
    	"Ежегодно" : "Ежегодно",
    	"Облачность" : "Облачность",
    	"Период" : "Период",
    	"Спутниковые покрытия" : "Спутниковые покрытия",
    	"Редактировать объект слоя [value0]" : "Редактировать объект слоя [value0]",
    	"Создать объект слоя [value0]" : "Создать объект слоя [value0]",
    	"Геометрия" : "Геометрия",
    	"Найти объекты" : "Найти объекты",
    	"Добавить объекты" : "Добавить объекты",
    	"Обновить объекты" : "Обновить объекты",
    	"Копировать объекты" : "Копировать объекты",
    	"Объекты скопированы" : "Объекты скопированы",
    	"Объекты добавлены" : "Объекты добавлены",
    	"Вставить объекты" : "Вставить объекты",
    	"Вставить объекты не удалось" : "Вставить объекты не удалось",
    	"Выберите правым кликом слой в левой панели и нажмите \"Вставить объекты\"": "Выберите правым кликом слой в левой панели и нажмите \"Вставить объекты\"",
    	"Изменить колонки" : "Изменить колонки",
    	"Обновить колонку" : "Обновить колонку",
    	"Очистить поиск" : "Очистить поиск",
        "Скачать shp": "Скачать shp",
        "Скачать gpx": "Скачать gpx",
        "Скачать csv": "Скачать csv",
        "Скачать geojson": "Скачать geojson",
        "Рассчитать площадь": "Суммарная площадь",
    	"Создать столбец" : "Создать столбец",
    	"Мультислой" : "Мультислой",
    	"В дереве слоев остались несохраненные изменения!" : "В дереве слоев остались несохраненные изменения!",
    	"файл версии отсутствует" : "файл версии отсутствует",
    	"оверлеи отсутствуют" : "оверлеи отсутствуют",
    	"Хост" : "Хост",
    	"Дополнительные карты" : "Дополнительные карты",
    	"Добавить карту" : "Добавить карту",
    	"Добавить в таймлайн" : "Добавить в таймлайн",
    	"Удалить из таймлайна" : "Удалить из таймлайна",
    	"Невозможно загрузить карту [value0] с домена [value1]" : "Невозможно загрузить карту [value0] с домена [value1]",
    	"Показывать" : "Показывать",
    	"Поиск снимков" : "Поиск снимков",
    	"Принудительно обновить тайлы" : "Принудительно обновить тайлы",
    	"Обводка" : "Обводка",
    	"Карта имеет более новую версию. Сохранить?" : "Карта имеет более новую версию. Сохранить?",
    	"Кодировка": "Кодировка",
    	"helpPostfix": "_rus.html",
    	"Показывать чекбокс видимости": "Чекбокс видимости",
    	"Разворачивать автоматически": "Разворачивать автоматически",
    	"Другая": "Другая",
    	"Временнóй слой": "Мультивременнóй слой",
    	"Колонка даты": "Колонка даты",
    	"Минимальный период": "Мин. период (дни)",
    	"Максимальный период": "Макс. период (дни)",
        "Отсутствует временной атрибут": "Отсутствует атрибут типа 'Дата'",
        "Период 1 день": "Период 1 день",
        "Показывать на карте данные за": "Показывать на карте данные за",
        "1 день": "1 день",
        "произвольный период" : "произвольный период",
    	"По границе экрана": "По границе экрана",
    	"По центру экрана": "По центру экрана",
    	"Пересечение": "Пересечение",
    	"Пролистывать слои": "Пролистывать слои",
    	"Следующий слой": "Следующий слой",
    	"Предыдущий слой": "Предыдущий слой",
        "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.": "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.",
        "WMS доступ": "WMS/WFS доступ",
        "ссылка": "ссылка",
        "Слой '[value0]' уже есть в карте": "Слой '[value0]' уже есть в карте",
        "Группа '[value0]' уже есть в карте": "Группа '[value0]' уже есть в карте",
        "Плагины": "Плагины",
        "Вручную": "Вручную",
        "Добавить атрибут": "Добавить поле",
        "Проекция": "Проекция",
        "Широта/Долгота (EPSG:4326)": "Широта/Долгота (EPSG:4326)",
        "Меркатор (EPSG:3395)": "Меркатор (EPSG:3395)",
        "Из файла": "Из файла",
        "Мультиполигон": "Мультиполигон",
        "Мультилиния": "Мультилиния",
        "Мультиточка": "Мультиточка",
        "Администрирование": "Администрирование",
        "Системные настройки": "Системные настройки",
        "Управление группами": "Управление группами",
        "Управление группами пользователей": "Управление группами пользователей",
        "Добавить снимки": "Добавить растры",
        "Существующие слои": "Существующие слои",
        "Слои из карты": "Слои из карты",
        "Слои из КР": "Слои из КР",
        "Новый слой": "Новый слой",
        "С экрана": "С экрана",
        "Добавлен растр": "Добавлен растр",
        "Добавлены растры": "Добавлены растры",
        "Выбранный объект не имеет растра": "Выбранный объект не имеет растра",
        "Этот растр уже был выбран": "Этот растр уже был выбран",
        "Каталог Растров": "Каталог растров",
        "Растр": "Растр",
        "Добавить выбранные растры": "Добавить выбранные растры",
        "EditObject.menuTitle" : "Добавить объект",
        "FileBrowser.ExceedLimitMessage" : "Размер файла превышает 500 Мб. Используйте GeoMixerFileBrowser для загрузки больших файлов.",
        "FileBrowser.DropInfo" : "Перетащите файлы сюда",
        "EditObject.drawingMenuTitle" : "Добавить объект в активный слой",
        "Поставить маркер": "Поставить маркер",
        "Центрировать": "Центрировать",
        "Пароль изменён": "Пароль изменён",
    	"портретная": "портретная",
    	"альбомная": "альбомная",
    	"gmx_geometry": "gmx_geometry"
    };

    _translationsHash.flags["eng"] = "img/flag_en.png";

    _translationsHash.titles["eng"] = "English";

    _translationsHash.hash["eng"] = {
    	"Да": "Yes",
    	"Нет": "No",
    	"Карта" : "Map",
    	"Создать" : "Create",
    	"Создать карту" : "Create map",
    	"Сохранить" : "Save",
    	"Сохранить как" : "Save as",
    	"Сохранить карту как" : "Save map as",
    	"Сохранить карту" : "Save map",
    	"Экспорт" : "Export",
    	"Ссылки" : "Links",

        "Карта пожаров": "Fires map",
        "Поиск снимков": "Search Imagery",
        "Платформа Геомиксер": "GeoMixer Web-GIS",
        "http://fires.ru": "http://fires-map.com",
        "https://search.kosmosnimki.ru": "https://search.kosmosnimki.ru/index_eng.html",

        "Данные": "Datasets",
        "Сервисы": "Services",
        "Поделиться": "Share",
        "Открыть слой": "Open layer",
        "Создать слой": "Create layer",
        "Растровый": "Raster",
        "Векторный": "Vector",
        "Создать группу": "Create group",
        "Базовые слои": "Base layers",
        "Подключить WMS": "Add WMS",
        "Подключить WFS": "Add WFS",
        "Объекты": "User objects",
        "Результаты поиска": "Search results",
        "Буфер": "Buffer",
        "Создание буферных зон": "Buffer zones",
        "Ручная привязка растров": "Manual rasters shift",
        "Поиск слоев на карте": "Search layers on map",
        "Краудсорсинг данных": "Crowdsourcing",
        "Пакетный геокодинг": "Batch geocode",
        "Маршруты": "Directions",
        "Кадастр Росреестра": "Cadastre data of Rosreestr",
        "Выбрать кадастровый объект": "Select Cadastre item",
        "Викимапиа": "Wikimapia",
        "Каталог СКАНЭКС": "Search imagery",
        "Космоснимки-пожары": "Kosmosnimki-fires",
        "GIBS NASA": "MODIS Images (NASA)",
        "Руководство пользователя": "Documentation",
        "Руководство": "User guide",
        "GeoMixer API": "GeoMixer API",
        "Использование плагинов": "Plugins usage",
    	"копия": "копия",

    	"Открыть" : "Open",
    	"Слой" : "Layer",
    	"Создать векторный слой" : "Create vector layer",
    	"Создать растровый слой" : "Create raster layer",
        "Создать мультислой" : "Create multilayer",
    	"Вид" : "View",
    	"Дерево слоев" : "Layers tree",
    	"Объекты на карте" : "Objects on map",
    	"Результаты поиска" : "Search results",
    	"Координатная сетка" : "Coordinate grid",
    	"Индексная сетка" : "Index grid",
    	"Панель оверлеев" : "Overlays panel",
    	"Сервисы" : "Services",
    	"Загрузить объекты" : "Upload objects",
    	"Загрузить фотографии" : "Upload photos",
    	"Загрузить данные" : "Load data",
    		"WFS сервер" : "WFS server",
    		"WMS сервер" : "WMS server",
    		"Кадастровые данные" : "Cadastre data",
    	"Ссылка на карту" : "Link to the map",
    	"Код для вставки" : "Embed code",
    	"Печать" : "Print",
    	"Привязать изображение" : "Bind image",
    	"Сообщить об ошибке на карте" : "Report a map error",
    	"Справка" : "Help",
    	"Использование" : "Usage",
    	"Сервисы" : "Services",
    	"О проекте" : "About/Contacts",
    	"$$phrase$$_1" : "Choose parameter defaultMapID in config.js file",
    	"У вас нет прав на просмотр данной карты" : "Sorry, you don’t have permission to view this map",
    	"Access error" : "Sorry, you don’t have permission to view this map",
    	"Map not found" : "Sorry, this map not found",
    	"Unable to locate EXIF content" : "Unable to locate EXIF content",
    	"Развернуть карту" : "Unfold map",
    	"Свернуть карту" : "Fold map",
    	"Точки на изображении:" : "Points on image:",
    	"Точки на карте:" : "Points on map:",
    	"Координаты" : "Coordinates",
    	"Нарисовать" : "Draw",
    	"Восстановить" : "Restore",
    	"Прозрачность" : "Transparency",
    	"Видимость" : "Visibility",
    	"Привязка изображения" : "Image binding",
    	"$$phrase$$_2" : "Point [value0] is outside the limits of image",
    	"$$phrase$$_3" : "Point [value0] is not specified on a map",
    	"Соответствие точек" : "Point correspondence",
    	"$$phrase$$_4" : "Points 1 and 2 coincide at the image",
    	"$$phrase$$_5" : "Points 1 and 3 coincide at the image",
    	"$$phrase$$_6" : "Points 2 and 3 coincide at the image",
    	"$$phrase$$_7" : "Points 1 and 2 coincide at the map",
    	"$$phrase$$_8" : "Points 1 and 3 coincide at the map ",
    	"$$phrase$$_9" : "Points 2 and 3 coincide at the map ",
    	"$$phrase$$_10" : "Points lie on a straight line at the image ",
    	"Создать экскурсию" : "Create guide",
    	"Чтобы пользоваться этим сайтом, установите Flash Player" : "To use this web site, please, install Flash Player",
    	"из Интернет" : "from Internet",
    	"или с локального диска " : "or from local disc",
    	"для Internet Explorer" : "for Internet Explorer",
    	" или " : " or ",
    	"для Firefox" : "for Firefox",
    	"Скачать shp-файл" : "Download shp-file",
    	"shp-файл" : "shp-file",
    	"gpx-файл" : "gpx-file",
    	"Скачать фрагмент растра" : "Download fragment of raster",
    	"Очистить" : "Delete",
    	"точка" : "point",
    	"линия" : "line",
    	"прямоугольник" : "rectangle",
    	"многоугольник" : "polygon",
    	"Скачать" : "Download",
    	"Введите имя файла для скачивания" : "Enter file name to download",
    	"Выберите область рамкой на карте" : "Select region using frame",
    	"Вырезать фрагмент растра" : "Cut fragment of raster",
    	"К прямоугольнику не подходит ни одного растрового слоя" : "No one raster layer fit the rectangle",
    	"Загруженный shp-файл пуст" : "The uploaded shp-file is empty",
    	"Ошибка скачивания" : "Download error",
    	"Обновить" : "Update",
    	"Домашняя директория" : "Project directory",
    	"Имя папки" : "Folder name",
    	"Имя" : "Name",
    	"Тип" : "Type",
    	"Размер" : "Size",
    	"Дата" : "Date",
        "Дата создания": "Дата создания",
    	"Снять выделение" : "Clear selection",
    	"Скопировать" : "Copy",
    	"Удалить" : "Delete",
    	"Извлечь" : "Extract",
    	"Упаковать" : "Add to archive",
    	"Загрузить" : "Download",
        "Параметр" : "Parameter",
        "Значение" : "Value",
    	"VALUE" : "VALUE",
    	"WHERE" : "WHERE",
    	"Колонки" : "Columns",
    	"Операторы" : "Operators",
    	"Функции" : "Functions",
        "Метаданные": "Metadata",
        "Редактировать колонки": "Edit columns",
    	"URL сервера" : "Server URL",
    	"Формат изображения" : "Image format",
    	"Введите имя gml-файла для скачивания:" : "Enter gml-file name to download:",
    	"точки" : "points",
    	"линии" : "lines",
    	"полигоны" : "polygons",
    	"(ссылка)" : "(link)",
    	"Сохранить состояние карты" : "Save map state",
    	"Ссылка на текущее состояние карты" : "Link to the map",
    	"Добавить стиль" : "Add style",
    	"Атрибут >" : "Attribute >",
    	"Значение >" : "Value >",
    	"Операция >" : "Operation >",
    	"Накладываемое изображение" : "Ground overlay",
    	"Цвет" : "Color",
    	"Авторизуйтесь для редактирования фильтров" : "Authorize to edit filters",
    	"Имя фильтра" : "Filter name",
    	"Переместить фильтр вверх" : "Move filter up",
    	"Переместить фильтр вниз" : "Move filter down",
    	"Удалить фильтр" : "Delete filter",
    	"Размер шрифта" : "Typesize",
    	"Смещение" : "Shift",
    	"Смещение по x" : "X shift",
    	"Смещение по y" : "Y shift",
    	"Имя атрибута" : "Attribute name",
    	"Граница обрезки" : "Clip region",
    	"Граница" : "Outline",
    	"Толщина линии" : "Line thickness",
    	"Заливка" : "Fill",
        "Заливка цветом": "Color fill",
        "Заливка штриховкой": "Pattern fill",
        "Заливка рисунком": "Image fill",
        "Ширина паттерна": "Pattern width",
        "Ширина отступа": "Indent width",
        "URL рисунка": "Image URL",
    	"Маркер URL" : "Icon URL ",
    	"URL изображения" : "Image URL",
        "Изображение" : "Image",
    	"Размер точек" : "Point size",
    	"Редактировать стили" : "Edit styles",
    	"Авторизуйтесь для редактирования настроек слоя" : " Authorize to edit layer properties",
    	"Недостаточно прав для редактирования настроек слоя" : "You have not enough permission to edit layer properties ",
    	"Недостаточно прав для редактирования объектов слоя" : "You have not enough permission to edit layer objects ",
    	"ID" : "ID",
    	"Описание" : "Description",
    	"Файл" : "File",
    	"Таблица" : "Table",
    	"Каталог с тайлами" : "Tile catalogue",
        "Каталог растров" : "Raster catalogue",
        "Данные с датой": "Split through time",
        "Источник": "Source",
        "Дополнительно": "Advanced options",
        "Шаблон названий объектов": "Objects title template",
    	"Y (широта)" : "Y (latitude)",
    	"X (долгота)" : "X (longitude)",
    	"Каталог" : "Catalogue",
    	"Изменить" : "Change",
    	"Вид вложенных элементов" : "Form of attached elements",
    	"Использовать KosmosnimkiAPI" : "Load Kosmosnimki base layers",
    	"Использовать OpenStreetMap" : "Use OpenStreetMap",
    	"Язык по умолчанию" : "Default language",
        "Единицы длины": "Distance unit",
        "Единицы площади": "Square unit",
    	"Формат координат": "Coordinates format",
        "units.auto": "auto",
        "units.m": "m",
        "units.km": "km",
        "units.nm": "nmi",
        "units.m2": "m<sup>2</sup>",
        "units.ha": "ha",
        "units.km2": "km<sup>2</sup>",
    	"coords.dd" : "dd.dddd",
    	"coords.dms" : "dd°mm′ss″",
    	"Генерализация" : "Generalization",
    	"gereralization.on": "on",
    	"gereralization.off": "off",
    	"gereralization.disable": "use layers settings",
    	"Количество информационных окошек" : "Max popup count",
        "layerOrder.title": "Layers order",
        "layerOrder.native": "Native",
        "layerOrder.vectorOnTop": "Vector on top",
    	"Разрешить поиск в векторных слоях" : "Allow search vector layers",
    	"Начальная позиция" : "Start position",
    	"Широта" : "Latitude",
    	"Долгота" : "Longitude",
    	"placeholder degrees": "dd.dddd",
    	"placeholder zoom": "1-21",
    	"placeholder minZoom": "1",
    	"placeholder maxZoom": "21",
    	"Зум" : "Zoom",
    	"Ссылка (permalink)" : "Permalink",
    	"Разрешить скачивание" : "Allow to download",
    	"Векторных слоев" : "Vector layers",
    	"Растровых слоев" : "Raster layers",
    	"Масштабирование в миникарте" : "Minimap zoom delta",
    	"Показывать всплывающие подсказки" : "Show tooltips",
    	"Свойства" : "Properties",
    	"Создать копию слоя" : "Create layer copy",
    	"Стили" : "Styles",
    	"Изображение на карте" : "Ground overlay",
    	"Слой [value0]" : "Layer [value0]",
    	"Стили слоя [value0]" : "Styles of layer [value0]",
    	"Мультислой [value0]" : "Multilayer [value0]",
    	"Группа [value0]" : "Group [value0]",
    	"Карта [value0]" : "Map [value0]",
    	"Редактировать стиль" : "Edit style",
    	"Редактирование стилей объекта" : "Object styles editing",
    	"Стили слоя" : "Layer styles",
    	"Навигация по карте и инструменты" : "Map navigation and tools",
    	"Список слоев" : "List of layers",
    	"Стиль векторного слоя" : "Vector layer style",
    	"Управление содержанием карты" : "Map content management",
    	"Пользовательские инструменты" : "Users tools",
    	"$$help$$_1" : "Hold mouse left button – move map with cursor. To zoom in or out use mouse wheel (or map zoom slider to zoom to the cursor position). In order to move map center to specified coordinates – enter coordinates in search line.",
    	"$$help$$_2" : "Layer tree is represented in the left panel. To change map center according to layer extent – click its title in the list. If this option was activated by map administrator, you can download vector layers and cut and download raster layers fragments.",
    	"$$help$$_3" : "To edit vector layer style click icon near layer name.",
    	"$$help$$_4" : "Map is a collection of layers, which is displayed using layer tree. It is necessary to authorize to be able to edit the collection of layers (create groups, change display order etc.) and save changes. For more information see ",
    	" - Руководство пользователя" : " – User guide",
    	"$$help$$_5" : "User tools serve the purpose of creation of objects on map, which can be saved via «save link to the map», and, at the same time, simple analytic functions fulfillment.",
    	"В режиме маркеров: " : "Creating markers: ",
    	"$$help$$_6" : "single click – add marker. Double click on marker – delete. Click on marker – open pop-up window (balloon), click on balloon – add text.",
    	"В режиме линейка/измерения расстояния, полигон/измерение площади: " : "Drawing lines/distance measurement, polygon/area measurement: ",
    	"$$help$$_7" : "single click – add vertex. Double click – complete figure. Click on line – add vertex. Double click on vertex – delete.",
    	"$$help$$_8" : "Click on object in list of «objects on map» to move map center to it. You can download object in shp/tab/kml format.",
    	"$$about$$_1" : "this web application for interactive geodata view and access to basic data sources in the Internet, such as: ",
    	"$$about$$_2" : " Using GeoMixer you can publish own geodata in intranet or in the Internet, put them over basic data coverages and give access to them for however large number of users, changing access permissions.",
    	"$$about$$_3" : "GeoMixer also includes API component, which enables integrating the created projects into other web sites and applications and carry out program control over interactive map functional.",
    	" - Общее описание" : " – General manual",
    	" - Руководство разработчика" : " – Developer’s gudie",
    	"Получить API-ключ" : "Get API-key",
    	"Введите API-ключ" : "Enter API-key",
    	"$$serviceHelp$$_1" : "Allows to upload small shp/tab/kml file on the fly in the form of user objects. After uploading user can edit geometry of objects and download objects in the same format kit.",
    	"$$serviceHelp$$_2" : "Link saves current map state, and also user objects and texts.",
    	"$$serviceHelp$$_3" : "Print current map fragment.",
    	"Редактировать" : "Edit",
        "Удалить объект?": "Delete object?",
        "Удалить отмеченные объекты?": "Delete selected objects?",
    	"Длина" : "Length",
    	"Площадь" : "Area",
    	"Добавить подгруппу" : "Create group",
    	"Введите имя группы" : "New group creation",
    	"Имя группы" : "Group name",
    	"Включая вложенные слои" : "Including attached layers",
    	"Удаление группы [value0]" : "Delete group [value0]",
    	"Сохранено" : "Saved",
    	"Прозрачность выбранного слоя/группы/карты" : "Transparency of the selected layer/group/map",
    	"$$updateInfo$$_1" : "To display new layer it is necessary to save and reload map",
    	"Любой" : "Any",
    	"Векторный" : "Vector",
    	"Растровый" : "Raster",
    	"Название" : "Name",
    	"Владелец" : "Owner",
    	"Последнее изменение": "Last modification",
    	"Список слоев" : "Layers list",
    	"Вы действительно хотите удалить этот слой?" : "Do you really want to delete the selected layer?",
    	"Ошибка!" : "Error!",
    	"Ошибка" : "Error",
    	"Выберите колонку" : "Select column",
    	"Список карт" : "Maps list",
    	"Показать" : "Show",
    	"загрузка..." : "loading...",
    	"удаление..." : "deleting...",
    	"Вы действительно хотите удалить эту карту?" : " Do you really want to delete the selected map?",
        "maplist.hint": "You can drag layers and folders from here to current map",
    	"Слоя нет в базе" : "Layer is not in base",
    	"ScanEx Web Geomixer - просмотр карты" : "ScanEx Web Geomixer – map view",
    	"Изменить параметры поиска" : "Change search parameters",
    	"$$search$$_1" : "Search vector layers and address base",
    	"$$search$$_2" : "Search address base",
    	"Поиск не дал результатов" : "There are no search results",
    	"Регистрация" : "Registration",
    	"Восстановление пароля" : "Restore password",
    	"Вход" : "Login",
    	"Выход" : "Logout",
    	"Логин" : "User name",
    	"Пароль" : "Password",
    	"пароль" : "password",
        "Псевдоним": "Nickname",
        "Полное имя": "Full name",
    	"Пожалуйста, авторизуйтесь" : "Please, authorize",
        "адрес электронной почты": "enter your e-mail",
    	"Ошибка сервера" : "Server error",
    	"Папка" : "Folder",
    	" и " : " and ",
    	"Название" : "Title",
    	"Рейтинг" : "Rating",
    	"Автор" : "Author",
    	"Тематика" : "Theme",
    	"Развлекательная" : "Fun",
    	"Спортивная" : "Sport",
    	"Историческая" : "History",
    	"Экологическая" : "Ecology",
    	"Любая" : "All",
    	"Создать новую тему" : "Create topic",
    	"Начало периода" : "Since",
    	"Окончание периода" : "Till",
    	"Накладываемые тайлы" : "Ground tiles",
    	"Отображать с зума" : "Show with zoom",
    	"По" : "to",
    	"Фильтр" : "Filter",
    	"Подпись" : "Label",
    	"Балун" : "Balloon",
    	"По умолчанию" : "Default",
    	"Показывать при клике": "Show on click",
    	"Показывать при наведении": "Show on mouse over",
    	"Символика" : "Shown style",
        "Библиотека стилей": "Style library",
        "Настройка стилей": "Style settings",
    	"скопировать": "copy style",
    	"применить везде": "apply to all",
    	"Применить": "Apply",
        "Кластеризация" : "Clustering",
    	"Минимальный" : "Mininmal",
    	"Максимальный" : "Maximal",
    	"Мин. зум" : "Min. zoom",
    	"Макс. зум" : "Max. zoom",
    	"Пешеходная" : "Footpath",
    	"Велосипедная" : "Bicycle",
    	"Автомобильная" : "Automobile",
    	"Места" : "Places",
    	"Маршрут" : "Route",
    	"Редактировать экскурсию" : "Edit excursion",
    	"Добавьте маршрут" : "Add route",
    	"Выберете темы на пути следования" : "Choose places throughout the journey",
    	"$$phrase$$_11" : "Add route by clicking \"Line\" tool on toolbar",
    	"$$phrase$$_12" : "There are no corresponding objects on the map",
    	"Выбор маршрута" : "Routes choice",
    	"Выбор мест" : "Places choice",
    	"$$phrase$$_13" : "You haven't places om map. You can add place in View-Forum tab",
    	"Обсуждения" : "Forum",
    	"Экскурсии" : "Excursions",
    	"$$phrase$$_14" : "Unable to delete default map",
    	"$$phrase$$_15" : "Unable to delete current map",
    	"Назад" : "Back",
    	"Вперед" : "Forward",
    	"$$phrase$$_16" : "There is no album with given image ID",
    	"Редактировать альбом" : "Edit album",
    	"Оценить" : "Vote",
    	"Поставьте маркер" : "Add marker",
    	"на карту и переместите его в нужное место." : "to map and move it to choosen place.",
    	"Недостаточно прав для совершения операции" : "Insufficient rights to perform operation",
    	"Новая папка" : "New folder",
    	"Выбрать" : "Choose",
    	"Добавить" : "Add",
    	"$$serviceHelp$$_4" : "Embedding the map: the user can embed a map window into their site by copying and pasting an HTML snippet. An API key for the site's domain is required.",
    	"Масштаб" : "Scale",
    	"Угол поворота" : "Angle",
    	"Диаграммы" : "Charts",
    	"График по времени" : "Time chart",
    	"Круговая" : "Pie chart",
    	"Маска атрибутов" : "Attributes mask",
    	"Закладки" : "Bookmarks",
    	"Добавить закладку" : "Add bookmark",
    	"Имя закладки" : "Bookmark name",
    	"Дерево" : "Tree view",
    	"Поиск слоев" : "Layers search",
    	"Пример выражения": "[Field1]\n[Field2]\nsimple text",
    	"Шкала прозрачности" : "Transparency bar",
    	"Цвет заливки" : "Fill color",
    	"Цвет обводки" : "Outline color",
    	"Цвет шрифта" : "Font color",
    	"Легенда" : "Legend",
    	"Событие загрузки карты" : "Событие загрузки карты",
    	"Мин" : "Min",
    	"Макс" : "Max",
    	"График" : "График",
    	"Гистограмма" : "Гистограмма",
    	"Столбчатая" : "Столбчатая",
    	"Временная" : "Временная",
    	"Круговая" : "Круговая",
    	"Копировать стиль" : "Copy style",
    	"Применить стиль" : "Apply style",
    	"Не выбран стиль" : "There is no copied style",
    	"Невозможно применить стиль к другому типу геометрии" : "Can't apply style to different geometry type",
    	"Общие" : "Common",
    	"Доступ" : "Policy",
    	"Окно карты" : "View",
    	"Загрузка" : "Onload",
    	"Копирайт" : "Copyright",
    	"Инструменты" : "Tools",
    	"Загрузить KML" : "Load KML",
    	"URL файла" : "File URL",
        "Поиск" : "Search",
        "Подложки": "Base Layers",
        "Доступные подложки": "Available base layers",
        "Подложки карты": "Base layers on map",
        "Выберите слои для поиска по атрибутам": "Select layers for attributes search",
    	"Включить синхронизацию слоев": "Enable sync layers",
    	"Выключить синхронизацию слоев": "Disable sync layers",

    	"Редактирование прав доступа карты [value0]" : "Map [value0] access editor",
    	"Редактирование прав доступа слоя [value0]" : "Layer [value0] access editor",
    	"Редактирование прав доступа слоев карты [value0]" : "Map [value0] layers access editor",
    	"Состав группы [value0]" : "Users of group [value0]",
    	"Роль" : "Role",
    	"Добавить пользователя" : "Add user",
    	"Права доступа" : "Access permissions",
    	"Права доступа к слоям" : "Layers access permissions",
    	"Пользователи без прав доступа:" : "Users wihout access:",
    	"Пользователи с правами доступа:" : "Users with access:",
    	"Выберите нового владельца" : "Select new owner",
    	"Сменить владельца" : "Change owner",

    	"Объекты RuMap" : "RuMap objects",
    	"Объекты пользователей" : "User objects",

    	"Контакты" : "Contacts",
    	"Фотографии" : "Photo",
    	"Момент съемки" : "Image date",
    	"Видео" : "Video",
    	"Сообщения" : "Messages",
    	"Ссылка на место" : "Ссылка на место",
    	"Ссылка на экскурсию" : "Ссылка на экскурсию",
    	"Ссылка на событие" : "Ссылка на событие",
    	"Создать новое событие" : "Создать новое событие",
    	"События" : "События",
    	"Календарь" : "Календарь",
    	"Новости" : "Новости",
    	"Мероприятия" : "Мероприятия",
    	"Отмена" : "Отмена",
    	"Пропустить" : "Skip",
    	"Время" : "Время",
    	"Альбом OpenPhotoVR" : "Фотоальбом",
    	"Встраиваемый код" : "Embed video",

    	"Объекты экологического риска" : "Объекты экологического риска",
    		"Санкционированные свалки" : "Санкционированные свалки",
    		"Несанкционированные свалки" : "Несанкционированные свалки",
    		"Полигоны отходов" : "Полигоны отходов",
    		"Предприятия переработки отходов" : "Предприятия переработки отходов",
    		"Факельные установки, ТЭЦ, трубы" : "Факельные установки, ТЭЦ, трубы",
    		"Закрытые свалки" : "Закрытые свалки",
    		"Пункты приема отходов" : "Пункты приема отходов",
    		"Оползни" : "Оползни",
    		"Карстовые явления" : "Карстовые явления",
    		"Суффозионные явления" : "Суффозионные явления",

    	"Государство и общество" : "Государство и общество",
    		"Радио" : "Радио",
    		"Правительственные учреждения" : "Правительственные учреждения",
    		"Оптики" : "Оптики",
    		"Охранные агенства" : "Охранные агенства",
    		"Травмпункты" : "Травмпункты",
    		"Таможня" : "Таможня",
    		"Ветеринарные клиники" : "Ветеринарные клиники",
    		"ЗАГС" : "ЗАГС",
    		"Больницы" : "Больницы",
    		"Аптеки" : "Аптеки",
    		"Поликлиники" : "Поликлиники",
    		"Колледжи" : "Колледжи",
    		"Университеты" : "Университеты",
    		"ОВИР" : "ОВИР",
    		"Посольства" : "Посольства",
    		"Почтовые отделения" : "Почтовые отделения",
    		"Суды" : "Суды",
    		"Банки" : "Банки",
    		"Родильные дома" : "Родильные дома",
    		"Дома престарелых" : "Дома престарелых",
    		"Детские сады" : "Детские сады",
    		"Школы" : "Школы",
    		"Инспекции" : "Инспекции",
    		"Адвокаты" : "Адвокаты",
    		"МЧС" : "МЧС",
    		"Муниципальные учреждения" : "Муниципальные учреждения",
    		"Администрация" : "Администрация",

    	"Культура и отдых" : "Культура и отдых",
    		"Боулинг" : "Боулинг",
    		"Аквапарки" : "Аквапарки",
    		"Парки развлечений" : "Парки развлечений",
    		"Библиотеки" : "Библиотеки",
    		"Памятники" : "Памятники",
    		"Лагери отдыха" : "Лагери отдыха",
    		"Кинотеатры" : "Кинотеатры",
    		"Цирки" : "Цирки",
    		"Галереи" : "Галереи",
    		"Отели" : "Отели",
    		"Мотели" : "Мотели",
    		"Музеи" : "Музеи",
    		"Концертные залы" : "Концертные залы",
    		"Ночные клубы" : "Ночные клубы",
    		"Театры" : "Театры",
    		"Санатории" : "Санатории",
    		"Зоопарки" : "Зоопарки",

    	"Общественное питание" : "Общественное питание",
    		"Кафе" : "Кафе",
    		"Фастфуды" : "Фастфуды",
    		"Рестораны" : "Рестораны",
    		"Кафе-мороженое" : "Кафе-мороженое",
    		"Столовые" : "Столовые",

    	"Природные достопримечательности" : "Природные достопримечательности",
    		"Ботанический сад" : "Ботанические сады",
    		"Пещеры" : "Пещеры",
    		"Водопады" : "Водопады",
    		"Парки" : "Парки",
    		"Источники" : "Источники",
    		"Заповедники" : "Заповедники",
    		"Прочие архитектурные и природные достопримечательности" : "Архитектурные достопримечательности",

    	"Религия" : "Религия",
    		"Культовые сооружения" : "Культовые сооружения",
    		"Мечети" : "Мечети",
    		"Монастыри" : "Монастыри",
    		"Церкви других христианских конфессий" : "Церкви других христианских конфессий",
    		"Православные церкви" : "Православные церкви",
    		"Синагоги" : "Синагоги",

    	"Спорт" : "Спорт",
    		"Стадионы" : "Стадионы",
    		"Теннисные корты" : "Теннисные корты",
    		"Катки" : "Катки",
    		"Ипподромы" : "Ипподромы",
    		"Фитнес" : "Фитнес",
    		"Бассейны" : "Бассейны",
    		"Прокат спортинвентаря" : "Прокат спортинвентаря",

    	"Торговля и услуги" : "Торговля и услуги",
    		"Солярии" : "Солярии",
    		"Интернет-кафе" : "Интернет-кафе",
    		"Рынки" : "Рынки",
    		"Стоматологические клиники" : "Стоматологические клиники",
    		"Магазины одежды" : "Магазины одежды",
    		"Парикмахерские" : "Парикмахерские",
    		"Бани" : "Бани",
    		"Магазины обуви" : "Магазины обуви",
    		"Магазины" : "Магазины",
    		"Ателье" : "Ателье",
    		"Такси" : "Такси",
    		"Туризм" : "Туризм",

    	"Транспорт и услуги" : "Транспорт и услуги",
    		"Аэропорты" : "Аэропорты",
    		"Автосервисы" : "Автосервисы",
    		"Автовокзалы" : "Автовокзалы",
    		"ДПС" : "ДПС",
    		"ГИБДД" : "ГИБДД",
    		"Шиномонтаж" : "Шиномонтаж",
    		"Парковки бесплатные" : "Парковки бесплатные",
    		"Парковки платные" : "Парковки платные",
    		"АЗС" : "АЗС",
    		"Автомойки" : "Автомойки",

    	"Экстренные службы" : "Экстренные службы",
    		"Пожарные/спасатели" : "Пожарные/спасатели",
    		"Милиция" : "Милиция",
    		"Скорая помощь" : "Скорая помощь",

    	"Другие темы" : "Другие темы",
    		"Разное" : "Разное",

    	"Изменение пароля" : "Password change",
    	"Новый пароль" : "New password",
    	"Старый пароль" : "Old password",
    	"Подтвердите пароль" : "Confirm password",
    	"Контур" : "Border",
    	"$$phrase$$_17" : "Add border by clicking \"Polygon\" tool on toolbar",
    	"Выбор контура" : "Border select",
    	"Таблица атрибутов слоя [value0]" : "[value0] attributes table",
    	"Показать параметры поиска" : "Show search params",
    	"Скрыть параметры поиска" : "Hide search params",
    	"Скрыть" : "Hide",
    	"Искать внутри полигона" : "Search inside polygon",
    	"Искать по пересечению с объектом" : "Search by geometry",
    	"SQL-условие WHERE" : "WHERE SQL expression",
    	"Колонки" : "Columns",
    	"Показывать колонки" : "Show columns",
    	"Скрыть колонки" : "Hide columns",
    	"Найти" : "Search",
    	"Нет полей" : "Empty fields",
    	"Нет данных" : "Empty data",
    	"Таблица атрибутов" : "Attributes table",
    	"Разрешить поиск" : "Allow search",
    	"Произвольный" : "Any",
    	"День" : "Day",
    	"Неделя" : "Week",
    	"Месяц" : "Month",
    	"Год" : "Year",
    	"Ежегодно" : "Every year",
    	"Облачность" : "Clouds",
    	"Период" : "Period",
    	"Спутниковые покрытия" : "Satellite cover",
    	"Редактировать объект слоя [value0]" : "Edit layer [value0] object",
    	"Создать объект слоя [value0]" : "Add layer [value0] object",
    	"Геометрия" : "Geometry",
    	"Найти объекты" : "Find objects",
    	"Добавить объекты" : "Add objects",
    	"Обновить объекты" : "Update objects",
    	"Копировать объекты" : "Copy objects",
    	"Объекты скопированы" : "Objects are copied",
    	"Объекты добавлены" : "Объекты добавлены",
    	"Вставить объекты" : "Paste objects",
    	"Вставить объекты не удалось" : "Paste objects failed",
    	"Выберите правым кликом слой в левой панели и нажмите \"Вставить объекты\"": "Right-click on layer name and select \"Paste objects\"",
    	"Изменить колонки" : "Update columns",
    	"Обновить колонку" : "Update column",
    	"Очистить поиск" : "Clean search",
        "Скачать shp": "Download shp",
        "Скачать gpx": "Download gpx",
        "Скачать csv": "Download csv",
        "Скачать geojson": "Download geojson",
        "Рассчитать площадь": "Total square",
    	"Создать столбец" : "Create column",
    	"Мультислой" : "Multilayer",
    	"В дереве слоев остались несохраненные изменения!" : "There are unsaved changes on layers tree!",
    	"файл версии отсутствует" : "version file doesn't exists",
    	"оверлеи отсутствуют" : "no overlays present",
    	"Хост" : "Host",
    	"Дополнительные карты" : "Additional maps",
    	"Добавить карту" : "Add map",
    	"Добавить в таймлайн" : "Add to timeLine",
    	"Удалить из таймлайна" : "Remove from timeline",
    	"Невозможно загрузить карту [value0] с домена [value1]" : "Unable to load map [value0] from domain [value1]",
    	"Показывать" : "Show",
    	"Поиск снимков" : "Search imagery",
    	"Принудительно обновить тайлы" : "Forced retiling",
    	"Обводка" : "Outline",
    	"Карта имеет более новую версию. Сохранить?" : "The map has a newer version. Save anyway?",
    	"Кодировка": "Encoding",
    	"helpPostfix": "_eng.html",
    	"Показывать чекбокс видимости": "Visibility checkbox",
    	"Разворачивать автоматически": "Expand automatically",
    	"Другая": "Another",
    	"Временнóй слой": "Multitemporal layer",
    	"Колонка даты": "Date column",
    	"Минимальный период": "Min. period (days)",
    	"Максимальный период": "Max. period (days)",
        "Отсутствует временной атрибут": "Missing attribute with type 'Date'",
        "Период 1 день": "Period 1 day",
        "Показывать на карте данные за": "Show data on map within",
        "1 день": "single day",
        "произвольный период" : "arbitrary period",
    	"По границе экрана": "Screen border",
    	"По центру экрана": "Screen center",
    	"Пересечение": "Intersection",
    	"Пролистывать слои": "Scroll layers",
    	"Следующий слой": "Next layer",
    	"Предыдущий слой": "Previous layer",
        "Геометрия не сохранена. Эта возможность будет реализована в будущих версиях Геомиксера.": "Geometry is not saved. This feature will be implemented in future Geomixer versions",
        "WMS доступ": "WMS/WFS access",
        "ссылка": "link",
        "Слой '[value0]' уже есть в карте": "Layer '[value0]' already exists in this map",
        "Группа '[value0]' уже есть в карте": "Group '[value0]' already exists in this map",
        "Плагины": "Plugins",
        "Вручную": "Manually",
        "Добавить атрибут": "Add attribute",
        "Проекция": "Projection",
        "Широта/Долгота (EPSG:4326)": "Lat/Lon (EPSG:4326)",
        "Меркатор (EPSG:3395)": "Mercator (EPSG:3395)",
        "Из файла": "From file",
        "Мультиполигон": "Multipolygon",
        "Мультилиния": "Multipolyline",
        "Мультиточка": "Multipoint",
        "Администрирование": "Administration",
        "Системные настройки": "System settings",
        "Управление группами": "User group management",
        "Управление группами пользователей": "User group management",
        "Добавить снимки": "Add rasters",
        "Существующие слои": "Existing layers",
        "Слои из карты": "Layers from map",
        "Слои из КР": "Layers from RC",
        "Новый слой": "New layer",
        "С экрана": "Select on map",
        "Добавлен растр": "Raster is added",
        "Добавлены растры": "Rasters are added",
        "Выбранный объект не имеет растра": "Selected object has no raster",
        "Этот растр уже был выбран": "This raster is already selected",
        "Каталог Растров": "Raster catalog",
        "Растр": "Raster",
        "Добавить выбранные растры": "Add selected rasters",
        "EditObject.menuTitle" : "Add object",
        "FileBrowser.ExceedLimitMessage" : "File size exceeds 500 Mb. Use GeoMixerFileBrowser tool to upload large files.",
        "FileBrowser.DropInfo" : "Drop files here",
        "EditObject.drawingMenuTitle" : "Add object to active layer",
        "Поставить маркер": "Add marker",
        "Центрировать": "Set center",
        "Пароль изменён": "Password has been changed",
    	"портретная": "portrait view",
    	"альбомная": "layout view",
    	"gmx_geometry": "gmx_geometry"
    };

    /**
      @class
      @virtual
      @name IMenuElem
      @desc Описание пункта верхнего меню ГеоМиксера
      @property {String} id Уникальный идентификатор элемента меню
      @property {String} title Tекст, который будет показываться пользователю
      @property {Function} func Ф-ция, которую нужно вызвать при клике
      @property {IMenuElem[]} childs Массив элементов подменю
    */

    /**
        Верхнее меню ГеоМиксера. Может содержать до 3 уровней вложенности элементов.
        @class
    */
    var UpMenu = function()
    {

        this.submenus = [];
    	this.currSel = null;
    	this.currUnSel = null;
    	this.refs = {};

    	this.parent = null;
        this.loginContainer = null;
        this._isCreated = false;
        this.defaultHash = 'layers';
        this.clicked = false;
        this.openedMenus = [];
        this.currentTopHash = null;

        document.addEventListener('click', this.hideOnClick.bind(this));

    };

    UpMenu.prototype.hideOnClick = function(e) {
        var parents = $(e.target).parents(),
            parentsArr = $(parents).toArray(),
            isHeader = $(e.target).hasClass('header1Internal'),
            isInsideHeader = parentsArr.some(function (elem) {
                return $(elem).hasClass('header1');
            });

        if (!isInsideHeader) {
            this.clicked = false;
            this.hideMenus();
            this.currentTopHash = null;
        }

        if (!isHeader) {
            $(document).find('.header1').each(function() {
                $(this).removeClass('menuActive');
            });
        }
    };

    //предполагает, что если callback возвращает true, то итерирование можно прекратить
    UpMenu.prototype._iterateMenus = function(elem, callback) {
        if (!elem.childs) {
            return;
        }

        for (var i = 0; i < elem.childs.length; i++) {
            if (elem.childs[i] && (callback(elem.childs[i]) || this._iterateMenus(elem.childs[i], callback))) {
                return true;
            }
        }
    };

    /** Добавляет к меню новый элемент верхнего уровня
    *
    * Если меню уже было нарисовано, вызов этой ф-ции приведёт к перерисовке
    *
    *    @param {IMenuElem} elem Элемент меню
    */
    UpMenu.prototype.addItem = function(elem)
    {
        this.submenus.push(elem);
        this._isCreated && this.draw();
    };

    /** Добавляет к меню новый элемент.
    *
    * Если меню уже было нарисовано, вызов этой ф-ции приведёт к перерисовке
    *
    *    @param {IMenuElem} newElem Вставляемый элемент меню
    *    @param {String} parentID ID элемента меню, к которому добавляется новый элемент
    *    @param {String} [insertBeforeID] ID элемента меню, перед которым нужно вставить пункт меню.
    *                    Если не указан, пункт меню будет добавлен в конец списка.
    */
    UpMenu.prototype.addChildItem = function(newElem, parentID, insertBeforeID)
    {
        this._iterateMenus({childs: this.submenus}, function(elem) {
            if (elem.id && elem.id === parentID) {
                elem.childs = elem.childs || [];

                var index = elem.childs.length;
                elem.childs.forEach(function(childElem, i) {
                    if (childElem.id === insertBeforeID) {
                        index = i;
                    }
                });

                elem.childs.splice(index, 0, newElem);

                this._isCreated && this.draw();

                return true;
            }
        }.bind(this));
    };

    /** Задаёт родителя в DOM дереве для меню
    * @param {DOMElement} parent Родительский элемент в DOM дереве
    */
    UpMenu.prototype.setParent = function(parent)
    {
    	this.parent = parent;

    	if (parent)
        {
    		$(parent).empty();
            parent.appendChild(_span());
        }

    	this.disabledTabs = {};
    };

    // Показывает элемент меню
    UpMenu.prototype.showmenu = function(elem)
    {
    	elem.style.visibility = 'visible';
        if (this.openedMenus.indexOf(elem) === -1) {
            this.openedMenus.push(elem);
        }
    };
    // Скрывает элемент меню
    UpMenu.prototype.hidemenu = function(elem)
    {
    	elem.style.visibility = 'hidden';
        if (this.openedMenus.indexOf(elem) !== -1) {
            this.openedMenus.splice(this.openedMenus.indexOf(elem), 1);
        }
    };

    UpMenu.prototype._template = Handlebars.compile(
    '<div class="headerContainer">\
{{#childs}}{{#if id}}\
    <div class = "header1{{#unless childs}} menuClickable{{/unless}}" hash = "{{id}}">\
        <div class = "header1Internal">{{title}}</div>\
        {{#if childs}}\
            <ul class = "header2" id="{{id}}">\
            {{#childs}}{{#if id}}\
                <li class = "header2{{#unless childs}} menuClickable{{/unless}}" hash = "{{id}}">\
                    <div class = "header2{{#if disabled}} menuDisabled{{/if}}{{#delimiter}} menuDelimiter{{/delimiter}}">\
                        <div class = "menuMarkerLeft {{#if checked}} ui-icon ui-icon-check{{/if}}"></div>\
                        {{title}}\
                        {{#if childs}}\
                            <div class = "menuMarkerRight"></div>\
                        {{/if}}\
                    </div>\
                    {{#if childs}}\
                        <ul class = "header3" id="{{id}}">\
                        {{#childs}}{{#if id}}\
                            <li class = "header3 menuClickable" hash = "{{id}}">\
                                <div class = "header3{{#if disabled}} menuDisabled{{/if}}{{#delimiter}} menuDelimiter{{/delimiter}}">\
                                    <div class = "menuMarkerLeft {{#if checked}} ui-icon ui-icon-check{{/if}}"></div>\
                                    {{title}}\
                                </div>\
                            </li>\
                        {{/if}}{{/childs}}\
                        </ul>\
                    {{/if}}\
                </li>\
            {{/if}}{{/childs}}\
            </ul>\
        {{/if}}\
    </div>\
    {{/if}}{{/childs}}\
</div>');

    /** Основная функция  - рисует меню по заданной структуре
    */
    UpMenu.prototype.draw = function()
    {
        var ui = $(this._template({
                childs: this.submenus
            })),
            _this = this;

        $(this.parent.firstChild).empty().append(ui);

        $(ui).find('.header1').each(function() {
            _this.attachEventOnClick(this, 'menuActive');
            _this.attachEventOnMouseover(this, 'menuActive');
            _this.attachEventOnMouseout(this, 'menuActive');
            $(this).width($(this).width() + 10);
        });

        $(ui).find('li.header2').each(function() {
            _this.attachEventOnMouseover(this, 'menu2Active');
            _this.attachEventOnMouseout(this, 'menu2Active');
        });

        $(ui).find('li.header3').each(function() {
            attachEffects$1(this, 'menu3Active');
        });

        $(ui).find('.menuClickable').each(function() {
            var id = $(this).attr('hash');
            $(this).click(function(e) {
                e.stopPropagation();
                _this.refs[id].disabled || _this.openTab(id, e);
            });
        });

        this._iterateMenus({childs: this.submenus}, function(elem) {
            _this.refs[elem.id] = elem;
        });

        //убираем все скрытые меню
        for (var d in this.disabledTabs)
            this.disableMenus([d]);

        this._isCreated = true;
    };

    UpMenu.prototype.checkItem = function(id, isChecked) {
        if (this.refs[id]) {
            this.refs[id].checked = isChecked;
            $(this.parent).find('li[hash=' + id + ']').find('.menuMarkerLeft').toggleClass('ui-icon ui-icon-check', isChecked);
        }
    };

    UpMenu.prototype.removeSelections = function(id)
    {
    	$('li.menu3Active').removeClass('menu3Active');
    	$('li.menu2Active').removeClass('menu2Active');
    	$('li.menuActive').removeClass('menuActive');
    };
    // Закрывает открытые меню
    UpMenu.prototype.hideMenus = function()
    {
    	var _this = this;

    	$('ul.header2').each(function()
    	{
    		_this.hidemenu(this);
    	});
    	$('ul.header3').each(function()
    	{
    		_this.hidemenu(this);
    	});
    };
    // Открывает закладку
    UpMenu.prototype.openRef = function(hash)
    {
    	_menuUp.removeSelections();
    	_menuUp.hideMenus();
    	_menuUp.openTab(hash);
    };

    UpMenu.prototype.attachEventOnClick = function(elem, className)
    {
    	var _this = this;
    	elem.onclick = function(e) {
            if (!_this.clicked) {
                var isTopLevel = $(elem).hasClass('header1'),
                    hash = this.getAttribute('hash');

                if (isTopLevel && !_this.currentTopHash) {
                    _this.currentTopHash = hash;
                    _this.clicked = true;
                }

                if ($('#' + hash)[0]) {
                    _this.showmenu($('#' + this.getAttribute('hash'))[0]);
                }

            } else {
                return;
            }
    	};
    };

    UpMenu.prototype.attachEventOnMouseover = function(elem, className)
    {
    	var _this = this;
    	elem.onmouseover = function(e) {
            $(this).addClass(className);
            if (_this.clicked) {
                var itemsToClose = [];
                for (var i = 0; i < _this.openedMenus.length; i++) {
                    if (!_this.checkInsideElem(elem, _this.openedMenus[i])) {
                        itemsToClose.push(_this.openedMenus[i]);
                    }
                }

                for (var i = 0; i < itemsToClose.length; i++) {
                    var ee = itemsToClose[i];
                    _this.hidemenu(ee);
                }

                if ($('#' + this.getAttribute('hash'))[0]) {
                    _this.showmenu($('#' + this.getAttribute('hash'))[0]);
                }

                //add top-level hash
                var isTopLevel = $(elem).hasClass('header1'),
                    hash = this.getAttribute('hash');
                if (isTopLevel) {
                    _this.currentTopHash = hash;
                    $(document).find('.header1').each(function() {
                        $(this).removeClass('menuActive');
                    });
                    $(this).addClass(className);
                }
            }
    	};
    };

    UpMenu.prototype.checkInsideElem = function(elem, descendant)
    {
        var parents = $(descendant).parents(),
            parentsArr = $(parents).toArray(),
            isInsideElem = parentsArr.some(function (em) {
                return $(em).attr('hash') === $(elem).attr('hash');
            });

        return isInsideElem;
    };
    UpMenu.prototype.attachEventOnMouseout = function(elem, className)
    {
    	var _this = this;
    	elem.onmouseout = function(e) {
    		var evt = e || window.event,
    			target = evt.srcElement || evt.target,
    			relTarget = evt.relatedTarget || evt.toElement,
    			elem = this,
                isTopLevel = $(elem).hasClass('header1'),
                hash = this.getAttribute('hash');

            try {
        		while (relTarget) {
        			if (relTarget == elem) {
        				stopEvent(e);

        				return false;
        			}
        			relTarget = relTarget.parentNode;
        		}
                if (isTopLevel && hash === _this.currentTopHash) {
                    return false;
                } else {
                    // _this.currentTopHash = null;
                    $(elem).removeClass(className);
                }
        	} catch (e) {
                if (isTopLevel && hash === _this.currentTopHash) {
                    return false;
                } else {
                    // _this.currentTopHash = null;
                    $(elem).removeClass(className);
                }
        	}
    	};
    };

    UpMenu.prototype.getNavigatePath = function(path) {
    	for (var menuIdx = 0; menuIdx < this.submenus.length; menuIdx++)
    	{
            var submenu = this.submenus[menuIdx];

            if (!submenu) {continue}
    		if (path == submenu.id)
    		{
                return [submenu.title];
    		}

    		if (submenu.childs)
    		{
    			var childsLevel2 = submenu.childs;
    			for (var i = 0; i < childsLevel2.length; i++)
    			{
                    if (!childsLevel2[i]) {continue}
    				if (childsLevel2[i].childs)
    				{
    					var childsLevel3 = childsLevel2[i].childs;
    					// есть подменю, смотрим там
    					for(var j = 0; j < childsLevel3.length; j++)
    					{
                            if (!childsLevel3[j]) {continue}
    						if (path == childsLevel3[j].id)
    						{
                                return [submenu.title, childsLevel2[i].title, childsLevel3[j].title];
    						}
    					}
    				}
    				if (path == childsLevel2[i].id)
    				{
    					// совпадение в меню 2го уровня
                        return [submenu.title, childsLevel2[i].title];
    				}
    			}
    		}
    	}

    	return [];
    };

    /** Показывает все ранее скрытые элементы меню
    */
    UpMenu.prototype.enableMenus = function()
    {
    	for (var name in this.disabledTabs)
    	{
    		$(this.parent).find("li[hash='" + name + "']").children('div').css('display','');

    		delete this.disabledTabs[name];
    	}
    };
    /** Скрывает заданные элементы меню
    * @param {String[]} arr Массив ID элементов меню, которые нужно скрыть
    */
    UpMenu.prototype.disableMenus = function(arr)
    {
    	for (var i = 0; i < arr.length; i++)
    	{
    		$(this.parent).find("li[hash='" + arr[i] + "']").children('div').css('display','none');

    		this.disabledTabs[arr[i]] = true;
    	}
    };

    UpMenu.prototype.checkView = function()
    {
    	if (!nsGmx$1.AuthManager.isLogin())
    	{
    		this.enableMenus();

    		this.disableMenus(['mapCreate', 'mapSave', 'mapSaveAs', 'layersMenu', 'pictureBinding']);
    	}
    	else if (_queryMapLayers.currentMapRights() != "edit")
    	{
    		this.enableMenus();

    		this.disableMenus(['mapSave', 'mapSaveAs', 'layersVector', 'layersRaster', 'layersMultiRaster']);
    	}

        if (!nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN)) {
            this.disableMenus(['stileLibrary']);
        }

        if (_queryMapLayers.currentMapRights() !== "edit") {
            this.disableMenus(['mapTabsNew']);
        }

    	if (!nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_CREATE_LAYERS))
    	{
                this.disableMenus(['layersVector', 'layersRaster', 'layersMultiRaster']);
    	}

        if (!nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_CREATE_MAP))
    	{
                this.disableMenus(['mapCreate']);
    	}
    };

    UpMenu.prototype.go = function(container)
    {
    	this.setParent(container);

    	this.createMenu();

    	this.draw();

    	this.checkView();

    	if (window.location.hash)
    	{
    		this.currUnsel = function(){};
    	}

    	this.openTab(this.defaultHash);
    };

    UpMenu.prototype.openTab = function(id, event)
    {
        if (this.disabledTabs[id] || !this.refs[id]) {
            return;
        }

        var item = this.refs[id];

        this.removeSelections();
    	this.hideMenus();

        if (item.func) {
            this.clicked = false;
            event.stopPropagation();
            this.hideOnClick(event);
            item.func(id);
        } else {
            var func = item[item.checked ? 'onunsel' : 'onsel'];
            this.checkItem(id, !item.checked);
            func && func(id);
        }
    };

    /** Блок (контейнер с заголовком) левой панели
        @class
        @param {String} canvasID Уникальный идентификатор блока
        @param {Object} options Параметры
        @param {function} [options.closeFunc] Ф-ция, которая будет вызвана при нажатии на иконку закрытия блока. По умолчанию ничего не делается.
        @param {String[]} [options.path] Массив строк для формирования названия блока (см. метод setTitle()).
                          По умолчанию будет сформирован из верхнего меню ГеоМиксера по canvasID.
        @param {Boolean} [options.showCloseButton=true] Показывать ли кнопку закрытия блока
        @param {Boolean} [options.showMinimizeButton=true] Показывать ли кнопку сворачивания блока
    */
    nsGmx$1.LeftPanelItem = function(canvasID, options) {
        /** Изменение видимости контента ("свёрнутости") панели
         * @event nsGmx.LeftPanelItem.changeVisibility
        */

        options = $.extend({
            closeFunc: function(){},
            showCloseButton: true,
            showMinimizeButton: true
        }, options);

        //по умолчанию оставляем только последний элемент списка
        if (!options.path) {
            var menuPath = _menuUp.getNavigatePath(canvasID);
            options.path = menuPath.length ? [menuPath[menuPath.length - 1]] : [];
        }

        var getPathHTML = function(path) {
            if (!path) return '';

            return Handlebars.compile(
                '<tr>' +
                    '{{#path}}' +
                        '<td class="leftmenu-path-item {{#last}}menuNavigateCurrent{{/last}}">{{name}}</td>' +
                        '{{^last}}<td><div class="markerRight"></div></td>{{/last}}' +
                    '{{/path}}' +
                '</tr>')(
                {
                    path: path.map(function(item, index, arr) {
                        return {name: item, last: index === arr.length-1};
                    })
                }
            );
        };

        var ui = Handlebars.compile(
            '<div class="leftmenu-canvas {{id}}" id="{{id}}">' +
                '{{#isTitle}}<div class="leftTitle">' +
                    '{{#showMinimizeButton}}' +
                        '<div class = "leftmenu-toggle-zone">' +
                            '<div class="ui-helper-noselect leftmenu-toggle-icon leftmenu-down-icon"></div>' +
                        '</div>' +
                    '{{/showMinimizeButton}}' +
                    '<table class="leftmenu-path ui-helper-noselect">{{{pathTR}}}</table>' +
                    '{{#showCloseButton}}<div class="gmx-icon-close"></div>{{/showCloseButton}}' +
                '</div>{{/isTitle}}' +
                '<div class = "workCanvas"></div>' +
            '</div>');

        /**HTML элемент с блоком (содержит шапку и рабочую область)*/
        this.panelCanvas = $(ui({
            isTitle: !!(options.path.length || options.showCloseButton || options.showMinimizeButton),
            id: 'left_' + canvasID,
            pathTR: getPathHTML(options.path),
            showCloseButton: options.showCloseButton,
            showMinimizeButton: options.showMinimizeButton
        }))[0];

        /**Рабочая область блока*/
        this.workCanvas = $(this.panelCanvas).find('.workCanvas')[0];

        /** Программная имитация нажатия кнопки закрытия блока
            @function
        */
        this.close = options.closeFunc;

        var isUICollapsed = false,
            _this = this;

        var toggleContentVisibility = function(isCollapsed) {
            if (isUICollapsed !== isCollapsed) {
                isUICollapsed = !isUICollapsed;
                $(_this.workCanvas).toggle();
                $(_this.panelCanvas).find('.leftmenu-toggle-zone div').toggleClass('leftmenu-down-icon leftmenu-right-icon');
                $(_this).trigger('changeVisibility');
            }
        };

        $('.leftmenu-toggle-zone, .leftmenu-path', this.panelCanvas).click(function() {
            toggleContentVisibility(!isUICollapsed);
        });

        /** Свернуть панель
            @function
        */
        this.hide = toggleContentVisibility.bind(null, true);

        /** Развернуть панель
            @function
        */
        this.show = toggleContentVisibility.bind(null, false);

        /** Свёрнута ли панель */
        this.isCollapsed = function() {return isUICollapsed};

        $('.leftTitle .gmx-icon-close',  this.panelCanvas).click(options.closeFunc);

        /** Задать новый заголовок окна
         @param {String[]} [path] Массив строк для формирования названия блока.
                          Предполагается, что последний элемент является собственно названием, а предыдущие - названиями категорий.
        */
        this.setTitle = function(path) {
            $('.leftmenu-path', this.panelCanvas).html(getPathHTML(path));
        };
    };

    /** Основное меню ГеоМиксера
     * @global
     * @type {UpMenu}
     */
    var _menuUp = new UpMenu();

    // содержит ссылку на рабочую область для текущей вкладки
    var leftMenu$1 = function()
    {
    	this.workCanvas = null;
    	this.parentWorkCanvas = null;
    };

    //варианты вызова:
    //    function(canvasID, closeFunc, options) - для обратной совместимости
    //    function(canvasID, options)
    // options - те же, что и в LeftPanelItem
    leftMenu$1.prototype.createWorkCanvas = function(canvasID, closeFunc, options)
    {
        if (typeof closeFunc !== 'function') {
            options = closeFunc || {};
            closeFunc = options.closeFunc;
        } else {
            options = options || {};
        }

        options.closeFunc = function() {
            $(_this.parentWorkCanvas).hide();
            closeFunc && closeFunc();
        };

        var _this = this;
    	if (!$('#left_' + canvasID).length)
    	{
            var leftPanelItem = new nsGmx$1.LeftPanelItem(canvasID, options);
            this.parentWorkCanvas = leftPanelItem.panelCanvas;
            this.workCanvas = leftPanelItem.workCanvas;
            this.leftPanelItem = leftPanelItem;

            // так как мы используем dom элементы для поиска панелей после первого добавления
            // возможно, лучше сделать полноценный менеджер панелей левой вкладки
            this.parentWorkCanvas.leftPanelItem = leftPanelItem;

            $('#leftContentInner').prepend(this.parentWorkCanvas);

    		return false;
    	}
    	else
    	{
    		this.parentWorkCanvas = $('#left_' + canvasID)[0];
    		this.workCanvas = this.parentWorkCanvas.lastChild;
            this.leftPanelItem = this.parentWorkCanvas.leftPanelItem;
            this.leftPanelItem.close = options.closeFunc;

    		$(this.parentWorkCanvas).show();

            $('#leftContentInner').prepend(this.parentWorkCanvas);

    		return true;
    	}
    };

    nsGmx$1.VirtualLayerManager = function() {
        this._classes = window.gmxVirtualClasses || {};
        this.loader = this.loader.bind(this);
    };

    nsGmx$1.VirtualLayerManager.prototype.loader = function(type) {
        var promise = new L.gmx.Deferred(),
            classInfo = this._classes[type];
        
        if (!classInfo) {
            promise.resolve();
            return promise;
        }
        
        gmxCore.loadModule(classInfo.module, classInfo.file).then(function(module) {
            promise.resolve(module.layerClass);
        }, promise.reject);
        
        return promise;
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var underscoreMin = createCommonjsModule(function (module, exports) {
    //     Underscore.js 1.8.3
    //     http://underscorejs.org
    //     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    //     Underscore may be freely distributed under the MIT license.
    (function(){function n(n){function t(t,r,e,u,i,o){for(;i>=0&&o>i;i+=n){var a=u?u[i]:i;e=r(e,t[a],a,t);}return e}return function(r,e,u,i){e=b(e,i,4);var o=!k(r)&&m.keys(r),a=(o||r).length,c=n>0?0:a-1;return arguments.length<3&&(u=r[o?o[c]:c],c+=n),t(r,e,u,o,c,a)}}function t(n){return function(t,r,e){r=x(r,e);for(var u=O(t),i=n>0?0:u-1;i>=0&&u>i;i+=n)if(r(t[i],i,t))return i;return -1}}function r(n,t,r){return function(e,u,i){var o=0,a=O(e);if("number"==typeof i)n>0?o=i>=0?i:Math.max(i+a,o):a=i>=0?Math.min(i+1,a):i+a+1;else if(r&&i&&a)return i=r(e,u),e[i]===u?i:-1;if(u!==u)return i=t(l.call(e,o,a),m.isNaN),i>=0?i+o:-1;for(i=n>0?o:a-1;i>=0&&a>i;i+=n)if(e[i]===u)return i;return -1}}function e(n,t){var r=I.length,e=n.constructor,u=m.isFunction(e)&&e.prototype||a,i="constructor";for(m.has(n,i)&&!m.contains(t,i)&&t.push(i);r--;)i=I[r],i in n&&n[i]!==u[i]&&!m.contains(t,i)&&t.push(i);}var u=this,i=u._,o=Array.prototype,a=Object.prototype,c=Function.prototype,f=o.push,l=o.slice,s=a.toString,p=a.hasOwnProperty,h=Array.isArray,v=Object.keys,g=c.bind,y=Object.create,d=function(){},m=function(n){return n instanceof m?n:this instanceof m?void(this._wrapped=n):new m(n)};(module.exports&&(exports=module.exports=m),exports._=m),m.VERSION="1.8.3";var b=function(n,t,r){if(t===void 0)return n;switch(null==r?3:r){case 1:return function(r){return n.call(t,r)};case 2:return function(r,e){return n.call(t,r,e)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,i){return n.call(t,r,e,u,i)}}return function(){return n.apply(t,arguments)}},x=function(n,t,r){return null==n?m.identity:m.isFunction(n)?b(n,t,r):m.isObject(n)?m.matcher(n):m.property(n)};m.iteratee=function(n,t){return x(n,t,1/0)};var _=function(n,t){return function(r){var e=arguments.length;if(2>e||null==r)return r;for(var u=1;e>u;u++)for(var i=arguments[u],o=n(i),a=o.length,c=0;a>c;c++){var f=o[c];t&&r[f]!==void 0||(r[f]=i[f]);}return r}},j=function(n){if(!m.isObject(n))return {};if(y)return y(n);d.prototype=n;var t=new d;return d.prototype=null,t},w=function(n){return function(t){return null==t?void 0:t[n]}},A=Math.pow(2,53)-1,O=w("length"),k=function(n){var t=O(n);return "number"==typeof t&&t>=0&&A>=t};m.each=m.forEach=function(n,t,r){t=b(t,r);var e,u;if(k(n))for(e=0,u=n.length;u>e;e++)t(n[e],e,n);else{var i=m.keys(n);for(e=0,u=i.length;u>e;e++)t(n[i[e]],i[e],n);}return n},m.map=m.collect=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=Array(u),o=0;u>o;o++){var a=e?e[o]:o;i[o]=t(n[a],a,n);}return i},m.reduce=m.foldl=m.inject=n(1),m.reduceRight=m.foldr=n(-1),m.find=m.detect=function(n,t,r){var e;return e=k(n)?m.findIndex(n,t,r):m.findKey(n,t,r),e!==void 0&&e!==-1?n[e]:void 0},m.filter=m.select=function(n,t,r){var e=[];return t=x(t,r),m.each(n,function(n,r,u){t(n,r,u)&&e.push(n);}),e},m.reject=function(n,t,r){return m.filter(n,m.negate(x(t)),r)},m.every=m.all=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=0;u>i;i++){var o=e?e[i]:i;if(!t(n[o],o,n))return !1}return !0},m.some=m.any=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=0;u>i;i++){var o=e?e[i]:i;if(t(n[o],o,n))return !0}return !1},m.contains=m.includes=m.include=function(n,t,r,e){return k(n)||(n=m.values(n)),("number"!=typeof r||e)&&(r=0),m.indexOf(n,t,r)>=0},m.invoke=function(n,t){var r=l.call(arguments,2),e=m.isFunction(t);return m.map(n,function(n){var u=e?t:n[t];return null==u?u:u.apply(n,r)})},m.pluck=function(n,t){return m.map(n,m.property(t))},m.where=function(n,t){return m.filter(n,m.matcher(t))},m.findWhere=function(n,t){return m.find(n,m.matcher(t))},m.max=function(n,t,r){var e,u,i=-1/0,o=-1/0;if(null==t&&null!=n){n=k(n)?n:m.values(n);for(var a=0,c=n.length;c>a;a++)e=n[a],e>i&&(i=e);}else t=x(t,r),m.each(n,function(n,r,e){u=t(n,r,e),(u>o||u===-1/0&&i===-1/0)&&(i=n,o=u);});return i},m.min=function(n,t,r){var e,u,i=1/0,o=1/0;if(null==t&&null!=n){n=k(n)?n:m.values(n);for(var a=0,c=n.length;c>a;a++)e=n[a],i>e&&(i=e);}else t=x(t,r),m.each(n,function(n,r,e){u=t(n,r,e),(o>u||1/0===u&&1/0===i)&&(i=n,o=u);});return i},m.shuffle=function(n){for(var t,r=k(n)?n:m.values(n),e=r.length,u=Array(e),i=0;e>i;i++)t=m.random(0,i),t!==i&&(u[i]=u[t]),u[t]=r[i];return u},m.sample=function(n,t,r){return null==t||r?(k(n)||(n=m.values(n)),n[m.random(n.length-1)]):m.shuffle(n).slice(0,Math.max(0,t))},m.sortBy=function(n,t,r){return t=x(t,r),m.pluck(m.map(n,function(n,r,e){return {value:n,index:r,criteria:t(n,r,e)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return -1}return n.index-t.index}),"value")};var F=function(n){return function(t,r,e){var u={};return r=x(r,e),m.each(t,function(e,i){var o=r(e,i,t);n(u,e,o);}),u}};m.groupBy=F(function(n,t,r){m.has(n,r)?n[r].push(t):n[r]=[t];}),m.indexBy=F(function(n,t,r){n[r]=t;}),m.countBy=F(function(n,t,r){m.has(n,r)?n[r]++:n[r]=1;}),m.toArray=function(n){return n?m.isArray(n)?l.call(n):k(n)?m.map(n,m.identity):m.values(n):[]},m.size=function(n){return null==n?0:k(n)?n.length:m.keys(n).length},m.partition=function(n,t,r){t=x(t,r);var e=[],u=[];return m.each(n,function(n,r,i){(t(n,r,i)?e:u).push(n);}),[e,u]},m.first=m.head=m.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:m.initial(n,n.length-t)},m.initial=function(n,t,r){return l.call(n,0,Math.max(0,n.length-(null==t||r?1:t)))},m.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:m.rest(n,Math.max(0,n.length-t))},m.rest=m.tail=m.drop=function(n,t,r){return l.call(n,null==t||r?1:t)},m.compact=function(n){return m.filter(n,m.identity)};var S=function(n,t,r,e){for(var u=[],i=0,o=e||0,a=O(n);a>o;o++){var c=n[o];if(k(c)&&(m.isArray(c)||m.isArguments(c))){t||(c=S(c,t,r));var f=0,l=c.length;for(u.length+=l;l>f;)u[i++]=c[f++];}else r||(u[i++]=c);}return u};m.flatten=function(n,t){return S(n,t,!1)},m.without=function(n){return m.difference(n,l.call(arguments,1))},m.uniq=m.unique=function(n,t,r,e){m.isBoolean(t)||(e=r,r=t,t=!1),null!=r&&(r=x(r,e));for(var u=[],i=[],o=0,a=O(n);a>o;o++){var c=n[o],f=r?r(c,o,n):c;t?(o&&i===f||u.push(c),i=f):r?m.contains(i,f)||(i.push(f),u.push(c)):m.contains(u,c)||u.push(c);}return u},m.union=function(){return m.uniq(S(arguments,!0,!0))},m.intersection=function(n){for(var t=[],r=arguments.length,e=0,u=O(n);u>e;e++){var i=n[e];if(!m.contains(t,i)){for(var o=1;r>o&&m.contains(arguments[o],i);o++);o===r&&t.push(i);}}return t},m.difference=function(n){var t=S(arguments,!0,!0,1);return m.filter(n,function(n){return !m.contains(t,n)})},m.zip=function(){return m.unzip(arguments)},m.unzip=function(n){for(var t=n&&m.max(n,O).length||0,r=Array(t),e=0;t>e;e++)r[e]=m.pluck(n,e);return r},m.object=function(n,t){for(var r={},e=0,u=O(n);u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},m.findIndex=t(1),m.findLastIndex=t(-1),m.sortedIndex=function(n,t,r,e){r=x(r,e,1);for(var u=r(t),i=0,o=O(n);o>i;){var a=Math.floor((i+o)/2);r(n[a])<u?i=a+1:o=a;}return i},m.indexOf=r(1,m.findIndex,m.sortedIndex),m.lastIndexOf=r(-1,m.findLastIndex),m.range=function(n,t,r){null==t&&(t=n||0,n=0),r=r||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=Array(e),i=0;e>i;i++,n+=r)u[i]=n;return u};var E=function(n,t,r,e,u){if(!(e instanceof t))return n.apply(r,u);var i=j(n.prototype),o=n.apply(i,u);return m.isObject(o)?o:i};m.bind=function(n,t){if(g&&n.bind===g)return g.apply(n,l.call(arguments,1));if(!m.isFunction(n))throw new TypeError("Bind must be called on a function");var r=l.call(arguments,2),e=function(){return E(n,e,t,this,r.concat(l.call(arguments)))};return e},m.partial=function(n){var t=l.call(arguments,1),r=function(){for(var e=0,u=t.length,i=Array(u),o=0;u>o;o++)i[o]=t[o]===m?arguments[e++]:t[o];for(;e<arguments.length;)i.push(arguments[e++]);return E(n,r,this,this,i)};return r},m.bindAll=function(n){var t,r,e=arguments.length;if(1>=e)throw new Error("bindAll must be passed function names");for(t=1;e>t;t++)r=arguments[t],n[r]=m.bind(n[r],n);return n},m.memoize=function(n,t){var r=function(e){var u=r.cache,i=""+(t?t.apply(this,arguments):e);return m.has(u,i)||(u[i]=n.apply(this,arguments)),u[i]};return r.cache={},r},m.delay=function(n,t){var r=l.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},m.defer=m.partial(m.delay,m,1),m.throttle=function(n,t,r){var e,u,i,o=null,a=0;r||(r={});var c=function(){a=r.leading===!1?0:m.now(),o=null,i=n.apply(e,u),o||(e=u=null);};return function(){var f=m.now();a||r.leading!==!1||(a=f);var l=t-(f-a);return e=this,u=arguments,0>=l||l>t?(o&&(clearTimeout(o),o=null),a=f,i=n.apply(e,u),o||(e=u=null)):o||r.trailing===!1||(o=setTimeout(c,l)),i}},m.debounce=function(n,t,r){var e,u,i,o,a,c=function(){var f=m.now()-o;t>f&&f>=0?e=setTimeout(c,t-f):(e=null,r||(a=n.apply(i,u),e||(i=u=null)));};return function(){i=this,u=arguments,o=m.now();var f=r&&!e;return e||(e=setTimeout(c,t)),f&&(a=n.apply(i,u),i=u=null),a}},m.wrap=function(n,t){return m.partial(t,n)},m.negate=function(n){return function(){return !n.apply(this,arguments)}},m.compose=function(){var n=arguments,t=n.length-1;return function(){for(var r=t,e=n[t].apply(this,arguments);r--;)e=n[r].call(this,e);return e}},m.after=function(n,t){return function(){return --n<1?t.apply(this,arguments):void 0}},m.before=function(n,t){var r;return function(){return --n>0&&(r=t.apply(this,arguments)),1>=n&&(t=null),r}},m.once=m.partial(m.before,2);var M=!{toString:null}.propertyIsEnumerable("toString"),I=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"];m.keys=function(n){if(!m.isObject(n))return [];if(v)return v(n);var t=[];for(var r in n)m.has(n,r)&&t.push(r);return M&&e(n,t),t},m.allKeys=function(n){if(!m.isObject(n))return [];var t=[];for(var r in n)t.push(r);return M&&e(n,t),t},m.values=function(n){for(var t=m.keys(n),r=t.length,e=Array(r),u=0;r>u;u++)e[u]=n[t[u]];return e},m.mapObject=function(n,t,r){t=x(t,r);for(var e,u=m.keys(n),i=u.length,o={},a=0;i>a;a++)e=u[a],o[e]=t(n[e],e,n);return o},m.pairs=function(n){for(var t=m.keys(n),r=t.length,e=Array(r),u=0;r>u;u++)e[u]=[t[u],n[t[u]]];return e},m.invert=function(n){for(var t={},r=m.keys(n),e=0,u=r.length;u>e;e++)t[n[r[e]]]=r[e];return t},m.functions=m.methods=function(n){var t=[];for(var r in n)m.isFunction(n[r])&&t.push(r);return t.sort()},m.extend=_(m.allKeys),m.extendOwn=m.assign=_(m.keys),m.findKey=function(n,t,r){t=x(t,r);for(var e,u=m.keys(n),i=0,o=u.length;o>i;i++)if(e=u[i],t(n[e],e,n))return e},m.pick=function(n,t,r){var e,u,i={},o=n;if(null==o)return i;m.isFunction(t)?(u=m.allKeys(o),e=b(t,r)):(u=S(arguments,!1,!1,1),e=function(n,t,r){return t in r},o=Object(o));for(var a=0,c=u.length;c>a;a++){var f=u[a],l=o[f];e(l,f,o)&&(i[f]=l);}return i},m.omit=function(n,t,r){if(m.isFunction(t))t=m.negate(t);else{var e=m.map(S(arguments,!1,!1,1),String);t=function(n,t){return !m.contains(e,t)};}return m.pick(n,t,r)},m.defaults=_(m.allKeys,!0),m.create=function(n,t){var r=j(n);return t&&m.extendOwn(r,t),r},m.clone=function(n){return m.isObject(n)?m.isArray(n)?n.slice():m.extend({},n):n},m.tap=function(n,t){return t(n),n},m.isMatch=function(n,t){var r=m.keys(t),e=r.length;if(null==n)return !e;for(var u=Object(n),i=0;e>i;i++){var o=r[i];if(t[o]!==u[o]||!(o in u))return !1}return !0};var N=function(n,t,r,e){if(n===t)return 0!==n||1/n===1/t;if(null==n||null==t)return n===t;n instanceof m&&(n=n._wrapped),t instanceof m&&(t=t._wrapped);var u=s.call(n);if(u!==s.call(t))return !1;switch(u){case"[object RegExp]":case"[object String]":return ""+n==""+t;case"[object Number]":return +n!==+n?+t!==+t:0===+n?1/+n===1/t:+n===+t;case"[object Date]":case"[object Boolean]":return +n===+t}var i="[object Array]"===u;if(!i){if("object"!=typeof n||"object"!=typeof t)return !1;var o=n.constructor,a=t.constructor;if(o!==a&&!(m.isFunction(o)&&o instanceof o&&m.isFunction(a)&&a instanceof a)&&"constructor"in n&&"constructor"in t)return !1}r=r||[],e=e||[];for(var c=r.length;c--;)if(r[c]===n)return e[c]===t;if(r.push(n),e.push(t),i){if(c=n.length,c!==t.length)return !1;for(;c--;)if(!N(n[c],t[c],r,e))return !1}else{var f,l=m.keys(n);if(c=l.length,m.keys(t).length!==c)return !1;for(;c--;)if(f=l[c],!m.has(t,f)||!N(n[f],t[f],r,e))return !1}return r.pop(),e.pop(),!0};m.isEqual=function(n,t){return N(n,t)},m.isEmpty=function(n){return null==n?!0:k(n)&&(m.isArray(n)||m.isString(n)||m.isArguments(n))?0===n.length:0===m.keys(n).length},m.isElement=function(n){return !(!n||1!==n.nodeType)},m.isArray=h||function(n){return "[object Array]"===s.call(n)},m.isObject=function(n){var t=typeof n;return "function"===t||"object"===t&&!!n},m.each(["Arguments","Function","String","Number","Date","RegExp","Error"],function(n){m["is"+n]=function(t){return s.call(t)==="[object "+n+"]"};}),m.isArguments(arguments)||(m.isArguments=function(n){return m.has(n,"callee")}),"object"!=typeof Int8Array&&(m.isFunction=function(n){return "function"==typeof n||!1}),m.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},m.isNaN=function(n){return m.isNumber(n)&&n!==+n},m.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"===s.call(n)},m.isNull=function(n){return null===n},m.isUndefined=function(n){return n===void 0},m.has=function(n,t){return null!=n&&p.call(n,t)},m.noConflict=function(){return u._=i,this},m.identity=function(n){return n},m.constant=function(n){return function(){return n}},m.noop=function(){},m.property=w,m.propertyOf=function(n){return null==n?function(){}:function(t){return n[t]}},m.matcher=m.matches=function(n){return n=m.extendOwn({},n),function(t){return m.isMatch(t,n)}},m.times=function(n,t,r){var e=Array(Math.max(0,n));t=b(t,r,1);for(var u=0;n>u;u++)e[u]=t(u);return e},m.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))},m.now=Date.now||function(){return (new Date).getTime()};var B={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},T=m.invert(B),R=function(n){var t=function(t){return n[t]},r="(?:"+m.keys(n).join("|")+")",e=RegExp(r),u=RegExp(r,"g");return function(n){return n=null==n?"":""+n,e.test(n)?n.replace(u,t):n}};m.escape=R(B),m.unescape=R(T),m.result=function(n,t,r){var e=null==n?void 0:n[t];return e===void 0&&(e=r),m.isFunction(e)?e.call(n):e};var q=0;m.uniqueId=function(n){var t=++q+"";return n?n+t:t},m.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var K=/(.)^/,z={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},D=/\\|'|\r|\n|\u2028|\u2029/g,L=function(n){return "\\"+z[n]};m.template=function(n,t,r){!t&&r&&(t=r),t=m.defaults({},t,m.templateSettings);var e=RegExp([(t.escape||K).source,(t.interpolate||K).source,(t.evaluate||K).source].join("|")+"|$","g"),u=0,i="__p+='";n.replace(e,function(t,r,e,o,a){return i+=n.slice(u,a).replace(D,L),u=a+t.length,r?i+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'":e?i+="'+\n((__t=("+e+"))==null?'':__t)+\n'":o&&(i+="';\n"+o+"\n__p+='"),t}),i+="';\n",t.variable||(i="with(obj||{}){\n"+i+"}\n"),i="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+i+"return __p;\n";try{var o=new Function(t.variable||"obj","_",i);}catch(a){throw a.source=i,a}var c=function(n){return o.call(this,n,m)},f=t.variable||"obj";return c.source="function("+f+"){\n"+i+"}",c},m.chain=function(n){var t=m(n);return t._chain=!0,t};var P=function(n,t){return n._chain?m(t).chain():t};m.mixin=function(n){m.each(m.functions(n),function(t){var r=m[t]=n[t];m.prototype[t]=function(){var n=[this._wrapped];return f.apply(n,arguments),P(this,r.apply(m,n))};});},m.mixin(m),m.each(["pop","push","reverse","shift","sort","splice","unshift"],function(n){var t=o[n];m.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),"shift"!==n&&"splice"!==n||0!==r.length||delete r[0],P(this,r)};}),m.each(["concat","join","slice"],function(n){var t=o[n];m.prototype[n]=function(){return P(this,t.apply(this._wrapped,arguments))};}),m.prototype.value=function(){return this._wrapped},m.prototype.valueOf=m.prototype.toJSON=m.prototype.value,m.prototype.toString=function(){return ""+this._wrapped},"function"==typeof undefined&&undefined.amd&&undefined("underscore",[],function(){return m});}).call(commonjsGlobal);
    //# sourceMappingURL=underscore-min.map
    });
    var underscoreMin_1 = underscoreMin._;

    (function(){

    //внутреннее представление плагина
    var Plugin = function(moduleName, file, body, params, pluginName, mapPlugin, isPublic, lazyLoad)
    {
        var usageState = mapPlugin && !lazyLoad ? 'unknown' : 'used'; //used, notused, unknown
        var _this = this;

        var doLoad = function()
        {
            if (_this.body || _this.isLoading)
                return;

            _this.isLoading = true;
            gmxCore$1.loadModule(moduleName, file).then(function()
            {
                _this.body = gmxCore$1.getModule(moduleName);
                _this.isLoading = false;
                _this.pluginName = _this.pluginName || _this.body.pluginName;
                _this.def.resolve();
            }, function() {
                _this.isLoading = false;
                _this.def.reject();
            });
        };

        this.body = body;
        this.moduleName = moduleName;
        this.params = params || {};
        this.def = $.Deferred(); //будет resolve когда плагин загрузится
        this.isLoading = false;
        this.mapPlugin = mapPlugin || (body && body.pluginName);
        this.pluginName = pluginName || (this.body && this.body.pluginName);
        this.isPublic = isPublic;
        this.lazyLoad = lazyLoad;
        this.file = file;

        if (this.body)
            this.def.resolve();

        //мы не будем пока загружать плагин только если он не глобальный и имеет имя
        // и только если специально не указана загрузка по требованию
        if (!mapPlugin || !pluginName) {
            if (!lazyLoad) {
                doLoad();
            }
        }

        this.setUsage = function(usage)
        {
            usageState = usage;
            if (usageState === 'used') {
                doLoad();
            }
        };

        this.isUsed = function()
        {
            return usageState === 'used';
        };

        this.updateParams = function (newParams) {
            $.extend(true, _this.params, newParams);
        };
    };

    /**
      @name IGeomixerPlugin
      @desc Интерфейс плагинов ГеоМиксера
      @class
      @abstract
      @property {String} pluginName Имя плагина для списка плагинов
    */

    /**
      @memberOf IGeomixerPlugin.prototype
      @method
      @name beforeMap
      @desc Вызывется сразу после загрузки всех модулей ядра вьюера (до инициализации карты, проверки пользователя и т.п.).
            Ещё нет информации о пользователе, но пока можно сменить карту для загрузки.
      @param {Object} params Параметры плагина
    */

    /**
      @memberOf IGeomixerPlugin.prototype
      @method
      @name preloadMap
      @desc Вызывется непосредственно перед началом создания слоёв по загруженной информации о карте.
            Карту сменить уже нельзя, но можно как-нибудь повлиять на процесс создания слоёв (например, добавить новые классы слоёв)
      @param {Object} params Параметры плагина
    */

    /**
      @memberOf IGeomixerPlugin.prototype
      @method
      @name beforeViewer
      @desc вызовется до начала инициализации ГеоМиксера, но сразу после инициализации карты
      @param {Object} params Параметры плагина
      @param {gmxAPI.Map} map Основная карта
    */

    /**
      @memberOf IGeomixerPlugin.prototype
      @method
      @name afterViewer
      @desc вызовется после окончания инициализации ГеоМиксера
      @param {Object} params Параметры плагина
      @param {gmxAPI.Map} map Основная карта
    */

    /** Менеджер плагинов. Загружает плагины из конфигурационного файла
    *
    * Загрузка плагинов происходит из массива window.gmxPlugins.
    *
    * Каждый элемент этого массива - объект со следующими свойствами:
    *
    *   * module (имя модуля)
    *   * file (из какого файла подгружать модуль, может отсутствовать). Только если указано module
    *   * plugin (сам плагин). Если указано, плагин подгружается в явном виде, иначе используется module (и file)
    *   * params - объект параметров, будет передаваться в методы модуля
    *   * pluginName - имя плагина. Должно быть уникальным. Заменяет IGeomixerPlugin.pluginName. Не рекомендуется использовать без особых причин
    *   * mapPlugin {bool, default: true} - является ли плагин плагином карт. Если является, то не будет грузиться по умолчанию.
    *   * isPublic {bool, default: false} - нужно ли показывать плагин в списках плагинов (для некоторых плагинов хочется иметь возможность подключать их к картам, но не показывать всем пользователям)
    *
    * Если очередной элемент массива просто строка (например, "name"), то это эквивалентно {module: "name", file: "plugins/name.js"}
    *
    * Каждый плагин хранится в отдельном модуле (через свойство module) или подгружается в явном виде (через свойство plugin). Модуль должен реализовывать интерфейс IGeomixerPlugin.
    *  @class PluginsManager
    */
    var PluginsManager = function()
    {
        var _plugins = [];
        var _pluginsWithName = {};

        var joinedPluginInfo = {};

        //сначала загружаем инфу о плагинах из переменной nsGmx._defaultPlugins - плагины по умолчанию
        window.nsGmx && nsGmx$1._defaultPlugins && $.each(nsGmx$1._defaultPlugins, function(i, info) {
            if (typeof info === 'string') {
                info = { module: info, file: 'plugins/' + info + '.js' };
            }
            joinedPluginInfo[info.module] = info;
        });

        //дополняем её инфой из window.gmxPlugins с возможностью перезаписать
        window.gmxPlugins && $.each(window.gmxPlugins, function(i, info) {
            if (typeof info === 'string') {
                info = { module: info, file: 'plugins/' + info + '.js' };
            }
            joinedPluginInfo[info.module] = $.extend(true, joinedPluginInfo[info.module], info);
        });

        $.each(joinedPluginInfo, function(key, info) {
            if (typeof info === 'string')
                info = { module: info, file: 'plugins/' + info + '.js' };

            var plugin = new Plugin(
                info.module,
                info.file,
                info.plugin,
                info.params,
                info.pluginName,
                info.mapPlugin,
                info.isPublic || false,
                info.lazyLoad || false
            );

            _plugins.push(plugin);

            if (plugin.pluginName) {
                _pluginsWithName[ plugin.pluginName ] = plugin;
            }
            else
            {
                plugin.def.done(function()
                {
                    if (plugin.pluginName) {
                        _pluginsWithName[ plugin.pluginName ] = plugin;
                    }
                });
            }
        });

        var _genIterativeFunction = function(funcName)
        {
            return function(map)
            {
                for (var p = 0; p < _plugins.length; p++)
                    if ( _plugins[p].isUsed() && _plugins[p].body && _plugins[p].body[funcName]) {
                        //передаём в плагин deep clone параметров, чтобы плагин не мог их менять in-place
                        var params = $.extend(true, {}, _plugins[p].params);
                        try {
                            _plugins[p].body[funcName]( params, map || nsGmx$1.leafletMap );
                        } catch (e) {
                            console && console.error('Error in function ' + funcName + '() of plugin ' + _plugins[p].moduleName + ': ' + e);
                            console && console.error(e.stack);
                        }
                    }
            }
        };

        //public interface

        /**
        Вызывет callback когда будут загружены все плагины, загружаемые в данный момент
        @memberOf PluginsManager
         @name done
         @method
         @param {Function} callback Ф-ция, которую нужно будет вызвать
        */

        this.done = function(f) {
            //не можем использовать $.when, так как при первой ошибке результирующий promise сразу же reject'ится, а нам нужно дождаться загрузки всех плагинов
            var loadingPlugins = underscoreMin.where(_plugins, {isLoading: true}),
                count = loadingPlugins.length;

            count || f();

            loadingPlugins.forEach(function(plugin) {
                plugin.def.always(function() {
                    --count || f();
                });
            });
        };

        /**
         Вызывает beforeMap() у всех плагинов
         @memberOf PluginsManager
         @name beforeMap
         @method
        */
        this.beforeMap = _genIterativeFunction('beforeMap');

        /**
         Вызывает preloadMap() у всех плагинов
         @memberOf PluginsManager
         @name preloadMap
         @method
        */
        this.preloadMap = _genIterativeFunction('preloadMap');

        /**
         Вызывает beforeViewer() у всех плагинов
         @memberOf PluginsManager
         @name beforeViewer
         @method
        */
        this.beforeViewer = _genIterativeFunction('beforeViewer');

        /**
         Вызывает afterViewer() у всех плагинов
         @memberOf PluginsManager
         @name afterViewer
         @method
        */
        this.afterViewer = _genIterativeFunction('afterViewer');

        /**
         Добавляет пункты меню всех плагинов к меню upMenu
         Устарело! Используйте непосредственное добавление элемента к меню из afterViewer()
         @method
         @ignore
        */
        this.addMenuItems = function( upMenu )
        {
            for (var p = 0; p < _plugins.length; p++) {
                if ( _plugins[p].isUsed() && _plugins[p].body && _plugins[p].body.addMenuItems) {
                    var menuItems = _plugins[p].body.addMenuItems();
                    for (var i = 0; i < menuItems.length; i++)
                        upMenu.addChildItem(menuItems[i].item, menuItems[i].parentID);
                }
            }
        };

        /**
         Вызывает callback(plugin) для каждого плагина
         @memberOf PluginsManager
         @name forEachPlugin
         @method
         @param {Function} callback Ф-ция для итерирования. Первый аргумент ф-ции - модуль плагина.
        */
        this.forEachPlugin = function(callback)
        {
            //if (!_initDone) return;
            for (var p = 0; p < _plugins.length; p++)
                callback(_plugins[p]);
        };

        /**
         Задаёт, нужно ли в дальнейшем использовать данный плагин
         @memberOf PluginsManager
         @name setUsePlugin
         @method
         @param {String} pluginName Имя плагина
         @param {Bool} isInUse Использовать ли его для карты
        */
        this.setUsePlugin = function(pluginName, isInUse)
        {
            if (pluginName in _pluginsWithName)
                _pluginsWithName[pluginName].setUsage(isInUse ? 'used' : 'notused');
        };

        /**
         Получить плагин по имени
         @memberOf PluginsManager
         @name getPluginByName
         @method
         @param {String} pluginName Имя плагина
         @returns {IGeomixerPlugin} Модуль плагина, ничего не возвращает, если плагина нет
        */
        this.getPluginByName = function(pluginName)
        {
            return _pluginsWithName[pluginName];
        };

        /**
         Проверка публичности плагина (можно ли его показывать в различных списках с перечислением подключенных плагинов)
         @memberOf PluginsManager
         @name isPublic
         @method
         @param {String} pluginName Имя плагина
         @returns {Bool} Является ли плагин публичным
        */
        this.isPublic = function(pluginName)
        {
            return _pluginsWithName[pluginName] && _pluginsWithName[pluginName].isPublic;
        };

        /**
         Обновление параметров плагина
         @memberOf PluginsManager
         @name updateParams
         @method
         @param {String} pluginName Имя плагина
         @param {Object} newParams Новые параметры плагина. Параметры с совпадающими именами будут перезатёрты
        */
        this.updateParams = function(pluginName, newParams) {
            _pluginsWithName[pluginName] && _pluginsWithName[pluginName].updateParams(newParams);
        };
    };

    var publicInterface = {PluginsManager : PluginsManager};
    gmxCore$1.addModule('PluginsManager', publicInterface);

    })();

    // Делегаты пользовательских объектов - классы, управляющие отображением и сериализацией пользовательских объектов
    // Методы:
    //   - isHidden(obj) -> Bool
    //   - isSerializable(obj) -> Bool
    nsGmx$1.DrawingObjectCustomControllers = (function()
    {
    	var _delegates = [];
    	return {
    		addDelegate: function(delegate)
    		{
    			_delegates.push(delegate);
    		},
    		
    		isHidden: function(obj)
    		{
    			for (var d = 0; d < _delegates.length; d++)
    				if ('isHidden' in _delegates[d] && _delegates[d].isHidden(obj))
    					return true;
    			return false;
    		},
    		
    		isSerializable: function(obj)
    		{
    			for (var d = 0; d < _delegates.length; d++)
    				if ('isSerializable' in _delegates[d] && !_delegates[d].isSerializable(obj))
    					return false;
    			return true;
    		}
    	}
    })();

    !(function(_){

    var BaseLayersControl = function(container, blm) {
        var lang = _translationsHash.getLanguage();

        $(container).append(
            '<table class="group-editor-blm-table">' +
                '<tr>' +
                    '<td class="group-editor-blm-title">' + _gtxt('Доступные подложки') + '</td>' +
                    '<td class="group-editor-blm-title">' + _gtxt('Подложки карты') + '</td>' +
                '</tr><tr>' +
                    '<td class="group-editor-blm-available"></td>' +
                    '<td class="group-editor-blm-map"></td>' +
                '</tr>' +
            '</table>'
        );

        var availContainer = $('<ul class="group-editor-blm-ul"></ul>').appendTo($('.group-editor-blm-available', container));
        var mapContainer = $('<ul class="group-editor-blm-ul"></ul>').appendTo($('.group-editor-blm-map', container));

        var constructItem = function(id, title) {
            if (title) {
                return $('<li class="group-editor-blm-item">' + title + '</li>').data('baseLayerID', id);
            } else {
                return $('<li class="group-editor-blm-item group-editor-blm-missing-item">' + id + '</li>').data('baseLayerID', id);
            }
        };

        var activeIDs = blm.getActiveIDs();

        blm.getAll().forEach(function(baseLayer) {
            if (activeIDs.indexOf(baseLayer.id) === -1) {
                var item = constructItem(baseLayer.id, baseLayer.options[lang]);
                availContainer.append(item);
            }
        });

        activeIDs.forEach(function(id) {
            var baseLayer = blm.get(id);
            mapContainer.append(constructItem(id, baseLayer && baseLayer.options[lang]));
        });

        var updateBaseLayers = function() {
            var activeIDs = [];
            mapContainer.children('li').each(function(index, elem) {
                activeIDs.push($(elem).data('baseLayerID'));
            });
            blm.setActiveIDs(activeIDs);
        };

        mapContainer.sortable({
            connectWith: '.group-editor-blm-available > ul',
            stop: updateBaseLayers
        });
        availContainer.sortable({
            connectWith: '.group-editor-blm-map > ul',
            stop: updateBaseLayers
        });
    };

    var GroupVisibilityPropertiesModel = Backbone.Model.extend({
        defaults: {
            isChildRadio: false,
            isVisibilityControl: false,
            isExpanded: false
        }
    });

    //возвращает массив описания элементов таблицы для использования в mapHelper.createPropertiesTable
    //model {GroupVisibilityPropertiesModel} - ассоциированные параметры видимости
    //showVisibilityCheckbox {bool} - добавлять ли возможность скрывать чекбокс видимости или нет
    var GroupVisibilityPropertiesView = function( model, showVisibilityCheckbox, showExpanded )
    {
    	var _model = model;
    	var boxSwitch = _checkbox$1(!_model.get('isChildRadio'), 'checkbox'),
    		radioSwitch = _checkbox$1(_model.get('isChildRadio'), 'radio');
    	var showCheckbox = _checkbox$1(_model.get('isVisibilityControl'), 'checkbox');
    	var isExpanded = _checkbox$1(_model.get('isExpanded'), 'checkbox');

    	showCheckbox.onclick = function()
    	{
    		_model.set('isVisibilityControl', this.checked );
    	};

        isExpanded.onclick = function()
    	{
    		_model.set('isExpanded', this.checked );
    	};

    	boxSwitch.onclick = function()
    	{
    		this.checked = true;
    		radioSwitch.checked = !this.checked;

    		_model.set('isChildRadio', !this.checked);
    	};

    	radioSwitch.onclick = function()
    	{
    		this.checked = true;
    		boxSwitch.checked = !this.checked;

    		_model.set('isChildRadio', this.checked );
    	};

    	var ret = [{name: _gtxt("Вид вложенных элементов"), field: 'list', elem: _div$1([boxSwitch, radioSwitch])}];

    	if (showVisibilityCheckbox)
    		ret.push({name: _gtxt("Показывать чекбокс видимости"), elem: _div$1([showCheckbox])});

        if (showExpanded)
    		ret.push({name: _gtxt("Разворачивать автоматически"), elem: _div$1([isExpanded])});

    	return ret;
    };

    /** Показывает диалог добавления новой подгруппы
      @param div {HTMLNode} - куда добавлять новую подгруппу (группа или карта)
      @param layersTree {layersTree} - дерево главной карты
    */
    var addSubGroup = function(div, layersTree)
    {
        var ul = _abstractTree.getChildsUl(div.parentNode),
            newIndex;

        if (!ul)
            newIndex = 0;
        else
            newIndex = ul.childNodes.length + 1;

        var groupVisibilityProperties = new GroupVisibilityPropertiesModel();
        var groupVisibilityPropertiesControls = new GroupVisibilityPropertiesView( groupVisibilityProperties, true, true );

        var elemProperties = (div.gmxProperties.content) ? div.gmxProperties.content.properties : div.gmxProperties.properties,
            newName = elemProperties.title,
            inputIndex = _input(null,[['attr','value', newName + ' ' + newIndex],['dir','className','inputStyle'],['css','width','140px']]),
            create = makeButton(_gtxt('Создать')),
            pos = nsGmx$1.Utils.getDialogPos(div, true, 100),
            createSubGroup = function()
            {
                if (inputIndex.value == '')
                    return;

                var parentProperties = div.gmxProperties,
                    newGroupProperties = {
                        type:'group',
                        content:{
                            properties:{
                                title:inputIndex.value,
                                list: groupVisibilityProperties.get('isChildRadio'),
                                visible: true,
                                ShowCheckbox: groupVisibilityProperties.get('isVisibilityControl'),
                                expanded: groupVisibilityProperties.get('isExpanded'),
                                initExpand: groupVisibilityProperties.get('isExpanded'),
                                GroupID: nsGmx$1.Utils.generateUniqueID()
                            }, children:[]
                        }
                    },
    				li = _layersTree.getChildsList(newGroupProperties, parentProperties, false, div.getAttribute('MapID') ? true : _layersTree.getLayerVisibility($(div).find('input[type="checkbox"]')[0]));

    			_queryMapLayers.addDraggable(li);

    			_queryMapLayers.addDroppable(li);

    			_queryMapLayers.addSwappable(li);

    			layersTree.addTreeElem(div, 0, newGroupProperties);

    			var childsUl = _abstractTree.getChildsUl(div.parentNode);

    			if (childsUl)
    			{
    				_abstractTree.addNode(div.parentNode, li);

    				_layersTree.updateListType(li, true);

    				if (!childsUl.loaded)
    					li.removeNode(true);
    			}
    			else
    			{
    				_abstractTree.addNode(div.parentNode, li);

    				_layersTree.updateListType(li, true);
    			}

    			$(dialogDiv).dialog('destroy');
    			dialogDiv.removeNode(true);

    			_mapHelper.updateUnloadEvent(true);
    		};

    	create.onclick = createSubGroup;

    	$(inputIndex).on('keyup', function(e)
    	{
    		if (this.value == '')
    			$(this).addClass('error');
    		else
    			$(this).removeClass('error');

    		if (e.keyCode === 13)
    	  	{
    			createSubGroup();

    	  		return false;
    	  	}

    		return true;
    	});

    	create.style.marginTop = '5px';

    	var parentDiv = _div$1([inputIndex, _br(), create],[['css','textAlign','center']]);
    	var trs = [{name: _gtxt("Имя группы"), elem: inputIndex}].concat(groupVisibilityPropertiesControls);

    	var trsControls = _mapHelper.createPropertiesTable(trs, elemProperties, {leftWidth: 100});
    	var propsTable = _div$1([_table([_tbody(trsControls)],[['dir','className','propertiesTable']])]);
    	_(parentDiv, [propsTable, _br(), create]);

    	var dialogDiv = showDialog$1(_gtxt("Введите имя группы"), parentDiv, 270, 220, pos.left, pos.top);
    };

    var createGroupEditorProperties = function(div, isMap, mainLayersTree)
    {
    	var elemProperties = (isMap) ? div.gmxProperties.properties : div.gmxProperties.content.properties;

        var rawTree = mainLayersTree.treeModel.getRawTree();

    	var title = _input(null,[['attr','value',typeof elemProperties.title != 'undefined' ? elemProperties.title : ''],['dir','className','inputStyle'],['css','width','206px']]);

    	var visibilityProperties = new GroupVisibilityPropertiesModel({
            isChildRadio: elemProperties.list,
            isVisibilityControl: typeof elemProperties.ShowCheckbox === 'undefined' ? false : elemProperties.ShowCheckbox,
            isExpanded: typeof elemProperties.initExpand === 'undefined' ? false : elemProperties.initExpand
        });
    	var visibilityPropertiesView = GroupVisibilityPropertiesView(visibilityProperties, !isMap, !isMap);
    	visibilityProperties.on('change', function()
    	{
    		elemProperties.list = visibilityProperties.get('isChildRadio');
    		elemProperties.ShowCheckbox = visibilityProperties.get('isVisibilityControl');
    		elemProperties.expanded = elemProperties.initExpand = visibilityProperties.get('isExpanded');

            _layersTree.treeModel.updateNodeVisibility(mainLayersTree.findTreeElem(div).elem, null);

    		var curBox = div.firstChild;
    		if (!elemProperties.ShowCheckbox)
    		{
    			curBox.checked = true;
    			curBox.style.display = 'none';
    			curBox.isDummyCheckbox = true;
    		}
    		else
    		{
    			curBox.style.display = 'block';
    			delete curBox.isDummyCheckbox;
    		}

    		if (isMap) {
    			rawTree.properties = div.gmxProperties.properties;
    		} else {
    			mainLayersTree.findTreeElem(div).elem.content.properties = div.gmxProperties.content.properties;
    		}

    		var ul = _abstractTree.getChildsUl(div.parentNode);

    		$(ul).children('li').each(function()
    		{
    			var box = _layersTree.updateListType(this, true);
    		});
    	});

    	title.onkeyup = function()
    	{
    		if (title.value == '')
    		{
    			$(title).addClass('error');

    			return;
    		}
    		else
    			$(title).removeClass('error');

    		var span = $(div).find(".groupLayer")[0];

    		$(span).empty();

    		_(span, [_t(title.value)]);

    		if (isMap)
    		{
                $('.mainmap-title').text(title.value);

    			div.gmxProperties.properties.title = title.value;

    			rawTree.properties = div.gmxProperties.properties;
    		}
    		else
    		{
    			div.gmxProperties.content.properties.title = title.value;

    			mainLayersTree.findTreeElem(div).elem.content.properties = div.gmxProperties.content.properties;
    		}

    		return true;
    	};

    	var addProperties = function(shownProperties)
    	{
    		return _mapHelper.createPropertiesTable(shownProperties, elemProperties, {leftWidth: 100});
    	};

    	if (isMap)
    	{
    		var useAPI = _checkbox$1(elemProperties.UseKosmosnimkiAPI, 'checkbox'),
    			useOSM = _checkbox$1(elemProperties.UseOpenStreetMap, 'checkbox'),
    			defLang = $('<span class="defaultMapLangContainer">' +
                                '<label><input type="radio" name="defLang" value="rus">rus</label>' +
                                '<label><input type="radio" name="defLang" value="eng">eng</label>' +
                            '</span>')[0],
                distUnit = $('<span class="defaultMapLangContainer">' +
                                '<label><input type="radio" name="distUnit" value="auto">' + _gtxt('units.auto') + '</label>' +
                                '<label><input type="radio" name="distUnit" value="m">' + _gtxt('units.m') + '</label>' +
                                '<label><input type="radio" name="distUnit" value="km">' + _gtxt('units.km') + '</label>' +
                                '<label><input type="radio" name="distUnit" value="nm">' + _gtxt('units.nm') + '</label>' +
                            '</span>')[0],
                squareUnit = $('<span class="defaultMapLangContainer">' +
                                '<label><input type="radio" name="squareUnit" value="auto">' + _gtxt('units.auto') + '</label>' +
                                '<label><input type="radio" name="squareUnit" value="m2">' + _gtxt('units.m2') + '</label>' +
                                '<label><input type="radio" name="squareUnit" value="ha">' + _gtxt('units.ha') + '</label>' +
                                '<label><input type="radio" name="squareUnit" value="km2">' + _gtxt('units.km2') + '</label>' +
                            '</span>')[0],
               coordinatesFormat = $('<span class="defaultMapLangContainer">' +
                                '<label><input type="radio" name="coordinatesFormat" value="0">' + _gtxt('coords.dd') + '</label>' +
                                '<label><input type="radio" name="coordinatesFormat" value="1">' + _gtxt('coords.dms') + '</label>' +
     						'</span>')[0],
                maxPopupCount = $('<span class="maxPopupCountContainer">' +
                                '<input type="number" min="1" class="inputStyle inputShortWidth">' +
                               '</input>' +
                               '</span>')[0],
                layerOrder = $('<select class="selectStyle">' +
                                '<option value="Native">' + _gtxt('layerOrder.native') + '</label>' +
                                '<option value="VectorOnTop">' + _gtxt('layerOrder.vectorOnTop') + '</label>' +
                               '</select>')[0],
    			downloadVectors = _checkbox$1(elemProperties.CanDownloadVectors, 'checkbox'),
    			downloadRasters = _checkbox$1(elemProperties.CanDownloadRasters, 'checkbox'),
                WMSLink = _a([_t(_gtxt('ссылка'))], [['attr', 'href', serverBase + 'TileService.ashx?map=' + elemProperties.name]]),
                WMSLinks = $(Handlebars.compile(
                    '<div>' +
                        '<ul>' +
                            '{{#each this.services}}' +
                            '<li>' +
                                '{{this.upper}}: {{this.url}}rest/ver1/service/{{this.name}}?map={{this.mapName}}{{#if this.site}}&apikey=[APIKEY_VALUE]{{/if}}' +
                            '</li>' +
                            '<br>' +
                            '{{/each}}' +
                        '</ul>' +
                    '</div>'
                )({
                    services: [{
                            site: window.mapsSite,
                            url: window.serverBase,
                            mapName: elemProperties.MapID,
                            name: 'wms',
                            upper: 'WMS'
                        }, {
                            site: window.mapsSite,
                            url: window.serverBase,
                            mapName: elemProperties.MapID,
                            name: 'wfs',
                            upper: 'WFS'
                        }]
                }))[0],
                WMSAccess = _checkbox$1(elemProperties.WMSAccess, 'checkbox'),
    			defLat = _input(null,[['attr','placeholder', _gtxt("placeholder degrees")], ['attr','value',elemProperties.DefaultLat !== null ? elemProperties.DefaultLat : ''],['dir','className','inputStyle'],['css','width','62px']]),
    			defLong = _input(null,[['attr','placeholder', _gtxt("placeholder degrees")], ['attr','value',elemProperties.DefaultLong !== null ? elemProperties.DefaultLong : ''],['dir','className','inputStyle'],['css','width','62px']]),
    			defPermalink = _input(null,[['attr','value',elemProperties.ViewUrl != null ? elemProperties.ViewUrl : ''],['dir','className','inputStyle'],['css','width','206px']]),
    			defZoom = _input(null,[['attr','placeholder', _gtxt("placeholder zoom")], ['attr','value',elemProperties.DefaultZoom != null ? elemProperties.DefaultZoom : ''],['dir','className','inputStyle'],['css','width','60px']]),
    			onLoad = _textarea(null,[['dir','className','inputStyle group-editor-onload']]),
    			copyright =  _input(null,[['attr','value',elemProperties.Copyright != null ? elemProperties.Copyright : ''],['dir','className','inputStyle'],['css','width','206px']]),
    			minViewX =   _input(null,[['attr','placeholder', _gtxt("placeholder degrees")], ['attr','value',elemProperties.MinViewX != null && elemProperties.MinViewX != 0 ? elemProperties.MinViewX : ''],['dir','className','inputStyle'],['css','width','62px']]),
    			minViewY =   _input(null,[['attr','placeholder', _gtxt("placeholder degrees")], ['attr','value',elemProperties.MinViewY != null && elemProperties.MinViewY != 0 ? elemProperties.MinViewY : ''],['dir','className','inputStyle'],['css','width','62px']]),
    			maxViewX =   _input(null,[['attr','placeholder', _gtxt("placeholder degrees")], ['attr','value',elemProperties.MaxViewX != null && elemProperties.MaxViewX != 0 ? elemProperties.MaxViewX : ''],['dir','className','inputStyle'],['css','width','62px']]),
    			maxViewY =   _input(null,[['attr','placeholder', _gtxt("placeholder degrees")], ['attr','value',elemProperties.MaxViewY != null && elemProperties.MaxViewY != 0 ? elemProperties.MaxViewY : ''],['dir','className','inputStyle'],['css','width','62px']]),
                minZoom =    _input(null,[['attr','placeholder', _gtxt("placeholder minZoom")], ['attr','value',elemProperties.MinZoom != null ? elemProperties.MinZoom : ''],['dir','className','inputStyle'],['css','width','62px']]),
                maxZoom =    _input(null,[['attr','placeholder', _gtxt("placeholder maxZoom")], ['attr','value',elemProperties.MaxZoom != null ? elemProperties.MaxZoom : ''],['dir','className','inputStyle'],['css','width','62px']]);

    		onLoad.value = nsGmx$1.mappletLoader.get();

    		useAPI.onclick = function()
    		{
    			div.gmxProperties.properties.UseKosmosnimkiAPI = this.checked;

    			rawTree.properties = div.gmxProperties.properties;
    		};

            $([useAPI, useOSM]).addClass('propertiesTable-checkbox');

            $('input[value=' + elemProperties.DefaultLanguage + ']', defLang).attr('checked', 'checked');
            $('input[value=' + elemProperties.DistanceUnit + ']', distUnit).attr('checked', 'checked');
            $('input[value=' + elemProperties.SquareUnit + ']', squareUnit).attr('checked', 'checked');
       		$('input[value=' + elemProperties.coordinatesFormat + ']', coordinatesFormat).attr('checked', 'checked');
            $('input', maxPopupCount).val(elemProperties.maxPopupContent);
            $('option[value=' + (elemProperties.LayerOrder || 'Native') + ']', layerOrder).attr('selected', 'selected');

            $('input', defLang).change(function()
    		{
    			div.gmxProperties.properties.DefaultLanguage = this.value;
    			rawTree.properties = div.gmxProperties.properties;
    		});

            $('input', distUnit).change(function()
    		{
    			div.gmxProperties.properties.DistanceUnit = this.value;
    			rawTree.properties = div.gmxProperties.properties;
                nsGmx$1.leafletMap.options.distanceUnit = this.value;
    		});

            $('input', squareUnit).change(function()
    		{
    			div.gmxProperties.properties.SquareUnit = this.value;
    			rawTree.properties = div.gmxProperties.properties;
                nsGmx$1.leafletMap.options.squareUnit = this.value;
    		});

            $('input', coordinatesFormat).change(function()
    		{
                var num = Number(this.value),
                    locationControl = nsGmx$1.leafletMap.gmxControlsManager.get('location');

                if (locationControl) {
                    locationControl.setCoordinatesFormat(num);
                }
                nsGmx$1.leafletMap.options.coordinatesFormat = num;
                div.gmxProperties.properties.coordinatesFormat = num;
    		});
            $('input', maxPopupCount).change(function()
    		{
                if (Number(this.value) > 0) {
                    div.gmxProperties.properties.maxPopupContent = this.value;
                    rawTree.properties = div.gmxProperties.properties;
                    nsGmx$1.leafletMap.options.maxPopupCount = this.value;
                }
    		});

            $(layerOrder).change(function()
    		{
    			div.gmxProperties.properties.LayerOrder = this.value;
    			rawTree.properties = div.gmxProperties.properties;
    		});

    		useOSM.onclick = function()
    		{
    			div.gmxProperties.properties.UseOpenStreetMap = this.checked;

    			rawTree.properties = div.gmxProperties.properties;
    		};
    		downloadVectors.onclick = function()
    		{
    			div.gmxProperties.properties.CanDownloadVectors = this.checked;

    			rawTree.properties = div.gmxProperties.properties;
    		};
    		downloadRasters.onclick = function()
    		{
    			div.gmxProperties.properties.CanDownloadRasters = this.checked;

    			rawTree.properties = div.gmxProperties.properties;
    		};

            WMSAccess.onclick = function()
    		{
    			div.gmxProperties.properties.WMSAccess = this.checked;

    			rawTree.properties = div.gmxProperties.properties;

                $(WMSLinks).toggle(this.checked);
    		};

    		defLat.onkeyup = function()
    		{
                div.gmxProperties.properties.DefaultLat = (this.value === '' || isNaN(Number(this.value))) ? null : Number(this.value);
                rawTree.properties = div.gmxProperties.properties;
    			return true;
    		};

            defLong.onkeyup = function()
    		{
    			div.gmxProperties.properties.DefaultLong = (this.value === '' || isNaN(Number(this.value))) ? null : Number(this.value);
                rawTree.properties = div.gmxProperties.properties;
    			return true;
    		};

            defPermalink.onkeyup = function()
    		{
    			div.gmxProperties.properties.ViewUrl = this.value;

    			rawTree.properties = div.gmxProperties.properties;

    			return true;
    		};

    		defZoom.onkeyup = function()
    		{
                div.gmxProperties.properties.DefaultZoom = (this.value === '' || isNaN(Number(this.value))) ? null : Number(this.value);
                rawTree.properties = div.gmxProperties.properties;
    			return true;
    		};

    		onLoad.onkeyup = function()
    		{
                nsGmx$1.mappletLoader.set(this.value);

    			return true;
    		};

    		copyright.onkeyup = function()
    		{
    			div.gmxProperties.properties.Copyright = this.value;

    			rawTree.properties = div.gmxProperties.properties;

    			return true;
    		};

    		minViewX.onkeyup = function()
    		{
    			if (!isNaN(Number(this.value)))
    			{
    				div.gmxProperties.properties.MinViewX = Number(this.value);

    				rawTree.properties = div.gmxProperties.properties;
    			}

    			return true;
    		};

    		minViewY.onkeyup = function()
    		{
    			if (!isNaN(Number(this.value)))
    			{
    				div.gmxProperties.properties.MinViewY = Number(this.value);

    				rawTree.properties = div.gmxProperties.properties;
    			}

    			return true;
    		};

    		maxViewX.onkeyup = function()
    		{
    			if (!isNaN(Number(this.value)))
    			{
    				div.gmxProperties.properties.MaxViewX = Number(this.value);

    				rawTree.properties = div.gmxProperties.properties;
    			}

    			return true;
    		};

    		maxViewY.onkeyup = function()
    		{
    			if (!isNaN(Number(this.value)))
    			{
    				div.gmxProperties.properties.MaxViewY = Number(this.value);

    				rawTree.properties = div.gmxProperties.properties;
    			}

    			return true;
    		};

            minZoom.onkeyup = function()
    		{
    			if (!isNaN(Number(this.value)))
    			{
    				div.gmxProperties.properties.MinZoom = Number(this.value) || null;

                    rawTree.properties = div.gmxProperties.properties;
    			}

    			return true;
    		};

            maxZoom.onkeyup = function()
    		{
    			if (!isNaN(Number(this.value)))
    			{
    				div.gmxProperties.properties.MaxZoom = Number(this.value) || null;

    				rawTree.properties = div.gmxProperties.properties;
    			}

    			return true;
    		};

            WMSAccess.style.verticalAlign = "middle";
            $(WMSLinks).toggle(elemProperties.WMSAccess);

    		var shownCommonProperties = [
    										{name: _gtxt("Имя"), field: 'title', elem: title},
    										{name: _gtxt("ID"), field: 'name'},
    										{name: _gtxt("Копирайт"), field: 'Copyright', elem: copyright}
    									]
    									.concat(
    										[{name: _gtxt("Использовать KosmosnimkiAPI"), elem: useAPI},
    										{name: _gtxt("Язык по умолчанию"), elem: defLang},
    										{name: _gtxt("Единицы длины"), elem: distUnit},
    										{name: _gtxt("Единицы площади"), elem: squareUnit},
    										{name: _gtxt("Формат координат"), elem: coordinatesFormat},
    										{name: _gtxt("Количество информационных окошек"), elem: maxPopupCount},
    										{name: _gtxt("layerOrder.title"), elem: layerOrder},
    										{name: _gtxt("Ссылка (permalink)"), elem: defPermalink}]
    									),
    			shownPolicyProperties = [
    										{name: _gtxt("Разрешить скачивание"), elem: _table([_tbody([_tr([_td([_t(_gtxt('Векторных слоев'))],[['css','width','100px'],['css','height','20px'],['css','paddingLeft','3px']]), _td([downloadVectors])]),
    																					 				_tr([_td([_t(_gtxt('Растровых слоев'))],[['css','width','100px'],['css','height','20px'],['css','paddingLeft','3px']]), _td([downloadRasters])])])])},
                                            {name: _gtxt("WMS доступ"), elem: _div$1([WMSAccess/*, WMSLinks*/])}
                                        ],
    			shownViewProperties = [
                    {
                        name: _gtxt("Начальная позиция"),
                        elem: _table([_tbody([_tr([
                                        _td([_span([_t(_gtxt('Широта'))],[['css','marginLeft','3px']]), _br(), defLat],[['css','width','70px']]),
                                        _td([_span([_t(_gtxt('Долгота'))],[['css','marginLeft','3px']]), _br(), defLong],[['css','width','70px']]),
                                        _td([_span([_t(_gtxt('Зум'))],[['css','marginLeft','3px']]), _br(), defZoom],[['css','width','68px']])
                                    ])])],[['css', 'borderCollapse', 'collapse']])
                    }, {
                        name: _gtxt("Зум"),
                        elem: _table([_tbody([_tr([
                                        _td([_span([_t(_gtxt('Мин'))],[['css','marginLeft','3px']]), _br(), minZoom],[['css','width','70px']]),
                                        _td([_span([_t(_gtxt('Макс'))],[['css','marginLeft','3px']]), _br(), maxZoom],[['css','width','70px'], ['css','rowspan','2']])
                                    ])])],[['css', 'borderCollapse', 'collapse']])
                    }, {
                        name: _gtxt("Граница обрезки"),
                        elem:_table([_tbody([
                                    _tr([
                                        _td([_span(null, [['css','marginLeft','3px']]), _br()],[['css','width','73px']]),
                                        _td([_span([_t(_gtxt('Широта'))],[['css','marginLeft','3px']])],[['css','width','70px']]),
                                        _td([_span([_t(_gtxt('Долгота'))],[['css','marginLeft','3px']])],[['css','width','68px']])]),
                                    _tr([
                                        _td([_span([_t(_gtxt('Мин'))],[['css','marginLeft','3px']])]),
                                        _td([minViewY]),
                                        _td([minViewX])]),
                                    _tr([
                                        _td([_span([_t(_gtxt('Макс'))],[['css','marginLeft','3px']])]),
                                        _td([maxViewY]),
                                        _td([maxViewX])])
                                ])],[['css', 'borderCollapse', 'collapse']])
                    }];

    		var id = 'mapProperties' + String(Math.random()).substring(2, 12),
    			tabMenu = _div$1([_ul([_li([_a([_t(_gtxt("Общие"))],[['attr','href','#common' + id]])]),
    								 _li([_a([_t(_gtxt("Подложки"))],[['attr','href','#baselayers' + id]])]),
    								 _li([_a([_t(_gtxt("Доступ"))],[['attr','href','#policy' + id]])]),
    								 _li([_a([_t(_gtxt("Поиск"))],[['attr','href','#search' + id]])]),
    								 _li([_a([_t(_gtxt("Окно карты"))],[['attr','href','#view' + id]])]),
    								 _li([_a([_t(_gtxt("Загрузка"))],[['attr','href','#onload' + id]])]),
    								 _li([_a([_t(_gtxt("Плагины"))],[['attr','href','#plugins' + id]])])])]),
    			divCommon     = _div$1(null,[['attr','id','common' + id],['css','width','320px']]),
                divBaseLayers = _div$1(null,[['attr','id','baselayers' + id],['dir','className','group-editor-tab-container'],['css','overflowY','auto']]),
    			divPolicy     = _div$1(null,[['attr','id','policy' + id],['css','width','320px']]),
    			divSearch     = _div$1(null,[['attr','id','search' + id],['dir','className','group-editor-tab-container']]),
    			divView       = _div$1(null,[['attr','id','view' + id],['css','width','320px']]),
    			divOnload     = _div$1(null,[['attr','id','onload' + id],['dir','className','group-editor-tab-container']]),
    			divPlugins    = _div$1(null,[['attr','id','plugins' + id],['dir','className','group-editor-tab-container']]);

    		_(tabMenu, [divCommon, divBaseLayers, divPolicy, divSearch, divView, divOnload, divPlugins]);

            var baseLayersControl = new BaseLayersControl(divBaseLayers, nsGmx$1.leafletMap.gmxBaseLayersManager);

    		_(divCommon, [_table([_tbody(addProperties(shownCommonProperties))],[['css','width','100%'], ['dir','className','propertiesTable']])]);
    		_(divPolicy, [_table([_tbody(addProperties(shownPolicyProperties))],[['css','width','100%'], ['dir','className','propertiesTable']]), WMSLinks]);
    		_(divView,   [_table([_tbody(addProperties(shownViewProperties))],  [['css','width','100%'], ['dir','className','propertiesTable']])]);
    		_(divOnload, [onLoad]);

            var pluginsEditor = nsGmx$1.createPluginsEditor(divPlugins, _mapHelper.mapPlugins);

            var mapLayersTree = new layersTree({
                showVisibilityCheckbox: false,
                allowActive: false,
                allowDblClick: false,
                showStyle: false,
                visibilityFunc: function(props, isVisible) {
                    var origTreeNode = mainLayersTree.treeModel.findElem('LayerID', props.LayerID).elem;
                    origTreeNode.content.properties.AllowSearch = isVisible;
                }
            });

            //формируем новое дерево - без не-векторных слоёв и пустых папок,
            //в котором видимость слоя отражает возможность его скачивания
            var searchRawTree = mainLayersTree.treeModel.cloneRawTree(function(node) {
                if (node.type === 'layer') {
                    var props = node.content.properties;
                    if (props.type !== 'Vector') {
                        return null;
                    }

                    props.visible = !!props.AllowSearch;

                    return node;
                }

                if (node.type === 'group') {
                    var children = node.content.children;
                    if (!children.length) {
                        return null;
                    }

                    var isVisible = false;
                    for (var i = 0; i < children.length; i++) {
                        isVisible = isVisible || children[i].content.properties.visible;
                    }

                    node.content.properties.visible = isVisible;
                    return node;
                }
            });

            var mapLayersDOM = mapLayersTree.drawTree(searchRawTree, 2);
            $('<div class="group-editor-search-title"/>').text(_gtxt('Выберите слои для поиска по атрибутам')).appendTo(divSearch);
    		$(mapLayersDOM).treeview().appendTo(divSearch);

            tabMenu.updateFunc = function() {
                var props = div.gmxProperties.properties;
                props.UseKosmosnimkiAPI = useAPI.checked;
                props.UseOpenStreetMap = useOSM.checked;
                props.CanDownloadVectors = downloadVectors.checked;
                props.CanDownloadRasters = downloadRasters.checked;
                props.WMSAccess = WMSAccess.checked;

                props.DefaultLat = (isNaN(Number(defLat.value)) || defLat.value === '') ? null : Number(defLat.value);
                props.DefaultLong = (isNaN(Number(defLong.value)) || defLong.value === '') ? null : Number(defLong.value);

                props.ViewUrl = defPermalink.checked;

                props.DefaultZoom = (isNaN(Number(defZoom.value)) || defZoom.value === '') ? null : Number(defZoom.value);

                props.onLoad = onLoad.value;
                props.Copyright = copyright.value;

                props.MinViewX = isNaN(Number(minViewX.value)) ? null : Number(minViewX.value);
                props.MinViewY = isNaN(Number(minViewY.value)) ? null : Number(minViewY.value);
                props.MaxViewX = isNaN(Number(maxViewX.value)) ? null : Number(maxViewX.value);
                props.MaxViewY = isNaN(Number(maxViewY.value)) ? null : Number(maxViewY.value);
                props.MaxZoom  = isNaN(Number(maxZoom.value))  ? null : (Number(maxZoom.value) || null);
                props.MinZoom  = isNaN(Number(minZoom.value))  ? null : (Number(minZoom.value) || null);

                rawTree.properties = props;

                pluginsEditor.update();
            };

            tabMenu.closeFunc = function() {
                pluginsEditor.closeParamsDialogs();
            };

    		return tabMenu;
    	}
    	else
    	{
    		var shownProperties = [
                {name: _gtxt("Имя"), field: 'title', elem: title},
                {name: _gtxt("ID"), field: 'GroupID'}
            ].concat(visibilityPropertiesView);

    		return _div$1([_table([_tbody(addProperties(shownProperties))],[['css','width','100%']])],[['css','width','320px'], ['dir','className','propertiesTable']]);
    	}
    };

    var _groupEditorsHash = {};

    /** Создаёт диалог редактирование свойств группы. Есть проверка на создание дублирующих диалогов
     @param div {HTMLHNode} - элемент дерева, соответствующий редактируемой группе
    */
    var createGroupEditor = function(div)
    {
    	var elemProperties = div.gmxProperties.content.properties;

    	if (_groupEditorsHash[elemProperties.GroupID])
    		return;

    	var pos = nsGmx$1.Utils.getDialogPos(div, true, 140),
    		closeFunc = function()
    		{
    			delete _groupEditorsHash[elemProperties.GroupID];

    			return false;
    		};

    	var canvas = createGroupEditorProperties(div, false, _layersTree);
    	showDialog$1(_gtxt('Группа [value0]', elemProperties.title), canvas, 340, 230, pos.left, pos.top, null, closeFunc);
    	_groupEditorsHash[elemProperties.GroupID] = true;

    	canvas.parentNode.style.width = canvas.clientWidth + 'px';
    };

    window._mapEditorsHash = {};


    /** Создаёт диалог редактирование свойств группы. Есть проверка на создание дублирующих диалогов
     @param div {HTMLHNode} - элемент дерева, соответствующий редактируемой карте
    */
    var createMapEditor = function(div, activePage)
    {
    	var elemProperties = div.gmxProperties.properties;

    	if (_mapEditorsHash[elemProperties.MapID])
    		return;

    	var pos = nsGmx$1.Utils.getDialogPos(div, true, 530),
    		closeFunc = function()
    		{
    			delete _mapEditorsHash[elemProperties.MapID];
    			canvas.updateFunc();
                canvas.closeFunc();
    			return false;
    		};

    	var canvas = createGroupEditorProperties(div, true, _layersTree);
    	showDialog$1(_gtxt('Карта [value0]', elemProperties.title), canvas, 450, 410, pos.left, pos.top, null, closeFunc);
    	_mapEditorsHash[elemProperties.MapID] = {
            update: canvas.updateFunc
        };

    	$(canvas).tabs({active: activePage || 0});

    	canvas.parentNode.style.width = canvas.clientWidth + 'px';
    };

    gmxCore.addModule('GroupEditor', {
        addSubGroup: addSubGroup,
        createGroupEditor: createGroupEditor,
        createMapEditor: createMapEditor
    });

    })(nsGmx$1.Utils._);

    !(function(_) {
    /** Разнообразные вспомогательные контролы (базовые элементы GUI)
        @namespace nsGmx.Controls
    */
    nsGmx$1.Controls = {

    	/** Создаёт контрол выбора цвета */
    	createColorPicker: function(color, showFunc, hideFunc, changeFunc){
    		var colorPicker = _div(null, [['dir','className','colorSelector'], ['css','backgroundColor',nsGmx$1.Utils.convertColor(color)]]);

    		$(colorPicker).ColorPicker({
    			color: nsGmx$1.Utils.convertColor(color),
    			onShow: showFunc,
    			onHide: hideFunc,
    			onChange: changeFunc
    		});

    		_title(colorPicker, _gtxt("Цвет"));

    		return colorPicker;
    	},

    	/** Создаёт иконку по описанию стиля слоя и типа геометрии
        */
    	createGeometryIcon: function(parentStyle, type){
    		var icon = _div(null, [['css','display','inline-block'],['dir','className','colorIcon'],['attr','styleType','color'],/*['css','backgroundColor','#FFFFFF']*/]);
    		if (window.newStyles) {
    			if (type.indexOf('linestring') < 0) {
    				if (parentStyle.fill && parentStyle.fill.pattern) {
    					var opaqueStyle = L.gmxUtil.fromServerStyle($.extend(true, {}, parentStyle, {fill: {opacity: 100}})),
    						patternData = L.gmxUtil.getPatternIcon(null, opaqueStyle);
    					icon = patternData ? patternData.canvas : document.createElement('canvas');
    					_(icon, [], [['dir','className','icon'],['attr','styleType','icon'],['css','width','13px'],['css','height','13px']]);
    				} else {
    					var fill = _div(null, [['dir','className','fillIcon'],['css','backgroundColor', parentStyle.fillColor ? color2Hex(parentStyle.fillColor) : "#FFFFFF"]]),
    						fillOpacity = (typeof parentStyle.fillOpacity !== 'undefined') ? parentStyle.fillOpacity : 1,
    						border = _div(null, [['dir','className','borderIcon'],['attr','styleType','color'],['css','borderColor', parentStyle.color ? color2Hex(parentStyle.color) : "#0000FF"]]),
    						borderOpacity = (typeof parentStyle.opacity !== 'undefined') ? parentStyle.opacity : 1;


    					fill.style.opacity = fillOpacity;
    					border.style.opacity = borderOpacity;

    					if (type.indexOf('point') > -1) {

    						border.style.height = '5px';
    						fill.style.height = '5px';
    						border.style.width = '5px';
    						fill.style.width = '5px';

    						border.style.top = '3px';
    						fill.style.top = '4px';
    						border.style.left = '1px';
    						fill.style.left = '2px';
    					}

    					_(icon, [border, fill]);
    				}
    			} else {
    				var border = _div(null, [['dir','className','borderIcon'],['attr','styleType','color'],['css','borderColor', parentStyle.color ? color2Hex(parentStyle.color) : "#0000FF"]]),
    					borderOpacity = (parentStyle.opacity !== 'undefined') ? parentStyle.opacity : 1;

    				border.style.opacity = borderOpacity;

    				border.style.width = '4px';
    				border.style.height = '13px';

    				border.style.borderTop = 'none';
    				border.style.borderBottom = 'none';
    				border.style.borderLeft = 'none';

    				_(icon, [border]);
    			}
    		} else {
    			if (type.indexOf('linestring') < 0) {
    				if (parentStyle.fill && parentStyle.fill.pattern) {
    					var opaqueStyle = L.gmxUtil.fromServerStyle($.extend(true, {}, parentStyle, {fill: {opacity: 100}})),
    						patternData = L.gmxUtil.getPatternIcon(null, opaqueStyle);
    					icon = patternData ? patternData.canvas : document.createElement('canvas');
    					_(icon, [], [['dir','className','icon'],['attr','styleType','icon'],['css','width','13px'],['css','height','13px']]);
    				} else {
    					var fill = _div(null, [['dir','className','fillIcon'],['css','backgroundColor',(parentStyle.fill && typeof parentStyle.fill.color != 'undefined') ? nsGmx$1.Utils.convertColor(parentStyle.fill.color) : "#FFFFFF"]]),
    						border = _div(null, [['dir','className','borderIcon'],['attr','styleType','color'],['css','borderColor',(parentStyle.outline && typeof parentStyle.outline.color != 'undefined') ? nsGmx$1.Utils.convertColor(parentStyle.outline.color) : "#0000FF"]]),
    						fillOpacity = (parentStyle.fill && typeof parentStyle.fill.opacity != 'undefined') ? parentStyle.fill.opacity : 100,
    						borderOpacity = (parentStyle.outline && typeof parentStyle.outline.opacity != 'undefined') ? parentStyle.outline.opacity : 100;


    					fill.style.opacity = fillOpacity / 100;
    					border.style.opacity = borderOpacity / 100;

    					if (type.indexOf('point') > -1) {

    						border.style.height = '5px';
    						fill.style.height = '5px';
    						border.style.width = '5px';
    						fill.style.width = '5px';

    						border.style.top = '3px';
    						fill.style.top = '4px';
    						border.style.left = '1px';
    						fill.style.left = '2px';
    					}

    					_(icon, [border, fill]);
    				}
    			} else {
    				var border = _div(null, [['dir','className','borderIcon'],['attr','styleType','color'],['css','borderColor',(parentStyle.outline && typeof parentStyle.outline.color != 'undefined') ? nsGmx$1.Utils.convertColor(parentStyle.outline.color) : "#0000FF"]]),
    					borderOpacity = (parentStyle.outline && typeof parentStyle.outline.opacity != 'undefined') ? parentStyle.outline.opacity : 100;


    				border.style.opacity = borderOpacity / 100;

    				border.style.width = '4px';
    				border.style.height = '13px';

    				border.style.borderTop = 'none';
    				border.style.borderBottom = 'none';
    				border.style.borderLeft = 'none';

    				_(icon, [border]);
    			}
    		}

    		icon.oncontextmenu = function(e) {
    			return false;
    		};

    		return icon;

    		function color2Hex(color) {
    			if (typeof color === 'number') {
    				return nsGmx$1.Utils.convertColor(color);
    			} else if (typeof color === 'string') {
    				if ((color.indexOf('#') === -1)) {
    					return color2Hex(Number(color));
    				} else {
    					return color;
    				}
    			}
    		}
    	},

    	/** Создаёт контрол "слайдер".
        */
    	createSlider: function(opacity, changeFunc)	{
    		var divSlider = _div(null, [['css','width','86px'],['css','height','8px'],['css','border','1px solid #cdcdcd']]);

    		$(divSlider).slider(
    			{
    				min:0,
    				max:100,
    				step:1,
    				value: opacity,
    				slide: function(event, ui)
    				{
    					changeFunc(event, ui);

    					_title(divSlider.firstChild, ui.value);
    				}
    			});

    		divSlider.firstChild.style.zIndex = 1;

    		divSlider.style.width = '100px';
    		divSlider.style.border = 'none';
    		divSlider.style.backgroundImage = 'url(img/slider.png)';

    		divSlider.firstChild.style.border = 'none';
    		divSlider.firstChild.style.width = '12px';
    		divSlider.firstChild.style.height = '14px';
    		divSlider.firstChild.style.marginLeft = '-6px';

            divSlider.firstChild.style.top = '-3px';

    		divSlider.firstChild.style.background = 'transparent url(img/sliderIcon.png) no-repeat';

    		divSlider.firstChild.onmouseover = function()
    		{
    			divSlider.firstChild.style.backgroundImage = 'url(img/sliderIcon_a.png)';
    		};
    		divSlider.firstChild.onmouseout = function()
    		{
    			divSlider.firstChild.style.backgroundImage = 'url(img/sliderIcon.png)';
    		};

    		_title(divSlider.firstChild, opacity);
    		_title(divSlider, _gtxt("Прозрачность"));

    		return divSlider;
    	},

    	createInput: function(value, changeFunc){
    		var input = _input(null, [['dir','className','inputStyle'],['css','width','30px'],['attr','value',value]]);
    		input.onkeyup = changeFunc;
    		return input;
    	},

        /** Создаёт диалог, позволяющий выбрать пользователю один из нарисованных на карте объектов
         * @param {String} name Уникальный идентификатор диалога
         * @param {function(gmxAPI.DrawingObject)} callback Ф-ция, которая вызовется при выборе пользователем одного из объектов
         * @param {Object} [params] Дополнительные параметры диалога
         * @param {String} [params.title] Заголовок диалога
         * @param {String} [params.geomType=null] Ограничения на тип геометрии (POINT, LINESTRING, POLYGON). null - без ограничений
         * @param {String} [params.errorTitle] Заголовок диалога с ошибками (например, если нет объектов)
         * @param {String} [params.errorMessage] Текст диалога с ошибками (например, если нет объектов)
         * @param {Number} [params.width=250] Ширина диалога в пикселях
        */
        chooseDrawingBorderDialog: function(name, callback, params)
        {
            var TYPE_CONVERT_DICT = {
                Polyline: 'linestring',
                MultiPolyline: 'linestring',
                Rectangle: 'polygon',
                Polygon: 'polygon',
                MultiPolygon: 'polygon',
                Point: 'point'
            };
            var _params = $.extend({
                title:         _gtxt("Выбор контура"),
                geomType:      null,
                errorTitle:   _gtxt("$$phrase$$_12"),
                errorMessage: _gtxt("$$phrase$$_12"),
    			width:        250
            }, params);

            if ($('#drawingBorderDialog' + name).length)
                return;

            var drawingObjs = [];

            nsGmx$1.leafletMap.gmxDrawing.getFeatures().forEach(function(obj)
            {
                if (!_params.geomType || TYPE_CONVERT_DICT[obj.getType()] === _params.geomType.toLowerCase()) {
                    drawingObjs.push(obj);
                }
            });

            if (!drawingObjs.length)
                showErrorMessage(_params.errorMessage, true, _params.errorTitle);
            else
            {
                gmxCore.loadModule('DrawingObjects').done(function(drawing) {
                    var canvas = _div();
                    var collection = new drawing.DrawingObjectCollection(nsGmx$1.leafletMap);

                    for (var i = 0; i < drawingObjs.length; i++)
                    {
                        collection.Add(drawingObjs[i]);
                    }

                    var list = new drawing.DrawingObjectList(nsGmx$1.leafletMap, canvas, collection, {
                        allowDelete: false,
                        editStyle: false,
                        showButtons: false,
                        click: function(drawingObject) {
                            callback && callback(drawingObject);
                            removeDialog(jDialog);
                        }
                    });

                    var jDialog = nsGmx$1.Utils.showDialog(
                            _params.title,
                            _div([canvas], [['attr','id','drawingBorderDialog' + name],['dir','className','drawingObjectsCanvas']]),
                            {
                                width: _params.width,
                                height: 180
                            }
                        );
                });
            }
        },
        /**
         Создаёт виджет для управления видимостью (скрытия/показа) других элементов
         Сам виджет представляет из себя изменяющуюся иконку с текстом заголовка рядом с ней
         @class
         @param {String} title - текст заголовка
         @param {DOMElement} titleElem - элемент для размещения самого виджета
         @param {DOMElement|Array[]} managedElems - элементы, видимостью которых будем
         @param {Bool} isCollapsed - начальное состояние виджета
        */
        CollapsibleWidget: function(title, titleElem, managedElems, isCollapsed)
        {
            //var contentTr = _tr([_td([layerTagsParent], [['dir', 'colSpan', '2']])]);
            var collapseTagIcon = $('<div/>').addClass('collabsible-icon');
            var _isCollapsed = !!isCollapsed;

            managedElems = managedElems || [];
            if (!$.isArray(managedElems))
                managedElems = [managedElems];

            var updateElems = function()
            {
                for (var iE = 0; iE < managedElems.length; iE++)
                $(managedElems[iE]).toggle(!_isCollapsed);
            };

            var updateView = function()
            {
                collapseTagIcon
                    .toggleClass('collabsible-icon-hidden', _isCollapsed)
                    .toggleClass('collabsible-icon-shown', !_isCollapsed);
                updateElems();
            };

            updateView();

            $(titleElem).empty().append(
                collapseTagIcon,
                $('<div/>').addClass('collabsible-title').text(title)
            ).click(function()
            {
                _isCollapsed = !_isCollapsed;
                updateView();
            });

            this.addManagedElements = function(elems)
            {
                managedElems = managedElems.concat(elems);
                updateElems();
            };

            this.isCollapsed = function() { return _isCollapsed; };
        },

        /** Показывает аттрибутивную информацию объекта в виде таблички в отдельном диалоге */
        showLayerInfo: function(layer, obj)
        {
            var trs = [];
            var typeSpans = {};
            for (var key in obj.properties)
            {
                var content = _div(),
                    contentText = String(obj.properties[key]);

                if (contentText.indexOf("http://") == 0 || contentText.indexOf("https://") == 0 || contentText.indexOf("www.") == 0)
                    contentText = "<a href=\"" + contentText + "\" target=\"_blank\">" + contentText + "</a>";

                content.innerHTML = contentText;

                var typeSpan = _span([_t(key)]);

                typeSpans[key] = typeSpan;

                trs.push(_tr([_td([typeSpan], [['css','width','30%']]), _td([content], [['css','width','70%']])]));
            }

            var title = _span(null, [['dir','className','title'], ['css','cursor','default']]),
                summary = _span(null, [['dir','className','summary']]),
                div;

            if ($('#layerPropertiesInfo').length)
            {
                div = $('#layerPropertiesInfo')[0];

                if (!trs.length && !layer.properties.Legend)
                {
                    $(div.parentNode).dialog('close');

                    return;
                }

                $(div).empty();

                _(div, [_table([_tbody(trs)], [['dir','className','vectorInfoParams']])]);

                if (layer.properties.Legend)
                {
                    var legend = _div();

                    legend.innerHTML = layer.properties.Legend;

                    _(div, [legend]);
                }

                var dialogTitle = div.parentNode.parentNode.firstChild.firstChild;

                $(dialogTitle).empty();

                _(dialogTitle, [_t(_gtxt("Слой [value0]", layer.properties.title))]);

                $(div.parentNode).dialog('open');
            }
            else
            {
                if (!trs.length && !layer.properties.Legend)
                    return;

                div = _div([_table([_tbody(trs)], [['dir','className','vectorInfoParams']])], [['attr','id','layerPropertiesInfo']]);

                if (layer.properties.Legend)
                {
                    var legend = _div();

                    legend.innerHTML = layer.properties.Legend;

                    _(div, [legend]);
                }

                showDialog(_gtxt("Слой [value0]", layer.properties.title), div, 360, 'auto', false, false, null, function(){return true});

            }

            //подстраиваем ширину
            setTimeout(function()
            {
                var dialogDiv = $('#layerPropertiesInfo')[0].parentNode;
                var width = $(div).find('.vectorInfoParams').width();
                if (width > 340) {
                    $(dialogDiv).dialog('option', 'width', width + 18);
                }
            }, 100);

            nsGmx$1.TagMetaInfo.loadFromServer(function(tagInfo)
            {
                for (var key in typeSpans)
                {
                    if (tagInfo.isTag(key))
                        $(typeSpans[key]).attr('title', tagInfo.getTagDescription(key));
                }
            });
        }
    };

    gmxCore.addModule('Controls', nsGmx$1.Controls);

    })(nsGmx$1.Utils._);

    const _$2 = nsGmx$1.Utils._;

    /** Вспомогательные ф-ции ГеоМиксера
    @namespace _mapHelper
    */
    nsGmx$1.mapHelper = {

    };

    var mapHelp =
    {
    	mapHelp: {},
    	serviceHelp: {},
    	tabs: {},
    	externalMaps : {}
    };

    var mapHelper = function()
    {
    	this.builded = false;
        //this._treeView = false;

    	this.defaultStyles =
    	{
    		'point':{outline:{color:0x0000FF, thickness:1},marker:{size:8}, fill:{color:0xFFFFFF, opacity:20}},
    		'linestring':{outline:{color:0x0000FF, thickness:1}},
    		'polygon':{outline:{color:0x0000FF, thickness:1}, fill:{color:0xFFFFFF, opacity:20}}
    	};

    	this.defaultPhotoIconStyles = {
    		'point': {
    			marker: {
    				image: 'api/img/camera18.png',
    				center: true
    			}
    		}
    	};

    	this.stylesDialogsHash = {};
    	this.drawingDialogsHash = {};

    	this.layerEditorsHash = {};

    	this.layerStylesHash = {};

    	this.attrValues = {};

    	this.customErrorsHash = {
    		"Unable to locate EXIF content" : "Unable to locate EXIF content"
    	};

    	// контролирует пользовательские объекты, которые являются редактируемыми контурами растровых слоёв.
    	// все такие объекты не будут сериализоваться
    	this.drawingBorders = (function()
    	{
    		var _borders = {};

    		//не будем сериализовать все пользовательские объекты, являющиеся контурами слоёв, так как это временные объекты
    		nsGmx$1.DrawingObjectCustomControllers.addDelegate({
    			isSerializable: function(obj)
    			{
    				for (var name in _borders)
    					if (_borders[name] === obj)
    						return false;

    				return true;
    			}
    		});

    		return {
    			set: function(name, obj)
    			{
                    if (name in _borders) {
                        _borders[name].drawingFeature.off('edit', _borders[name].editListener);
                    }
                    var editListener = function() {
                        _borders[name].isChanged = true;
                    };

                    obj.on('edit', editListener);

    				_borders[name] = {
                        isChanged: !!_borders[name],
                        drawingFeature: obj,
                        editListener: editListener
                    };
    			},
    			get: function(name)
    			{
    				return _borders[name] && _borders[name].drawingFeature;
    			},
    			length: function()
    			{
    				return objLength$1(_borders);
    			},

    			//callback(name, obj)
    			forEach: function(callback)
    			{
    				for (var name in _borders)
    					callback(name, _borders[name].drawingFeature);
    			},

                isChanged: function(name) {
                    return !!_borders[name] && _borders[name].isChanged;
                },

    			updateBorder: function(name, span)
    			{
    				if (!_borders[name])
    					return;

                    var geom = _borders[name].drawingFeature.toGeoJSON().geometry,
                        areaStr = L.gmxUtil.prettifyArea(L.gmxUtil.geoArea(geom, false));

    				if (span)
    				{
    					_$2(span, [_t(areaStr)]);
    					return;
    				}

    				if (!$('#drawingBorderDescr' + name).length)
    					return;

    				$('#drawingBorderDescr' + name).empty();

    				_$2($('#drawingBorderDescr' + name)[0], [_t(areaStr)]);
    			},

    			//Удаляет объект из списка контуров слоя
    			//?removeDrawring {bool, default: false} - удалять ли сам пользовательский объект
    			removeRoute: function(name, removeDrawing)
    			{
    				if (!(name in _borders))
    					return;

                    _borders[name].drawingFeature.off('edit', _borders[name].editListener);

    				if (removeDrawing) {
    					nsGmx$1.leafletMap.gmxDrawing.remove(_borders[name].drawingFeature);
                    }

    				delete _borders[name];

    				$('#drawingBorderDescr' + name).empty();
    			}
    		}
    	})();

    	this.unsavedChanges = false;

    };

    mapHelper.prototype = new leftMenu$1();

    /** Менеджер кастомных параметров карты.
     * Содержит набор провайдеров доп. параметров, которые могут сохранять и загружать данные из хранилища параметров
     * Данные загружаются один раз. Возможна асинхронная загрузка данных/добавление провайдеров.
     * Порядок вызова провайдеров не определён.
     *
     * @memberOf _mapHelper
     * @name customParamsManager
     */
    mapHelper.prototype.customParamsManager = (function()
    {
    	var _providers = [];
    	var _params = []; //хранит параметры, которые не были загружены провайдерами

    	var loadProviderState = function( provider )
    	{
    		if ( provider.name in _params && typeof provider.loadState !== 'undefined')
    		{
    			provider.loadState( _params[ provider.name ] );
    			delete _params[ provider.name ];
    		}
    	};

    	return {
    		saveParams: function()
    		{
    			if ( !_providers.length ) return;
    			var params = {};
    			for (var p = 0; p < _providers.length; p++ )
    			{
    				if (typeof _providers[p].saveState !== 'undefined')
                        params[_providers[p].name] = _providers[p].saveState();
    			}

    			return params;
    		},
    		loadParams: function(params)
    		{
    			_params = params;
    			for (var p = 0; p < _providers.length; p++ )
    				loadProviderState( _providers[p] );
    		},

    		//интерфейс провайдера: name, saveState(), loadState(state)
    		addProvider: function(provider)
    		{
    			_providers.push( provider );
    			loadProviderState( provider );
    		},

            isProvider: function(providerName) {
                return !!nsGmx$1._.findWhere(_providers, {name: providerName});
            },
            removeProvider: function(providerName) {
                _providers = nsGmx$1._.filter(_providers, function(provider) {
                    return provider.name !== providerName;
                });
            }
    	}
    })();

    mapHelper.prototype.makeStyle = function(style)
    {
        style = style || {};
    	var givenStyle = {};

    	if (typeof style.RenderStyle != 'undefined')
    		givenStyle = style.RenderStyle;
    	else if (style.outline || style.marker)
    		givenStyle = style;
    	else
    	{
    		if (style.PointSize)
    			givenStyle.marker = { size: parseInt(style.PointSize) };
    		if (style.Icon)
    		{
    			var src = (style.Icon.indexOf("http://") != -1) || (style.Icon.indexOf("https://") != -1) ?
    				style.Icon :
    				(baseAddress + "/" + style.Icon);
    			givenStyle.marker = { image: src, center: true };
    		}
    		if (style.BorderColor || style.BorderWidth)
    			givenStyle.outline = {
    				color: parseColor(style.BorderColor),
    				thickness: parseInt(style.BorderWidth || "1")
    			};
    		if (style.FillColor)
    			givenStyle.fill = {
    				color: parseColor(style.FillColor),
    				opacity: 100 - parseInt(style.Transparency || "0")
    			};

    		var label = style.label || style.Label;
    		if (label)
    			givenStyle.label = {
    				field: label.FieldName,
    				color: parseColor(label.FontColor),
    				size: parseInt(label.FontSize || "12")
    			};
    	}

    	return givenStyle;
    };

    mapHelper.prototype.getMapStateAsPermalink = function(callback)
    {
        // сохраняем состояние карты
        var mapState = _mapHelper$1.getMapState();

        // туда же сохраним созданные объекты
        nsGmx$1.userObjectsManager.collect();
        mapState.userObjects = JSON.stringify(nsGmx$1.userObjectsManager.getData());

        nsGmx$1.Utils.TinyReference.create(mapState, true).then(callback);
    };

    mapHelper.prototype.reloadMap = function()
    {
        if (!nsGmx$1.gmxMap) {
            window.location.reload();
        }

        _mapHelper$1.getMapStateAsPermalink(function(permalinkID)
        {
            createCookie("TempPermalink", permalinkID);
            window.location.replace(window.location.href.split("?")[0] + "?permalink=" + permalinkID + (window.defaultMapID == globalMapName ? "" : ("&" + globalMapName)));
        });
    };

    mapHelper.prototype.updateUnloadEvent = function(flag)
    {
    	if (typeof flag != 'undefined')
    		this.unsavedChanges = flag;

    	if (this.unsavedChanges)
    	{
    		window.onbeforeunload = function(e)
    		{
    			return _gtxt("В дереве слоев остались несохраненные изменения!");
    		};
    	}
    	else
    		window.onbeforeunload = null;
    };

    mapHelper.prototype.setBalloon = function(filter, template)
    {
    	filter.enableHoverBalloon(function(o)
    	{
    		return template.replace(/\[([a-zA-Z0-9_а-яА-Я ]+)\]/g, function()
    		{
    			var key = arguments[1];
    			if (key == "SUMMARY")
    				return o.getGeometrySummary();
    			else
    				return o.properties[key];
    		});
    	});
    };

    mapHelper.prototype.updateMapStyles = function(newStyles, name)
    {
        var layer = nsGmx$1.gmxMap.layersByID[name],
            styles = newStyles.map(nsGmx$1.Utils.prepareGmxLayerStyle);

        layer.setStyles(styles);
    };

    //TODO: remove isEditableStyles
    mapHelper.prototype.updateTreeStyles = function(newStyles, div, treeView, isEditableStyles)
    {
        isEditableStyles = typeof isEditableStyles === 'undefined' || isEditableStyles;

    	if (window.newStyles) {
    		div.gmxProperties.content.properties.gmxStyles.styles = newStyles;
    	} else {
    		div.gmxProperties.content.properties.styles = newStyles;
    	}

    	var multiStyleParent = $(div).children('[multiStyle]')[0];

    	var parentIcon = $(div).children("[styleType]")[0],
    		newIcon = _mapHelper$1.createStylesEditorIcon(newStyles, div.gmxProperties.content.properties.GeometryType.toLowerCase(), {addTitle: isEditableStyles});

    	$(parentIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));

    	$(multiStyleParent).empty();

    	_mapHelper$1.createMultiStyle(div.gmxProperties.content.properties, treeView, multiStyleParent);
    };

    mapHelper.prototype.restoreTinyReference = function(id, callbackSuccess, errorCallback)
    {
    	window.suppressDefaultPermalink = true;
        nsGmx$1.Utils.TinyReference.get(id).then(function(obj) {
    		if (obj.position) {
                var latLngPos = L.Projection.Mercator.unproject(obj.position);
    			obj.position.x = latLngPos.lng;
    			obj.position.y = latLngPos.lat;
    			obj.position.z = 17 - obj.position.z;
    			if (obj.drawnObjects) {
    				for (var i in obj.drawnObjects) {
                        //эта двойная конвертация в действительности просто перевод координат из Меркатора в LatLng
    					obj.drawnObjects[i].geometry = L.gmxUtil.geoJSONtoGeometry(L.gmxUtil.geometryToGeoJSON(obj.drawnObjects[i].geometry, true));
    				}
                }
    		}
            obj.originalReference = id;
    		callbackSuccess(obj);
        }, errorCallback);
    };

    mapHelper.prototype.getMapState = function() {
        var lmap = nsGmx$1.leafletMap;

        if (!lmap) {
            return {};
        }

        var drawnObjects = [],
    		drawings = lmap.gmxDrawing.saveState(),
    		features = drawings.featureCollection.features;
            openPopups = {},
            condition = {expanded:{}, visible:{}},
    		LayersTreePermalinkParams = {},
    		mercCenter = L.Projection.Mercator.project(lmap.getCenter());

    		for (var i = 0; i < features.length; i++) {
    			if (features[i].properties.exportRect) {
    				features.splice(i, 1);
    			}
    		}

        lmap.gmxDrawing.getFeatures().forEach(function(feature) {
            if (!nsGmx$1.DrawingObjectCustomControllers.isSerializable(feature) || feature.options.exportRect) {
                return;
            }

            var geoJSON = feature.toGeoJSON();

            var elem = {
                properties: geoJSON.properties,
                geometry: L.gmxUtil.geoJSONtoGeometry(geoJSON, true)
            };

            if (elem.geometry.type !== "POINT") {
                var style = feature.getOptions().lineStyle;

                if (style) {
                    elem.thickness = style.weight || 2;
                    elem.color = style.color;
                    elem.opacity = (style.opacity || 0.8) * 100;
                }
            }

            if (lmap.hasLayer(feature.getPopup())) {
                elem.isBalloonVisible = true;
            }

            drawnObjects.push(elem);
        });

        for (var l in nsGmx$1.gmxMap.layersByID) {
            var layer = nsGmx$1.gmxMap.layersByID[l];

            if (layer.getPopups) {
                var popups = layer.getPopups();
                if (popups.length) {
                    openPopups[l] = popups;
                }
            }
        }

        this.findTreeElems(_layersTree.treeModel.getRawTree(), function(elem) {
            var props = elem.content.properties;
            if (elem.type == 'group') {
                var groupId = props.GroupID;

                if (!$("div[GroupID='" + groupId + "']").length && !props.changedByViewer)
                    return;

                condition.visible[groupId] = props.visible;
                condition.expanded[groupId] = props.expanded;
            } else {
                if (props.changedByViewer) {
                    condition.visible[props.name] = props.visible;
                }
            }
        });

    	// layers tree permalink params (without server)
    	this.findTreeElems(_layersTree.treeModel.getRawTree(), function(elem) {
    		var props = elem.content.properties,
    			id = elem.type == 'group' ? props.GroupID : props.LayerID;

    		if (props.permalinkParams) {
    			LayersTreePermalinkParams[id] = props.permalinkParams;
    		}
    	});

    	var dateIntervals = {};

    	for (var l in nsGmx$1.gmxMap.layersByID) {
    		var layer = nsGmx$1.gmxMap.layersByID[l];
    			props = layer.getGmxProperties(),
    			isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.setDateInterval);

    		if (isTemporalLayer && layer.getDateInterval) {
    			dateIntervals[props.LayerID] = layer.getDateInterval();
    		}
    	}

        return {
            mode: lmap.gmxBaseLayersManager.getCurrentID(),
            mapName: globalMapName,
            position: {
                x: mercCenter.x,
                y: mercCenter.y,
                z: 17 - lmap.getZoom()
            },
            mapStyles: this.getMapStyles(),
    		drawings: drawings,
    		drawnObjects: drawnObjects,
            isFullScreen: window.layersShown ? "false" : "true",
            condition: condition,
    		LayersTreePermalinkParams: LayersTreePermalinkParams,
            language: window.language,
    		customParamsCollection: this.customParamsManager.saveParams(),
    		dateIntervals: dateIntervals,
            openPopups: openPopups
        }
    };

    mapHelper.prototype.getMapStyles = function()
    {
    	var styles = {};

    	this.findChilds(_layersTree.treeModel.getRawTree(), function(child)
    	{
    		if (child.content.properties.type == "Vector" && $("div[LayerID='" + child.content.properties.LayerID + "']").length)
    			styles[child.content.properties.name] = child.content.properties.styles;
    	}, true);

    	return styles;
    };

    mapHelper.prototype.showPermalink = function()
    {
    	this.createPermalink(function(id){
            var url = window.location.protocol + "//" + window.location.host + window.location.pathname + "?permalink=" + id + (window.defaultMapID == globalMapName ? "" : ("&" + globalMapName));
            var input = _input(null, [['dir','className','inputStyle inputFullWidth'],['attr','value', url]]);

            showDialog$1(_gtxt("Ссылка на текущее состояние карты"), _div([input]), 311, 80, false, false);

            input.select();
        });
    };

    mapHelper.prototype.createExportPermalink = function(params, callback)
    {
    	var mapState = $.extend(this.getMapState(), params),
    		def = nsGmx$1.Utils.TinyReference.create(mapState, false);
        def.then(callback);
    	return def;
    };

    mapHelper.prototype.createPermalink = function(callback)
    {
    	var mapState = this.getMapState(),
            def = nsGmx$1.Utils.TinyReference.create(mapState, false);

        def.then(callback);
        return def;
    };

    mapHelper.prototype.updateTinyMCE = function(container) {
        gmxCore$1.loadModule('TinyMCELoader', window.location + '//' + window.location.host + window.location.pathname.replace('index.html', '') + 'TinyMCELoader.js', function() {
            $('.balloonEditor', container).each(function() {
                var id = $(this).attr('id');
                if (!tinyMCE.get(id)) {
                    tinyMCE.execCommand("mceAddControl", true, id);
                }
            });
        });
    };

    //event: selected(url)
    mapHelper.ImageSelectionWidget = Backbone.View.extend({
        tagName: 'span',
        className: 'gmx-icon-choose',
        events: {
            'click': function() {
                var imagesDir = nsGmx$1.AuthManager.getUserFolder() + 'images';
                    _this = this;
                sendCrossDomainJSONRequest(serverBase + 'FileBrowser/CreateFolder.ashx?WrapStyle=func&FullName=' + encodeURIComponent(imagesDir), function(response) {
                    if (!parseResponse(response))
                        return;

                    _fileBrowser.createBrowser(_gtxt("Изображение"), ['jpg', 'jpeg', 'png', 'gif', 'swf'], function(path) {
                        var relativePath = path.substring(imagesDir.length);
                        if (relativePath[0] == '\\') {
                            relativePath = relativePath.substring(1);
                        }

                        var url = serverBase + "GetImage.ashx?usr=" + encodeURIComponent(nsGmx$1.AuthManager.getLogin()) + "&img=" + encodeURIComponent(relativePath);

                        _this.trigger('selected', url);
                    }, {startDir: imagesDir, restrictDir: imagesDir});
                });
            }
        }
    });

    mapHelper.ImageInputControl = function(initURL) {
        var prevValue = initURL || '';
        var inputUrl = _input(null, [['dir','className','inputStyle'],['attr','value', prevValue], ['css','width','170px']]);
        _title$1(inputUrl, _gtxt('URL изображения'));

        var _this = this;

        var update = function() {
            if (inputUrl.value != prevValue) {
                prevValue = inputUrl.value;
                $(_this).change();
            }
        };

        var mainDiv = $('<div/>').append(inputUrl);
        inputUrl.onkeyup = inputUrl.change = update;

        if (nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_UPLOAD_FILES)) {
            var imageSelectionWidget = new mapHelper.ImageSelectionWidget();
            imageSelectionWidget.on('selected', function(url) {
                inputUrl.value = url;
                update();
            });

            mainDiv.append(imageSelectionWidget.el);
        }

        this.getControl = function()
        {
            return mainDiv[0];
        };

        this.value = function()
        {
            return inputUrl.value;
        };
    };

    //params:
    //  * addTitle {bool, default: true}
    mapHelper.prototype.createStylesEditorIcon = function(parentStyles, type, params) {
        var _params = $.extend({addTitle: true}, params);
    	var icon;

    	if ($.isArray(parentStyles) && parentStyles.length > 1) {
    		icon = _img(null, [['attr','src','img/misc.png'],['css','margin','0px 2px -3px 4px'],['css','cursor','pointer'],['attr','styleType','multi']]);
    	} else {
    		var parentStyle = _mapHelper$1.makeStyle(parentStyles[0]);
    		var iconUrlProp = window.newStyles ? parentStyle.iconUrl : parentStyle.marker && parentStyle.marker.image;
    		if (iconUrlProp) {
    			icon = _img(null, [['dir','className','icon'],['attr','styleType','icon']]);

    			var fixFunc = function() {
    				var width = this.width,
    					height = this.height,
    					scale;

    				if (width && height) {
    					var scaleX = 14.0 / width;
    					var scaleY = 14.0 / height;
    					scale = Math.min(scaleX, scaleY);
    				} else {
    					scale = 1;
    					width = height = 14;
    				}

    				setTimeout(function() {
    					icon.style.width = Math.round(width * scale) + 'px';
    					icon.style.height = Math.round(height * scale) + 'px';
    				}, 10);
    			};

    			icon.onload = fixFunc;
    			icon.src = iconUrlProp;
    		} else {
    			icon = nsGmx$1.Controls.createGeometryIcon(parentStyle, type);
    		}
    	}

        if (_params.addTitle)
            _title$1(icon, _gtxt("Редактировать стили"));

    	icon.geometryType = type;

    	return icon;
    };

    mapHelper.prototype.createLoadingLayerEditorProperties = function(div, parent, layerProperties, params) {
    	var elemProperties = div.gmxProperties.content.properties,
    		loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]),
            type = elemProperties.type;

        if (type == "Vector")
        {
            nsGmx$1.createLayerEditor(div, type, parent, layerProperties, params);

            return;
        }
        else
        {
            if (elemProperties.name)
            {
                _$2(parent, [loading]);

                sendCrossDomainJSONRequest(serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&LayerName=" + elemProperties.name, function(response)
                {
                    if (!parseResponse(response))
                        return;

                    loading.removeNode(true);

                    nsGmx$1.createLayerEditor(div, type, parent, response.Result, params);
                });
            }
        }
    };

    mapHelper.prototype.createNewLayer = function(type)
    {
    	if ($('#new' + type + 'Layer').length)
    		return;

    	var parent = _div(null, [['attr','id','new' + type + 'Layer'], ['css', 'height', '100%']]),
    		height = (type == 'Vector') ? 340 : 360;

        if (type !== 'Multi')
        {
    		var properties = {Title:'', Description: '', Date: '', TilePath: {Path:''}, ShapePath: {Path:''}};
            var dialogDiv = showDialog$1(type != 'Vector' ? _gtxt('Создать растровый слой') : _gtxt('Создать векторный слой'), parent, 340, height, false, false);
            nsGmx$1.createLayerEditor(false, type, parent, properties,
                {
                    doneCallback: function()
                    {
                        removeDialog(dialogDiv);
                    }
                }
            );
        }
        else
        { //мультислой
            nsGmx$1.createMultiLayerEditorNew( _layersTree );
        }
    };

    // перенос clipLayer из маплетов карты
    mapHelper.prototype.clipLayer = function(layer, props)
    {
    	var sw = L.latLng([props.MinViewY, props.MinViewX]),
    		nw = L.latLng([props.MaxViewY, props.MinViewX]),
    		ne = L.latLng([props.MaxViewY, props.MaxViewX]),
    		se = L.latLng([props.MinViewY, props.MaxViewX]),
    		clip = L.polygon([sw, nw, ne, se, sw]);

    	    layer.addClipPolygon(clip);
    };

    // Формирует набор элементов tr используя контролы из shownProperties.
    // Параметры:
    // - shownProperties: массив со следующими свойствами:
    //   * tr - если есть это свойство, то оно помещается в tr, все остальные игнорируются
    //   * name - названия свойства, которое будет писаться в левой колонке
    //   * elem - если есть, то в правую колонку помещается этот элемент
    //   * field - если нет "elem", в правый столбец подставляется layerProperties[field]
    //   * trid - id для DOM элементов. Не применяется, если прямо указано tr
    //   * trclass - class для DOM элементов. Не применяется, если прямо указано tr
    // - layerProperties - просто хеш строк для подстановки в правую колонку
    // - style:
    //   * leftWidth - ширина левой колонки в пикселях
    //   * leftcolumnclass - class для td элементов первого столбца. Не применяется, если прямо указано tr
    //   * rightcolumnclass - class для td элементов второго столбца. Не применяется, если прямо указано tr
    mapHelper.prototype.createPropertiesTable = function(shownProperties, layerProperties, style)
    {
    	var _styles = $.extend({leftWidth: 100}, style);
    	var trs = [];
    	for (var i = 0; i < shownProperties.length; i++)
    	{
    		var td;
    		if (typeof shownProperties[i].tr !== 'undefined')
    		{
    			trs.push(shownProperties[i].tr);
    			continue;
    		}

    		if (typeof shownProperties[i].elem !== 'undefined')
    			td = _td([shownProperties[i].elem]);
    		else
    			td = _td([_t(layerProperties[shownProperties[i].field] != null ? layerProperties[shownProperties[i].field] : '')],[['css','padding','0px 3px']]);

            var tdTitle = _td([_t(shownProperties[i].name)],[['css','width', _styles.leftWidth + 'px']]);

    		var tr = _tr([tdTitle, td]);

            _$2(tdTitle, [], [['dir', 'className', 'propertiesTable-title ' + (_styles.leftcolumnclass || '')]]);

            if (_styles.rightcolumnclass)
                _$2(td, [], [['dir', 'className', _styles.rightcolumnclass]]);

            if (shownProperties[i].trid)
                _$2(tr, [], [['attr', 'id', shownProperties[i].trid]]);

            if (shownProperties[i].trclass)
                _$2(tr, [], [['dir', 'className', shownProperties[i].trclass]]);

    		trs.push(tr);
    	}

    	return trs;
    };

    mapHelper.prototype.createLayerEditor = function(div, treeView, selected, openedStyleIndex)
    {
    	var elemProperties = div.gmxProperties.content.properties,
            layerName = elemProperties.name,
    		_this = this;

    	if (elemProperties.type == "Vector")
    	{
    		if (typeof this.layerEditorsHash[layerName] != 'undefined')
    		{
    			if (this.layerEditorsHash[layerName] != false) {
                    this.layerEditorsHash[layerName].selectTab(selected);
                }

    			return;
    		}

    		this.layerEditorsHash[layerName] = false;

    		var mapName = elemProperties.mapName,
    			createTabs = function(layerProperties)
    			{
    				var id = 'layertabs' + layerName,
    					divProperties = _div(null,[['attr','id','properties' + id], ['css', 'height', '100%']]),
    					additionalTabs = [];

    				var pos = nsGmx$1.Utils.getDialogPos(div, true, 390),
                        updateFunc = function()
                        {
                        },
    					closeFunc = function()
    					{
    						return false;
    					};

    				_this.createLoadingLayerEditorProperties(div, divProperties, layerProperties, {
                        doneCallback: function()
                        {
                            $(divDialog).dialog('close');
                        },
                        additionalTabs: additionalTabs,
                        selected: selected,
                        createdCallback: function(layerEditor) {
                            _this.layerEditorsHash[layerName] = layerEditor;
                            _this.layerEditorsHash[layerName].closeFunc = closeFunc;
                            _this.layerEditorsHash[layerName].updateFunc = updateFunc;
                        }
                    });

    				var divDialog = showDialog$1(_gtxt('Слой [value0]', elemProperties.title), divProperties, 350, 470, pos.left, pos.top, null, function()
                    {
                        delete _this.layerEditorsHash[layerName];
                    });

    				// при сохранении карты сбросим все временные стили в json карты
    				divProperties.closeFunc = closeFunc;
    				divProperties.updateFunc = updateFunc;
    			};

    		if (!this.attrValues[mapName])
    			this.attrValues[mapName] = {};

    		sendCrossDomainJSONRequest(serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + layerName, function(response)
    		{
    			if (!parseResponse(response))
    				return;

                var columns = response.Result.Columns;
                var attributesHash = {};

                for (var i = 0; i < columns.length; i++) {
                    attributesHash[columns[i].Name] = [];
                }

    			_this.attrValues[mapName][layerName] = new nsGmx$1.LazyAttributeValuesProviderFromServer(attributesHash, layerName);

    			createTabs(response.Result);
    		});
    	}
    	else if (elemProperties.type == "Raster")
    	{
    		if (elemProperties.LayerID)
    		{
    			if (this.layerEditorsHash[layerName])
    				return;

    			this.layerEditorsHash[layerName] = true;

    			var id = 'layertabs' + layerName,
    				divProperties = _div(null,[['attr','id','properties' + id], ['css', 'height', '100%']]),
    				divStyles = _div(null,[['attr','id','styles' + id], ['css', 'height', '100%'], ['css', 'overflowY', 'auto']]);

    			var layer = nsGmx$1.gmxMap.layersByID[layerName],
    				parentStyle = elemProperties.styles && elemProperties.styles[0] || elemProperties;

                var zoomPropertiesControl = new nsGmx$1.ZoomPropertiesControl(parentStyle.MinZoom, parentStyle.MaxZoom),
                    liMinZoom = zoomPropertiesControl.getMinLi(),
                    liMaxZoom = zoomPropertiesControl.getMaxLi();

                $(zoomPropertiesControl).change(function()
                {
                    layer.setZoomBounds(this.getMinZoom(), this.getMaxZoom());
                });

    			_$2(divStyles, [_ul([liMinZoom, liMaxZoom])]);

    			this.createLoadingLayerEditorProperties(div, divProperties, null, {
                    doneCallback: function()
                    {
                        $(divDialog).dialog('close');
                    },
                    additionalTabs: [{title: _gtxt("Стили"), name: 'styles', container: divStyles}]

                });

    			var pos = nsGmx$1.Utils.getDialogPos(div, true, 330),
    				closeFunc = function()
    				{
                        elemProperties.styles = elemProperties.styles || [];
                        elemProperties.styles[0] = elemProperties.styles[0] || {};

    					elemProperties.styles[0].MinZoom = zoomPropertiesControl.getMinZoom();
    					elemProperties.styles[0].MaxZoom = zoomPropertiesControl.getMaxZoom();

    					delete _this.layerEditorsHash[layerName];

    					treeView.findTreeElem(div).elem.content.properties = elemProperties;

    					_this.drawingBorders.removeRoute(layerName, true);

    					if ($('#drawingBorderDialog' + layerName).length)
    						removeDialog($('#drawingBorderDialog' + layerName)[0].parentNode);

    					return false;
    				};

    			var divDialog = showDialog$1(_gtxt('Слой [value0]', elemProperties.title), divProperties, 330, 410, pos.left, pos.top, null, closeFunc);
    		}
    		else
    		{
                nsGmx$1.createMultiLayerEditorServer(elemProperties, div, treeView);
            }
    	} else if (elemProperties.type == "Virtual"){
            var divProperties = _div(null,[['attr','id','properties' + id], ['css', 'height', '100%']]);

            this.createLoadingLayerEditorProperties(div, divProperties, null, {
                doneCallback: function() {
                    $(divDialog).dialog('close');
                }
            });

            var closeFunc = function() {
                delete _this.layerEditorsHash[layerName];
            };

            var pos = nsGmx$1.Utils.getDialogPos(div, true, 330);

            var divDialog = showDialog$1(_gtxt('Слой [value0]', elemProperties.title), divProperties, 330, 410, pos.left, pos.top, null);
        }
    };

    mapHelper.prototype.createWFSStylesEditor = function(parentObject, style, geometryType, divCanvas)
    {
    	var _this = this,
    		templateStyle = {};

    	$.extend(true, templateStyle, style);

        var elemCanvas = _mapHelper$1.createStylesEditorIcon([{MinZoom:1, MaxZoom: 21, RenderStyle: style.regularStyle}], geometryType);
        var spanIcon = _span([elemCanvas]);

    	spanIcon.onclick = function()
    	{
            var listenerId = parentObject.addListener('onSetStyle', function(style)
                {
                    var newIcon = _this.createStylesEditorIcon([{MinZoom:1,MaxZoom:21,RenderStyle:style.regularStyle}], geometryType);
                    $(spanIcon).empty().append(newIcon).attr('styleType', $(newIcon).attr('styleType'));
                });

    		var canvasStyles = _div(null,[['css','marginTop','10px']]),
    			canvasCharts = _div(null,[['css','marginTop','10px']]),
    			closeFunc = function()
    			{
    				$(canvasStyles).find(".colorSelector").each(function()
    				{
    					$('#' + $(this).data("colorpickerId")).remove();
    				});

    				var layerElemCanvas = $(divCanvas).find("[geometryType='" + geometryType.toUpperCase() + "']")[0];
    				layerElemCanvas.graphDataType = $(canvasCharts).find("select")[0].value;
    				layerElemCanvas.graphDataProperties = $(canvasCharts).find("input")[0].value;

                    parentObject.removeMapStateListener('onSetStyle', listenerId);
    			};

    		var id = 'wfstabs' + String(Math.random()).substring(2, 9),
    			tabMenu = _div([_ul([_li([_a([_t(_gtxt("Стили"))],[['attr','href','#styles' + id]])]),
    								 _li([_a([_t(_gtxt("Диаграммы"))],[['attr','href','#graph' + id]])])])]),
    			divStyles = _div(null,[['attr','id','styles' + id]]),
    			divGraph = _div(null,[['attr','id','graph' + id]]);

    		_$2(tabMenu, [divStyles, divGraph]);

            gmxCore$1.loadModule('LayerStylesEditor').done(function(module) {
                var resObject = module.createStyleEditor(canvasStyles, templateStyle, geometryType, false);

                $(resObject).change(function()
                {
                    nsGmx$1.Utils.setMapObjectStyle(parentObject, templateStyle);
                });
            });

    		canvasStyles.firstChild.style.marginLeft = '0px';
    		_$2(divStyles, [canvasStyles]);

    		_mapHelper$1.createChartsEditor(canvasCharts, $(divCanvas).find("[geometryType='" + geometryType.toUpperCase() + "']")[0]);
    		canvasCharts.firstChild.style.marginLeft = '0px';
    		_$2(divGraph, [canvasCharts]);

    		var pos = nsGmx$1.Utils.getDialogPos(spanIcon, false, 160);
    		showDialog$1(_gtxt('Редактирование стилей объекта'), tabMenu, 330, 180, pos.left, pos.top, false, closeFunc);

    		$(tabMenu).tabs({active: 0});
    	};

    	spanIcon.getStyle = function()
    	{
    		return templateStyle;
    	};

        return spanIcon;
    };

    mapHelper.prototype.createChartsEditor = function(parent, elemCanvas)
    {
    	var graphTypeSel = nsGmx$1.Utils._select([_option([_t(_gtxt("График по времени"))], [['attr','value','func']]),
    								_option([_t(_gtxt("Круговая"))], [['attr','value','pie']])], [['dir','className','selectStyle'],['css','width','180px']]),
    		propertiesMask = _input(null, [['dir','className','inputStyle'],['css','width','180px']]);

    	switchSelect(graphTypeSel, elemCanvas.graphDataType);
    	propertiesMask.value = elemCanvas.graphDataProperties;

    	_$2(parent, [_table([_tbody([_tr([_td([_t(_gtxt("Тип"))], [['css','width','100px']]), _td([graphTypeSel])]),
    								_tr([_td([_t(_gtxt("Маска атрибутов"))]), _td([propertiesMask])])])])]);
    };

    mapHelper.prototype.createMultiStyle = function(elem, treeView, multiStyleParent, treeviewFlag, layerManagerFlag)
    {
    	var filters = window.newStyles ? elem.gmxStyles.styles : elem.styles;

    	if (filters.length < 2)
    	{
    		multiStyleParent.style.display = 'none';

    		return;
    	}

    	multiStyleParent.style.display = '';

    	var ulFilters = _ul();

    	for (var i = 0; i < filters.length; i++) {
    		var checkbox = $('<input type="checkbox" class="multistlye-visibility-checkbox">'),
    		// var eye = $('<span class="multistyle-visibility-icon"><svg><use xlink:href="#transparency-eye"></use></svg></span>'),
    			icon = this.createStylesEditorIcon([filters[i]], elem.GeometryType.toLowerCase(), {addTitle: !layerManagerFlag}),
    			name = filters[i].Name || filters[i].Filter || 'Без имени ' + (i + 1),
                iconSpan = _span([icon]),
    			li = _li([_div([$(checkbox)[0], iconSpan, _span([_t(name)],[['css','marginLeft','3px']])])]);

            $(iconSpan).attr('styleType', $(icon).attr('styleType'));
    		$(checkbox).prop('checked', filters[i].MinZoom !== 25);

    		bindCheckboxHandler(checkbox, i);

    		if (!layerManagerFlag) {
    			(function(i) {
    				iconSpan.onclick = function() {
                        nsGmx$1.createStylesDialog(elem, treeView, i);
    					//_mapHelper.createLayerEditor(multiStyleParent.parentNode, treeView, 'styles', i);
    				};
    			})(i);
    		}

    		_$2(ulFilters, [li]);
    	}

    	function bindCheckboxHandler(checkbox, index) {
    		$(checkbox).on('change', function (e) {
    			var styleVisibilityProps = {
    				elem: elem,
    				styleIndex: index,
    				show: e.target.checked
    			};

    			$(_layersTree).triggerHandler('styleVisibilityChange', [styleVisibilityProps]);
    		});
    	}

    	ulFilters.style.display = 'none';
    	ulFilters.className = 'hiddenTree';

    	_$2(multiStyleParent, [_ul([_li([_div([_t(_gtxt("Стили слоя"))]), ulFilters])])]);

    	if (typeof treeviewFlag == 'undefined')
            $(multiStyleParent.firstChild).treeview();
    };

    mapHelper.prototype.load = function()
    {
    	var _this = this;

    	if (!this.builded)
    	{
    		var fileName;

    		if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.usageFilePrefix !== 'undefined')
    			fileName = window.gmxViewerUI.usageFilePrefix;
    		else
    			fileName = window.gmxJSHost ? window.gmxJSHost + "usageHelp" : "usageHelp";

    		fileName += _gtxt("helpPostfix");

    		_mapHelper$1._loadHelpTextFromFile(fileName, function( text )
    		{
    			var div = _div(null, [['dir','className','help']]);
    			div.innerHTML = text;
    			_$2(_this.workCanvas, [div]);
    		});

    		this.builded = true;
    	}
    };

    mapHelper.prototype._loadHelpTextFromFile = function( fileName, callback, num, data )
    {
    	var proceess = function( text ) {
    		callback(Handlebars.compile(text)({gmxVersion: num, gmxData: data}));
    	};

    	if (fileName.indexOf("http://") !== 0 || fileName.indexOf("https://") !== 0)
    		$.ajax({url: fileName, success: proceess});
    	else
    		sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(fileName), function(response)
    		{
    			proceess(response.Result);
    		});
    };

    mapHelper.prototype.version = function()
    {
        var div = $("<div class='gmx-about'></div>");

        var fileName;

        if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.helpFilePrefix !== 'undefined')
            fileName = window.gmxViewerUI.helpFilePrefix;
        else
            fileName = window.gmxJSHost ? window.gmxJSHost + "help" : "help";

        fileName += _gtxt("helpPostfix");

        _mapHelper$1._loadHelpTextFromFile( fileName, function(text)
        {
            div.html(text);
            showDialog$1(_gtxt("О проекте"), div[0], 500, 300, false, false);
        }, window.nsGmx.GeomixerFrameworkVersion, '' );
    };

    mapHelper.prototype.print = function() {
    	var centerControl = nsGmx$1.leafletMap.gmxControlsManager.get('center'),
    		map = nsGmx$1.leafletMap,
        	toggleMode = function(isPreviewMode) {
            	map.gmxControlsManager.get('hide').setActive(!isPreviewMode);
            	window.printMode = isPreviewMode;
            	$('#header, #leftMenu, #leftCollapser, #bottomContent, #tooltip, .ui-datepicker-div').toggleClass('print-preview-hide', isPreviewMode);
            	$('#all').toggleClass('print-preview-all', isPreviewMode);
    			$('.ui-dialog').toggle();
    			$('.leaflet-gmx-iconSvg-hide').toggle();
    			$('.leaflet-control-container').toggle();
        	};

        toggleMode(true);
    	centerControl.removeFrom ? centerControl.removeFrom(map) : centerControl.remove();

        var ui = $(Handlebars.compile('<div class="print-ui"><span class="print-ui-inner">' +
            '<button class="print-ui-close">Закрыть</button>' +
            '<button class="print-ui-print">Печать</button>' +
    			'<span class="layoutContainer">' +
    				'<label><input type="radio" name="layout" value="portrait" checked="true">' + _gtxt('портретная') + '</label>' +
    				'<label><input type="radio" name="layout" value="layout">' + _gtxt('альбомная') + '</label>' +
    			'</span>' +
    		'</span>' +
    		'</div>')());

    	var BIG = 1150,
    		SMALL = BIG / 1.4142;
    	var layout = {
    		width: SMALL + 'px',
    		height: BIG + 'px'
    	};

    	ui.find('input[value="portrait"]').click(function() {
    		this.checked = true;
    		layout.width = SMALL + 'px';
    		layout.height = BIG + 'px';

    		$('#flash').css({
    			width: layout.width,
    			height: layout.height
    		});

    	    map.invalidateSize();
    	});

    	ui.find('input[value="layout"]').click(function() {
    		this.checked = true;
    		layout.width = BIG + 'px';
    		layout.height = SMALL + 'px';

    		$('#flash').css({
    			width: layout.width,
    			height: layout.height
    		});

    	    map.invalidateSize();
    	});

    	ui.find('.print-ui-print').click(function() {
    		window.print();
    	});

        ui.find('.print-ui-close').click(function() {
            toggleMode(false);
    		centerControl.addTo(map);

            $('#flash').css({
                marginLeft: '0px',
                marginTop: '0px'
            });

            window.resizeAll();
            ui.remove();
        });

        $('body').append(ui);

        $('#flash').css({
    		top: '0px',
    		left: '0px',
    		width: layout.width,
    		height: layout.height
    	});

        map.invalidateSize();
    };

    // экспортный режим редактора
    mapHelper.prototype.exportMap = function(params) {
    	var map = nsGmx$1.leafletMap,
    		hide = map.gmxControlsManager.get('hide'),
    		center = map.gmxControlsManager.get('center');

    	hide.setActive(false);

    	center.removeFrom ? center.removeFrom(map) : center.remove();

        window.exportMode = true;

    	if (params.grid) {
    		if (!nsGmx$1.gridManager.gridControl) {
    			nsGmx$1.gridManager.setState({isActive: true});
    		}
    		var grid = nsGmx$1.gridManager.gridControl;

    		params.exportBounds && grid.setFixBounds(L.latLngBounds(params.exportBounds._southWest, params.exportBounds._northEast));

    	} else {
    		nsGmx$1.gridManager.setState(false);
    	}

        $('#header, #leftMenu, #leftCollapser, #bottomContent, #tooltip, .ui-datepicker-div').toggleClass('print-preview-hide', true);

        $('#all').toggleClass('print-preview-all', true);

    	if (params.controls) {
    		$('.gmx-slider-control').hide();
    		var cs = nsGmx$1.leafletMap.gmxControlsManager.getAll();
    		for (var key in cs) {
    			if (!(key in params.controls)) {
    				nsGmx$1.leafletMap.removeControl(cs[key]);
    			}
    		}
    	} else {
    		$('.leaflet-control-container').hide();
    	}

        $('#leftContent').mCustomScrollbar({live:"off"});

    	var exportCssParams = {
    		top: '0px',
    		left: '0px',
    		width: '100%',
    		height: '100%'
    	};

    	$('#flash').css(exportCssParams);
    	map.invalidateSize();
    };

    //вызывает callback для всех слоёв поддерева treeElem. Параметры: callback(layerInfo, visibilityFlag)
    mapHelper.prototype.findChilds = function(treeElem, callback, flag)
    {
    	var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;
    	if (childsArr)
    	{
    		for (var i = 0; i < childsArr.length; i++)
    		{
    			var child = childsArr[i];

    			if (child.type == 'group')
    				this.findChilds(child, callback, flag && child.content.properties.visible);
    			else
    				callback(child, flag && child.content.properties.visible);
    		}
    	}
    };

    mapHelper.prototype.findTreeElems = function(treeElem, callback, flag, list)
    {
    	var childsArr = treeElem.content ? treeElem.content.children : treeElem.children;

    	for (var i = 0; i < childsArr.length; i++)
    	{
    		var child = childsArr[i];

    		if (child.type == 'group')
    		{
    			callback(child, flag, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list, i);

    			this.findTreeElems(child, callback, flag && child.content.properties.visible, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list);
    		}
    		else
    			callback(child, flag, treeElem.content ? treeElem.content.properties.list : treeElem.properties.list, i);
    	}
    };

    /**
     *  Модифицирует объекты внутри векторного слоя, отправляя изменения на сервер и информируя об этом API
     *
     * @memberOf _mapHelper
     * @name modifyObjectLayer
     * @function
     * @param {String} layerName Имя слоя
     * @param {Object[]} objs Массив описания объектов. Каждое описание представляет из себя объект:
     *
     *  * id {String} ID объекта слоя, над которым производятся изменения (только для модификации и удаления)
     *  * geometry Описание геометрии (вставка и изменение). GeoJSON
     *  * source: {rc: <name КР-источника>, rcobj: <id объекта внутри КР>}
     *  * properties Свойства объекта (вставка и изменение)
     *  * action {'delete'|'insert'|'update'} Производимое действие. Если не указано, то вычисляется следующим образом:
     *    * Если не указан id, то вставка
     *    * Если указан id, то модифицируем
     *    * Для удаления объекта нужно явно прописать параметр
     * @param {String} [crs='EPSG:3395'] Название системы координат геометрии объектов. Поддерживаются 3395, 4326, 3857
     * @return {jQuery.Deferred} Ресолвится в соответствии с ответом сервера
    */
    mapHelper.prototype.modifyObjectLayer = function(layerName, objs, crs)
    {
        var def = $.Deferred();

        $.each(objs, function(i, obj)
        {
            obj.action = obj.action || (obj.id ? 'update' : 'insert');
        });
        var params = {
            WrapStyle: 'window',
            LayerName: layerName,
            objects: JSON.stringify(objs)
        };
        if (crs) {
            params.geometry_cs = crs;
        }
        sendCrossDomainPostRequest(serverBase + "VectorLayer/ModifyVectorObjects.ashx",
            params
            ,
            function(addResponse)
            {
    			if (!parseResponse(addResponse))
                {
                    def.reject();
                    return;
                }

                var mapLayer = nsGmx$1.gmxMap.layersByID[layerName];
                if (mapLayer) {
                    L.gmx.layersVersion.chkVersion(mapLayer);
                }
    			def.resolve();
            }
        );

        return def.promise();
    };

    /** Запросить с сервера объекты векторного слоя
     * @memberOf _mapHelper
     * @name searchObjectLayer
     * @function
     * @param {String} layerName ID векторного слоя
     * @param {Object} options Параметры запроса
     * @param {String} [options.query] SQL-подобное выражение для выборки объектов
     * @param {Boolean} [options.includeGeometry=false] Возвращать ли геометрию с сервера или нет
     * @param {Object} [options.border=null] GeoJSON для ограничения выборки по геометрии
     * @param {Number} [options.page=0] номер страницы результатов (0 - результаты с самого первого)
     * @param {Number} [options.pagesize=100000] максимальное кол-во объектов в ответе
     * @return {jQuery.Deferred} Promise, который ресолвится массивом найденных объектов. Каждый объект имеет свойства properties и, возможно, geometry
    */
    mapHelper.prototype.searchObjectLayer = function(layerName, options) {
        options = options || {};

        var def = $.Deferred();

        var requestParams = {
            WrapStyle: 'message',
            layer: layerName
        };

        if (options.query) {
            requestParams.query = options.query;
        }

        if (options.includeGeometry) {
            requestParams.geometry = true;
        }

        if (options.border) {
            requestParams.border = JSON.stringify(options.border);
        }

        requestParams.page = options.page || 0;
        requestParams.pagesize = options.pagesize || 100000;

        sendCrossDomainPostRequest(serverBase + "VectorLayer/Search.ashx", requestParams, function(response) {
            if (!parseResponse(response)) {
                def.reject(response);
                return;
            }
            var values = response.Result.values;
            var fields = response.Result.fields;
            var objects = [];
            for (var i = 0; i < values.length; i++) {
                var obj = {properties: {}};

                for (var p = 0; p < values[i].length; p++) {
                    if (fields[p] === 'geomixergeojson') {
                        obj.geometry = values[i][p];
                    } else {
                        obj.properties[fields[p]] = values[i][p];
                    }
                }
                objects.push(obj);
            }

            def.resolve(objects);
        });

        return def.promise();
    };

    /** Скачать векторный слой с сервера
     * @memberOf _mapHelper
     * @name downloadVectorLayer
     * @function
     * @param {Object} params Параметры запроса
     * @param {String} params.name ID векторного слоя, который нужно скачать
     * @param {String} params.host хост, с которого будем скачивать слой
     * @param {String} [params.format=Shape] В каком формате хотим получить (Shape, Tab, gpx, csv, csv_wkt, excel, kml или несколько через запятую)
     * @param {String} [params.query] SQL запрос для сохранения выборки данных вместо всех данных слоя
     * @param {Array} [params.columns] Атрибуты, которые нужно скачать. Массив объектов с ключами {Value, Alias}
    */
    mapHelper.prototype.downloadVectorLayer = function(params) {
        var requestParams = {
            t: params.name
        };

        if (params.format) {
            requestParams.format = params.format;
        }

        if (params.query) {
            requestParams.query = params.query;
        }

        if (params.columns) {
            requestParams.columns = JSON.stringify(params.columns);
        }

        sendCrossDomainPostRequest(window.location.protocol + "//" + params.host + "/" + "DownloadLayer.ashx", requestParams);


    	// if (window.FormData) {
    	//
    	// 	var form = document.createElement("form");
    	// 	form.style.display = 'none';
    	// 	form.setAttribute('enctype', 'multipart/form-data');
    	// 	form.name = 'uploadFile';
    	//
    	// 	var hiddenParamsDiv = document.createElement("div");
    	// 	hiddenParamsDiv.style.display = 'none';
    	//
    	// 	for (var paramName in requestParams) {
    	// 		var input = document.createElement("input");
    	// 		var value = typeof requestParams[paramName] !== 'undefined' ? requestParams[paramName] : '';
    	//
    	// 		input.setAttribute('type', 'hidden');
    	// 		input.setAttribute('name', paramName);
    	// 		input.setAttribute('value', value);
    	//
    	// 		hiddenParamsDiv.appendChild(input)
    	// 	}
    	//
    	//     form.appendChild(hiddenParamsDiv);
    	//
    	// 	var formData = new FormData(form);
    	//
    	//
    	// 	var xhr = new XMLHttpRequest();
    	// 	// :attachment; filename="suda_15062017_Sentinel_poly.zip";
    	// 	xhr.open('POST', /*"http://" + /*params.host*/ window.serverBase + /*"/" + */"DownloadLayer.ashx");
    	//
    	// 	// xhr.setRequestHeader('Content-Disposition', 'attachment');
    	// 	xhr.onload = function () {
    	// 		if (xhr.status === 200) {
    	// 			// var blob = new Blob([xhr.response], {type: "application/zip"});
    	// 			var blob = xhr.response;
    	// 			console.log(xhr);
    	// 			console.log(blob);
    	// 			saveData(blob, params.name);
    	// 		}
    	// 	}
    	//
    	// 	xhr.withCredentials = true;
    	// 	xhr.responseType = "blob";
    	// 	xhr.send(formData);
    	//
    	// 	function saveData(blob, name) {
    	// 		var url = window.URL.createObjectURL(blob),
    	// 		a = document.createElement("a");
    	// 		console.log(url);
    	// 		document.body.appendChild(a);
    	// 		a.style = "display: none";
    	// 		a.href = url;
    	// 		a.download = name;
    	// 		// a.click();
    	// 		window.URL.revokeObjectURL(url);
    	// 	};
    	// }
    };

    var _mapHelper$1 = new mapHelper();
    window._mapHelper = _mapHelper$1;
    window.mapHelper = mapHelper;

    mapHelp.mapHelp.load = function()
    {
    	var alreadyLoaded = _mapHelper$1.createWorkCanvas(arguments[0]);

    	if (!alreadyLoaded)
    		_mapHelper$1.load();
    };

    mapHelp.mapHelp.unload = function()
    {
    };

    mapHelp.serviceHelp.load = function()
    {
    	var alreadyLoaded = _serviceHelper.createWorkCanvas(arguments[0]);

    	if (!alreadyLoaded)
    		_serviceHelper.load();
    };
    mapHelp.serviceHelp.unload = function()
    {
    };

    var serviceHelper = function()
    {
    	this.builded = false;
    };

    serviceHelper.prototype = new leftMenu$1();

    serviceHelper.prototype.load = function()
    {
    	var _this = this;
    	if (!this.builded)
    	{
    		var fileName;

    		if (typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.servicesFilePrefix !== 'undefined')
    			fileName = window.gmxViewerUI.servicesFilePrefix;
    		else
    			fileName = window.gmxJSHost ? window.gmxJSHost + "servicesHelp" : "servicesHelp";

    		fileName += _gtxt("helpPostfix");

    		_mapHelper$1._loadHelpTextFromFile(fileName, function( text )
    		{
    			var div = _div(null, [['dir','className','help']]);
    			div.innerHTML = text;
    			_$2(_this.workCanvas, [div]);
    		});

    		this.builded = true;
    	}
    };

    var _serviceHelper = new serviceHelper();
    window._serviceHelper = _serviceHelper;

    mapHelp.tabs.load = function()
    {
    	var alreadyLoaded = _queryTabs.createWorkCanvas(arguments[0]);

    	if (!alreadyLoaded)
    		_queryTabs.load();
    };
    mapHelp.tabs.unload = function()
    {
    };

    mapHelp.externalMaps.load = function()
    {
    	var alreadyLoaded = _queryExternalMaps.createWorkCanvas(arguments[0]);

    	if (!alreadyLoaded)
    		_queryExternalMaps.load();
    };
    mapHelp.externalMaps.unload = function()
    {
    };

    //Динамически подгружаемые части вьюера

    //Редактирование мультислоя
    nsGmx$1.createMultiLayerEditorServer = gmxCore$1.createDeferredFunction('MultiLayerEditor', 'createMultiLayerEditorServer');
    nsGmx$1.createMultiLayerEditorNew = gmxCore$1.createDeferredFunction('MultiLayerEditor', 'createMultiLayerEditorNew');

    //Редактирование карты и группы
    nsGmx$1.addSubGroup = gmxCore$1.createDeferredFunction('GroupEditor', 'addSubGroup');
    nsGmx$1.createGroupEditor = gmxCore$1.createDeferredFunction('GroupEditor', 'createGroupEditor');
    nsGmx$1.createMapEditor = gmxCore$1.createDeferredFunction('GroupEditor', 'createMapEditor');

    //Редактирование свойств слоя
    nsGmx$1.createLayerEditor = gmxCore$1.createDeferredFunction('LayerEditor', 'createLayerEditor');

    //Редактирование стилей векторного слоя
    nsGmx$1.createStylesDialog = gmxCore$1.createDeferredFunction('LayerStylesEditor', 'createStylesDialog');

    //Библиотека стилей
    nsGmx$1.showStyleLibraryDialog = gmxCore$1.createDeferredFunction('StyleLibrary', 'showStyleLibraryDialog');

    /** Менеджер аудетификационной информации системы. Умеет запрашивать у сервера текущий статус пользователя,
     хранит информацию о ролях и допустимых действиях пользователей с этой ролью.
     @memberOf nsGmx
     @class
     @name AuthManager
    */

    (function($)
    {
        $.extend(nsGmx$1, {
            ROLE_ADMIN        : 'admin',
            ROLE_USER         : 'user',
            ROLE_GUEST        : 'guest',
            ROLE_UNAUTHORIZED : undefined,

            ACTION_CREATE_LAYERS        : 'createData',      // Создавать новые слои (векторные и растровые)
            ACTION_CREATE_MAP           : 'createMap',       // Cоздавать новые карты
            ACTION_SAVE_MAP             : 'saveMap',         // Сохранять карту (нужны права редактирования на карту)
            ACTION_CHANGE_MAP_TYPE      : 'changeType',      // Менять тип карты (публичная/открытая/закрытая и т.п.)
            ACTION_SEE_OPEN_MAP_LIST    : 'openMap',         // Видеть список публичных карт
            ACTION_SEE_PRIVATE_MAP_LIST : 'privateMap',      // Видеть спискок всех карт
            ACTION_SEE_MAP_RIGHTS       : 'seeRights',       // Видеть и редактировать права пользователей (для объектов, владельцем которых является)
            ACTION_SEE_FILE_STRUCTURE   : 'seeFiles',        // Видеть всю файловую структуру сервера, а не только свою дом. директорию
            ACTION_SEE_ALL_USERS        : 'seeUsers',        // Видеть список всех пользователей
            ACTION_SEE_USER_FULLNAME    : 'seeUserFullname', // Видеть полные имена и логины пользователей (а не только псевдонимы)
            ACTION_UPLOAD_FILES         : 'uploadFiles'      // Загружать файлы на сервер через web-интерфейс
        });

        var _actions = {};
        _actions[nsGmx$1.ROLE_ADMIN] = {};
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_CREATE_LAYERS       ] = true;
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_CREATE_MAP          ] = true;
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SAVE_MAP            ] = true;
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_OPEN_MAP_LIST   ] = true;
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_PRIVATE_MAP_LIST] = true;
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_CHANGE_MAP_TYPE     ] = true;
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_MAP_RIGHTS      ] = true;
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_FILE_STRUCTURE  ] = true;
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_ALL_USERS       ] = true;
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_SEE_USER_FULLNAME   ] = true;
        _actions[nsGmx$1.ROLE_ADMIN][nsGmx$1.ACTION_UPLOAD_FILES        ] = true;

        _actions[nsGmx$1.ROLE_USER] = {};
        _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_CREATE_LAYERS     ] = true;
        _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_CREATE_MAP        ] = true;
        _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_SAVE_MAP          ] = true;
        _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_SEE_OPEN_MAP_LIST ] = true;
        _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_SEE_MAP_RIGHTS    ] = true;
        _actions[nsGmx$1.ROLE_USER][nsGmx$1.ACTION_UPLOAD_FILES      ] = true;

        _actions[nsGmx$1.ROLE_GUEST] = {};
        _actions[nsGmx$1.ROLE_GUEST][nsGmx$1.ACTION_SEE_OPEN_MAP_LIST ] = true;
        _actions[nsGmx$1.ROLE_GUEST][nsGmx$1.ACTION_SAVE_MAP          ] = true;

        nsGmx$1.AuthManager = new function()
        {
            var _userInfo = null;
            var _this = this;

            this.getLogin = function()
            {
                if (!_userInfo) return null;
                return _userInfo.Login || null;
            };

            this.getNickname = function()
            {
                if (!_userInfo) return null;
                return _userInfo.Nickname || null;
            };

            this.getFullname = function()
            {
                if (!_userInfo) return null;
                return _userInfo.FullName || null;
            };

            this.getUserFolder = function()
            {
                if (!_userInfo) return null;
                return _userInfo.Folder;
            };

            this.isRole = function(role)
            {

                return _userInfo && _userInfo.Role === role;
            };

            this.canDoAction = function(action)
            {
                return _userInfo && _userInfo.Role in _actions && action in _actions[_userInfo.Role];
            };

            this.isAccounts = function()
            {
                return _userInfo && _userInfo.IsAccounts;
            };

            this.isLogin = function()
            {
                return _userInfo && _userInfo.Login !== false && _userInfo.Role !== this.ROLE_UNAUTHORIZED;
            };

            this.setUserInfo = function(userInfo)
            {
                _userInfo = $.extend({}, {IsAccounts: false, Role: this.ROLE_UNAUTHORIZED}, userInfo);
                $(this).triggerHandler('change');
            };

            this.checkUserInfo = function(callback, errorCallback)
            {
                //var isTokenUsed = false;
                var _processResponse = function( response )
                {
                    var resOk = parseResponse(response);

                    !resOk && errorCallback && errorCallback();

                    if (response.Result == null || !resOk)
                    {
                        // юзер не авторизован
                        _this.setUserInfo({Login: false});
                    }
                    else
                    {
                        _this.setUserInfo(response.Result);
                    }

                    resOk && callback && callback();
                };


                for (var iProvider = 0; iProvider < checkProviders.length; iProvider++)
                {
                    if (checkProviders[iProvider].canAuth())
                    {
                        checkProviders[iProvider].doAuth(callback, errorCallback);
                        return;
                    }
                }

                sendCrossDomainJSONRequest$1(serverBase + 'User/GetUserInfo.ashx?WrapStyle=func', function(response) {
                    if (response.Status === 'ok' && !response.Result && window.mapsSite && window.gmxAuthServer) {
                        var callbackPath = location.href.match(/(.*)\//)[0] + 'oAuthCallback.html';
                        nsGmx$1.Utils.login(callbackPath, serverBase + 'oAuth/', function(userInfo) {
                            _processResponse({Status: 'ok', Result: userInfo || null});
                        }, null, true);
                    } else {
                        doAuthServerLogin(response.Result && response.Result.Token);
                        _processResponse(response);
                    }
                });
            };

            this.login = function(login, password, callback, errorCallback)
            {
                sendCrossDomainPostRequest(serverBase + "Login.ashx", {WrapStyle: 'message', login: login, pass: password}, function(response)
                {
                    if (response.Status == 'ok' && response.Result)
                    {
                        _this.setUserInfo(response.Result);

                        doAuthServerLogin(response.Result && response.Result.Token);

                        callback && callback();
                    }
                    else
                    {
                        if (response.Status === 'auth' && ('Result' in response) && (typeof(response.Result) === 'object') && ('ExceptionType' in response.Result) && response.Result.ExceptionType.indexOf('System.ArgumentException') == 0)
                        {
                            errorCallback && errorCallback({emailWarning: true, message: response.Result.Message});
                        }
                        errorCallback && errorCallback({emailWarning: false});
                    }
                });
            };

            this.logout = function(callback)
            {
                sendCrossDomainJSONRequest$1(serverBase + "Logout.ashx?WrapStyle=func&WithoutRedirection=1", function(response)
                {
                    if (!parseResponse(response))
                        return;

                    if (_this.isAccounts() && window.gmxAuthServer)
                    {
                        sendCrossDomainJSONRequest$1(window.gmxAuthServer + "Handler/Logout", function(response)
                        {
                            //TODO: check result
                            _this.setUserInfo({Login: false});
                            callback && callback();
                        }, 'callback');
                    }
                    else
                    {
                        _this.setUserInfo({Login: false});
                        callback && callback();
                    }
                });
            };

            this.changePassword = function(oldPass, newPass, callback, errorCallback)
            {
                sendCrossDomainJSONRequest$1(serverBase + "ChangePassword.ashx?WrapStyle=func&old=" + encodeURIComponent(oldPass) + "&new=" + encodeURIComponent(newPass), function(response)
                {
                    if (response.Status == 'ok' && response.Result)
                        callback && callback();
                    else
                    {
                        var msg = response.ErrorInfo && typeof response.ErrorInfo.ErrorMessage != 'undefined' ? response.ErrorInfo.ErrorMessage : null;
                        errorCallback && errorCallback(msg);
                    }
                });
            };
        };

        var checkProviders = [];

        var doAuthServerLogin = function(token) {
            if (token && window.mapsSite && window.gmxAuthServer) {
                sendCrossDomainJSONRequest$1(gmxAuthServer + 'Handler/Me?token=' + encodeURIComponent(token), function(response) {
                    //console.log(response);
                }, 'callback');
            }
        };

        //canAuth() -> bool
        //doAuth(callbackSuccess, callbackError)
        nsGmx$1.AuthManager.addCheckUserMethod = function(provider)
        {
            checkProviders.push(provider);
        };
    })(jQuery);

    /** Менеджер дополнительных данных карты. Данные собираются и используются набором сборщиков данных, каждый из которых имеет свой уникальный id.
     @class userObjectsManager
     @memberOf nsGmx 
    */

    nsGmx$1.userObjectsManager = {
        _data: {},
        _collectors: {},
        
        /**
         Устанавливает данные, которые потом могут быть использованы поставщиками данных
    	 @method
        */
        setData: function(data) {
            this._data = data;
        },
        
        /**
         Возвращает собранные данные
    	 @method
        */
        getData: function() {
            return this._data;
        },
        
    	/**
    	 Собирает данные со всех сборщиков данных. Собранные данные доступны через метод getData
    	 @method
    	*/
        collect: function() {
            for (var id in this._collectors) {
                if ('collect' in this._collectors[id]) {
                    var data = this._collectors[id].collect();
                    if (data !== null) {
                        this._data[id] = data;
                    }
                }
            }
        },
        
        /**
    	 Вызывает метод load() у всех поставщиков данных, для которых есть данные.
         После вызова метода данные для данного загрузчика будут удалены (чтобы предотвратить множественную загрузку)
    	 @method
    	*/
        load: function(dataCollectorNames) {
            var collectors = {};
            
            if (dataCollectorNames)
            {
                if (typeof dataCollectorNames === 'string')
                    dataCollectorNames = [dataCollectorNames];

                for (var dc = 0; dc < dataCollectorNames.length; dc++)
                {
                    var name = dataCollectorNames[dc];
                    if (name in this._collectors)
                        collectors[name] = this._collectors[name];
                }
            }
            else
                collectors = this._collectors;
            
            for (var id in collectors) {
                if (id in this._data && 'load' in collectors[id])
                {
                    collectors[id].load(this._data[id]);
                    delete this._data[id];
                }
            }
        },
        
        /**
    	 Добавляет новый сборщик данных. Если в момент добавления есть какие-нибудь данные для загрузчика, они будут ему сразу же переданы
    	 @method
         @param collectorId {String} - уникальный идентификатор сборщика данных
         @param collector {Object} - сборщик данных. Должен иметь следующие методы:<br/>
             collect()->Object - возвращает собранные данные. Если данных нет, нужно вернуть null
             load(data)->void - передаёт существующие данные загрузчику
    	*/
        addDataCollector: function( collectorId, collector ) {
            this._collectors[collectorId] = collector;
            if (collectorId in this._data && 'load' in collector)
            {
                collector.load(this._data[collectorId]);
                delete this._data[collectorId];
            }
        }
    };

    nsGmx$1.GmxWidgetMixin = {
        getContainer: function() {
            return this.el || this._container;
        },
        appendTo: function(el) {
            el = el[0] || el;
            el.appendChild(this.getContainer());
        },
        show: function() {
            var el = this.getContainer();
            el.style.display = (this._previousStyleDisplayValue !== 'none' && this._previousStyleDisplayValue) || 'block';
            delete this._previousStyleDisplayValue;
        },
        hide: function() {
            var el = this.getContainer();
            this._previousStyleDisplayValue = el.style.display;
            el.style.display = 'none';
        },
        _terminateMouseEvents: function(el) {
            el = el || this.getContainer();
            L.DomEvent.disableClickPropagation(el);
            el.addEventListener('mousewheel', L.DomEvent.stopPropagation);
            el.addEventListener('mousemove', L.DomEvent.stopPropagation);
        }
    };

    nsGmx$1.GmxWidget = Backbone.View.extend(nsGmx$1.GmxWidgetMixin);

    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.DropdownMenuWidget = {};
    nsGmx$1.Templates.DropdownMenuWidget["dropdownMenuWidget"] = "<div class=\"dropdownMenuWidget ui-widget\">\n" +
        "    {{#each items}}\n" +
        "    <div class=\"dropdownMenuWidget-item{{#if className}} {{className}}{{/if}}\">\n" +
        "        <a\n" +
        "            {{#if id}}id=\"{{id}}\"{{/if}}\n" +
        "            {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" +
        "            {{#if newWindow}}{{#if link}}target=\"_blank\"{{/if}}{{/if}}\n" +
        "            class=\"dropdownMenuWidget-itemAnchor{{#if newWindow}} dropdownMenuWidget-itemAnchor_newWindow{{/if}}\"\n" +
        "        >\n" +
        "            {{#if icon}}\n" +
        "                <img src=\"{{icon}}\" />\n" +
        "            {{/if}}\n" +
        "            {{#if fonticon}}\n" +
        "                <i class=\"{{fonticon}}\"></i>\n" +
        "            {{/if}}\n" +
        "            {{#if title}}\n" +
        "                <span>{{title}}</span>\n" +
        "                {{#if dropdown}}<i class=\"icon-angle-down\"></i>{{/if}}\n" +
        "            {{/if}}\n" +
        "        </a>\n" +
        "        {{#if dropdown}}\n" +
        "            <div class=\"dropdownMenuWidget-itemDropdown\">\n" +
        "                <ul class=\"dropdownMenuWidget-dropdownMenu\">\n" +
        "                    {{#each dropdown}}\n" +
        "                        <li class=\"dropdownMenuWidget-dropdownMenuItem{{#if className}} {{className}}{{/if}}\">\n" +
        "                            {{#if newWindow}}<div class=\"ui-icon ui-icon-newwin dropdownMenuWidget-dropdownMenuIcon\"></div>{{/if}}\n" +
        "                            <a\n" +
        "                                {{#if id}}id=\"{{id}}\"{{/if}}\n" +
        "                                {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" +
        "                                {{#if newWindow}}{{#if link}}target=\"_blank\"{{/if}}{{/if}}\n" +
        "                                class=\"dropdownMenuWidget-dropdownItemAnchor{{#if newWindow}} dropdownMenuWidget-dropdownItemAnchor_newWindow{{/if}}\"\n" +
        "                            >\n" +
        "                                {{#if icon}}\n" +
        "                                    <img src=\"{{icon}}\" />\n" +
        "                                {{/if}}\n" +
        "                                {{#if title}}\n" +
        "                                    <span>{{title}}</span>\n" +
        "                                {{/if}}\n" +
        "                            </a>\n" +
        "                        </li>\n" +
        "                    {{/each}}\n" +
        "                </ul>\n" +
        "            </div>\n" +
        "        {{/if}}\n" +
        "    </div>\n" +
        "    {{/each}}\n" +
        "</div>\n" +
        "";
    nsGmx$1.Templates.DropdownMenuWidget["anchor"] = "<a \n" +
        "    {{#if id}}id=\"{{id}}\"{{/if}}\n" +
        "    {{#if link}}href=\"{{link}}\"{{else}}href=\"javascript:void(0)\"{{/if}}\n" +
        "    {{#if newWindow}}target=\"_blank\" class=\"dropdownMenuWidget-anchor_newWindow\"{{/if}}\n" +
        ">\n" +
        "    {{#if icon}}\n" +
        "        <img src=\"{{icon}}\" />\n" +
        "    {{/if}}\n" +
        "    {{#if title}}\n" +
        "        <span>{{title}}</span>\n" +
        "    {{/if}}\n" +
        "</a>";
    nsGmx$1.PlainTextWidget = nsGmx$1.GmxWidget.extend({
        initialize: function(txt) {
            this.setText(txt);
            this.$el.on('click', function () {
                this.trigger('click');
            }.bind(this));
        },
        getText: function () {
            return this.$el.html();
        },
        setText: function (txt) {
            this.$el.html(txt);
        }
    });

    // <String>options.title
    // <String>options.className
    // <String>options.trigger (hover|click|manual)
    // <String>options.direction (down|up)
    // <Boolean>options.adjustWidth
    // <Boolean>options.showTopItem
    nsGmx$1.DropdownWidget = nsGmx$1.GmxWidget.extend({
        className: 'dropdownWidget dropdownWidget-item',

        options: {
            title: '',
            trigger: 'hover',
            direction: 'down',
            adjustWidth: true,
            showTopItem: true,
            titleClassName: ''
        },

        initialize: function(options) {
            this.options = _.extend(this.options, options);
            this.$titleContainer = $('<div>')
                .addClass('dropdownWidget-dropdownTitle')
                .addClass(options.titleClassName)
                .html(this.options.title)
                .appendTo(this.$el);
            this.$dropdownContainer = $('<div>')
                .addClass('dropdownWidget-dropdown')
                .hide()
                .appendTo(this.$el);
            this.$dropdownTitle = $('<div>')
                .addClass('dropdownWidget-item dropdownWidget-dropdownTitle')
                .addClass(options.titleClassName)
                .html(this.options.title)
                .appendTo(this.$dropdownContainer);

            if (!this.options.showTopItem) {
                this.$dropdownTitle.hide();
            }

            if (this.options.trigger === 'hover') {
                this.$dropdownTitle.addClass('ui-state-disabled');
                this.$titleContainer.on('mouseover', function(je) {
                    this.expand();
                }.bind(this));
                this.$dropdownContainer.on('mouseleave', function(je) {
                    this.collapse();
                }.bind(this));
            } else if (this.options.trigger === 'click') {
                this.$titleContainer.on('click', function(je) {
                    this.expand();
                }.bind(this));
                this.$dropdownTitle.on('click', function(je) {
                    this.collapse();
                }.bind(this));
            }

            if (this.options.direction === 'up') {
                this.$el.addClass('dropdownWidget_direction-up');
            } else {
                this.$el.addClass('dropdownWidget_direction-down');
            }

            this._items = {};
        },

        addItem: function(id, inst, position) {
            this._items[id] = inst;
            var $container = $('<div>')
                .addClass('dropdownWidget-item dropdownWidget-dropdownItem')
                .attr('data-id', id)
                .attr('data-position', position)
                .on('click', function(je) {
                    this.trigger('item', $(je.currentTarget).attr('data-id'));
                    this.trigger('item:' + $(je.currentTarget).attr('data-id'));
                    if (this.options.trigger === 'click') {
                        this.collapse();
                    }
                }.bind(this));
            $container.append(inst.el);
            this.$dropdownContainer.append($container);
            this._sortItems();
        },

        setTitle: function(title) {
            this.$titleContainer.html(title);
            this.$dropdownTitle.html(title);
        },

        toggle: function() {
            this._expanded ? this.collapse() : this.expand();
            this._expanded = !this._expanded;
        },

        expand: function() {
            this.$dropdownContainer.css('min-width', this.$el.width());
            this.$dropdownContainer.show();
            this.trigger('expand');
        },

        collapse: function() {
            this.$dropdownContainer.hide();
            this.trigger('collapse');
        },

        reset: function() {
            this.collapse();
        },

        _sortItems: function() {
            var containerEl = this.$dropdownContainer[0];
            var items = Array.prototype.slice.call(containerEl.children);

            var titleEl = items.splice(
                items.indexOf($(containerEl).find('.dropdownWidget-dropdownTitle')[0]), 1
            );

            while (items.length) {
                var maxPositionIndex = items.indexOf(_.max(items, function(el) {
                    return el.getAttribute('data-position') / 1;
                }));
                $(containerEl).prepend(items.splice(maxPositionIndex, 1)[0]);
            }

            if (this.options.direction === 'up') {
                $(containerEl).append(titleEl);
            } else {
                $(containerEl).prepend(titleEl);
            }
        }
    });

    nsGmx$1.DropdownMenuWidget = (function() {
        var DropdownMenuWidget = function(options) {
            var h = Handlebars.create();
            h.registerPartial('anchor', nsGmx$1.Templates.DropdownMenuWidget.anchor);
            this._view = $(h.compile(nsGmx$1.Templates.DropdownMenuWidget.dropdownMenuWidget)({
                items: options.items
            }));
            this._view.find('.dropdownMenuWidget-itemDropdown').hide();

            var mouseTimeout = options.mouseTimeout || 100;
            this._view.find('.dropdownMenuWidget-item').each(function(index) {
                var mouseIsOver = false;
                $(this).on('mouseenter', function(je) {
                    mouseIsOver = true;
                    setTimeout(function() {
                        if (mouseIsOver) {
                            $(je.currentTarget).find('.dropdownMenuWidget-itemDropdown').show();
                        }
                    }, 100);
                });
                $(this).on('mouseleave', function(je) {
                    mouseIsOver = false;
                    $(je.currentTarget).find('.dropdownMenuWidget-itemDropdown').hide();
                });
            });
        };

        DropdownMenuWidget.prototype.appendTo = function(placeholder) {
            $(placeholder).append(this._view);
        };

        return DropdownMenuWidget;
    })();

    nsGmx$1.HeaderWidget = (function() {

        var SocialShareWidget = function(socials) {
            this._view = Handlebars.compile(nsGmx$1.Templates.HeaderWidget.socials)(socials);
        };

        SocialShareWidget.prototype.appendTo = function(placeholder) {
            $(placeholder).append(this._view);
        };

        var HeaderWidget = function(options) {
            var addDots = function(item) {
                if (!item.icon && !item.className) {
                    item.className = item.className + ' headerWidget-menuDot';
                }
                return item;
            };

            var h = Handlebars.create();
            this._view = $(h.compile(nsGmx$1.Templates.HeaderWidget.layout)(options));
            if (nsGmx$1.DropdownMenuWidget) {
                (new nsGmx$1.DropdownMenuWidget({
                    items: options.leftLinks && options.leftLinks.map(addDots)
                })).appendTo(this._view.find('.headerWidget-leftLinksContainer'));
                (new nsGmx$1.DropdownMenuWidget({
                    items: options.rightLinks && options.rightLinks.map(addDots)
                })).appendTo(this._view.find('.headerWidget-rightLinksContainer'));
            } else {
                console.warn('DropdownMenuWidget not found');
            }
            (new SocialShareWidget(options.socials)).appendTo(this._view.find('.headerWidget-socialsContainer'));
            this._view.find(".headerWidget-authContainer").hide();
            this._view.find(".headerWidget-menuContainer").hide();
            this._view.find(".headerWidget-searchContainer").hide();
            this._view.find(".headerWidget-languageContainer").hide();
            if (!options.socials) {
                this._view.find(".headerWidget-socialsContainer").hide();
            }
        };

        HeaderWidget.prototype.appendTo = function(placeholder) {
            $(placeholder).append(this._view);
        };

        HeaderWidget.prototype.getAuthPlaceholder = function() {
            return this._view.find(".headerWidget-authContainer").show();
        };

        HeaderWidget.prototype.getMenuPlaceholder = function() {
            return this._view.find(".headerWidget-menuContainer").show();
        };

        HeaderWidget.prototype.getSearchPlaceholder = function() {
            return this._view.find(".headerWidget-searchContainer").show();
        };

        HeaderWidget.prototype.getLanguagePlaceholder = function() {
            return this._view.find(".headerWidget-languageContainer").show();
        };

        HeaderWidget.prototype.getSocialsPlaceholder = function(first_argument) {
            return this._view.find(".headerWidget-socialsContainer");
        };

        return HeaderWidget;
    })();nsGmx$1.Translations.addText('rus', {
        header: {
            'langRu': 'Ru',
            'langEn': 'En'
        }
    });

    nsGmx$1.Translations.addText('eng', {
        header: {
            'langRu': 'Ru',
            'langEn': 'En'
        }
    });nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.HeaderWidget = {};
    nsGmx$1.Templates.HeaderWidget["layout"] = "<div class=\"headerWidget\">\n" +
        "    <div class=\"headerWidget-left\">\n" +
        "        <div class=\"headerWidget-logoContainer\">\n" +
        "            <img class=\"headerWidget-logo\" src=\"{{logo}}\" />\n" +
        "        </div>\n" +
        "    </div>\n" +
        "    <div class=\"headerWidget-right\">\n" +
        "        <div class=\"headerWidget-bar headerWidget-controlsBar\">\n" +
        "            <div class=\"headerWidget-barTable headerWidget-controlsBarTable\">\n" +
        "                <div class=\"headerWidget-barCell headerWidget-menuContainer\"></div>\n" +
        "                <div class=\"headerWidget-barCell headerWidget-authContainer\"></div>\n" +
        "                <div class=\"headerWidget-barCell headerWidget-languageContainer\"></div>\n" +
        "            </div>\n" +
        "        </div>\n" +
        "    </div>\n" +
        "</div>\n" +
        "";
    nsGmx$1.Templates.HeaderWidget["socials"] = "<div class=\"headerWidget-socialIcons\">\n" +
        "    {{#if vk}}\n" +
        "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{vk}}\" target=\"_blank\"><i class=\"icon-vk\"></i></a></div>\n" +
        "    {{/if}}\n" +
        "    {{#if facebook}}\n" +
        "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{facebook}}\" target=\"_blank\"><i class=\"icon-facebook\"></i></a></div>\n" +
        "    {{/if}}\n" +
        "    {{#if twitter}}\n" +
        "        <div class=\"headerWidget-socialIconCell\"><a href=\"{{twitter}}\" target=\"_blank\"><i class=\"icon-twitter\"></i></a></div>\n" +
        "    {{/if}}\n" +
        "</div>";

    nsGmx$1.LanguageWidget = (function() {
        
        var LanguageWidget = function(options) {
            this._view = $(Handlebars.compile(nsGmx$1.Templates.LanguageWidget.layout)({
                eng: nsGmx$1.Translations.getLanguage() === 'eng',
                rus: nsGmx$1.Translations.getLanguage() === 'rus'
            }));

            if (nsGmx$1.Translations.getLanguage() !== 'eng') {
                this._view.find('.languageWidget-item_eng').click(function() {
                    nsGmx$1.Translations.updateLanguageCookies('eng');
                    // присвоение url не работает, если есть #
                    window.location.reload(false);
                });
            }

            if (nsGmx$1.Translations.getLanguage() !== 'rus') {
                this._view.find('.languageWidget-item_rus').click(function() {
                    nsGmx$1.Translations.updateLanguageCookies('rus');
                    window.location.reload(false);
                });
            }
        };

        LanguageWidget.prototype.appendTo = function(placeholder) {
            $(placeholder).append(this._view);
        };

        return LanguageWidget;
    })();

    nsGmx$1.Templates = nsGmx$1.Templates || {};nsGmx$1.Templates.LanguageWidget = {};
    nsGmx$1.Templates.LanguageWidget["layout"] = "<div class=\"languageWidget ui-widget\">\n" +
        "    <div class=\"languageWidget-item languageWidget-item_rus\"><span class=\"{{^rus}}link languageWidget-link{{/rus}}{{#rus}}languageWidget-disabled{{/rus}}\">Ru</span></div>\n" +
        "    <div class=\"languageWidget-item languageWidget-item_eng\"><span class=\"{{^eng}}link languageWidget-link{{/eng}}{{#eng}}languageWidget-disabled{{/eng}}\">En</span></div>\n" +
        "</div>";

    function each(o, cb) {
        for (var p in o) {
            if (o.hasOwnProperty(p)) {
                cb(o[p], p, o);
            }
        }
    }

    function find(ar, cb) {
        if (ar.length) {
            for (var i = 0; i < ar.length; i++) {
                if (cb(ar[i])) {
                    return ar[i];
                }
            }
        } else {
            for (var p in ar) {
                if (ar.hasOwnProperty(p) && cb(ar[p])) {
                    return ar[p];
                }
            }
        }
    }

    function first(o) {
        for (var p in o) {
            if (o.hasOwnProperty(p)) {
                return o[p];
            }
        }
    }

    function length(o) {
        var length = 0;
        for (var p in o) {
            if (o.hasOwnProperty(p)) {
                length++;
            }
        }
        return length;
    }

    function prepend(parent, el) {
        if (parent.children.length) {
            parent.insertBefore(el, parent.children[0]);
        } else {
            parent.appendChild(el);
        }
    }

    var IconLayers = L.Control.extend({

        includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,
        _getActiveLayer: function() {
            if (this._activeLayerId) {
                return this._layers[this._activeLayerId];
            } else if (length(this._layers)) {
                return first(this._layers);
            } else {
                return null;
            }
        },
        _getPreviousLayer: function() {
            var activeLayer = this._getActiveLayer();
            if (!activeLayer) {
                return null;
            } else if (this._previousLayerId) {
                return this._layers[this._previousLayerId];
            } else {
                return find(this._layers, function(l) {
                    return l.id !== activeLayer.id;
                }.bind(this)) || null;
            }
        },
        _getInactiveLayers: function() {
            var ar = [];
            var activeLayerId = this._getActiveLayer() ? this._getActiveLayer().id : null;
            var previousLayerId = this._getPreviousLayer() ? this._getPreviousLayer().id : null;
            each(this._layers, function(l) {
                if ((l.id !== activeLayerId) && (l.id !== previousLayerId)) {
                    ar.push(l);
                }
            });
            return ar;
        },
        _arrangeLayers: function() {
            var behaviors = {};
            behaviors.previous = function() {
                var layers = this._getInactiveLayers();
                if (this._getActiveLayer()) {
                    layers.unshift(this._getActiveLayer());
                }
                if (this._getPreviousLayer()) {
                    layers.unshift(this._getPreviousLayer());
                }
                return layers;
            };
            return behaviors[this.options.behavior].apply(this, arguments);
        },
        _getLayerCellByLayerId: function(id) {
            var els = this._container.getElementsByClassName('leaflet-iconLayers-layerCell');
            for (var i = 0; i < els.length; i++) {
                if (els[i].getAttribute('data-layerid') == id) {
                    return els[i];
                }
            }
        },
        _createLayerElement: function(layerObj) {
            var el = L.DomUtil.create('div', 'leaflet-iconLayers-layer');
            if (layerObj.title) {
                var titleContainerEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitleContainer');
                var titleEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerTitle');
                var checkIconEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerCheckIcon');
                titleEl.innerHTML = layerObj.title;
                titleContainerEl.appendChild(titleEl);
                el.appendChild(titleContainerEl);
                el.appendChild(checkIconEl);
            }
            if (layerObj.icon) {
                el.setAttribute('style', 'background-image: url(\'' + layerObj.icon + '\')');
            }
            return el;
        },
        _createLayerElements: function() {
            var currentRow, layerCell;
            var layers = this._arrangeLayers();
            var activeLayerId = this._getActiveLayer() && this._getActiveLayer().id;

            for (var i = 0; i < layers.length; i++) {
                if (i % this.options.maxLayersInRow === 0) {
                    currentRow = L.DomUtil.create('div', 'leaflet-iconLayers-layersRow');
                    if (this.options.position.indexOf('bottom') === -1) {
                        this._container.appendChild(currentRow);
                    } else {
                        prepend(this._container, currentRow);
                    }
                }
                layerCell = L.DomUtil.create('div', 'leaflet-iconLayers-layerCell');
                layerCell.setAttribute('data-layerid', layers[i].id);
                if (i !== 0) {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_hidden');
                }
                if (layers[i].id === activeLayerId) {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_active');
                }
                if (this._expandDirection === 'left') {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandLeft');
                } else {
                    L.DomUtil.addClass(layerCell, 'leaflet-iconLayers-layerCell_expandRight');
                }
                layerCell.appendChild(this._createLayerElement(layers[i]));

                if (this.options.position.indexOf('right') === -1) {
                    currentRow.appendChild(layerCell);
                } else {
                    prepend(currentRow, layerCell);
                }
            }
        },
        _onLayerClick: function(e) {
            e.stopPropagation();
            var layerId = e.currentTarget.getAttribute('data-layerid');
            var layer = this._layers[layerId];
            this.setActiveLayer(layer.layer);
            this.expand();
        },
        _attachEvents: function() {
            each(this._layers, function(l) {
                var e = this._getLayerCellByLayerId(l.id);
                if (e) {
                    e.addEventListener('click', this._onLayerClick.bind(this));
                }
            }.bind(this));
            var layersRowCollection = this._container.getElementsByClassName('leaflet-iconLayers-layersRow');

            var onMouseEnter = function(e) {
                e.stopPropagation();
                this.expand();
            }.bind(this);

            var onMouseLeave = function(e) {
                e.stopPropagation();
                this.collapse();
            }.bind(this);

            var stopPropagation = function(e) {
                e.stopPropagation();
            };

            //TODO Don't make functions within a loop.
            for (var i = 0; i < layersRowCollection.length; i++) {
                var el = layersRowCollection[i];
                el.addEventListener('mouseenter', onMouseEnter);
                el.addEventListener('mouseleave', onMouseLeave);
                el.addEventListener('mousemove', stopPropagation);
            }
        },
        _render: function() {
            this._container.innerHTML = '';
            this._createLayerElements();
            this._attachEvents();
        },
        _switchMapLayers: function() {
            if (!this._map) {
                return;
            }
            var activeLayer = this._getActiveLayer();
            var previousLayer = this._getPreviousLayer();
            if (previousLayer) {
                this._map.removeLayer(previousLayer.layer);
            } else {
                each(this._layers, function(layerObject) {
                    var layer = layerObject.layer;
                    this._map.removeLayer(layer);
                }.bind(this));
            }
            if (activeLayer) {
                this._map.addLayer(activeLayer.layer);
            }
        },
        options: {
            position: 'bottomleft', // one of expanding directions depends on this
            behavior: 'previous', // may be 'previous', 'expanded' or 'first'
            expand: 'horizontal', // or 'vertical'
            autoZIndex: true, // from L.Control.Layers
            maxLayersInRow: 5,
            manageLayers: true
        },
        initialize: function(layers, options) {
            if (!L.Util.isArray(arguments[0])) {
                // first argument is options
                options = layers;
                layers = [];
            }
            L.setOptions(this, options);
            this._expandDirection = (this.options.position.indexOf('left') != -1) ? 'right' : 'left';
            if (this.options.manageLayers) {
                this.on('activelayerchange', this._switchMapLayers, this);
            }
            this.setLayers(layers);
        },
        onAdd: function(map) {
            this._container = L.DomUtil.create('div', 'leaflet-iconLayers');
            L.DomUtil.addClass(this._container, 'leaflet-iconLayers_' + this.options.position);
            this._render();
            map.on('click', this.collapse, this);
            if (this.options.manageLayers) {
                this._switchMapLayers();
            }
            return this._container;
        },
        onRemove: function(map) {
            map.off('click', this.collapse, this);
        },
        setLayers: function(layers) {
            this._layers = {};
            layers.map(function(layer) {
                var id = L.stamp(layer.layer);
                this._layers[id] = L.extend(layer, {
                    id: id
                });
            }.bind(this));
            if (this._container) {
                this._render();
            }
        },
        setActiveLayer: function(layer) {
            var l = layer && this._layers[L.stamp(layer)];
            if (!l || l.id === this._activeLayerId) {
                return;
            }
            this._previousLayerId = this._activeLayerId;
            this._activeLayerId = l.id;
            if (this._container) {
                this._render();
            }
            this.fire('activelayerchange', {
                layer: layer
            });
        },
        expand: function() {
            this._arrangeLayers().slice(1).map(function(l) {
                var el = this._getLayerCellByLayerId(l.id);
                L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_hidden');
            }.bind(this));
        },
        collapse: function() {
            this._arrangeLayers().slice(1).map(function(l) {
                var el = this._getLayerCellByLayerId(l.id);
                L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_hidden');
            }.bind(this));
        }
    });

    // var iconLayers = function(layers, options) {
    //     return new IconLayers(layers, options);
    // };

    // iconLayers.Constructor = IconLayers;

    // window.L.control.iconLayers = iconLayers;
    // window.L.Control.IconLayers = window.L.control.iconLayers.Constructor;

    window.L.Control.IconLayers = IconLayers;

    /* ========================================================================
     * Bootstrap: tooltip.js v3.3.1
     * http://getbootstrap.com/javascript/#tooltip
     * Inspired by the original jQuery.tipsy by Jason Frame
     * ========================================================================
     * Copyright 2011-2014 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */


    +function ($) {

      // TOOLTIP PUBLIC CLASS DEFINITION
      // ===============================

      var Tooltip = function (element, options) {
        this.type       =
        this.options    =
        this.enabled    =
        this.timeout    =
        this.hoverState =
        this.$element   = null;

        this.init('tooltip', element, options);
      };

      Tooltip.VERSION  = '3.3.1';

      Tooltip.TRANSITION_DURATION = 150;

      Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
          selector: 'body',
          padding: 0
        }
      };

      Tooltip.prototype.init = function (type, element, options) {
        this.enabled   = true;
        this.type      = type;
        this.$element  = $(element);
        this.options   = this.getOptions(options);
        this.$viewport = this.options.viewport && $(this.options.viewport.selector || this.options.viewport);

        var triggers = this.options.trigger.split(' ');

        for (var i = triggers.length; i--;) {
          var trigger = triggers[i];

          if (trigger == 'click') {
            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
          } else if (trigger != 'manual') {
            var eventIn  = trigger == 'hover' ? 'mouseenter' : 'focusin';
            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';

            this.$element.on(eventIn  + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
          }
        }

        this.options.selector ?
          (this._options = $.extend({}, this.options, { trigger: 'manual', selector: '' })) :
          this.fixTitle();
      };

      Tooltip.prototype.getDefaults = function () {
        return Tooltip.DEFAULTS
      };

      Tooltip.prototype.getOptions = function (options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);

        if (options.delay && typeof options.delay == 'number') {
          options.delay = {
            show: options.delay,
            hide: options.delay
          };
        }

        return options
      };

      Tooltip.prototype.getDelegateOptions = function () {
        var options  = {};
        var defaults = this.getDefaults();

        this._options && $.each(this._options, function (key, value) {
          if (defaults[key] != value) options[key] = value;
        });

        return options
      };

      Tooltip.prototype.enter = function (obj) {
        var self = obj instanceof this.constructor ?
          obj : $(obj.currentTarget).data('bs.' + this.type);

        if (self && self.$tip && self.$tip.is(':visible')) {
          self.hoverState = 'in';
          return
        }

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        clearTimeout(self.timeout);

        self.hoverState = 'in';

        if (!self.options.delay || !self.options.delay.show) return self.show()

        self.timeout = setTimeout(function () {
          if (self.hoverState == 'in') self.show();
        }, self.options.delay.show);
      };

      Tooltip.prototype.leave = function (obj) {
        var self = obj instanceof this.constructor ?
          obj : $(obj.currentTarget).data('bs.' + this.type);

        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }

        clearTimeout(self.timeout);

        self.hoverState = 'out';

        if (!self.options.delay || !self.options.delay.hide) return self.hide()

        self.timeout = setTimeout(function () {
          if (self.hoverState == 'out') self.hide();
        }, self.options.delay.hide);
      };

      Tooltip.prototype.show = function () {
        var that = this;
        if (this.hasContent() && this.enabled) {
          this._toBeShown = true;
          this._preloadImages().then(function() {
            if (that._toBeShown) {
              that.doShow();
            }
          });
        }
      };

      Tooltip.prototype._preloadImages = function() {
        var that = this;
        
        var $images = $('<div>').html(that.getContent()).find('img');
        var srcs = Array.prototype.slice.apply($images).map(function(el) {
          return el.src;
        });

        var promises = srcs.map(function(src) {
          return $.Deferred(function(def) {
            var img = new Image();
            img.addEventListener('load', function() {
              def.resolve();
            });
            img.addEventListener('error', function() {
              def.reject();
            });
            img.src = src;
          }).promise();
        });

        return $.when.apply(null, promises);
      };

      Tooltip.prototype.doShow = function () {
          var e = $.Event('show.bs.' + this.type);

          this.$element.trigger(e);

          var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
          if (e.isDefaultPrevented() || !inDom) return
          var that = this;

          var $tip = this.tip();

          var tipId = this.getUID(this.type);

          this.setContent();

          $tip.attr('id', tipId);
          this.$element.attr('aria-describedby', tipId);

          if (this.options.animation) $tip.addClass('fade');

          var placement = typeof this.options.placement == 'function' ?
            this.options.placement.call(this, $tip[0], this.$element[0]) :
            this.options.placement;

          var autoToken = /\s?auto?\s?/i;
          var autoPlace = autoToken.test(placement);
          if (autoPlace) placement = placement.replace(autoToken, '') || 'top';

          $tip
            .detach()
            .css({ top: 0, left: 0, display: 'block' })
            .addClass(placement)
            .data('bs.' + this.type, this);

          this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);

          var pos          = this.getPosition();
          var actualWidth  = $tip[0].offsetWidth;
          var actualHeight = $tip[0].offsetHeight;

          if (autoPlace) {
            var orgPlacement = placement;
            var $container   = this.options.container ? $(this.options.container) : this.$element.parent();
            var containerDim = this.getPosition($container);

            placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top'    :
                        placement == 'top'    && pos.top    - actualHeight < containerDim.top    ? 'bottom' :
                        placement == 'right'  && pos.right  + actualWidth  > containerDim.width  ? 'left'   :
                        placement == 'left'   && pos.left   - actualWidth  < containerDim.left   ? 'right'  :
                        placement;

            $tip
              .removeClass(orgPlacement)
              .addClass(placement);
          }

          var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);

          this.applyPlacement(calculatedOffset, placement);

          var complete = function () {
            var prevHoverState = that.hoverState;
            that.$element.trigger('shown.bs.' + that.type);
            that.hoverState = null;

            if (prevHoverState == 'out') that.leave(that);
          };

          $.support.transition && this.$tip.hasClass('fade') ?
            $tip
              .one('bsTransitionEnd', complete)
              .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
            complete();
      };

      Tooltip.prototype.applyPlacement = function (offset, placement) {
        var $tip   = this.tip();
        var width  = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;

        // manually read margins because getBoundingClientRect includes difference
        var marginTop = parseInt($tip.css('margin-top'), 10);
        var marginLeft = parseInt($tip.css('margin-left'), 10);

        // we must check for NaN for ie 8/9
        if (isNaN(marginTop))  marginTop  = 0;
        if (isNaN(marginLeft)) marginLeft = 0;

        offset.top  = offset.top  + marginTop;
        offset.left = offset.left + marginLeft;

        // $.fn.offset doesn't round pixel values
        // so we use setOffset directly with our own function B-0
        $.offset.setOffset($tip[0], $.extend({
          using: function (props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left)
            });
          }
        }, offset), 0);

        $tip.addClass('in');

        // check to see if placing tip in new offset caused the tip to resize itself
        var actualWidth  = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;

        if (placement == 'top' && actualHeight != height) {
          offset.top = offset.top + height - actualHeight;
        }

        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);

        if (delta.left) offset.left += delta.left;
        else offset.top += delta.top;

        var isVertical          = /top|bottom/.test(placement);
        var arrowDelta          = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';

        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
      };

      Tooltip.prototype.replaceArrow = function (delta, dimension, isHorizontal) {
        this.arrow()
          .css(isHorizontal ? 'left' : 'top', 50 * (1 - delta / dimension) + '%')
          .css(isHorizontal ? 'top' : 'left', '');
      };

      Tooltip.prototype.setContent = function () {
        var $tip  = this.tip();
        var title = this.getTitle();

        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
        $tip.removeClass('fade in top bottom left right');
      };

      Tooltip.prototype.hide = function (callback) {
        var that = this;
        var $tip = this.tip();
        var e    = $.Event('hide.bs.' + this.type);

        this._toBeShown = false;

        function complete() {
          if (that.hoverState != 'in') $tip.detach();
          that.$element
            .removeAttr('aria-describedby')
            .trigger('hidden.bs.' + that.type);
          callback && callback();
        }

        this.$element.trigger(e);

        if (e.isDefaultPrevented()) return

        $tip.removeClass('in');

        $.support.transition && this.$tip.hasClass('fade') ?
          $tip
            .one('bsTransitionEnd', complete)
            .emulateTransitionEnd(Tooltip.TRANSITION_DURATION) :
          complete();

        this.hoverState = null;

        return this
      };

      Tooltip.prototype.fixTitle = function () {
        var $e = this.$element;
        if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
        }
      };

      Tooltip.prototype.hasContent = function () {
        return this.getTitle()
      };

      Tooltip.prototype.getPosition = function ($element) {
        $element   = $element || this.$element;

        var el     = $element[0];
        var isBody = el.tagName == 'BODY';

        var elRect    = el.getBoundingClientRect();
        if (elRect.width == null) {
          // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
          elRect = $.extend({}, elRect, { width: elRect.right - elRect.left, height: elRect.bottom - elRect.top });
        }
        var elOffset  = isBody ? { top: 0, left: 0 } : $element.offset();
        var scroll    = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() };
        var outerDims = isBody ? { width: $(window).width(), height: $(window).height() } : null;

        return $.extend({}, elRect, scroll, outerDims, elOffset)
      };

      Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? { top: pos.top + pos.height,   left: pos.left + pos.width / 2 - actualWidth / 2  } :
               placement == 'top'    ? { top: pos.top - actualHeight, left: pos.left + pos.width / 2 - actualWidth / 2  } :
               placement == 'left'   ? { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left - actualWidth } :
            /* placement == 'right' */ { top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width   }

      };

      Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
        var delta = { top: 0, left: 0 };
        if (!this.$viewport) return delta

        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);

        if (/right|left/.test(placement)) {
          var topEdgeOffset    = pos.top - viewportPadding - viewportDimensions.scroll;
          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
          if (topEdgeOffset < viewportDimensions.top) { // top overflow
            delta.top = viewportDimensions.top - topEdgeOffset;
          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) { // bottom overflow
            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
          }
        } else {
          var leftEdgeOffset  = pos.left - viewportPadding;
          var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
          if (leftEdgeOffset < viewportDimensions.left) { // left overflow
            delta.left = viewportDimensions.left - leftEdgeOffset;
          } else if (rightEdgeOffset > viewportDimensions.width) { // right overflow
            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
          }
        }

        return delta
      };

      Tooltip.prototype.getTitle = function () {
        var title;
        var $e = this.$element;
        var o  = this.options;

        title = $e.attr('data-original-title')
          || (typeof o.title == 'function' ? o.title.call($e[0]) :  o.title);

        return title
      };

      Tooltip.prototype.getUID = function (prefix) {
        do prefix += ~~(Math.random() * 1000000);
        while (document.getElementById(prefix))
        return prefix
      };

      Tooltip.prototype.tip = function () {
        return (this.$tip = this.$tip || $(this.options.template))
      };

      Tooltip.prototype.arrow = function () {
        return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'))
      };

      Tooltip.prototype.enable = function () {
        this.enabled = true;
      };

      Tooltip.prototype.disable = function () {
        this.enabled = false;
      };

      Tooltip.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled;
      };

      Tooltip.prototype.toggle = function (e) {
        var self = this;
        if (e) {
          self = $(e.currentTarget).data('bs.' + this.type);
          if (!self) {
            self = new this.constructor(e.currentTarget, this.getDelegateOptions());
            $(e.currentTarget).data('bs.' + this.type, self);
          }
        }

        self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
      };

      Tooltip.prototype.destroy = function () {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function () {
          that.$element.off('.' + that.type).removeData('bs.' + that.type);
        });
      };


      // TOOLTIP PLUGIN DEFINITION
      // =========================

      function Plugin(option) {
        return this.each(function () {
          var $this    = $(this);
          var data     = $this.data('bs.tooltip');
          var options  = typeof option == 'object' && option;
          var selector = options && options.selector;

          if (!data && option == 'destroy') return
          if (selector) {
            if (!data) $this.data('bs.tooltip', (data = {}));
            if (!data[selector]) data[selector] = new Tooltip(this, options);
          } else {
            if (!data) $this.data('bs.tooltip', (data = new Tooltip(this, options)));
          }
          if (typeof option == 'string') data[option]();
        })
      }

      var old = $.fn.tooltip;

      $.fn.tooltip             = Plugin;
      $.fn.tooltip.Constructor = Tooltip;


      // TOOLTIP NO CONFLICT
      // ===================

      $.fn.tooltip.noConflict = function () {
        $.fn.tooltip = old;
        return this
      };

    }(jQuery);

    /* ========================================================================
     * Bootstrap: popover.js v3.3.1
     * http://getbootstrap.com/javascript/#popovers
     * ========================================================================
     * Copyright 2011-2014 Twitter, Inc.
     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
     * ======================================================================== */


    +function ($) {

      // POPOVER PUBLIC CLASS DEFINITION
      // ===============================

      var Popover = function (element, options) {
        this.init('popover', element, options);
      };

      if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js')

      Popover.VERSION  = '3.3.1';

      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      });


      // NOTE: POPOVER EXTENDS tooltip.js
      // ================================

      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);

      Popover.prototype.constructor = Popover;

      Popover.prototype.getDefaults = function () {
        return Popover.DEFAULTS
      };

      Popover.prototype.setContent = function () {
        var $tip    = this.tip();
        var title   = this.getTitle();
        var content = this.getContent();

        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
        $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
          this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
        ](content);

        $tip.removeClass('fade top bottom left right in');

        // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
        // this manually by checking the contents.
        if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();
      };

      Popover.prototype.hasContent = function () {
        return this.getTitle() || this.getContent()
      };

      Popover.prototype.getContent = function () {
        var $e = this.$element;
        var o  = this.options;

        return $e.attr('data-content')
          || (typeof o.content == 'function' ?
                o.content.call($e[0]) :
                o.content)
      };

      Popover.prototype.arrow = function () {
        return (this.$arrow = this.$arrow || this.tip().find('.arrow'))
      };

      Popover.prototype.tip = function () {
        if (!this.$tip) this.$tip = $(this.options.template);
        return this.$tip
      };


      // POPOVER PLUGIN DEFINITION
      // =========================

      function Plugin(option) {
        return this.each(function () {
          var $this    = $(this);
          var data     = $this.data('bs.popover');
          var options  = typeof option == 'object' && option;
          var selector = options && options.selector;

          if (!data && option == 'destroy') return
          if (selector) {
            if (!data) $this.data('bs.popover', (data = {}));
            if (!data[selector]) data[selector] = new Popover(this, options);
          } else {
            if (!data) $this.data('bs.popover', (data = new Popover(this, options)));
          }
          if (typeof option == 'string') data[option]();
        })
      }

      var old = $.fn.popover;

      $.fn.popover             = Plugin;
      $.fn.popover.Constructor = Popover;


      // POPOVER NO CONFLICT
      // ===================

      $.fn.popover.noConflict = function () {
        $.fn.popover = old;
        return this
      };

    }(jQuery);

    nsGmx$1.Translations.addText('rus', {
        gmxIconLayers: {
            zoominpls: 'Приблизьте карту, чтобы активировать слой',
            zoomoutpls: 'Отдалите карту, чтобы активировать слой'
        }
    });

    nsGmx$1.Translations.addText('eng', {
        gmxIconLayers: {
            zoominpls: 'Zoom in to enable layer',
            zoomoutpls: 'Zoom out to enable layer'
        }
    });

    window.L.Control.GmxIconLayers = window.L.Control.IconLayers.extend({
        _updateLayers: function() {
            var lang = nsGmx$1.Translations.getLanguage();
            lang = lang || 'rus';
            var blm = this._baseLayersManager;
            var layers = blm.getActiveIDs().map(function(id) {
                var layer = blm.get(id);
                if (!layer) {
                    return null;
                } else {
                    return {
                        layer: layer,
                        icon: layer.options.icon,
                        title: layer.options[lang]
                    }
                }
            }).filter(function(e) {
                return e;
            });

            this.setLayers(layers);
            this.setActiveLayer(
                blm.get(
                    blm.getCurrentID()
                )
            );

            this._updateDisabledLayers();
        },
        _updateDisabledLayers: function() {
            this._disabledLayerIds = this._map ? this._baseLayersManager.getActiveIDs().map(function(id) {
                return this._baseLayersManager.get(id);
            }.bind(this)).filter(function(l) {
                return !!l && (this._map.getZoom() < l.options.minZoom || this._map.getZoom() > l.options.maxZoom);
            }.bind(this)).map(function(l) {
                return L.stamp(l) + '';
            }) : [];
            this._updateDisabledLayersStyle();
        },
        _updateDisabledLayersStyle: function() {
            var els = this._container ? this._container.getElementsByClassName('leaflet-iconLayers-layerCell') : [];

            Array.prototype.slice.call(els).map(function(el) {
                var elId = el.getAttribute('data-layerid');
                if (this._disabledLayerIds.indexOf(elId) + 1) {
                    L.DomUtil.addClass(el, 'leaflet-iconLayers-layerCell_disabled');
                } else {
                    L.DomUtil.removeClass(el, 'leaflet-iconLayers-layerCell_disabled');
                }
            }.bind(this));
        },
        _updatePopoversContent: function() {
            var els = this._container ? this._container.getElementsByClassName('leaflet-iconLayers-layerCell') : [];

            var defaultTemplate = (new $.fn.popover.Constructor()).getDefaults().template;

            function createPopover(el, text) {
                $(el).popover({
                    viewport: {
                        selector: this._map && this._map.getContainer(),
                        padding: 10
                    },
                    container: this._map && this._map.getContainer(),
                    content: text,
                    trigger: 'manual',
                    placement: this.options.position.indexOf('bottom') != -1 ? 'top' : 'bottom',
                    html: true,
                    template: $(defaultTemplate).css('pointer-events', 'none')[0].outerHTML
                });
                if (el.mouseIsOver) {
                    $(el).popover('show');
                }
            }

            Array.prototype.slice.call(els).map(function(el) {
                var elId = el.getAttribute('data-layerid');
                var layerEl = el.getElementsByClassName('leaflet-iconLayers-layer')[0];
                var layer = this._layers[elId].layer;
                if (layer.options.maxZoom && this._map && this._map.getZoom() > layer.options.maxZoom) {
                    $(layerEl).popover('destroy');
                    createPopover.call(this, layerEl, nsGmx$1.Translations.getText('gmxIconLayers.zoomoutpls'));
                } else if (layer.options.minZoom && this._map && this._map.getZoom() < layer.options.minZoom) {
                    $(layerEl).popover('destroy');
                    createPopover.call(this, layerEl, nsGmx$1.Translations.getText('gmxIconLayers.zoominpls'));
                } else if (layer.options.description) {
                    $(layerEl).popover('destroy');
                    createPopover.call(this, layerEl, layer.options.description);
                } else {
                    $(layerEl).popover('destroy');
                }
            }.bind(this));
        },
        _createLayerElement: function(layerObj) {
            var layer = layerObj.layer;
            var el = L.Control.IconLayers.prototype._createLayerElement.call(this, layerObj);
            var shutterEl = L.DomUtil.create('div', 'leaflet-iconLayers-layerShutter');
            $(el).prepend(shutterEl);
            el.addEventListener('mouseover', function(e) {
                e.currentTarget.mouseIsOver = true;
                $(e.currentTarget).popover('show');
            });
            el.addEventListener('mouseout', function(e) {
                e.currentTarget.mouseIsOver = false;
                $(e.currentTarget).popover('hide');
            });
            return el;
        },
        _render: function() {
            L.Control.IconLayers.prototype._render.apply(this, arguments);
            this._updateDisabledLayers();
            this._updatePopoversContent();
        },
        _onLayerClick: function(e) {
            e.stopPropagation();
            $(e.currentTarget).find('.leaflet-iconLayers-layer').popover('hide');
            var layerId = e.currentTarget.getAttribute('data-layerid');
            if (this._disabledLayerIds.indexOf(layerId) === -1) {
                var layer = this._layers[layerId];
                this.setActiveLayer(layer.layer);
            }
            this.expand();
        },
        initialize: function(gmxBaseLayersManager, options) {
            L.Control.IconLayers.prototype.initialize.call(this, [], L.extend(options || {}, {
                manageLayers: false
            }));

            this._baseLayersManager = gmxBaseLayersManager;
            this._updateLayers();

            this.on('activelayerchange', function(le) {
                this._baseLayersManager.setCurrentID(le.layer.id);
            }.bind(this));

            this._baseLayersManager.on('baselayeradd', this._updateLayers.bind(this));
            this._baseLayersManager.on('baselayerremove', this._updateLayers.bind(this));
            this._baseLayersManager.on('baselayeractiveids', this._updateLayers.bind(this));
            this._baseLayersManager.on('baselayerchange', this._updateLayers.bind(this));
            this._baseLayersManager.on('baselayerlayerschange', this._updateLayers.bind(this));
        },
        onAdd: function() {
            var container = L.Control.IconLayers.prototype.onAdd.apply(this, arguments);
            this._map.on('zoomend', function() {
                this._updateDisabledLayers();
                this._updatePopoversContent();
            }.bind(this));
            return container;
        }
    });

    var DateInterval = Backbone.Model.extend({
        initialize: function() {
            if (!('dateBegin' in this.attributes) && !('dateEnd' in this.attributes)) {
                this.set(DateInterval.getUTCDayBoundary());
            }
        },

        saveState: function() {
            return {
                version: '1.1.0',
                dateBegin: +this.attributes.dateBegin,
                dateEnd: +this.attributes.dateEnd
            }
        },

        loadState: function(state) {
            if (!state.version || state.version === '1.1.0' || state.version === '1.0.0') {
                this.set({
                    dateBegin: new Date(state.dateBegin),
                    dateEnd: new Date(state.dateEnd)
                });
            } else {
                throw 'Unknown state version';
            }
        }
    }, {
        //number of milliseconds in one day
        MS_IN_DAY: 24*3600*1000,

        //set time to UTC midnight
        toMidnight: function(date) {
            return new Date(date - date % DateInterval.MS_IN_DAY);
        },

        getUTCDayBoundary: function(date) {
            date = date || new Date();

            var midnight = DateInterval.toMidnight(date);
            return {
                dateBegin: midnight,
                dateEnd: new Date(midnight.valueOf() + DateInterval.MS_IN_DAY)
            }
        },

        // 24+n interval
        defaultFireDateInterval: function() {
            var now = new Date(),
                lastMidnight = DateInterval.toMidnight(now),
                dateEnd = new Date((now - 1) - (now - 1) % (3600*1000) + 3600*1000), //round to the nearest hour greater then 'now'
                isTooSmall = dateEnd - lastMidnight < 12*3600*1000,
                dateBegin = new Date(isTooSmall ? (lastMidnight - nsGmx$1.DateInterval.MS_IN_DAY) : lastMidnight.valueOf());

            return {
                dateBegin: dateBegin,
                dateEnd: dateEnd
            }
        }
    });

    nsGmx$1.DateInterval = DateInterval;

    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.CalendarWidget = {};
    nsGmx$1.Templates.CalendarWidget["CalendarWidget"] = "<table>\n" +
        "    <tr>\n" +
        "        <td><div class = \"CalendarWidget-iconScrollLeft ui-helper-noselect icon-left-open\"></div></td>\n" +
        "        <td class = \"CalendarWidget-inputCell\"><input class = \"gmx-input-text CalendarWidget-dateBegin\"></td>\n" +
        "        <td class = \"CalendarWidget-inputCell CalendarWidget-onlyMaxVersion\"><input class = \"gmx-input-text CalendarWidget-dateEnd\"></td>\n" +
        "        <td><div class = \"CalendarWidget-iconScrollRight ui-helper-noselect icon-right-open\" ></div></td>\n" +
        "        <td><div class = \"CalendarWidget-iconMore {{moreIconClass}}\" title = \"{{moreIconTitle}}\"></div></td>\n" +
        "        <td><div class = \"CalendarWidget-forecast\" hidden>{{forecast}}</div></td>\n" +
        "    </tr><tr>\n" +
        "        <td></td>\n" +
        "        <td class = \"CalendarWidget-dateBeginInfo\"></td>\n" +
        "        <td class = \"CalendarWidget-dateEndInfo\"></td>\n" +
        "        <td></td>\n" +
        "        <td></td>\n" +
        "    </tr>\n" +
        "</table>\n" +
        "<div class=\"CalendarWidget-footer\"></div>\n" +
        "";

    (function($){

    var _gtxt = nsGmx$1.Translations.getText.bind(nsGmx$1.Translations),
        toMidnight = nsGmx$1.DateInterval.toMidnight;

    /** Параметры календаря
     * @typedef nsGmx.CalendarWidget~Parameters
     * @property {nsGmx.DateInterval} dateInterval Временной интервал, который нужно менять
     * @property {Date} [dateMin] минимальная граничная дата для календарей, null - без ограничений
     * @property {Date} [dateMax] максимальная граничная дата для календарей, null - без ограничений
     * @property {String} [dateFormat='dd.mm.yy'] формат даты
     * @property {bool} [minimized=true] показывать ли минимизированный или развёрнутый виджет в начале
     * @property {bool} [showSwitcher=true] показывать ли иконку для разворачивания/сворачивания периода
     * @property {Date} [dateBegin=<текущая дата>] начальная дата интервала
     * @property {Date} [dateEnd=<текущая дата>] конечная дата интервала
     * @property {String|DOMNode} [container] куда добавлять календарик
     * @property {String} [buttonImage] URL иконки для активации календариков
     */

    /** Контрол для задания диапазона дат. Даты календарика всегда в UTC, а не в текущем поясе.
     @description Виджет для выбора интервала дат. Пользователь при помощи datepicker'ов выбирает два дня (год, месяц, число),
                  затем выбранные значения при помощи ф-ции `_updateModel()` переводятся в интервал дат ({@link nsGmx.DateInterval}).
                  Так же виджет реагирует на изменения модели (с использованием ф-ции `_updateWidget()`)
     @alias nsGmx.CalendarWidget
     @extends nsGmx.GmxWidget
     @class
     @param {nsGmx.CalendarWidget~Parameters} options Параметры календаря
    */
    var Calendar = nsGmx$1.GmxWidget.extend({
        tagName: 'div',
        className: 'CalendarWidget ui-widget',
        template: Handlebars.compile(nsGmx$1.Templates.CalendarWidget.CalendarWidget),

        events: {
            'click .CalendarWidget-iconMore': 'toggleMode',
            'click .CalendarWidget-iconScrollLeft': function() {
                this._shiftDates(-1);
            },
            'click .CalendarWidget-iconScrollRight': function() {
                this._shiftDates(1);
            }
        },

        initialize: function(options) {
            options = $.extend({
                minimized: true,
                showSwitcher: true,
                dateMax: null,
                dateMin: null,
                dateFormat: 'dd.mm.yy',
                name: null
            }, options);

            this._dateMin = options.dateMin;
            this._dateMax = options.dateMax;

            this._dateInterval = options.dateInterval;

            this.$el.html(this.template({
                moreIconClass: options.minimized ? 'icon-calendar' : 'icon-calendar-empty',
                moreIconTitle: options.minimized ? _gtxt('CalendarWidget.ExtendedViewTitle') : _gtxt('CalendarWidget.MinimalViewTitle'),
                forecast: _gtxt('CalendarWidget.forecast')
            }));

            this._moreIcon = this.$('.CalendarWidget-iconMore')
                .toggle(!!options.showSwitcher);

            this._dateBegin = this.$('.CalendarWidget-dateBegin');
            this._dateEnd = this.$('.CalendarWidget-dateEnd');
            this._dateInputs = this._dateBegin.add(this._dateEnd);

            this._dateInputs.datepicker({
                onSelect: function(dateText, inst){
                    this._selectFunc(inst.input);
                    this._updateModel();
                }.bind(this),
                showAnim: 'fadeIn',
                changeMonth: true,
                changeYear: true,
                minDate: this._dateMin ? Calendar.toUTC(this._dateMin) : null,
                maxDate: this._dateMax ? Calendar.toUTC(this._dateMax) : null,
                dateFormat: options.dateFormat,
                defaultDate: Calendar.toUTC(this._dateMax || new Date()),
                showOn: options.buttonImage ? 'both' : 'focus',
                buttonImageOnly: true
            });

            //устанавливаем опцию после того, как добавили календарик в canvas
            if (options.buttonImage) {
                this._dateInputs.datepicker('option', 'buttonImage', options.buttonImage);
            }

            this.$('.CalendarWidget-onlyMaxVersion').toggle(!options.minimized);

            options.dateBegin && this._dateBegin.datepicker('setDate', Calendar.toUTC(options.dateBegin));
            options.dateEnd && this._dateEnd.datepicker('setDate', Calendar.toUTC(options.dateEnd));

            if (options.container) {
                if (typeof options.container === 'string')
                    $('#' + options.container).append(this.$el);
                else
                    $(options.container).append(this.$el);
            }

            this.setMode(options.minimized ? Calendar.SIMPLE_MODE : Calendar.ADVANCED_MODE);

            this._updateWidget();

            this._dateInterval.on('change', this._updateWidget, this);

            //for backward compatibility
            this.canvas = this.$el;
        },

        _shiftDates: function(delta) {
            var dateBegin = this.getDateBegin(),
                dateEnd = this.getDateEnd();

            if (!dateBegin || !dateEnd) {
                return;
            }

            var shift = (dateEnd - dateBegin + nsGmx$1.DateInterval.MS_IN_DAY) * delta,
                newDateBegin = new Date(dateBegin.valueOf() + shift),
                newDateEnd = new Date(dateEnd.valueOf() + shift);

            if ((!this._dateMin || toMidnight(this._dateMin) <= toMidnight(newDateBegin)) &&
                (!this._dateMax || toMidnight(this._dateMax) >= toMidnight(newDateEnd)))
            {
                this._dateBegin.datepicker('setDate', Calendar.toUTC(newDateBegin));
                this._dateEnd.datepicker('setDate', Calendar.toUTC(newDateEnd));

                this._updateModel();
            }
        },

        _selectFunc: function(activeInput) {
            var begin = this._dateBegin.datepicker('getDate');
            var end   = this._dateEnd.datepicker('getDate');

            if (end && begin && begin > end) {
                var dateToFix = activeInput[0] == this._dateEnd[0] ? this._dateBegin : this._dateEnd;
                dateToFix.datepicker('setDate', $(activeInput[0]).datepicker('getDate'));
            } else if (this._curMode === Calendar.SIMPLE_MODE) {
                //либо установлена только одна дата, либо две, но отличающиеся
                if (!begin != !end || begin && begin.valueOf() !== end.valueOf()) {
                    this._dateEnd.datepicker('setDate', this._dateBegin.datepicker('getDate'));
                }
            }
        },

        _updateModel: function() {
            var dateBegin = this.getDateBegin(),
                dateEnd = this.getDateEnd();

            this._dateInterval.set({
                dateBegin: dateBegin ? toMidnight(dateBegin) : null,
                dateEnd: dateEnd ? toMidnight(dateEnd.valueOf() + nsGmx$1.DateInterval.MS_IN_DAY) : null
            });
        },

        _updateWidget: function() {
            var dateBegin = this._dateInterval.get('dateBegin'),
                dateEnd = this._dateInterval.get('dateEnd'),
                dayms = nsGmx$1.DateInterval.MS_IN_DAY;

            if (!dateBegin || !dateEnd) {
                return;
            }
            var isValid = !(dateBegin % dayms) && !(dateEnd % dayms);

            var newDateBegin = Calendar.toUTC(dateBegin),
                newDateEnd;
            if (isValid) {
                newDateEnd = Calendar.toUTC(new Date(dateEnd - dayms));
                if (dateEnd - dateBegin > dayms) {
                    this.setMode(Calendar.ADVANCED_MODE);
                }
            } else {
                newDateEnd = Calendar.toUTC(dateEnd);
                this.setMode(Calendar.ADVANCED_MODE);
            }

            //если мы сюда пришли после выбора интервала в самом виджете, вызов setDate сохраняет фокус на input-поле
            //возможно, это какая-то проблема jQueryUI.datepicker'ов.
            //чтобы этого избежать, явно проверяем, нужно ли изменять дату
            var prevDateBegin = this._dateBegin.datepicker('getDate'),
                prevDateEnd = this._dateEnd.datepicker('getDate');

            if (!prevDateBegin || prevDateBegin.valueOf() !== newDateBegin.valueOf()) {
                this._dateBegin.datepicker('setDate', newDateBegin);
            }

            if (!prevDateEnd || prevDateEnd.valueOf() !== newDateEnd.valueOf()) {
                this._dateEnd.datepicker('setDate', newDateEnd);
            }
        },

        //public interface

        /** Закрыть все открытые datepicker'ы.
         * @return {nsGmx.CalendarWidget} this
         */
        reset: function() {
            this._dateInputs.datepicker('hide');
            return this;
        },

        /** Сериализация состояния виджета
         * @return {Object} Сериализованное состояние
         */
        saveState: function() {
            return {
                version: '1.1.0',
                vismode: this.getMode()
            }
        },

        /** Восстановить состояние виджета по сериализованным данным
         * @param {Object} data Сериализованное состояние календарика
         */
        loadState: function( data ) {
            this.setMode(data.vismode);
        },

        /** Получить начальную дату
         * @return {Date} начальная дата
         */
        getDateBegin: function() {
            return Calendar.fromUTC(this._dateBegin.datepicker('getDate'));
        },

        /** Получить конечную дату
         * @return {Date} конечная дата
         */
        getDateEnd: function() {
            return Calendar.fromUTC(this._dateEnd.datepicker('getDate'));
        },

        /** Получить верхнюю границу возможных дат периода
         * @return {Date} верхняя граница возможных периодов
         */
        getDateMax: function() {
            return this._dateMax;
        },

        /** Получить нижнуюю границу возможных дат периода
         * @return {Date} нижняя граница возможных периодов
         */
        getDateMin: function() {
            return this._dateMin;
        },

        /** Установить нижнуюю границу возможных дат периода
         * @param {Date} dateMin нижняя граница возможных периодов
         */
        setDateMin: function(dateMin) {
            this._dateMin = dateMin;
            this._dateInputs.datepicker('option', 'minDate', dateMin ? Calendar.toUTC(dateMin) : null);
        },

        /** Установить верхнюю границу возможных дат периода
         * @param {Date} dateMax верхняя граница возможных периодов
         */
        setDateMax: function(dateMax) {
            var titleContainer = this.$('.CalendarWidget-forecast');

            this._dateMax = dateMax;
            if (dateMax) {
                var utcDate = Calendar.toUTC(dateMax);
                this._dateInputs.datepicker('option', 'maxDate', utcDate);

                if (dateMax > new Date()) {
                    $(titleContainer).attr('title', _gtxt('CalendarWidget.tooltip') + ' ' +
                    ('0' + dateMax.getDate()).slice(-2) + '.' +
                    ('0' + (dateMax.getMonth() + 1)).slice(-2) + '.' +
                    dateMax.getFullYear());
                    $(titleContainer).show();
                } else {
                    $(titleContainer).hide();
                }

            } else {
                this._dateInputs.datepicker('option', 'maxDate', null);
            }
        },

        setSwitcherVisibility: function(isVisible) {
            this._moreIcon && this._moreIcon.toggle(isVisible);
        },

        getDateInterval: function() {
            return this._dateInterval;
        },

        getMode: function() {
            return this._curMode;
        },

        setMode: function(mode) {
            if (this._curMode === mode) {
                return this;
            }

            this.reset();

            this._curMode = mode;
            var isSimple = mode === Calendar.SIMPLE_MODE;

            this.$('.CalendarWidget-onlyMaxVersion').toggle(!isSimple);

            this._moreIcon
                .toggleClass('icon-calendar', isSimple)
                .toggleClass('icon-calendar-empty', !isSimple)
                .attr('title', isSimple ? _gtxt('CalendarWidget.ExtendedViewTitle') : _gtxt('CalendarWidget.MinimalViewTitle'));


            var dateBegin = this._dateBegin.datepicker('getDate'),
                dateEnd = this._dateEnd.datepicker('getDate');

            if (isSimple && dateBegin && dateEnd && dateBegin.valueOf() !== dateEnd.valueOf()) {
                this._selectFunc(this._dateEnd);
                this._updateModel();
            }

            this.trigger('modechange');

            return this;
        },

        toggleMode: function() {
            this.setMode(this._curMode === Calendar.SIMPLE_MODE ? Calendar.ADVANCED_MODE : Calendar.SIMPLE_MODE );
        }
    }, {
        /* static methods */
        fromUTC: function(date) {
            if (!date) return null;
            var timeOffset = date.getTimezoneOffset()*60*1000;
            return new Date(date.valueOf() - timeOffset);
        },
        toUTC: function(date) {
            if (!date) return null;
            var timeOffset = date.getTimezoneOffset()*60*1000;
            return new Date(date.valueOf() + timeOffset);
        },
        SIMPLE_MODE: 1,
        ADVANCED_MODE: 2
    });

    nsGmx$1.CalendarWidget = Calendar;

    })(jQuery);
    nsGmx$1.Translations.addText("rus", { CalendarWidget: {
        ExtendedViewTitle: "Выбор периода",
        MinimalViewTitle:  "Свернуть",
        UTC:               "Всемирное координированное время",
        forecast:           "прогноз",
        tooltip:            "доступны прогнозные данные до"
    }});

    nsGmx$1.Translations.addText("eng", { CalendarWidget: {
        ExtendedViewTitle: "Period selection",
        MinimalViewTitle:  "Minimize",
        UTC:               "Coordinated Universal Time",
        forecast:           "forecast",
        tooltip:            "forecast data is available up to"
    }});
    /** Контрол для задания диапазона дат с логикой работы, взятой с сайта fires.ru.
     @description Основное отличае в логине формировании интервала на основе выбранных в календариках дат.
                  Работает так же, как и обычный виджет ({@link nsGmx.CalendarWidget}) за исключением ситуации, когда dateEnd попадает в текущие UTC сутки.
                  В этом случае, dateEnd устанавливается равном началу следующего часа. Далее, если длина выбранного интервала меньше 12 часов, начало интервала смещается на сутки назад.
                  Кроме формирования интервала, этот виджет показывает пользователю дополнительную информацию о выбранном интервале.
     @alias nsGmx.FireCalendarWidget
     @class
     @param {nsGmx.CalendarWidget~Parameters} params Параметры календаря
    */

    (function($){

    var toMidnight = nsGmx$1.DateInterval.toMidnight;

    nsGmx$1.Translations.addText("rus", { FireCalendarWidget: {
        timeTitlePrefix : 'За ',
        timeTitleLastPrefix : 'За последние ',
        timeTitlePostfix : 'ч (UTC)'
    }});

    nsGmx$1.Translations.addText("eng", { FireCalendarWidget: {
        timeTitlePrefix : 'For ',
        timeTitleLastPrefix : 'For last ',
        timeTitlePostfix : 'h (UTC)'
    }});


    function f(n) {
        return n < 10 ? '0' + n : n;
    }

    function getStr (hours, minutes) {
        return f(hours) + ":" + f(minutes); /*+ ":" + f(time.seconds)*/
    }
    var FireCalendarWidget = nsGmx$1.CalendarWidget.extend({
        initialize: function(options) {
            options = $.extend({
                dateMax: new Date()
            }, options);

            nsGmx$1.CalendarWidget.prototype.initialize.call(this, options);

            this._dateInterval.on('change', this._updateInfo, this);
            this.on('modechange', this._updateInfo, this);
            this.on('modechange', this._updateModel, this);
            this._updateInfo();
        },

        _updateModel: function() {
            var dateBegin = this.getDateBegin(),
                origDateEnd = this.getDateEnd(),
                now = new Date(),
                lastMidnight = toMidnight(now),
                dateEnd;

            if (lastMidnight <= origDateEnd) {
                //last day
                dateEnd = new Date((now - 1) - (now - 1) % (3600*1000) + 3600*1000); //round to the nearest hour greater then 'now'

                if (dateEnd - toMidnight(dateBegin) < 12*3600*1000 && this.getMode() === nsGmx$1.CalendarWidget.SIMPLE_MODE) {
                    dateBegin = new Date(dateBegin - nsGmx$1.DateInterval.MS_IN_DAY);
                }
            } else {
                //previous days
                dateEnd = new Date(origDateEnd.valueOf() + nsGmx$1.DateInterval.MS_IN_DAY);
            }

            this._dateInterval.set({
                dateBegin: toMidnight(dateBegin),
                dateEnd: dateEnd
            });
        },

        _updateWidget: function() {
            var dateBegin = +this._dateInterval.get('dateBegin'),
                dateEnd = +this._dateInterval.get('dateEnd');

            if (!dateBegin || !dateEnd) {
                return;
            }
            var currentDayMode = toMidnight(new Date()) < dateEnd;

            if (currentDayMode && this.getMode() === nsGmx$1.CalendarWidget.SIMPLE_MODE && dateEnd - dateBegin < 2 * nsGmx$1.DateInterval.MS_IN_DAY) {
                this._dateBegin.datepicker("setDate", nsGmx$1.CalendarWidget.toUTC(new Date()));
                this._dateEnd.datepicker("setDate", nsGmx$1.CalendarWidget.toUTC(new Date()));
            } else if (nsGmx$1.CalendarWidget1) {
                nsGmx$1.CalendarWidget1.prototype._updateWidget.call(this);
            } else {
                nsGmx$1.CalendarWidget.prototype._updateWidget.call(this);
            }    },

        _updateInfo: function() {
            var isSimpleMode = this.getMode() === nsGmx$1.CalendarWidget.SIMPLE_MODE;

            this.$('.CalendarWidget-footer').toggle(isSimpleMode);
            this.$('.CalendarWidget-dateBeginInfo, .CalendarWidget-dateEndInfo').toggle(!isSimpleMode);

            var dateBegin = this._dateInterval.get('dateBegin'),
                dateEnd = this._dateInterval.get('dateEnd');

            if (!dateBegin || !dateEnd) {
                return;
            }

            var hours = Math.ceil((dateEnd - dateBegin)/3600000);

            if (isSimpleMode) {
                var hoursStr = hours > 24 ? "24+" + (hours-24) : hours;
                var prefix = hours === 24 ? _gtxt("FireCalendarWidget.timeTitlePrefix") : _gtxt("FireCalendarWidget.timeTitleLastPrefix");

                this.$('.CalendarWidget-footer').html(prefix + hoursStr + _gtxt("FireCalendarWidget.timeTitlePostfix"));
            } else {
                var dateEndToShow = (hours % 24) === 0 ? new Date(+dateEnd - 1) : dateEnd; //hack to show 23:59 instead of 00:00
                this.$('.CalendarWidget-dateBeginInfo').text(getStr(dateBegin.getUTCHours(), dateBegin.getUTCMinutes()) + " (UTC)").attr('title', _gtxt('CalendarWidget.UTC'));
                this.$('.CalendarWidget-dateEndInfo'  ).text(getStr(dateEndToShow.getUTCHours(), dateEndToShow.getUTCMinutes()) + " (UTC)").attr('title', _gtxt('CalendarWidget.UTC'));

            }
        }
    }, {
        defaultFireDateInterval: function() {
            var now = new Date(),
                lastMidnight = toMidnight(now),
                dateEnd = new Date((now - 1) - (now - 1) % (3600*1000) + 3600*1000), //round to the nearest hour greater then 'now'
                isTooSmall = dateEnd - lastMidnight < 12*3600*1000,
                dateBegin = new Date(isTooSmall ? (lastMidnight - nsGmx$1.DateInterval.MS_IN_DAY) : lastMidnight.valueOf());

            return {
                dateBegin: dateBegin,
                dateEnd: dateEnd
            }
        }
    });

    nsGmx$1.FireCalendarWidget = FireCalendarWidget;

    })(jQuery);

    (function($){

    var _gtxt = nsGmx$1.Translations.getText.bind(nsGmx$1.Translations),
        toMidnight = nsGmx$1.DateInterval.toMidnight;


        nsGmx$1.Translations.addText("rus", { CalendarWidget: {
            ShowIconTitle:     "Выбрать дату",
            createDateInterval: "Задать интервал",
            resetDateInterval:  "Сбросить интервал",
            selectDateInterval: "Применить",
            hour:               "ч.",
            from: "с",
            to: "до"
        }});

        nsGmx$1.Translations.addText("eng", { CalendarWidget: {
            ShowIconTitle:     "Select date",
            createDateInterval: "Create date interval",
            resetDateInterval:  "Reset date interval",
            selectDateInterval: "Select date interval",
            hour:               "h.",
            from: "from",
            to: "to"
        }});

        var template = '' +
            '<div>' +
                '<div class = "CalendarWidget-row CalendarWidget-dates">' +
                    // dates block
                    '<span class = "CalendarWidget-iconScrollLeft icon-left-open"></span>' +
                    '<span class = "CalendarWidget-dates-outside">' +
                        '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputBegin">' +
                        '<input class = "CalendarWidget-dateBegin">' +
                        '</span>' +
                        '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputMiddle">-</span>' +
                        '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputEnd">' +
                        '<input class = "CalendarWidget-dateEnd">' +
                        '</span>' +
                    '</span>' +
                    '<span class = "CalendarWidget-iconScrollRight ui-helper-noselect icon-right-open"></span>' +
                    // space between dates and time
                    '<span class = "CalendarWidget-space"></span>' +
                    // times block
                    '<span class = "CalendarWidget-timeicon"><img src="img/time-icon-01.svg"></img></span>' +
                    '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputTimeBegin"><input class = "CalendarWidget-timeInput CalendarWidget-timeBegin" value={{hourBegin}} ></span>' +
                    '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputMiddle CalendarWidget-inputCell-inputTimeMiddle">-</span>' +
                    '<span class = "CalendarWidget-inputCell CalendarWidget-inputCell-inputTimeEnd"><input class = "CalendarWidget-timeInput CalendarWidget-timeEnd" value={{hourEnd}}></span>' +
                '</div>' +
            '</div>';

    /** Параметры календаря
     * @typedef nsGmx.CalendarWidget~Parameters
     * @property {nsGmx.DateInterval} dateInterval Временной интервал, который нужно менять
     * @property {Date} [dateMin] минимальная граничная дата для календарей, null - без ограничений
     * @property {Date} [dateMax] максимальная граничная дата для календарей, null - без ограничений
     * @property {String} [dateFormat='dd.mm.yy'] формат даты
     * @property {bool} [minimized=true] показывать ли минимизированный или развёрнутый виджет в начале
     * @property {bool} [showSwitcher=true] показывать ли иконку для разворачивания/сворачивания периода
     * @property {Date} [dateBegin=<текущая дата>] начальная дата интервала
     * @property {Date} [dateEnd=<текущая дата>] конечная дата интервала
     * @property {String|DOMNode} [container] куда добавлять календарик
     * @property {String} [buttonImage] URL иконки для активации календариков
     */

    /** Контрол для задания диапазона дат. Даты календарика всегда в UTC, а не в текущем поясе.
     @description Виджет для выбора интервала дат. Пользователь при помощи datepicker'ов выбирает два дня (год, месяц, число),
                  затем выбранные значения при помощи ф-ции `_updateModel()` переводятся в интервал дат ({@link nsGmx.DateInterval}).
                  Так же виджет реагирует на изменения модели (с использованием ф-ции `_updateWidget()`)
     @alias nsGmx.CalendarWidget
     @extends nsGmx.GmxWidget
     @class
     @param {nsGmx.CalendarWidget~Parameters} options Параметры календаря
    */

    var CalendarModel = window.Backbone.Model.extend({
        defaults: {
            dailyFilter: true
        }
    });
    var Calendar1 = window.Backbone.View.extend({
        tagName: 'div',
        model: new CalendarModel(),
        className: 'CalendarWidget ui-widget',
        template: Handlebars.compile(template),
        events: {
            'click .CalendarWidget-dates-outside .CalendarWidget-inputCell': function (e) {
                e.stopPropagation();
                this.showCalendar(e);
                $(e.target).focus();
            },
            'keydown .CalendarWidget-dateBegin': function (e) {
                this.manuallyChangeDateInterval(e, 'begin');
            },
            'keydown .CalendarWidget-dateEnd': function (e) {
                this.manuallyChangeDateInterval(e, 'end');
            },
            'click .CalendarWidget-iconScrollLeft': function () {
                this._shiftDates(-1);
            },
            'click .CalendarWidget-iconScrollRight': function () {
                this._shiftDates(1);
            },
            'keydown .CalendarWidget-inputCell-inputTimeBegin': function (e) {
                this.jumpByArrow(e, 'left');
            },
            'keydown .CalendarWidget-inputCell-inputTimeEnd': function (e) {
                this.jumpByArrow(e, 'right');
            }
        },

        initialize: function(options) {
            var _this = this;
            options = $.extend({
                minimized: true,
                showSwitcher: true,
                dateMax: null,
                dateMin: null,
                dateFormat: 'dd.mm.yy',
                name: null
            }, options);

            this._dateMin = options.dateMin;
            this._dateMax = options.dateMax;
            this._dateInterval = options.dateInterval;
            this._opened = false;

            $.datepicker.setDefaults({

                onSelect: function(dateText, inst){
                    this._selectFunc(inst.input);
                }.bind(this),
                minDate: this._dateMin ? Calendar1.toUTC(this._dateMin) : null,
                maxDate: this._dateMax ? Calendar1.toUTC(this._dateMax) : null,
                changeMonth: true,
                changeYear: true,
                dateFormat: 'dd.mm.yy',
                defaultDate: Calendar1.toUTC(this._dateMax || new Date()),
                buttonImageOnly: true,
                constrainInput: true
            });

            this.calendarTemplates = {
                beginTemplate: Handlebars.compile('' +
                    '<div class="outside-calendar-container">' +
                        '<div class="begin-outside-calendar">' +
                        '</div>' +
                        '<div class="time-container begin-time-container">' +
                        '</div>' +
                        '<div class="time-placeholder begin-time-placeholder" hidden>' +
                        '</div>' +
                            '<span class="calendar-button createdateinterval-button">' +
                            '{{i "CalendarWidget.createDateInterval"}}'+
                            '</span>' +
                            '<span class="calendar-button resetdateinterval-button" hidden>' +
                                '{{i "CalendarWidget.resetDateInterval"}}'+
                            '</span>' +
                    '</div>'
                ),
                endTemplate: Handlebars.compile('' +
                    '<div class="outside-calendar-container">' +
                        '<div class="end-outside-calendar">' +
                        '</div>' +
                        '<div class="time-container end-time-container">' +
                        '</div>' +
                        '<div class="time-placeholder end-time-placeholder" hidden>' +
                        '</div>' +
                        '<span class="calendar-button selectdateinterval-button disabled">' +
                            '{{i "CalendarWidget.selectDateInterval"}}'+
                        '</span>' +
                    '</div>'
                )
            };

            var dateBegin = this._dateInterval.get('dateBegin'),
                dateEnd = this._dateInterval.get('dateEnd'),
                hourBegin = Calendar1.getTime(dateBegin, 'begin'),
                hourEnd = Calendar1.getTime(dateEnd, 'end');

            this.$el.html(this.template({
                showCalendarIconClass:'icon-calendar-empty',
                showCalendarIconTitle: _gtxt('CalendarWidget.ShowIconTitle'),
                hourBegin: hourBegin,
                hourEnd: hourEnd
            }));

            // если есть контейнер, куда прикреплять виджет календаря
            if (options.container) {
                if (typeof options.container === 'string')
                    $('#' + options.container).append(this.$el);
                else
                    $(options.container).append(this.$el);
            }

            this._updateWidget();

            this._dateInterval.on('change', this._updateWidget, this);
            this.listenTo(this.model, 'change:dailyFilter', this.enableDailyFilter);

            $('#leftMenu').on('click', function (e) {
                if (e.target.className !== 'CalendarWidget-show-calendar-icon icon-calendar-empty' &&
                    e.target.className !== 'layers-before' &&
                    !(e.target.className instanceof SVGAnimatedString) &&
                    e.target.className.indexOf('CalendarWidget-timeInput') === -1 &&
                    e.target.className !== 'calendar-container'
                ) {
                    $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
                    _this._opened = false;
                }
            });

            this.$('.CalendarWidget-timeInput').on('blur', this._selectTime.bind(this));

            //for backward compatibility
            this.canvas = this.$el;
        },

        manuallyChangeDateInterval: function (e, type) {
            if (e.keyCode !== 13) return;
            e.preventDefault();
            e.stopPropagation();
            var value = $(e.target).val(),
                beginInput = this.$('.CalendarWidget-dateBegin')[0],
                endInput = this.$('.CalendarWidget-dateEnd')[0],
                dayms = nsGmx$1.DateInterval.MS_IN_DAY,
                dateBegin = this._dateInterval.get('dateBegin'),
                dateEnd = this._dateInterval.get('dateEnd'),
                endMidnight = (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()),
                oneDayPeriod, parsed;

            try {
                parsed = $.datepicker.parseDate('dd.mm.yy', value);
            } catch (e) {
                return;
            }

            // handle errors and too large values
            if (!parsed || parsed < this._dateMin || parsed > this._dateMax) { return; }

            parsed = nsGmx$1.CalendarWidget1.fromUTC(parsed);

            oneDayPeriod = (parsed.valueOf() === dateBegin.valueOf());
            oneDayPeriod ? this.setMode(Calendar1.SIMPLE_MODE) : this.setMode(Calendar1.ADVANCED_MODE);

            if (type === 'begin') {
                this._dateBegin.datepicker('setDate', parsed);
                if (parsed > new Date(dateEnd.valueOf() - dayms)) {
                    this._dateEnd.datepicker('setDate', parsed);
                    $(endInput).val(e.target.value);
                    this._selectFunc(endInput);
                }
                this._dateInterval.set({
                    dateBegin: new Date(parsed.valueOf()),
                    dateEnd: new Date(parsed.valueOf() + dayms)
                });
            } else {
                this._dateEnd.datepicker('setDate', parsed);
                if (parsed < dateBegin) {
                    this._dateBegin.datepicker('setDate', parsed);
                    $(beginInput).val(e.target.value);
                    this._selectFunc(beginInput);
                    this._dateInterval.set({
                        dateBegin: new Date(parsed.valueOf()),
                        dateEnd: new Date(parsed.valueOf() + dayms)
                    });
                } else if (parsed > dateBegin) {
                    this._dateInterval.set({
                        dateEnd: new Date(parsed.valueOf() + dayms)
                    });
                }
            }

            this._selectFunc(e.target);
            this.showCalendar(e);
        },

        enableDailyFilter: function () {
            var dailyFilter = this.model.get('dailyFilter'),
                timeBeginValue = this.$('.CalendarWidget-timeBegin').val(),
                timeEndValue = this.$('.CalendarWidget-timeEnd').val();

            if (dailyFilter) {
                if (Number(timeBeginValue) >= Number(timeEndValue)) {
                    this.$('.CalendarWidget-timeBegin').addClass('error');
                    this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
                    this.$('.CalendarWidget-timeEnd').addClass('error');
                } else {
                    this.$('.CalendarWidget-timeBegin').removeClass('error');
                    this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
                    this.$('.CalendarWidget-timeEnd').removeClass('error');
                }
            } else {
                this.$('.CalendarWidget-timeBegin').removeClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
                this.$('.CalendarWidget-timeEnd').removeClass('error');
            }
            this.$('.CalendarWidget-timeBegin').trigger('blur');
            this.$('.CalendarWidget-timeEnd').trigger('blur');
        },

        _selectTime: function (e) {
            var match = this._checkValue(e.target.value);

            if (!match) {
                this.$('.CalendarWidget-timeBegin').addClass('error');
                this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
                this.$('.CalendarWidget-timeEnd').addClass('error');
                return;
            }

            // $(e.target).removeClass('error');

            var isBegin = $(e.target).hasClass('CalendarWidget-timeBegin'),
                dayms = nsGmx$1.DateInterval.MS_IN_DAY,
                dailyFilter = this.model.get('dailyFilter'),
                timeBeginValue = this.$('.CalendarWidget-timeBegin').val(),
                timeEndValue = this.$('.CalendarWidget-timeEnd').val(),
                msBeginInputValue = Calendar1.convertTimeValueToMs(timeBeginValue),
                msEndInputValue = Calendar1.convertTimeValueToMs(timeEndValue),
                dateBegin = this._dateInterval.get('dateBegin'),
                dateEnd = this._dateInterval.get('dateEnd'),
                hourBegin = Calendar1.getTime(dateBegin, 'begin'),
                hourEnd = Calendar1.getTime(dateEnd, 'end'),
                msBegin = Calendar1.convertTimeValueToMs(hourBegin),
                msEnd = Calendar1.convertTimeValueToMs(hourEnd),
                newDateBegin = new Date(dateBegin.valueOf() + (msBeginInputValue - msBegin)),
                newDateEnd = new Date(dateEnd.valueOf() + (msEndInputValue - msEnd));

                if (dailyFilter && Number(timeBeginValue) >= Number(timeEndValue)) {
                    this.$('.CalendarWidget-timeBegin').addClass('error');
                    this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
                    this.$('.CalendarWidget-timeEnd').addClass('error');
                    return;
                }

                if (newDateBegin.valueOf() >= newDateEnd.valueOf()) {
                    this.$('.CalendarWidget-timeBegin').addClass('error');
                    this.$('.CalendarWidget-inputCell-inputTimeMiddle').addClass('error');
                    this.$('.CalendarWidget-timeEnd').addClass('error');
                    return;
                } else {
                    this.$('.CalendarWidget-timeBegin').removeClass('error');
                    this.$('.CalendarWidget-inputCell-inputTimeMiddle').removeClass('error');
                    this.$('.CalendarWidget-timeEnd').removeClass('error');
                }

            this._dateInterval.set({
                dateBegin: newDateBegin,
                dateEnd: newDateEnd
            });
        },

        _checkValue: function (value) {
            var hours = [
                    '00', '01', '02', '03', '04', '05', '06', '07', '08', '09',
                    '10', '11', '12', '13', '14', '15', '16', '17', '18', '19',
                    '20', '21', '22', '23', '24'
                 ],
                 match = false;

            for (var i = 0; i < hours.length; i++) {
                if (value === hours[i]) {
                    match = true;
                }
            }

            return match;
        },

        showCalendar: function (e) {
            var _this = this,
                beginInput = this.$('.CalendarWidget-dateBegin')[0],
                endInput = this.$('.CalendarWidget-dateEnd')[0],
                dateBegin = this._dateInterval.get('dateBegin'),
                dateEnd = this._dateInterval.get('dateEnd'),
                dayms = nsGmx$1.DateInterval.MS_IN_DAY,
                oneDayPeriod = (dateEnd.valueOf() - dateBegin.valueOf() === dayms),
                endMidnight = (dateEnd.valueOf() === toMidnight(dateEnd).valueOf());

            this.beginCalendar = $(this.calendarTemplates.beginTemplate({oneDayPeriod: oneDayPeriod}));
            this.endCalendar = $(this.calendarTemplates.endTemplate({}));

            var createIntervalButton = $('.createdateinterval-button', this.beginCalendar),
                resetIntervalButton = $('.resetdateinterval-button', this.beginCalendar),
                selectIntervalButton = $('.selectdateinterval-button', this.endCalendar),
                beginDialogOptions = {
                    dialogClass: "calendar-outside begin-calendar",
                    draggable: false,
                    resizable: false,
                    width: 224.8,
                    height: 280,
                    position: [372, 105],
                    resizeFunc: function () {
                        return false;
                    },
                    closeFunc: function () {
                        _this._dateBegin.datepicker("destroy");
                    },
                },
                endDialogOptions = {
                    dialogClass: "calendar-outside end-calendar",
                    draggable: false,
                    resizable: false,
                    width: 224.8,
                    height: 280,
                    position: [610, 105],
                    resizeFunc: function () {
                        return false;
                    },
                    closeFunc: function () {
                        _this._dateEnd.datepicker("destroy");
                    }
                };

            if (this._opened) {
                $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
                this._opened = false;
            }

            oneDayPeriod ? this.setMode(Calendar1.SIMPLE_MODE) : this.setMode(Calendar1.ADVANCED_MODE);

            this._dateBegin = $('.begin-outside-calendar', this.beginCalendar);
            this._dateEnd = $('.end-outside-calendar', this.endCalendar);

            this._dateInputs = this._dateBegin.add(this._dateEnd);

            this._dateInputs.datepicker();

            this._dateInputs.datepicker('option', 'minDate', Calendar1.toUTC(this._dateMin));
            this._dateInputs.datepicker('option', 'maxDate', Calendar1.toUTC(this._dateMax));

            this._dateBegin.datepicker('setDate', Calendar1.toUTC(dateBegin));
            this._dateEnd.datepicker('setDate', oneDayPeriod || endMidnight ? Calendar1.toUTC(new Date(dateEnd.valueOf() - dayms)) : Calendar1.toUTC(dateEnd));

            $(this.beginCalendar).dialog(beginDialogOptions);
            this._opened = true;

            if (this.getMode() === Calendar1.ADVANCED_MODE) {
                $(createIntervalButton).toggle(false);
                $(resetIntervalButton).toggle(true);
                $(this.endCalendar).dialog(endDialogOptions);
                this._opened = true;
            }

            // кнопки в первом календаре
            $(createIntervalButton).on('click', function () {
                var begin = _this._dateInterval.get('dateBegin'),
                    end = _this._dateInterval.get('dateEnd');

                _this.setMode(Calendar1.ADVANCED_MODE);
                $(_this.endCalendar).dialog(endDialogOptions);
                _this._opened = true;

                $(this).toggle(false);
                $(resetIntervalButton).toggle(true);
            });

            $(resetIntervalButton).on('click', function () {
                var dateBegin = toMidnight(_this._dateInterval.get('dateBegin'));
                _this.setMode(Calendar1.SIMPLE_MODE);
                _this._dateBegin.datepicker('setDate', Calendar1.toUTC(dateBegin));
                _this._dateEnd.datepicker('setDate', Calendar1.toUTC(dateBegin));
                $(".calendar-outside.end-calendar .ui-dialog-titlebar-close").trigger('click');
                _this._opened = false;

                $(this).toggle(false);
                $(createIntervalButton).toggle(true);
                _this._dateInterval.set({
                    dateBegin: dateBegin,
                    dateEnd: new Date(dateBegin.valueOf() + dayms)
                });
            });

            // кнопка во втором календаре
            $(selectIntervalButton).on('click', function () {
                _this._updateModel();
                _this.setActive(true);
                _this._enableCreateIntervalButton();
                $(".calendar-outside .ui-dialog-titlebar-close").trigger('click');
                _this._opened = false;
            });
        },

        _enableCreateIntervalButton: function (e) {
            var dayms = nsGmx$1.DateInterval.MS_IN_DAY,
                selectIntervalButton = $('.selectdateinterval-button'),
                dateBegin = this._dateInterval.get('dateBegin'),
                dateEnd = this._dateInterval.get('dateEnd'),
                beginTimeValue = Calendar1.convertTimeValueToMs(e && e.target === $('CalendarWidget-timeBegin', this)[0] ? $(e.target).val() : $('.CalendarWidget-timeBegin').val()),
                endTimeValue = Calendar1.convertTimeValueToMs(e && e.target === $('CalendarWidget-timeEnd', this)[0] ? $(e.target).val() : $('.CalendarWidget-timeEnd').val()),
                calendarDateBegin = this.getDateBegin(),
                calendarDateEnd = this.getDateEnd(),
                newDateBegin = new Date(calendarDateBegin.valueOf() + beginTimeValue),
                newDateEnd = new Date(calendarDateEnd.valueOf() + endTimeValue);

            // если даты в итоге не поменялись или вторая дата больше первой
            if ((newDateBegin.valueOf() === dateBegin.valueOf() && newDateEnd.valueOf() === dateEnd.valueOf()) ||
                newDateBegin.valueOf() >= newDateEnd.valueOf()) {
                    $(selectIntervalButton).addClass('disabled');
            } else {
                $(selectIntervalButton).removeClass('disabled');
            }
        },

        _shiftDates: function(delta) {
            var dateBegin = this._dateInterval.get('dateBegin'),
                dateEnd = this._dateInterval.get('dateEnd'),
                dayms = nsGmx$1.DateInterval.MS_IN_DAY,
                dailyFilter = this.model.get('dailyFilter'),
                shift;

            if (!dateBegin || !dateEnd) {
                return;
            }

            if (dailyFilter) {
                var diff = (toMidnight(dateEnd) - toMidnight(dateBegin));
                shift = diff ? diff * delta : dayms * delta;
            } else {
                shift = (dateEnd - dateBegin) * delta;
            }

            var newDateBegin = new Date(dateBegin.valueOf() + shift),
                newDateEnd = new Date(dateEnd.valueOf() + shift);

            if ((!this._dateMin || toMidnight(this._dateMin) <= toMidnight(newDateBegin)) &&
                (!this._dateMax || toMidnight(this._dateMax) >= toMidnight(newDateEnd)))
            {
                this._dateInterval.set({
                    dateBegin: newDateBegin ? newDateBegin : null,
                    dateEnd: newDateEnd ? newDateEnd : null
                });
            }
        },

        _selectFunc: function(activeInput) {
            var begin = this.getDateBegin(),
                end = this.getDateEnd(),
                dayms = nsGmx$1.DateInterval.MS_IN_DAY,
                selectIntervalButton = $('.selectdateinterval-button');

            if (end && begin && begin > end) {
                var dateToFix = activeInput[0] == this._dateEnd[0] ? this._dateBegin : this._dateEnd;

                dateToFix.datepicker('setDate', $(activeInput[0]).datepicker('getDate'));
            }
            if (this._curMode === Calendar1.SIMPLE_MODE) {
                if (!begin != !end || begin && begin.valueOf() !== end.valueOf()) {
                    this._dateEnd.datepicker('setDate', this._dateBegin.datepicker('getDate'));
                }
                this._dateInterval.set({
                    dateBegin: begin ? begin : null,
                    dateEnd: end ? new Date(begin.valueOf() + nsGmx$1.DateInterval.MS_IN_DAY) : null
                });
            } else if (this._curMode === Calendar1.ADVANCED_MODE) {
                this._enableCreateIntervalButton();
            }
        },

        _updateModel: function() {
            // получаем значения с дейтпикеров и переводим их в локальное время
            var dateBegin = this.getDateBegin(),
                dateEnd = this.getDateEnd(),
                // значение часов
                beginTimeValue = Calendar1.convertTimeValueToMs($('.CalendarWidget-timeBegin').val()),
                endTimeValue = Calendar1.convertTimeValueToMs($('.CalendarWidget-timeEnd').val()),
                dayms = nsGmx$1.DateInterval.MS_IN_DAY;

            // добавим время к часам (в локальном времени)
            dateBegin = new Date(dateBegin.valueOf() + beginTimeValue);
            dateEnd = new Date(dateEnd.valueOf() + endTimeValue);

            this._dateInterval.set({
                dateBegin: dateBegin ? dateBegin : null,
                dateEnd: dateEnd ? dateEnd : null
            });
        },

        _updateWidget: function() {
            var dateBegin = this._dateInterval.get('dateBegin'),
                dateEnd = this._dateInterval.get('dateEnd'),
                hourBegin = Calendar1.getTime(dateBegin, 'begin'),
                hourEnd = Calendar1.getTime(dateEnd, 'end'),
                beginInput = this.$('.CalendarWidget-dateBegin')[0],
                endInput = this.$('.CalendarWidget-dateEnd')[0],
                timeBegin = this.$('.CalendarWidget-timeBegin')[0],
                timeEnd = this.$('.CalendarWidget-timeEnd')[0],
                dayms = nsGmx$1.DateInterval.MS_IN_DAY,
                newDateEnd;

            if (!dateBegin || !dateEnd) {
                return;
            }
            var newDateBegin = Calendar1.toUTC(dateBegin),
                newDateEnd = Calendar1.toUTC(new Date(dateEnd));

            // если календарь показывает ровно один день,
            // прибавляем 24 часа к первой дате, чтобы получить сутки
            if (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()) {
                newDateEnd = Calendar1.toUTC(new Date(dateEnd - dayms));
            }

            $(beginInput).val(Calendar1.formatDate(newDateBegin));
            $(endInput).val(Calendar1.formatDate(newDateEnd));

            $(timeBegin).val(Calendar1.prefixTimeValue(hourBegin));
            $(timeEnd).val(Calendar1.prefixTimeValue(hourEnd));

            this.enableDailyFilter && this.enableDailyFilter();
        },

        setActive: function (value) {
            var active = this.active;
            if (value !== active) {
                this.active = value;
            }

            if (this.active) {
                this.$el.removeClass('gmx-disabled');
            } else {
                this.$el.addClass('gmx-disabled');
            }
        },

        jumpByArrow: function (e, type) {
            var target = type === 'left' ? this.$('.CalendarWidget-inputCell-inputTimeBegin').find('input') : this.$('.CalendarWidget-inputCell-inputTimeEnd').find('input'),
                source = type === 'left' ? this.$('.CalendarWidget-inputCell-inputTimeEnd').find('input') : this.$('.CalendarWidget-inputCell-inputTimeBegin').find('input'),
                sourceElem = $(source).get(0),
                strEnd;

            switch (type) {
                case 'left':
                    if (e.key === 'ArrowRight' && e.target.value.length === e.target.selectionEnd) {
                        $(target).blur();
                        $(source).focus();

                        strEnd = sourceElem.value.length || 0;

                        setTimeout(function () {
                            sourceElem.setSelectionRange(strEnd, strEnd);
                        }, 0);
                    }
                    break;
                case 'right':
                    if (e.key === 'ArrowLeft' && e.target.selectionStart === 0) {
                        $(target).blur();
                        $(source).focus();

                        strEnd = sourceElem.value.length || 0;

                        setTimeout(function () {
                            sourceElem.setSelectionRange(strEnd, strEnd);
                        }, 0);
                    }
                    break;
                default: return;
            }
        },

        //public interface

        /** Закрыть все открытые datepicker'ы.
         * @return {nsGmx.CalendarWidget} this
         */
        reset: function() {
            this._dateInputs.datepicker('hide');
            return this;
        },

        /** Сериализация состояния виджета
         * @return {Object} Сериализованное состояние
         */
        saveState: function() {
            return {
                version: '1.1.0',
                vismode: this.getMode()
            }
        },

        /** Восстановить состояние виджета по сериализованным данным
         * @param {Object} data Сериализованное состояние календарика
         */
        loadState: function( data ) {
            this.setMode(data.vismode);
        },

        /** Получить начальную дату
         * @return {Date} начальная дата
         */
        getDateBegin: function() {
            return this._dateBegin ? Calendar1.fromUTC(this._dateBegin.datepicker('getDate')) : this.getDateInterval().get('dateBegin');
        },

        /** Получить конечную дату
         * @return {Date} конечная дата
         */
        getDateEnd: function() {
            return this._dateEnd ? Calendar1.fromUTC(this._dateEnd.datepicker('getDate')) : this.getDateInterval().get('dateEnd');
        },

        /** Получить верхнюю границу возможных дат периода
         * @return {Date} верхняя граница возможных периодов
         */
        getDateMax: function() {
            return this._dateMax;
        },

        /** Получить нижнуюю границу возможных дат периода
         * @return {Date} нижняя граница возможных периодов
         */
        getDateMin: function() {
            return this._dateMin;
        },

        /** Установить нижнуюю границу возможных дат периода
         * @param {Date} dateMin нижняя граница возможных периодов
         */
        setDateMin: function(dateMin) {
            this._dateMin = dateMin;
            this._dateInputs.datepicker('option', 'minDate', dateMin ? Calendar1.toUTC(dateMin) : null);
        },

        /** Установить верхнюю границу возможных дат периода
         * @param {Date} dateMax верхняя граница возможных периодов
         */
        setDateMax: function(dateMax) {
            // var titleContainer = this.$('.CalendarWidget-forecast');

            this._dateMax = dateMax;
            if (dateMax) {
                var utcDate = Calendar1.toUTC(dateMax);
                if (this._dateInputs) {
                    this._dateInputs.datepicker('option', 'maxDate', utcDate);
                }

            } else {
                if (this._dateInputs) {
                    this._dateInputs.datepicker('option', 'maxDate', null);
                }
            }
        },

        setSwitcherVisibility: function(isVisible) {
            this._showCalendarIcon && this._showCalendarIcon.toggle(isVisible);
        },

        getDateInterval: function() {
            return this._dateInterval;
        },

        getMode: function() {
            return this._curMode;
        },

        setMode: function(mode) {
            if (this._curMode === mode) {
                return this;
            }

            this._curMode = mode;
        }

    }, {
        /* static methods */

        // date показывает в utc
        // нужно вычесть отрицательную разницу
        // utc 13:00
        // 13:00 - (-3 часа) = 16:00
        // locale 16:00
        // return locale date
        fromUTC: function(date) {
            if (!date) return null;
            var timeOffset = date.getTimezoneOffset()*60*1000;
            return new Date(date.valueOf() - timeOffset);
        },
        toUTC: function(date) {
            if (!date) return null;
            var timeOffset = date.getTimezoneOffset()*60*1000;
            return new Date(date.valueOf() + timeOffset);
        },
        formatDate: function(date) {
            var d = new Date(date),
            month = '' + (d.getMonth() + 1),
            day = '' + d.getDate(),
            year = d.getFullYear();

            if (month.length < 2) month = '0' + month;
            if (day.length < 2) day = '0' + day;

            return [day, month, year].join('.');
        },
        convertTimeValueToMs: function (value) {
            var ms = Number(value)*1000*3600;
            return ms;
        },
        getTime: function (date, position) {
            var dayms = nsGmx$1.DateInterval.MS_IN_DAY,
                offset, hours;

            if (position === 'begin') {
                offset = date.valueOf() - toMidnight(date).valueOf();
            } else {
                if (date.valueOf() === toMidnight(date).valueOf()) {
                    offset = dayms;
                } else {
                    offset = date.valueOf() - toMidnight(date).valueOf();
                }
            }
            hours = offset/(3600*1000);

            return hours;
        },

        prefixTimeValue: function (value) {
            value = Number(value);
            return value < 10 ? '0' + value : String(value);
        },
        SIMPLE_MODE: 1,
        ADVANCED_MODE: 2
    });

    nsGmx$1.CalendarWidget1 = Calendar1;

    })(jQuery);

    // COMMON CalendarWidget

    (function($){

        nsGmx$1.Translations.addText("rus", { CommonCalendarWidget: {
            Timeline:    "Таймлайн",
            select: "Выберите мультивременной слой",
            sync: "Единый интервал для слоев",
            daily: "посуточно",
            on: "Включить синхронизацию слоев",
            off: "Выключить синхронизацию слоев",
            all: "Интервал для всех слоев"
        }});

        nsGmx$1.Translations.addText("eng", { CommonCalendarWidget: {
            Timeline:     "Timeline",
            select: "Select temporal layer",
            sync: "Single date interval",
            daily: "daily",
            on: "Layers sync on",
            off: "Layers sync off",
            all: "Интервал для всех слоев"
        }});

        var toMidnight = nsGmx$1.DateInterval.toMidnight,
            dayms = nsGmx$1.DateInterval.MS_IN_DAY;

        var calendarWidgetTemplate = '' +
            '<div class="commoncalendar-container">' +
                '<div class="calendar-layers-container">' +
                    '<div class="calendar-container">' +
                        '<div class="calendar-widget-container"></div>' +
                    '</div>' +
                '</div>' +
                '<div class="sync-switch-container switch-container">' +
                    '<label class="sync-switch switch">' +
                        '<input type="checkbox"' +
                        '{{#if synchronyzed}}checked{{/if}}' +
                        '>' +
                        '<div class="sync-switch-slider switch-slider round"></div>' +
                    '</label>' +
                    '<span class="sync-switch-slider-description">{{i "CommonCalendarWidget.sync"}}</span>' +
                    '<label class="daily-switch">' +
                        '<input type="checkbox"' +
                        '{{#if dailyFilter}}checked{{/if}}' +
                        '>' +
                        '{{i "CommonCalendarWidget.daily"}}' +
                    '</label>' +
                '</div>' +
                '<div class="unsync-layers-container" style="display: none">' +
                    '<select class="layersList">' +
                        '{{#each this.layers}}' +
                        '<option value="{{this.layer}}"' +
                            '{{#if this.current}} selected="selected"{{/if}}>' +
                            '{{this.layer}}' +
                        '</option>' +
                        '{{/each}}' +
                    '</select>' +
                '</div>' +
            '</div>' ;

        var _gtxt = nsGmx$1.Translations.getText.bind(nsGmx$1.Translations);

        var CommonCalendarModel = Backbone.Model.extend({
            defaults: {
                active: true,
                currentLayer: null,
                calendar: null,
                isAppended: false,
                unbindedTemporalLayers: {},
                dailyFiltersHash: {},
                dailyFilter: true,
                synchronyzed: true
            }
        });

        var CommonCalendar = Backbone.View.extend({
            tagName: 'div',
            model: new CommonCalendarModel(),
            className: 'CommonCalendarWidget ui-widget',
            template: Handlebars.compile(calendarWidgetTemplate),
            events: {
                'change .sync-switch': 'toggleSync',
                'change .daily-switch': 'toggleDailyFilter',
                'change .layersList': 'changeCurrentLayer'
            },
            initialize: function (options) {
                var _this = this;

                this.$el.html(this.template({
                    synchronyzed: _this.model.get('synchronyzed'),
                    layers: _this.model.get('visibleTemporalLayers'),
                    dailyFilter: _this.model.get('dailyFilter')
                }));

                //for backward compatibility
                this.canvas = this.$el;
                this.dateInterval = new nsGmx$1.DateInterval();

                this.listenTo(this.model, 'change:synchronyzed', this.updateSync);
                this.listenTo(this.model, 'change:dailyFilter', (function () {
                    this.handleFiltersHash();
                    this.applyDailyFilter();
                }).bind(this));

                this.dateInterval.on('change', function () {
                    _this.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);
                    if (_this.model.get('dailyFilter')) {
                        _this.applyDailyFilter();
                    }
                });

                this._fillFiltersHash();
            },

            _fillFiltersHash: function(layers) {
                layers = layers || nsGmx$1.gmxMap.layers;

                var dailyFiltersHash = {};

                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i],
                        props = layer.getGmxProperties(),
                        layerID = props.LayerID,
                        isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                    if (isTemporalLayer) {
                        dailyFiltersHash[layerID] = true;
                    }

                    this.model.set('dailyFiltersHash', dailyFiltersHash);
                }
            },

            _clearFiltersHash: function (layers) {
                layers = layers || nsGmx$1.gmxMap.layers;

                var dailyFiltersHash = {};

                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i],
                        props = layer.getGmxProperties(),
                        layerID = props.LayerID,
                        isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                    if (isTemporalLayer) {
                        dailyFiltersHash[layerID] = false;
                    }

                    this.model.set('dailyFiltersHash', dailyFiltersHash);
                }
            },

            setDateInterval: function (dateBegin, dateEnd, layer) {
                if (layer) {
                    this.setCurrentLayer(layer);
                }

                var oldBegin = this.dateInterval.get('dateBegin').valueOf(),
                    oldEnd = this.dateInterval.get('dateEnd').valueOf();

                if (oldBegin === dateBegin.valueOf() && oldEnd === dateEnd.valueOf()) {
                    this.updateTemporalLayers();

                    this.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);
                    if (this.model.get('dailyFilter')) {
                        this.applyDailyFilter();
                    }
                    this.trigger('change:dateInterval');
                } else {
                    this.dateInterval.set({
                        dateBegin: dateBegin,
                        dateEnd: dateEnd
                    });
                }

                if (this.dateInterval.get('dailyFilter')) {
                    this.applyDailyFilter();
                }
            },

            setCurrentLayer: function (layer) {
                var props = layer.getGmxProperties();

                this.model.set('currentLayer', props.LayerID);
            },

            changeCurrentLayer: function (e) {
                var _this = this,
                    layerID = e.target.value;

                _this.model.set('currentLayer', layerID);
            },

            log: function () {
                var f = function(list) {
                    var layers = nsGmx$1.gmxMap.layers;

                    for (var i = 0; i < layers.length; i++) {
    	               var layer = layers[i],
                            props = layer.getGmxProperties(),
                            t = props.title,
                            isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);
                            int = layer.getDateInterval();

                        if (isTemporalLayer && int) {
                            var b = int.beginDate.toString(),
                                e = int.endDate.toString();
                            list.push({
                                title: t,
                                beginDate: b,
                                endDate: e
                            });
                        }
    	            }
    	               console.table(list);
                };
                f([]);
            },

            getDateInterval: function () {
                return this.dateInterval;
            },

            get: function() {
                var attrs = this.model.toJSON(),
                    _this = this,
                    calendar;

                if (!attrs.calendar) {
                    calendar = new nsGmx$1.CalendarWidget1({
                        minimized: false,
                        dateMin: new Date(2000, 1, 1),
                        dateMax: new Date(Date.now() + dayms) > _this.dateInterval.get('dateEnd') ? new Date(Date.now() + dayms) : _this.dateInterval.get('dateEnd'),
                        dateInterval: _this.dateInterval
                    });

                    this.dateInterval.on('change', this.updateTemporalLayers.bind(this, null));

                    this.model.set('calendar', calendar);
                this.updateTemporalLayers();
                }

                return this.model.get('calendar');
            },

            replaceCalendarWidget: function(newCalendar) {
                this._calendar = newCalendar;

                //заменим виджет перед деревом слоёв
                if (this._isAppended) {
                    var doChange = function() {
                        var calendarDiv = $('<div class="commoncalendar-container"></div>').append(newCalendar.canvas);
                        // special for steppe project
                        if (nsGmx$1.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                            _queryMapLayers.getContainerAfter().find('.commoncalendar-container').replaceWith(calendarDiv);
                        } else {
                            _queryMapLayers.getContainerBefore().findcommoncalendar-container('.commoncalendar-container').replaceWith(calendarDiv);
                        }
                    };
                    //явная проверка, так как хочется быть максимально синхронными в этом методе
                    if (_queryMapLayers.loadDeferred.state() === 'resolved') {
                        doChange();
                    } else {
                        _queryMapLayers.loadDeferred.then(doChange);
                    }
                }
            },

            show: function() {
                var calendarDiv = this.$('.calendar-widget-container'),
                    calendarCanvas = this.get().canvas;

                $(_queryMapLayers.getContainerBefore()).append(calendarCanvas[0]);

                var doAdd = function() {
                    calendarDiv.append(calendarCanvas);

                    var commonCanvas = this.canvas;

                    // special for steppe Project
                    if (nsGmx$1.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                        _queryMapLayers.getContainerAfter().append(commonCanvas);
                    } else {
                        _queryMapLayers.getContainerBefore().append(commonCanvas);
                    }
                    this.model.set('isAppended', true);
                }.bind(this);

                if (!this.model.get('isAppended')) {
                    //явная проверка, так как хочется быть максимально синхронными в этом методе
                    if (_queryMapLayers.loadDeferred.state() === 'resolved') {
                        doAdd();
                    } else {
                        _queryMapLayers.loadDeferred.then(doAdd);
                    }
                }

                return this;
            },

            hide: function() {
                var attrs = this.model.toJSON();
                attrs._isAppended && $(this.get().canvas).hide();
                this.model.set('isAppended', true);

                return this;
            },

            bindLayer: function (layerName) {
                var attrs = this.model.toJSON(),
                    unbindedTemporalLayers = attrs.unbindedTemporalLayers,
                    clone = {};

                // clone object
                for (var variable in unbindedTemporalLayers) {
                    if (unbindedTemporalLayers.hasOwnProperty(variable)) {
                        clone[variable] = unbindedTemporalLayers[variable];
                    }
                }
                delete clone[layerName];

                this.model.set('unbindedTemporalLayers', clone);
                this.updateTemporalLayers();
            },

            unbindLayer: function (layerName) {
                var attrs = this.model.toJSON(),
                    layer = nsGmx$1.gmxMap.layersByID[layerName];
                if (!layer) {
                    return;
                }
                var props = layer.getGmxProperties(),
                    unbindedTemporalLayers = attrs.unbindedTemporalLayers,
                    clone = {};

                layer.removeLayerFilter({ id: 'dailyFilter' });
                // clone object
                for (var variable in unbindedTemporalLayers) {
                    if (unbindedTemporalLayers.hasOwnProperty(variable)) {
                        clone[variable] = unbindedTemporalLayers[variable];
                    }
                }
                clone[layerName] = true;
                this.model.set('unbindedTemporalLayers', clone);
                this.updateTemporalLayers([layer]);
            },

            _updateOneLayer: function(layer, dateBegin, dateEnd) {
                var props = layer.getGmxProperties();
                if (props.maxShownPeriod) {
                    var msecPeriod = props.maxShownPeriod*24*3600*1000;
                    var newDateBegin = new Date( Math.max(dateBegin.valueOf(), dateEnd.valueOf() - msecPeriod));
                    layer.setDateInterval(newDateBegin, dateEnd);
                } else {
                    layer.setDateInterval(dateBegin, dateEnd);
                }
            },

            updateTemporalLayers: function(layers) {
                layers = layers || nsGmx$1.gmxMap.layers;

                var attrs = this.model.toJSON(),
                    synchronyzed = attrs.synchronyzed,
                    dateBegin = this.dateInterval.get('dateBegin'),
                    dateEnd = this.dateInterval.get('dateEnd'),
                    currentLayer = attrs.currentLayer,
                    layersMaxDates = [],
                    maxDate = null,
                    localeDate;

                if (!attrs.calendar) {return;}

                if (synchronyzed) {
                    for (var i = 0, len = layers.length; i < len; i++) {
                        var layer = layers[i],
                        props = layer.getGmxProperties(),
                        isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.setDateInterval);

                        if (isTemporalLayer && !(props.name in attrs.unbindedTemporalLayers)) {
                            if (props.DateEnd) {
                                if (typeof props.DateEnd === "string") {
                                    localeDate = $.datepicker.parseDate('dd.mm.yy', props.DateEnd);
                                } else if (typeof props.DateEnd === "number") {
                                    localeDate = new Date(props.DateEnd);
                                }

                                layersMaxDates.push(localeDate);
                            }

                            this._updateOneLayer(layer, dateBegin, dateEnd);
                        }
                    }
                } else {
                    if (currentLayer && !(currentLayer in attrs.unbindedTemporalLayers)) {
                        currentLayer = nsGmx$1.gmxMap.layersByID[currentLayer];
                        this._updateOneLayer(currentLayer, dateBegin, dateEnd);
                    } else {
                        return;
                    }
                }

                if (layersMaxDates.length > 0) {
                    layersMaxDates.sort(function(a, b) {
                        return b - a;
                    });

                    maxDate = new Date(layersMaxDates[0]);

                    if (maxDate > attrs.calendar.getDateMax()) {
                        attrs.calendar.setDateMax(nsGmx$1.CalendarWidget.fromUTC(new Date(maxDate.valueOf() + dayms)));
                    }

                    this.model.set('calendar', attrs.calendar);
                }
            },

            onDateIntervalChanged: function (e) {
                var attrs = this.model.toJSON(),
                    currentLayer = attrs.currentLayer,
                    layer = e.target,
                    props,
                    dateInterval, dateBegin, dateEnd;

                if (!currentLayer) {
                    return;
                }

                props = layer.getGmxProperties(),
                layerID = props.LayerID;

                if (layerID in attrs.unbindedTemporalLayers) {
                    return;
                }

                if (layerID === currentLayer) {
                    if (props.maxShownPeriod) { return; }
                    dateInterval = layer.getDateInterval(),
                    dateBegin = dateInterval.beginDate,
                    dateEnd = dateInterval.endDate;

                    this.setDateInterval(dateBegin, dateEnd, layer);
                }
            },

            updateVisibleTemporalLayers: function (layers) {
                var _this = this,
                    attrs = this.model.toJSON(),
                    currentLayer = attrs.currentLayer,
                    layersList = this.$('.layersList'),
                    temporalLayers = [],
                    str = '';

                $.widget( "ui.temporallayersmenu", $.ui.selectmenu, {
                    _renderItem: function(ul, item) {
                        var li = $( "<li>" );

                        if ( item.value ) {
                            var l = nsGmx$1.gmxMap.layersByID[item.value],
                                props = l.getGmxProperties(),
                                di = l.getDateInterval && l.getDateInterval(),
                                dateBegin, dateEnd,
                                hourBegin, hourEnd,
                                newDateBegin, newDateEnd,
                                str = '';

                            if (di) {
                                var now = new Date(),
                                    dateBeginToMidnight = new Date(now - now % dayms);

                                // dateBegin = di.beginDate;
                                // dateEnd = di.endDate);
                                dateBegin = di.beginDate || dateBeginToMidnight;
                                dateEnd = di.endDate || new Date(dateBeginToMidnight.valueOf() + dayms);
                                hourBegin = nsGmx$1.CalendarWidget1.prefixTimeValue(nsGmx$1.CalendarWidget1.getTime(dateBegin, 'begin'));
                                hourEnd = nsGmx$1.CalendarWidget1.prefixTimeValue(nsGmx$1.CalendarWidget1.getTime(dateEnd, 'end'));
                                newDateBegin = nsGmx$1.CalendarWidget1.toUTC(dateBegin);
                                newDateEnd = nsGmx$1.CalendarWidget1.toUTC(dateEnd);

                                // если календарь показывает ровно один день,
                                // прибавляем 24 часа к первой дате, чтобы получить сутки
                                if (dateEnd.valueOf() === toMidnight(dateEnd).valueOf()) {
                                    newDateEnd = nsGmx$1.CalendarWidget1.toUTC(new Date(dateEnd - dayms));
                                }

                                str = '<span class=\'layerslist-title\'>' +  props.title + '</span>' + ' ' +
                                      '<span class=\'layerslist-dates-times\'>' + nsGmx$1.CalendarWidget1.formatDate(newDateBegin) + ' - ' + nsGmx$1.CalendarWidget1.formatDate(newDateEnd) +
                                      ' | ' + hourBegin + '-' + hourEnd + '</span>';

                            }

                            $(li).html(str);
                            $(li).prop('layerID', item.value);

                            return li.appendTo( ul );
                        }
                    },
                    _renderMenu: function( ul, items ) {
                        var that = this;
                        $.each( items, function( index, item ) {
                            that._renderItemData( ul, item );
                        });
                    }
                });

                if ($(layersList).temporallayersmenu("instance")) {
                    $(layersList).temporallayersmenu("destroy");
                }

                for (var i = 0; i < layers.length; i++) {
                    var layer = layers[i];
                        if (layer.getGmxProperties) {
                            var props = layer.getGmxProperties(),
                                isVisible = props.visible,
                                isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                            if (isTemporalLayer && isVisible) {
                                temporalLayers.push(layer);
                            }
                        }
                    }

                for (var i = 0; i < temporalLayers.length; i++) {
                    var layer = temporalLayers[i],
                        props = layer.getGmxProperties(),
                        layerID = props.LayerID;

                    str += '<option value=' + layerID + '>' + props.title + '</option>';
                }
                $(layersList).html(str);

                if (currentLayer) {
                    var l = nsGmx$1.gmxMap.layersByID[currentLayer];

                    this.$('.layersList option').each(function () {
                        if ($(this).val() === currentLayer) {
                            $(this).prop("selected", true);
                        }
                    });

                // установим текщим первый слой из списка
                } else if (!currentLayer && temporalLayers.length) {
                    var props = temporalLayers[0].getGmxProperties(),
                        layerID = props.LayerID;

                    this.$('.layersList option[value="' + layerID + '"]').prop("selected", true);
                }

                $(layersList).temporallayersmenu({
                    change: function (e) {
                        var layerID = $(e.currentTarget).prop('layerID'),
                            layer = nsGmx$1.gmxMap.layersByID[layerID],
                            filters = layer._gmx.dataManager._filtersView,
                            layerFilters = filters[layerID],
                            dateBegin, dateEnd;

                        dateInterval = layer.getDateInterval();

                        if (dateInterval.beginDate && dateInterval.endDate) {
                            dateBegin = dateInterval.beginDate;
                            dateEnd = dateInterval.endDate;
                        } else {
                            dateInterval = new nsGmx$1.DateInterval();
                            dateBegin = dateInterval.get('dateBegin');
                            dateEnd = dateInterval.get('dateEnd');
                        }

                        if (layerFilters) {
                            if ('screen_dailyFilter' in layerFilters) {
                                _this.$('.daily-switch input').prop("checked", true);
                            } else {
                                _this.$('.daily-switch input').prop("checked", false);
                            }
                        }

                        _this.$('.layersList option[value="' + layerID + '"]').prop("selected", true);
                        _this.setDateInterval(dateBegin, dateEnd, layer);

                    }
                });
            },

            toggleSync: function () {
                this.model.set('synchronyzed', !this.model.get('synchronyzed'));
            },

            setSyncMode: function (value) {
                this.model.set('synchronyzed', Boolean(value));
            },

            updateSync: function () {
                var _this = this,
                    layers = nsGmx$1.gmxMap.layers,
                    attrs = this.model.toJSON(),
                    synchronyzed = attrs.synchronyzed,
                    currentLayer = attrs.currentLayer,
                    listContainer = this.$('.unsync-layers-container'),
                    layersList = this.$('.layersList'),
                    dateBegin, dateEnd;

                if (synchronyzed) {
                    dateBegin = _this.dateInterval.get('dateBegin'),
                    dateEnd = _this.dateInterval.get('dateEnd'),
                    _this.setDateInterval(dateBegin, dateEnd);
                    this.model.set('currentLayer', null);
                    this.model.set('currentLayer', null);
                    this.$('.sync-switch input').prop("checked", true);
                    $(listContainer).hide();
                } else {
                    if (currentLayer) {
                        return;
                    } else {
                        var temporalLayers = [];

                        this.$('.sync-switch input').prop("checked", false);
                        $(listContainer).show();
                        this.updateVisibleTemporalLayers(layers);

                        for (var i = 0; i < layers.length; i++) {
                            var layer = layers[i];
                            if (layer.getGmxProperties) {
                                var props = layer.getGmxProperties(),
                                isVisible = props.visible,
                                isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                                if (isTemporalLayer && isVisible) {
                                    temporalLayers.push(layer);
                                }
                            }
                        }
                        if (!temporalLayers.length) {
                            this.model.set('currentLayer', null);
                        } else {
                            var props = temporalLayers[0].getGmxProperties(),
                            layerID = props.LayerID;
                            this.model.set('currentLayer', layerID);
                        }
                    }
                }
            },

            toggleDailyFilter: function () {
                var attrs = this.model.toJSON(),
                    calendar = attrs.calendar;

                calendar.model.set('dailyFilter', !this.model.get('dailyFilter'));
                this.model.set('dailyFilter', !this.model.get('dailyFilter'));
            },

            setDailyFilter: function (active) {
                var attrs = this.model.toJSON(),
                    calendar = attrs.calendar;

                calendar.model.set('dailyFilter', active);
                this.model.set('dailyFilter', active);
            },

            handleFiltersHash: function () {
                var attrs = this.model.toJSON(),
                    synchronyzed = attrs.synchronyzed,
                    currentLayer = attrs.currentLayer,
                    dateInterval = this.dateInterval,
                    calendar = attrs.calendar,
                    dailyFilter = attrs.dailyFilter,
                    dailyFiltersHash = attrs.dailyFiltersHash;

                if (dailyFilter) {
                    if (currentLayer) {
                        dailyFiltersHash[currentLayer] = true;
                    } else {
                        this._fillFiltersHash();
                    }
                } else {
                    if (currentLayer) {
                        dailyFiltersHash[currentLayer] = false;
                    } else {
                        this._clearFiltersHash();
                    }
                }
            },

            applyDailyFilter: function (layers) {
                var temporalLayers = layers || nsGmx$1.gmxMap.layers,
                    _this = this,
                    attrs = this.model.toJSON(),
                    dailyFilter = attrs.dailyFilter,
                    dailyFiltersHash = attrs.dailyFiltersHash,
                    synchronyzed = attrs.synchronyzed,
                    currentLayer = attrs.currentLayer,
                    dateInterval = this.dateInterval,
                    calendar = attrs.calendar,
                    dateBegin = this.dateInterval.get('dateBegin'),
                    dateEnd = this.dateInterval.get('dateEnd'),
                    hourBegin = Number(nsGmx$1.CalendarWidget1.getTime(dateBegin, 'begin')) * 1000 * 3600,
                    hourEnd = Number(nsGmx$1.CalendarWidget1.getTime(dateEnd, 'end')) * 1000 * 3600;

                if (synchronyzed) {
                    temporalLayers = nsGmx$1.gmxMap.layers;
                }

                if (!synchronyzed && !currentLayer) {
                    return;
                }

                for (var i = 0; i < temporalLayers.length; i++) {
                    var l = temporalLayers[i],
                        p = l.getGmxProperties && l.getGmxProperties(),
                        layerName;

                    if (!p) {
                        continue;
                    }

                    layerName = p.name;

                    if (layerName in attrs.unbindedTemporalLayers) {
                        continue;
                    }

                    (function (x) {
                    var layer = temporalLayers[x];

                    if (layer.getGmxProperties) {
                            var props = layer.getGmxProperties(),
                                isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                            if (isTemporalLayer && layer.getDataManager) {

                                if (layer.getGmxProperties().name === '509762F05B0044D8A7CCC9D3C2383365') ;

                                if (!synchronyzed && layer.getDateInterval()) {
                                    dateInterval = layer.getDateInterval();
                                    if (dateInterval.beginDate && dateInterval.endDate) {
                                        dateBegin = dateInterval.beginDate;
                                        dateEnd = dateInterval.endDate;
                                        hourBegin = Number(nsGmx$1.CalendarWidget1.getTime(dateBegin, 'begin')) * 1000 * 3600,
                                        hourEnd = Number(nsGmx$1.CalendarWidget1.getTime(dateEnd, 'end')) * 1000 * 3600;
                                    }
                                }

                                var dm = layer.getDataManager(),
                                    dmOpt = dm.options,
                                    fullDays,
                                    intervals = [];

                                if (dmOpt.Temporal) {
                                    var tmpKeyNum = dm.tileAttributeIndexes[dmOpt.TemporalColumnName];
                                }

                                if (hourEnd < dayms) {
                                    fullDays = toMidnight(dateEnd).valueOf() - toMidnight(dateBegin).valueOf() + dayms;
                                } else if (hourEnd === dayms) {
                                    fullDays = toMidnight(dateEnd).valueOf() - toMidnight(dateBegin).valueOf();
                                }

                                for (var i = 0; i < fullDays; i+= dayms) {
                                    intervals.push({
                                        begin: toMidnight(dateBegin).valueOf() + hourBegin + i,
                                        end: toMidnight(dateBegin).valueOf() + hourEnd + i
                                    });
                                }

                                if (dailyFilter && dailyFiltersHash[props.LayerID]) {
                                    layer.addLayerFilter(function (item) {
                                        var itemDate = item.properties[tmpKeyNum] * 1000,
                                            inside = false;
                                        for (var j = 0; j < intervals.length; j++) {
                                            if (intervals[j].begin <= itemDate && itemDate <= intervals[j].end) {
                                                inside = true;
                                                break;
                                            }
                                        }
                                        //
                                        // if (inside) {
                                        //     console.log(layer.getGmxProperties().title + ' / ' + 'loaded');
                                        // } else {
                                        //     console.log(layer.getGmxProperties().title + ' / ' + 'filtered');
                                        // }
                                        return inside;
                                    }, {id: 'dailyFilter'});

                                    _this.$('.daily-switch input').prop("checked", true);

                                } else {
                                    layer.removeLayerFilter({id: 'dailyFilter'});
                                    _this.$('.daily-switch input').prop("checked", false);
                                }
                            }
                        }
                    }(i));
                }
            }
        });

        nsGmx$1.CommonCalendarWidget = CommonCalendar;

    })(jQuery);

    !(function() {
    //Контроллёр контектных меню и соответствующие пункты всех меню...
    /**
    * Контроллёр контекстных меню.
    * @class
    * @name ContextMenuController
    * @memberOf nsGmx
    *
    * @description Позволяет добавлять элементы контектсного меню разного типа и привязывать меню к отдельным DOM элементам.
    * Возможно динамическое создание меню при клике на объекте. Элементам меню передаётся контекст,
    * указанный при привязке меню к элементу (он так же может создаваться в момент клика на элементе)
    * Каждый элемент меню - отдельный объект, они независимо добавляются в контроллер.
    * При создании меню определённого типа из этого набора выбираются нужные элементы.
    */
    nsGmx$1.ContextMenuController = (function()
    {
    	var _menuItems = {};
    	var SUGGEST_TIMEOUT = 700;

    	// Показывает контектное меню для конкретного элемента.
    	// В Opera меню показывается при наведении на элемент в течении некоторого времени, во всех остальных браузерах - по правому клику.
    	// Меню исчезает при потере фокуса
    	// Параметры:
    	// * elem {DOMElement} - элемент, на который навешивается меню
    	// * menuFunc {Function, menuFunc()->DomElement} - функция, создающая меню
    	// * checkFunc {Function, checkFunc()->Bool} - если возвращает false, то ничего не показывается...
    	var _context = function(elem, menuFunc, checkFunc)
    	{
            var menu = null;
            elem.oncontextmenu = function(e)
            {
                if (typeof checkFunc != 'undefined' && !checkFunc())
                    return false;

                if (menu && menu.parentNode)
                    menu.parentNode.removeChild(menu);

                menu = menuFunc();
                if (!menu) return false;

                var contextMenu = _div([menu],[['dir','className','contextMenu'], ['attr','id','contextMenuCanvas']]);

                var evt = e || window.event;

                hidden(contextMenu);
                document.body.appendChild(contextMenu);

                // определение координат курсора для ie
                if (evt.pageX == null && evt.clientX != null )
                {
                    var html = document.documentElement;
                    var body = document.body;

                    evt.pageX = evt.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0);
                    evt.pageY = evt.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0);
                }

                if (evt.pageX + contextMenu.clientWidth < getWindowWidth())
                    contextMenu.style.left = evt.pageX - 5 + 'px';
                else
                    contextMenu.style.left = evt.pageX - contextMenu.clientWidth + 5 + 'px';

                if (evt.pageY + contextMenu.clientHeight < getWindowHeight())
                    contextMenu.style.top = evt.pageY - 5 + 'px';
                else
                    contextMenu.style.top = evt.pageY - contextMenu.clientHeight + 5 + 'px';

                visible(contextMenu);

                var menuArea = contextMenu.getBoundingClientRect();

                contextMenu.onmouseout = function(e)
                {
                    var evt = e || window.event;

                    // определение координат курсора для ie
                    if (evt.pageX == null && evt.clientX != null )
                    {
                        var html = document.documentElement;
                        var body = document.body;

                        evt.pageX = evt.clientX + (html && html.scrollLeft || body && body.scrollLeft || 0) - (html.clientLeft || 0);
                        evt.pageY = evt.clientY + (html && html.scrollTop || body && body.scrollTop || 0) - (html.clientTop || 0);
                    }

                    if (evt.pageX <= menuArea.left || evt.pageX >= menuArea.right ||
                        evt.clientY <= menuArea.top || evt.clientY >= menuArea.bottom)
                    {
                        menu = null;
                        contextMenu.removeNode(true);
                    }
                };

                return false;
            };
    	};

    	var _contextClose = function()
    	{
            $('#contextMenuCanvas').remove();
    	};

    	var _generateMenuDiv = function(type, context)
    	{
            var uiTemplate = Handlebars.compile('<div>' +
                '{{#menuItems}}' +
                    '{{#if separator}}<div class = "contextMenuSeparator"></div>{{/if}}' +
                    '<div class = "contextMenuItem" data-itemIndex="{{index}}">{{title}}</div>' +
                '{{/menuItems}}' +
            '</div>');

    		var items = _menuItems[type],
                visibleItems = [];

    		for (var e = 0; e < items.length; e++) {
    			var menuElem = items[e];
                if (menuElem.isVisible && !menuElem.isVisible(context)) {
                    continue;
                }

                visibleItems.push({
                    index: e,
                    title: typeof menuElem.title === 'function' ? menuElem.title() : menuElem.title,
                    separator: menuElem.isSeparatorBefore && menuElem.isSeparatorBefore(context)
                });
            }

            if (visibleItems.length) {
                var ui = $(uiTemplate({menuItems: visibleItems}));
                ui.find('.contextMenuItem').click(function() {
                    var itemIndex = Number($(this).data('itemindex'));
                    context.contentMenuArea = getOffsetRect$1(this);
                    context.contentMenuType = type;
                    _contextClose();
                    _menuItems[type][itemIndex].clickCallback(context);
                });

                return ui[0];
            }

            return null;
    	};

    	//public interface
    	return {

    		/**
    		 * Добавляет новый пункт меню
             * @memberOf nsGmx.ContextMenuController
    		 * @function
    		 * @param {nsGmx.ContextMenuController.IContextMenuElem} menuItem Элемент контекстного меню
    		 * @param {String | String[]} menuType Тип меню (например: "Layer", "Map", "Group"). Если массив, то данный элемент применяется в нескольких типах меню
    		 */
    		addContextMenuElem: function(menuItem, menuType)
    		{
    			if (typeof menuType === 'string')
    				menuType = [menuType];

    			for (var i = 0; i < menuType.length; i++)
    			{
    				_menuItems[menuType[i]] = _menuItems[menuType[i]] || [];
    				_menuItems[menuType[i]].push(menuItem);
    			}
    		},

    		/**
    		 * Добавляет к DOM элементу контекстное меню
    		 * @function
             * @memberOf nsGmx.ContextMenuController
    		 * @param {DOMElement} elem Целевой DOM-элемент
    		 * @param {String} type Тип меню
    		 * @param {function():Boolean} checkFunc Проверка, показывать ли сейчас меню. Если ф-ция возвращает false, меню не показывается
    		 * @param {Object|function(context):Object} context Контекст, который будет передан в элемент меню при клике на DOM-элементе.
    		 *        Если контект - ф-ция, она будет вызвана непосредственно при клике. В контекст при клике будут добавлены элементы contentMenuArea и contentMenuType.
    		 */
    		bindMenuToElem: function(elem, type, checkFunc, context)
    		{
    			_context(elem, function()
    			{
    				if (typeof context === 'function')
    					context = context(); //

    				return _generateMenuDiv(type, context);
    			}, checkFunc, SUGGEST_TIMEOUT);
    		}
    	}
    })();


    /** Интерфейс для задания контекстного меню пользователей
    * @class
    * @name nsGmx.ContextMenuController.IContextMenuElem
    */

    /** Нужно ли отображать данный пункт меню для данного элемента и типа дерева. Необязательная (по умолчанию отображается)
    @function
    @name isVisible
    @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
    @param {Object} context - контекст, специфический для конкретного типа меню
    */

    /** Нужно ли рисовать перед данным пунктом разделитель (гориз. черту). Необязательная (по умолчанию не рисуется)
    @function
    @name isSeparatorBefore
    @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
    @param {Object} context - контекст, специфический для конкретного типа меню
    */

    /** Вызывается при клике по соответствующему пункту меню
    * @function
    * @name clickCallback
    * @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
    * @param {object} context - контекст, который был передан при привязке меню к DOM-элементу. В контекст будут добавлены поля:
    *
    *  * contentMenuArea {Object} - координаты верхнего левого угла пункта меню, на которое было нажатие. {left: int, top: int}. Если нужно привязаться к месту текущего клика
    *  * contentMenuType {String}- тип вызванного контекстного меню. Актуально, если элемент меню используется в нескольких типах меню.
    */

    /** Строка или ф-ция, которую нужно отображать в контекстном меню. Если ф-ция, то она будет вызываться при каждом формировании меню и должна возвращать строку.
    @name title
    @memberOf nsGmx.ContextMenuController.IContextMenuElem.prototype
    */


    //Все заголовки элементов меню заданы как ф-ции, так как на момент выполенения этого кода неизвестен выбранный язык системы

    ///////////////////////////////////////////////////////////////////////////////
    /////////////////////////// Контекстное меню слоёв ////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    /*
    В контексте типа "Layer" присутствуют следующие атрибуты:
     * layerManagerFlag {int} Тип дерева
     * elem Элемент (слой), для которого стротся меню
     * tree {layersTree} Текущее дерево, внутри которого находится слой
    */

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Свойства"); },
    	isVisible: function(context)
    	{
    		return !context.layerManagerFlag && nsGmx$1.AuthManager.isLogin();
    	},
    	clickCallback: function(context)
    	{
    		var div;
    		if (context.elem.MultiLayerID)
    			div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];
    		else
    			div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];
    		_mapHelper.createLayerEditor(div, context.tree, 'main', div.gmxProperties.content.properties.styles.length > 1 ? -1 : 0);
    	}
    }, 'Layer');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Стили"); },
    	isVisible: function(context)
    	{
    		return !context.layerManagerFlag && context.elem.type === "Vector" && _queryMapLayers.currentMapRights() === "edit";
    	},
    	clickCallback: function(context)
    	{
            nsGmx$1.createStylesDialog(context.elem, context.tree);
    	}
    }, 'Layer');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Таблица атрибутов"); },
    	isVisible: function(context)
    	{
    		return !nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_UNAUTHORIZED) && !context.layerManagerFlag && (_queryMapLayers.currentMapRights() === "edit" || _queryMapLayers.layerRights(context.elem.name) == 'view' || _queryMapLayers.layerRights(context.elem.name) == 'edit' || _queryMapLayers.layerRights(context.elem.name) === 'editrows') && context.elem.type === "Vector";
    	},
    	clickCallback: function(context)
    	{
    		nsGmx$1.createAttributesTable(context.elem.name);
    	}
    }, 'Layer');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Права доступа"); },
    	isVisible: function(context)
    	{
    		return !context.layerManagerFlag &&
    				nsGmx$1.AuthManager.canDoAction( nsGmx$1.ACTION_SEE_MAP_RIGHTS ) &&
    				_queryMapLayers.layerRights(context.elem.name) === 'edit';
    	},
    	clickCallback: function(context) {
    		if (context.elem.MultiLayerID) {
                var securityDialog = new nsGmx$1.multiLayerSecurity();
    			securityDialog.getRights(context.elem.MultiLayerID, context.elem.title);
            } else {
                var securityDialog = new nsGmx$1.layerSecurity(context.elem.name);
    			securityDialog.getRights(context.elem.name, context.elem.title);
            }
    	}
    }, 'Layer');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Скачать"); },
    	isVisible: function(context)
    	{
    		return !context.layerManagerFlag &&
    				( _queryMapLayers.currentMapRights() === "edit" || (_queryMapLayers.currentMapRights() == "view" && nsGmx$1.AuthManager.isLogin() ) ) &&
    				context.elem.type == "Vector" &&
    				context.tree.treeModel.getMapProperties().CanDownloadVectors;
    	},
    	clickCallback: function(context)
    	{
    		_mapHelper.downloadVectorLayer({
                name: context.elem.name,
                host: context.elem.hostName
            });
    	}
    }, 'Layer');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Удалить"); },
    	isVisible: function(context)
    	{
    		return !context.layerManagerFlag && _queryMapLayers.currentMapRights() === "edit";
    	},
    	clickCallback: function(context)
    	{
    		_queryMapLayers.removeLayer(context.elem.name);

    		var div;

    		if (context.elem.MultiLayerID)
    			div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];
    		else
    			div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];

    		var treeElem = _layersTree.findTreeElem(div).elem,
    			node = div.parentNode,
    			parentTree = node.parentNode;

    		_layersTree.removeTreeElem(div);

    		node.removeNode(true);

    		_abstractTree.delNode(null, parentTree, parentTree.parentNode);

    		_mapHelper.updateUnloadEvent(true);
    	}
    }, 'Layer');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Добавить снимки"); },
    	isVisible: function(context)
    	{
            var layerRights = _queryMapLayers.layerRights(context.elem.name);
    		return !context.layerManagerFlag &&
                   (layerRights === 'edit' || layerRights === 'editrows') &&
                   context.elem.type == "Vector" &&
                   context.elem.IsRasterCatalog;
    	},
    	clickCallback: function(context)
    	{
            new nsGmx$1.RCAddLayerControl(nsGmx$1.gmxMap, context.elem.name);
    	}
    }, 'Layer');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Копировать стиль"); },
    	isVisible: function(context)
    	{
    		return context.elem.type == "Vector" &&
    		       (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
    	},
    	isSeparatorBefore: function(context)
    	{
    		return !context.layerManagerFlag;
    	},
    	clickCallback: function(context)
    	{
    		var rawTree = context.tree.treeModel,
                elem;
            if (context.elem.MultiLayerID)
    			elem = rawTree.findElem("MultiLayerID", context.elem.MultiLayerID).elem;
    		else
    			elem = rawTree.findElem("LayerID", context.elem.name).elem;

            nsGmx$1.ClipboardController.addItem('LayerStyle', {type: context.elem.GeometryType, style: elem.content.properties.styles});
    	}
    }, 'Layer');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Создать копию слоя"); },
    	isVisible: function(context)
    	{
    		return context.elem.type == "Vector" &&
    		       (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
    	},
    	isSeparatorBefore: function(context)
    	{
    		return false;
    	},
    	clickCallback: function(context)
    	{
    		sendCrossDomainJSONRequest(window.serverBase + "Layer/GetLayerInfo.ashx?WrapStyle=func&NeedAttrValues=false&LayerName=" + context.elem.name, function(response) {
    			if (!parseResponse(response)) {
    				return;
    			}

    			createEditorFromSelection(response.Result);

    			function createEditorFromSelection(props) {
    				var query = '';

    				var parent = nsGmx$1.Utils._div(null, [['attr','id','new' + 'Vector' + 'Layer'], ['css', 'height', '100%']]),
    					properties = {
    						Title:  props.Title + ' ' + _gtxt('копия'),
    						Copyright: props.Copyright,
    						Description: props.Description,
    						Date: props.Date,
    						MetaProperties: props.MetaProperties,
    						TilePath: {
    							Path: ''
    						},
    						ShapePath: props.ShapePath,
    						Columns: props.Columns,
    						IsRasterCatalog: props.IsRasterCatalog,
    						SourceType: "sql",
    						Quicklook: props.Quicklook
    					},
    					dialogDiv = nsGmx$1.Utils.showDialog(_gtxt('Создать векторный слой'), parent, 340, 340, false, false),
    					params = {
    						copy: true,
    						sourceLayerName: context.elem.name,
    						query: query,
    						doneCallback: function(res) {
    							nsGmx$1.Utils.removeDialog(dialogDiv);
    						}
    					};

    				nsGmx$1.createLayerEditor(false, 'Vector', parent, properties, params);
    			}
    		});
    	}
    }, 'Layer');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Вставить объекты"); },
    	isVisible: function(context)
    	{
    		return context.elem.type == "Vector" &&
    		       (context.layerManagerFlag || _queryMapLayers.currentMapRights() === "edit");
    	},
    	isSeparatorBefore: function(context)
    	{
    		return false;
    	},
    	clickCallback: function(context)
    	{
    		var copyLayerParams = nsGmx$1.ClipboardController.get('CopyObjects', -1),
    			copyLayerName = copyLayerParams.layerName,
    			copyLayerQuery = copyLayerParams.query,
    			list = copyLayerParams.list || '';

    		var url = window.serverBase +
    			"VectorLayer/Append?LayerName=" + context.elem.name +
    			"&FromLayer=" + copyLayerName +
    			"&Query=" + copyLayerQuery;

    		var  def = nsGmx$1.asyncTaskManager.sendGmxPostRequest(url);

    		def.done(function(taskInfo){
    			showErrorMessage(list, true, window._gtxt('Объекты добавлены'));
            }).fail(function(taskInfo){
    			showErrorMessage(window._gtxt('Вставить объекты не удалось'), true);
    			// console.log(taskInfo);
            }).progress(function(taskInfo){
    			// console.log(taskInfo);
            });
    	}
    }, 'Layer');

    var applyStyleContentMenuItem = {
    	title: function() { return _gtxt("Применить стиль"); },
    	isVisible: function(context)
    	{
            if (context.layerManagerFlag ||
                _queryMapLayers.currentMapRights() !== "edit" ||
                nsGmx$1.ClipboardController.getCount('LayerStyle') === 0 )
            {
                return false;
            }

            if (context.contentMenuType === 'Layer') {
                return context.elem.type == "Vector" &&
                    nsGmx$1.ClipboardController.get('LayerStyle', -1).type === context.elem.GeometryType;
            } else { //группы
                return true;
            }
    	},
    	clickCallback: function(context)
    	{
    		var
                newStyles = nsGmx$1.ClipboardController.get('LayerStyle', -1).style,
                stylesType = nsGmx$1.ClipboardController.get('LayerStyle', -1).type;

    		if (context.contentMenuType === 'Layer') {
                var div;
                if (context.elem.MultiLayerID)
                    div = $(_queryMapLayers.buildedTree).find("div[MultiLayerID='" + context.elem.MultiLayerID + "']")[0];
                else
                    div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + context.elem.name + "']")[0];

                div.gmxProperties.content.properties.styles = newStyles;

                _mapHelper.updateMapStyles(newStyles, context.elem.name);

                _mapHelper.updateTreeStyles(newStyles, div, context.tree, true);
            } else { //группа
                var tree = context.tree.treeModel,
                    node = tree.findElemByGmxProperties(context.div.gmxProperties).elem;

                tree.forEachLayer(function(layerContent) {
                    if (layerContent.properties.type !== "Vector" || layerContent.properties.GeometryType !== stylesType){
                        return;
                    }
                    layerContent.properties.styles = newStyles;
                    _mapHelper.updateMapStyles(newStyles, layerContent.properties.name);

                    var div = context.tree.findUITreeElem({content: layerContent});
                    if (div) {
                        // div.gmxProperties.content.properties.styles = newStyles;
                        _mapHelper.updateTreeStyles(newStyles, div, context.tree, true);
                    }
                }, node);
            }
    	}
    };

    nsGmx$1.ContextMenuController.addContextMenuElem(applyStyleContentMenuItem, 'Layer');

    ///////////////////////////////////////////////////////////////////////////////
    /////////////////////////// Контекстное меню групп ////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    /*
    В контексте типа "Group" присутствуют следующие атрибуты:
     * div {DOMElement} Элемент дерева, для которого стротся меню
     * tree {layersTree} Текущее дерево карты
    */

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Свойства"); },
    	clickCallback: function(context)
    	{
    		nsGmx$1.createGroupEditor(context.div);
    	}
    }, 'Group');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Добавить подгруппу"); },
    	clickCallback: function(context)
    	{
    		nsGmx$1.addSubGroup(context.div, context.tree);
    	}
    }, 'Group');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Удалить"); },
    	clickCallback: function(context)
    	{
    		context.tree.removeGroup(context.div);
    		_mapHelper.updateUnloadEvent(true);
    	}
    }, 'Group');

    nsGmx$1.ContextMenuController.addContextMenuElem(applyStyleContentMenuItem, 'Group');
    ///////////////////////////////////////////////////////////////////////////////
    /////////////////////////// Контекстное меню карты ////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    /*
    В контексте типа "Map" присутствуют следующие атрибуты:
     * div {DOMElement} Элемент дерева, для которого стротся меню
     * tree {layersTree} Текущее дерево карты
    */
    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Свойства"); },
    	clickCallback: function(context)
    	{
    		nsGmx$1.createMapEditor(context.div);
    	}
    }, 'Map');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Добавить подгруппу"); },
    	clickCallback: function(context)
    	{
    		nsGmx$1.addSubGroup(context.div, context.tree);
    	}
    }, 'Map');

    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Права доступа"); },
    	clickCallback: function(context)
    	{
            var securityDialog = new nsGmx$1.mapSecurity();
    		securityDialog.getRights(context.tree.treeModel.getMapProperties().MapID, context.tree.treeModel.getMapProperties().title);
    	},
    	isVisible: function(context)
    	{
    		return nsGmx$1.AuthManager.canDoAction(nsGmx$1.ACTION_SEE_MAP_RIGHTS) &&
                (_queryMapLayers.currentMapRights() === "edit" || nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN));
    	}
    }, 'Map');

    //групповое редактирование слоев
    nsGmx$1.ContextMenuController.addContextMenuElem({
    	title: function() { return _gtxt("Права доступа к слоям"); },
    	isVisible: function(context)
    	{
    		var treeModel = context.tree.treeModel,
    			layersFlag = false,
    			layersRights = false;
    		treeModel.forEachNode(function (node) {
    			if (node.type !== 'group') {
    				layersFlag = true;
    				if (_queryMapLayers.layerRights(node.content.properties.LayerID) === 'edit') {
    					layersRights = true;
    				}
    			}
    		});

    		return nsGmx$1.AuthManager.canDoAction( nsGmx$1.ACTION_SEE_MAP_RIGHTS ) &&
    			layersFlag &&
    			layersRights;
    	},
    	clickCallback: function(context) {
            var securityDialog = new nsGmx$1.layersGroupSecurity(),
    			props = _layersTree.treeModel.getMapProperties();
    		securityDialog.getRights(props.MapID, props.title);

    	}
    }, 'Map');

    })();

    nsGmx$1.GeomixerFrameworkVersion = '05.12.2018';

    !(function($, _) {

    var modulePath = "";

    //TODO: вынести переключалку страниц в отдельный модуль
    var appendTranslations = function()
    {
        _translationsHash.addtext("rus", {
            "Следующие [value0] страниц" : "Следующие [value0] страниц",
            "Предыдущие [value0] страниц" : "Предыдущие [value0] страниц",
            "Первая страница" : "Первая страница",
            "Последняя страница" : "Последняя страница"
        });

        _translationsHash.addtext("eng", {
            "Следующие [value0] страниц" : "Next [value0] pages",
            "Предыдущие [value0] страниц" : "Previous [value0] pages",
            "Первая страница" : "First page",
            "Последняя страница" : "Last page"
        });
    };

    /** Интерфейс провайдера данных таблицы {@link nsGmx.ScrollTable}
     * @class nsGmx.ScrollTable.IDataProvider
     * @abstract
     */

    /** Получить общее количество объектов
      @method nsGmx.ScrollTable.IDataProvider#getCount
      @param {function(Number)} callback Ф-ция, которую нужно вызвать с общим количеством объектов
    */

    /** Это событие должно генерироваться при любом изменении набора данных. Приведёт к перерисовке таблицы
      @event nsGmx.ScrollTable.IDataProvider#change
    */

    /** Получить массив объектов для отрисовки на странице
      @method nsGmx.ScrollTable.IDataProvider#getItems
      @param {Number} page Номер страницы (нумерация с нуля)
      @param {Number} pageSize Размер страницы
      @param {String} sortParam По какому атрибуту сортировать
      @param {Boolean} sortDec Направление сортировки (true - по убыванию)
      @param {function(Array)} callback Ф-ция, которую нужно вызвать с результирующим массивом объектов. Структура самих объектов определяется провайдером
    */

    /** Получить массив объектов для отрисовки на страницы и общее количество данных за один запрос.
        Альтернатива раздельным запросам getItems() и getCount(). Можно реализовать либо эту ф-цию, либо две другие
      @method nsGmx.ScrollTable.IDataProvider#getCountAndItems
      @param {Number} page Номер страницы (нумерация с нуля)
      @param {Number} pageSize Размер страницы
      @param {String} sortParam По какому атрибуту сортировать
      @param {Boolean} sortDec Направление сортировки (true - по убыванию)
      @param {function(count:Number, objs:Object[])} callback Ф-ция, которую нужно вызвать с полученным результатом.
             Первый параметр - общее количество объектов, второй - массив объектов для данной страницы.
    */

    /** Таблица с разбиением данных по страницам. Сильно кастомизируемый виджет. Поддерживает различные провайдеры данных и рендереры.
     * @class
     * @alias nsGmx.ScrollTable
     */
    var scrollTable = function( params )
    {
        /** Перед перерисовкой данных
         * @event nsGmx.ScrollTable#beforeRedraw
         */

        /** После перерисовки данных
         * @event nsGmx.ScrollTable#redraw
         */

        /** Изменились параметры сортировки
         * @event nsGmx.ScrollTable#sortChange
         */

        this._params = $.extend(
        {
            limit: 50,
            page: 0,
            pagesCount: 10,
            height: '',
            showFooter: true
        }, params);

    	this.limit = this._params.limit;
    	this.pagesCount = this._params.pagesCount;

    	this.start = 0;
    	this.reportStart = 0;

    	this.drawFunc = null;

        this._requestID = 0;
        this._pageVals = [];
        this._currValsCount = 0;

        this._dataProvider = null;

    	 // Переход на предыдущую страницу
    	this.next = function()
    	{
    		var _this = this,
    			button = makeImageButton$1(modulePath + 'img/next.png', modulePath + 'img/next_a.png');

    		button.style.marginBottom = '-7px';

    		button.onclick = function()
    		{
    			_this.start += _this.pagesCount;
    			_this.reportStart = _this.start * _this.limit;

    			_this._drawPagesRow();

    			_this.tableBody.scrollTop = 0;
    			_this.tableParent.scrollTop = 0;
    		};

    		_title$1(button, _gtxt('Следующие [value0] страниц', _this.pagesCount));

    		return button;
    	};

    	// Переход на следующую страницу
    	this.previous = function()
    	{
    		var _this = this,
    			button = makeImageButton$1(modulePath + 'img/prev.png', modulePath + 'img/prev_a.png');

    		button.style.marginBottom = '-7px';

    		button.onclick = function()
    		{
    			_this.start -= _this.pagesCount;
    			_this.reportStart = _this.start * _this.limit;

    			_this._drawPagesRow();

    			_this.tableBody.scrollTop = 0;
    			_this.tableParent.scrollTop = 0;
    		};

    		_title$1(button, _gtxt('Предыдущие [value0] страниц', _this.pagesCount));

    		return button;
    	};

    	// Переход на первую страницу
    	this.first = function()
    	{
    		var _this = this,
    			button = makeImageButton$1(modulePath + 'img/first.png', modulePath + 'img/first_a.png');

    		button.style.marginBottom = '-7px';

    		button.onclick = function()
    		{
    			_this.start = 0;
    			_this.reportStart = _this.start * _this.limit;

    			_this._drawPagesRow();

    			_this.tableBody.scrollTop = 0;
    			_this.tableParent.scrollTop = 0;
    		};

    		_title$1(button, _gtxt('Первая страница'));

    		return button;
    	};

    	// Переход на последнюю страницу
    	this.last = function()
    	{
    		var _this = this,
    			button = makeImageButton$1(modulePath + 'img/last.png', modulePath + 'img/last_a.png');

    		button.style.marginBottom = '-7px';

    		button.onclick = function()
    		{
    			_this.start = Math.floor(_this._currValsCount / (_this.pagesCount * _this.limit)) * _this.pagesCount;
    			_this.reportStart = Math.floor(_this._currValsCount / _this.limit) * _this.limit;

    			_this._drawPagesRow();

    			_this.tableBody.scrollTop = 0;
    			_this.tableParent.scrollTop = 0;
    		};

    		_title$1(button, _gtxt('Последняя страница'));

    		return button;
    	};

        var _this = this;
        this._status = {
            _state: false,
            start: function() {
                this._state = true;
                var me = this;
                setTimeout(function() {
                    if (me._state) {
                        $(_this.statusContainer).siblings().hide();
                        $(_this.statusContainer).show();
                    }
                }, 100);
            },
            stop: function() {
                $(_this.statusContainer).siblings().show();
                $(_this.statusContainer).hide();
                this._state = false;
            }
        };

    	this.limitSel = nsGmx$1.Utils._select([_option$1([_t("10")], [['attr','value',10]]),
    							 _option$1([_t("20")], [['attr','value',20]]),
    							 _option$1([_t("50")], [['attr','value',50]]),
    							 _option$1([_t("100")], [['attr','value',100]]),
    							 _option$1([_t("200")], [['attr','value',200]]),
    							 _option$1([_t("500")], [['attr','value',500]])], [['dir','className','selectStyle floatRight'], ['css','width','60px']]);
    };

    /** Установка провайдера данных
     @param {nsGmx.ScrollTable.IDataProvider} dataProvider Провайдер данных
     */
    scrollTable.prototype.setDataProvider = function( dataProvider )
    {
        this._dataProvider = dataProvider;
        this._drawTable();
    };

    /** Получить текущий провайдер данных
     @return {nsGmx.ScrollTable.IDataProvider} Текущий провайдер данных
     */
    scrollTable.prototype.getDataProvider = function()
    {
        return this._dataProvider;
    };

    /** Изменить активность (видимость) колонки в таблице
      @param {String} name имя колонки
      @param {Boolean} isActive активность (видимость) колонки
    */
    scrollTable.prototype.activateField = function(name, isActive)
    {
        for (var f = 0; f < this._fields.length; f++)
            if (this._fields[f].title == name)
            {
                if (this._fields[f].isActive == isActive)
                    return;

                this._fields[f].isActive = isActive;

                this._drawHeader();
                this._drawRows();
            }
    };

    scrollTable.prototype._getActiveFields = function()
    {
        var res = [];
        for (var f = 0; f < this._fields.length; f++)
            if (this._fields[f].isActive)
                res.push(this._fields[f].title);

        return res;
    };

    scrollTable.prototype._drawRows = function()
    {
    	var trs = [],
            tr;

        $(this).triggerHandler('beforeRedraw');

    	$(this.tableBody).empty();

        var activeFields = this._getActiveFields();

    	for (var i = 0; i < this._pageVals.length; i++)
        {
            tr = this.drawFunc(this._pageVals[i], i, activeFields);
    		tr && trs.push(tr);
        }

    	_(this.tableBody, trs);

    	if (this._pageVals.length == 0)
    		_(this.tableBody, [_tr$1(null,[['css','height','1px'],['attr','empty', true]])]);

    	$(this.tableCount).empty();

        this.statusContainer = _div(null, [['dir', 'className', 'fileBrowser-progress'], ['css', 'display', 'none']]);

    	if (this._currValsCount) {
    		var cntStr = this._currValsCount === 100001 ? 'более 100000' : this._currValsCount;
    		_(this.tableCount, [_span([
                _t((this.reportStart + 1) + '-' + (Math.min(this.reportStart + this.limit, this._currValsCount))),
                _span([_t(' ')],[['css','margin','0px 3px']]),
                _t("(" + cntStr + ")")
            ]), this.statusContainer]);
        }
    	else {
    		_(this.tableCount, [_span([_t("0-0"), _span([_t(' ')],[['css','margin','0px 3px']]), _t("(0)")]), this.statusContainer]);
        }

        $(this).triggerHandler('redraw');
    };

    scrollTable.prototype._drawPages = function(end)
    {
    	var _this = this;
    	for (var i = this.start + 1; i<= end; i++)
    	{
    		// текущий элемент
     		if (i - 1 == this.reportStart/this.limit)
     		{
    		    var el = _span([_t(i.toString())]);
    			_(_this.tablePages, [el]);
    			$(el).addClass('page');
    		}
    		else
    		{
    			var link = makeLinkButton$1(i.toString());

    			link.setAttribute('page', i - 1);
    			link.style.margin = '0px 2px';

    			_(_this.tablePages, [link]);

    			link.onclick = function()
    			{
    				_this.reportStart = this.getAttribute('page') * _this.limit;

    				_this._drawPagesRow();

    				// мозилла
    				_this.tableBody.scrollTop = 0;
    				// ие
    				_this.tableParent.scrollTop = 0;
    			};
    		}
    	}
    };

    scrollTable.prototype._updatePageData = function(callback)
    {
        var _this = this;

        if (this._dataProvider.getCountAndItems)
        {
            var requestID = this._requestID++;
            this._status.start();
            _this._dataProvider.getCountAndItems(
                _this.reportStart / _this.limit,
                _this.limit,
                _this.currentSortType,
                _this.currentSortIndex[_this.currentSortType] == 1,
                function(count, values)
                {
                    if (requestID !== _this._requestID - 1) {
                        _this._status.stop();
                        return;
                    }

                    _this._currValsCount = count;


                    //если данных стало слишком мало, мы встанем на первую страницу и перезапросим данные ещё раз
                    if (_this.reportStart > _this._currValsCount)
                    {
                        requestID = _this._requestID++;

                        _this.start = _this.reportStart = 0; //на первую страницу

                        _this._dataProvider.getCountAndItems(
                            _this.reportStart / _this.limit,
                            _this.limit,
                            _this.currentSortType,
                            _this.currentSortIndex[_this.currentSortType] == 1,
                            function(count, values)
                            {
                                _this._status.stop();
                                if (requestID !== _this._requestID - 1)
                                    return;

                                _this._pageVals = values;
                                callback();
                            }
                        );
                    }
                    else
                    {
                        _this._status.stop();
                        _this._pageVals = values;
                        callback();
                    }
                }
            );
        }
        else
        {
            this._status.start();
            this._dataProvider.getCount(function(count)
            {
                _this._currValsCount = count;

                //вообще-то при обновлении данных мы не изменяем текущей страницы
                //однако если данных стало слишком мало, то текущую страницу сохранить нельзя,
                //и мы переключимся на первую
                if (_this.reportStart >= _this._currValsCount)
                {
                    _this.start = _this.reportStart = 0;
                }

                _this._dataProvider.getItems(
                    _this.reportStart / _this.limit,
                    _this.limit,
                    _this.currentSortType,
                    _this.currentSortIndex[_this.currentSortType] == 1,
                    function(values)
                    {
                        _this._status.stop();
                        _this._pageVals = values || [];
                        callback();
                    }
                );
            });
        }
    };

    scrollTable.prototype._drawPagesRow = function()
    {
        var _this = this;
        this._updatePageData(function()
        {
            // перерисовывем номера страниц
            $(_this.tablePages).empty();

            if (_this._currValsCount > _this.limit)
            {
                var allPages = Math.ceil(_this._currValsCount / _this.limit);

                var end = (_this.start + _this.pagesCount <= allPages) ? _this.start + _this.pagesCount : allPages;

                if (_this.start - _this.pagesCount >= 0)
                    _(_this.tablePages,[_this.first(), _this.previous()]);

                _this._drawPages(end);

                if (end + 1 <= allPages)
                    _(_this.tablePages,[_this.next(), _this.last()]);
            }

            _this._drawRows();
        });

    };

    scrollTable.prototype._drawHeader = function()
    {
        var tds = [],
            _this = this;

        var headerElemFactory = this._isWidthScroll ? _th : _td;

        this._fields.forEach(function(field) {
            if (!field.isActive)
                return;

            var title = field.title,
                button;

    		if (title != '' && field.isSortable)
    		{
    			button = makeLinkButton$1(title);

    			button.sortType = title;
    		}
    		else
    			button = _t(title);

            var td = headerElemFactory([button], [['css','width',field.width]]);

            if (field.isSortable) {
                $(td).click(function() {
                    _this.setSortParams(title, 1 - _this.currentSortIndex[title]);
                });
            }

    		tds.push(td);
        });

        $(this._tableHeaderRow).empty();
        _(this._tableHeaderRow, tds);
    };

    //Если baseWidth == 0, таблица растягивается на весь контейнер по ширине

    /** Нарисовать таблицу
    * @param {Object} params
    * @param {DOMElement} params.parent Контейнер для помещения результата отрисовки
    * @param {String} params.name Уникальное имя таблицы
    * @param {Number} [params.baseWidth] Какой ширины должна быть таблица. Если не указано, будет занимать 100% контейнера
    * @param {String[]} params.fields массив имён колонок
    * @param {String[]} params.fieldsWidths массив с описанием ширины колонок. Описание даётся в терминах css
    * @param {function} params.drawFunc Ф-ция отрисовки одной строки таблицы. На вход - объект для отрисовки (полученный от провайдера). На выходе - "tr" элемент
    * @param {Object} [params.sortableFields] Хеш для указания возможности сортировки колонок (будет включена для всех ключей хеша)
    * @param {Boolean} [params.isWidthScroll] Трубется ли возможность прокрутки данных по горизонтали
    */
    scrollTable.prototype.createTable = function(parent, name, baseWidth, fields, fieldsWidths, drawFunc, sortableFields, isWidthScroll)
    {
        var params = null;
        //передача параметров в виде структуры
        if (arguments.length === 1)
        {
            params = $.extend(true, {
                sortableFields: {}
            }, parent);
        }
        else
        {
            params = {
                parent: parent,
                name: name,
                baseWidth: baseWidth,
                fields: fields,
                fieldsWidths: fieldsWidths,
                drawFunc: drawFunc,
                sortableFields: sortableFields,
                isWidthScroll: isWidthScroll
            };
        }

        var name = params.name;

    	var _this = this;
        this._isWidthScroll = params.isWidthScroll;

        this._fields = [];
        for (var f = 0; f < params.fields.length; f++)
            this._fields.push({
                title: params.fields[f],
                width: params.fieldsWidths[f],
                isSortable: params.fields[f] in params.sortableFields,
                isActive: true
            });


    	this.limitSel = switchSelect(this.limitSel,  this.limit);

    	this.limitSel.onchange = function()
    	{
    		_this.limit = Number(this.value);

    		_this.start = 0;
    		_this.reportStart = _this.start * _this.limit;

    		_this._drawTable();
    	};

    	this.tableCount = _div();
    	this.tableLimit = _div([this.limitSel]);
    	this.tablePages = _div(null,[['dir','className','tablePages']]);

        this.tableBody = _tbody(null,[['attr','id',name + 'TableBody']]);


        this._tableHeaderRow = _tr$1();
        if (this._isWidthScroll)
        {
            this.tableHeader = _thead([this._tableHeaderRow], [['attr','id',name + 'TableHeader'], ['dir','className','tableHeader']]);
        }
        else
        {
            //как формировать фиксированный заголовок таблицы, зависит от того, будет ли у таблицы фиксированный размер или нет
            //TODO: убрать возможность задавать фиксированный размер
            if ( params.baseWidth )
                this.tableHeader = _tbody([this._tableHeaderRow],[['attr','id',name + 'TableHeader']]);
            else
                this.tableHeader = _tbody([_tr$1([_td([_table([_tbody([this._tableHeaderRow])])]), _td(null, [['css', 'width', '20px']])])], [['attr','id',name + 'TableHeader']]);
        }

        this._drawHeader();

        if (this._isWidthScroll)
        {
            this.tableParent = _div([_table([this.tableHeader, this.tableBody], [['css', 'width', '100%']])],
                                    [['attr','id',name + 'TableParent'],['dir','className','scrollTable'],['css','width', baseWidth ? baseWidth + 'px' : "100%"], ['css', 'height', this._params.height], ['css', 'overflow', 'auto']]);
        }
        else
        {
            this.tableParent = _div([
                                    _div([_table([this.tableHeader])],[['dir','className','tableHeader']]),
                                    _div([_table([this.tableBody])],[['dir','className','tableBody'],['css', 'height', this._params.height ? (this._params.height - 20) + 'px' : ''], ['css','width', params.baseWidth ? params.baseWidth + 20 + 'px' : "100%"]])
                                ],[['attr','id',name + 'TableParent'],['dir','className','scrollTable'], ['css', 'height', this._params.height ? this._params.height + 'px' : ''], ['css','width', params.baseWidth ? params.baseWidth + 'px' : "100%"]]);
        }

    	_(params.parent, [this.tableParent]);

        if (this._params.showFooter)
            _(params.parent, [_table([_tbody([_tr$1([_td([this.tableCount], [['css','width','20%']]), _td([this.tablePages]), _td([this.tableLimit], [['css','width','20%']])])])], [['css','width','100%']])]);


    	this.drawFunc = params.drawFunc;
    	this.start = 0;         //Первый номер страницы, показываемый на экране (это не текущая страница!)
    	this.reportStart = 0;   //Первый номер элемента на текущей странице

    	this.currentSortType = null;
    	// сортировка по умолчанию
    	for (var name in params.sortableFields)
    	{
    		this.currentSortType = name;

    		break;
    	}

    	this.currentSortIndex = {};
    	for (var name in params.sortableFields)
    	{
    		this.currentSortIndex[name] = 0;
    	}

        if (!this._dataProvider)
            this.setDataProvider(new scrollTable.StaticDataProvider());

        $(this._dataProvider).change(function()
        {
            _this._drawTable();
        });
        this._drawTable();
    };

    scrollTable.prototype.updateHeight = function( height )
    {
        if (this._isWidthScroll)
        {
            this.tableParent.style.height = (height - 40) + 'px';
        }
        else
        {
            $(this.tableParent).find('.tableBody').height(height - 20);
            $(this.tableParent).height(height);
        }
    };

    scrollTable.prototype._drawTable = function()
    {
        if (!this.tableBody) return; //ещё не создана таблица
        this._drawPagesRow();
    };

    /** Выбрать страницу для показа
    @param {Number} page Номер страницы (нумерация с нуля)
    */
    scrollTable.prototype.setPage = function(iPage)
    {
    	if (this.limit*iPage >= this._currValsCount || iPage < 0 || this.reportStart == iPage * this.limit)
    		return;

    	this.reportStart = iPage * this.limit;
    	this.start = Math.floor(iPage/this.pagesCount) * this.pagesCount;

    	this._drawPagesRow();

    	this.tableBody.scrollTop = 0;
    	this.tableParent.scrollTop = 0;
    };

    /** Получить массив объектов, которые нарисованы в данный момент
     @return {Array} массив объектов в формате провайдера данных
    */
    scrollTable.prototype.getVisibleItems = function()
    {
        return this._pageVals;
    };

    /** Задать параметры сортровки
     @param {String} sortType Имя колонки для сортировки
     @param {Boolean} sortDirection Направление сортровки (false - по возрастанию, true - по убыванию)
    */
    scrollTable.prototype.setSortParams = function(sortType, sortDirection)
    {
        this.currentSortType = sortType;
        this.currentSortIndex[this.currentSortType] = sortDirection;

        this.start = 0;
        this.reportStart = this.start * this.limit;

        this._drawTable();

        $(this).triggerHandler('sortChange');
    };

    /** Получить текущее направление сортировки.
     @return {Boolean} false - по возрастанию, true - по убыванию
    */
    scrollTable.prototype.getSortDirection = function()
    {
        return this.currentSortIndex[this.currentSortType] == 1
    };

    /** Получить по какой колонке происходит сортровка
     @return Имя колонки
    */
    scrollTable.prototype.getSortType = function()
    {
        return this.currentSortType;
    };

    /** Перерисовать текущую страницу без перезапроса данных у провайдера */
    scrollTable.prototype.repaint = function()
    {
        this._drawRows();
    };

    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////

    /** Провайдер данных для {@link nsGmx.ScrollTable}.
    * Хранит статический массив данных, умеет их фильтровать и упорядочивать.
    * @class
    * @extends nsGmx.ScrollTable.IDataProvider
    */
    scrollTable.StaticDataProvider = function( originalData )
    {
        var _vals = originalData || []; //исходный список элементов
        var _filteredVals = []; //список элементов после фильтрации. Валиден только если _isFiltered == true

        var _isFiltered = false;
        var _predicate = {}; //фильтры. Ф-ции predicate(name, value, items)->filteredItems
        var _filterVals = {}; //значения фильтров

        var _sortFunctions = {};
        var _this = this;

        var _filter = function()
        {
            if (_isFiltered) return;

            _filteredVals = _vals;

            for (var filterElem in _filterVals)
            {
                _filteredVals = _predicate[filterElem](filterElem, _filterVals[filterElem], _filteredVals);
            }

            _isFiltered = true;
        };

        var _update = function()
        {
            _isFiltered = false;
            $(_this).change();
        };

        /** синхронный вариант getCount() */
        this.getCountDirect = function()
        {
            _filter();
            return _filteredVals.length;
        };

        /** синхронный вариант getItems() */
        this.getItemsDirect = function(page, pageSize, sortParam, sortDec)
        {
            var nMin = page*pageSize;
            var nMax = nMin + pageSize;
            _filter();
            var sortDirIndex = sortDec ? 1 : 0;
            var sortedVals;

            if (_sortFunctions[sortParam])
            {
                if (typeof _sortFunctions[sortParam] === 'function') //если нет ф-ции для сортировки в обратном порядке, инвертируем прямую ф-цию
                    sortedVals = _filteredVals.sort(function(a, b) { return (1-2*sortDirIndex) * _sortFunctions[sortParam](a, b); });
                else
                    sortedVals = _filteredVals.sort(_sortFunctions[sortParam][sortDirIndex]);
            }
            else
                sortedVals = _filteredVals;

            nMin = Math.min(Math.max(nMin, 0), sortedVals.length);
            nMax = Math.min(Math.max(nMax, 0), sortedVals.length);
            return sortedVals.slice(nMin, nMax);
        };

        //IDataProvider interface
        this.getCount = function(callback)
        {
            callback(this.getCountDirect());
        };

        this.getItems = function(page, pageSize, sortParam, sortDec, callback)
        {
            callback(this.getItemsDirect(page, pageSize, sortParam, sortDec, callback));
        };

        /** задание исходных данных */
        this.setOriginalItems = function(items)
        {
            _vals = items;
            _update();
        };

        /** получение исходных данных */
        this.getOriginalItems = function()
        {
            return _vals;
        };

        /** Фильтруем исходные данные
        * @param {function(val:Object):Boolean} filterFunction ф-ция для фильтрации. На вход принимает элемент массива данных, возвращает false, если элемент отфильтровывается, иначе true
        */
        this.filterOriginalItems = function(filterFunction)
        {
            var newOrigData = [];
            for (var i = 0; i < _vals.length; i++)
                if (filterFunction(_vals[i]))
                    newOrigData.push(_vals[i]);

            _vals = newOrigData;
            _update();
        };

        /** Добавляем новый элемент в исходные данные */
        this.addOriginalItem = function(item)
        {
            _vals.push(item);
            _update();
        };

        /** Добавляем массив элементов в исходные данные */
        this.addOriginalItems = function(itemArr)
        {
            _vals = _vals.concat(itemArr);
            _update();
        };

        //фильтрация
        this.attachFilterEvents = function(inputField, fieldName, predicate)
        {

            _predicate[fieldName] = predicate;

            $(inputField).bind('keyup', function()
            {
                if (_filterVals[fieldName] !== this.value)
                {
                    _filterVals[fieldName] = this.value;
                    _update();
                }
            });

            _filterVals[fieldName] = inputField.value;
            _update();
        };

        /** Добавить ф-цию фильтрации исходных данных
            @param {String} fieldName Имя фильтра
            @param {function} predicate Ф-ция фильтрации: predicate(name, value, items)->filteredItems
        */
        this.addFilter = function(fieldName, predicate)
        {
            _predicate[fieldName] = predicate;
        };

        /** Установить значение для фильтра
            @param {String} fieldName Имя фильтра
            @param {String} value Значение для фильтрации
        */
        this.setFilterValue = function(fieldName, value)
        {
            _filterVals[fieldName] = value;
            _update();
        };

        this.attachSelectFilterEvents = function(selectField, fieldName, predicate)
        {

            _predicate[fieldName] = predicate;

            selectField.onchange = function()
            {
                _filterVals[fieldName] = this.value;
                _update();
            };

            _filterVals[fieldName] = selectField.value;
            _update();
        };

        /** Задать ф-ции сортировки
         @param {Object} sortFunctions Хеш из ф-ций {Имя столбца -> ф-ция или массив из двух ф-ций}.
            Если массив из двух ф-ций, то первая используется для сортировки по возрастанию, вторая - по убыванию.
            Если просто ф-ция, то по убыванию используется инвертная к ней.
            Формат ф-ции совпадает с ф-цией для sort().
        */
        this.setSortFunctions = function(sortFunctions)
        {
            _sortFunctions = sortFunctions;
        };
    };

    // простое стравнение по атрибутам объекта.
    // Использование: genAttrSort(func(a)->value), genAttrSort(attrName), genAttrSort(attrName1, attrName2)
    scrollTable.StaticDataProvider.genAttrSort = function(attrName1, attrName2)
    {
        if (typeof attrName1 === 'function')
        {
            return function(a, b) {
                var av = attrName1(a),
                    bv = attrName1(b);
                if (av > bv)      return 1;
                else if (av < bv) return -1;
                else              return 0;
            }
        }
        else if (attrName2)
        {
            return function(a, b) {
                var av = a[attrName1][attrName2];
                var bv = b[attrName1][attrName2];
                if (av > bv)      return 1;
                else if (av < bv) return -1;
                else              return 0;
            }
        } else {
            return function(a, b) {
                var av = a[attrName1];
                var bv = b[attrName1];
                if (av > bv)      return 1;
                else if (av < bv) return -1;
                else              return 0;
            }
        }
    };

    // //если есть вьюер, добавляем для него переменные в глобальный namespace
    // if ('nsGmx' in window && 'GeomixerFramework' in window.nsGmx)
    // {
        window.scrollTable = scrollTable; //Depricated - use nsGmx
        window.nsGmx.ScrollTable = scrollTable;
    // }

    if (typeof window.gmxCore !== 'undefined')
    {
        gmxCore.addModule("ScrollTableControl",
            {
                ScrollTable: scrollTable
            },
            {
                require: ['translations', 'utilities'],
                // css: 'table.css',
                init: function(module, path)
                {
                    modulePath = path || "";
                    appendTranslations();
                }
            }
        );
    }

    })(jQuery, nsGmx$1.Utils._);

    //рисует диалог со списком карт.
    //позволяет загрузить карту, просмотреть слои карты, перетащить слой в текущую карту
    !(function(_){

    nsGmx$1.MapsManagerControl = function()
    {
        var _this = this;
        this._activeIndex = 0;
        this._mapsTable = new nsGmx$1.ScrollTable();
        this._canvas = _div$1(null, [['attr','id','mapsList']]);
        this._mapPreview = null;
        
        $(this._canvas).append('<div class="gmx-icon-progress"></div>');
        
        this._dialogDiv = showDialog$1(_gtxt("Список карт"), this._canvas, 571, 360, 535, 130, this._resize.bind(this));
        
        sendCrossDomainJSONRequest$1(serverBase + "Map/GetMaps.ashx?WrapStyle=func", function(response)
        {
            $(_this._canvas).empty();
            
            if (!parseResponse(response))
                return;

            _this._drawMapsDialog(response.Result);
        });
        this._previewMapName = null;
    };

    nsGmx$1.MapsManagerControl.prototype._resize = function() {
        var canvas = this._canvas,
            mapsTable = this._mapsTable,
            mapPreview = this._mapPreview;
            
        var dialogWidth = canvas.parentNode.parentNode.offsetWidth;
        mapsTable.tableParent.style.width = dialogWidth - 15 - 21 + 'px';
        mapsTable.tableBody.parentNode.parentNode.style.width = dialogWidth + 5 - 21 + 'px';
        mapsTable.tableBody.parentNode.style.width = dialogWidth - 15 - 21 + 'px';

        mapsTable.tablePages.parentNode.parentNode.parentNode.parentNode.style.width = dialogWidth - 12 - 21 + 'px';

        mapsTable.tableParent.style.height = '200px';
        mapsTable.tableBody.parentNode.parentNode.style.height = '170px';
        
        if (mapPreview) {
            mapPreview.style.height = canvas.parentNode.offsetHeight - canvas.firstChild.offsetHeight - 250 + 'px';
            mapPreview.style.width = dialogWidth + 5 - 21 + 'px';
        }
    };

    nsGmx$1.MapsManagerControl.prototype._drawMapsDialog = function(mapsList)
    {
        var searchUITemplate = Handlebars.compile(
            '<div class="mapslist-search">' +
                '<table class="mapslist-search-table"><tr>' +
                    '<td>' +
                        '{{i "Название"}}<input class="inputStyle mapslist-search-name">' +
                    '</td><td>' +
                        '{{i "Владелец"}}<input class="inputStyle mapslist-search-owner">' +
                    '</td>' +
                '</tr></table>' +
            '</div>');
            
        var searchCanvas = $(searchUITemplate())[0];
    	var canvas = this._canvas,
    		name = 'maps',
            mapsTable = this._mapsTable,
    		_this = this;
    	
    	var mapNameInput = $('.mapslist-search-name', searchCanvas)[0],
            mapOwnerInput = $('.mapslist-search-owner', searchCanvas)[0];
    	_(canvas, [searchCanvas]);
    	
    	var tableParent = _div$1(),
    		sortFuncs = {};
    			
    	var sign = function(n1, n2) { return n1 < n2 ? -1 : (n1 > n2 ? 1 : 0) };
    	var sortFuncFactory = function(f1, f2) {
    		return [
    			function(_a,_b){ return sign(f1(_a), f1(_b)) || sign(f2(_a), f2(_b)); },
    			function(_b,_a){ return sign(f1(_a), f1(_b)) || sign(f2(_a), f2(_b)); }
    		]
    	};
    	
        var idFunc = function(_a){ return _a.Name; };
        var titleFunc = function(_a){ return String(_a.Title).toLowerCase(); };
        var ownerFunc = function(_a){ return String(_a.Owner).toLowerCase(); };
        var dateFunc  = function(_a){ return _a.LastModificationDateTime; };
        
    	sortFuncs[_gtxt('Имя')]                 = sortFuncFactory(titleFunc, idFunc);
    	sortFuncs[_gtxt('Владелец')]            = sortFuncFactory(ownerFunc, idFunc);
    	sortFuncs[_gtxt('Последнее изменение')] = sortFuncFactory(dateFunc, idFunc);
    	
    	mapsTable.createTable(tableParent, name, 410, ["", _gtxt("Имя"), _gtxt("Владелец"), _gtxt("Последнее изменение"), ""], ['5%', '55%', '15%', '15%', '5%'], function(map, i)
        {
            return _this._drawMaps.call(this, map, i, _this);
        }, sortFuncs);
        
        mapsTable.getDataProvider().setSortFunctions(sortFuncs);
    	
    	var inputPredicate = function(value, fieldValue)
        {
            return !!value && String(value).toLowerCase().indexOf(fieldValue) > -1;
        };

        $([mapNameInput, mapOwnerInput]).bind('keydown', function(event) {
            var numItems = mapsTable.getVisibleItems().length;
            
            if (event.keyCode === 13) {
                var firstItem = mapsTable.getVisibleItems()[_this._activeIndex];
                firstItem && window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + firstItem.Name);
            }
            
            if (event.keyCode === 38) {
                _this._activeIndex = Math.max(0, Math.min(_this._activeIndex - 1, numItems - 1));
                $(mapsTable.getDataProvider()).change();
                event.preventDefault();
            }
            
            if (event.keyCode === 40) {
                _this._activeIndex = Math.max(0, Math.min(_this._activeIndex + 1, numItems - 1));
                $(mapsTable.getDataProvider()).change();
                event.preventDefault();
            }
        });
        
    	mapsTable.getDataProvider().attachFilterEvents(mapNameInput, 'Title', function(fieldName, fieldValue, vals)
    	{
    		if (fieldValue == "") {
    			return vals;
            }
            
            fieldValue = fieldValue.toLowerCase();
    		
            return vals.filter(function(value) {
                return inputPredicate(value[fieldName], fieldValue) || value['Name'].toLowerCase() === fieldValue;
            });
    	});
    	
    	mapsTable.getDataProvider().attachFilterEvents(mapOwnerInput, 'Owner', function(fieldName, fieldValue, vals)
    	{
    		if (fieldValue == "") {
    			return vals;
            }
            
            fieldValue = fieldValue.toLowerCase();
            
            return vals.filter(function(value) {
                return inputPredicate(value[fieldName], fieldValue);
            });
    	});

    	_(canvas, [tableParent]);
    	
    	mapsTable.tableHeader.firstChild.childNodes[1].style.textAlign = 'left';

    	this._resize();
    	
    	mapsTable.getDataProvider().setOriginalItems(mapsList);
    	
    	mapNameInput.focus();
    };

    nsGmx$1.MapsManagerControl.prototype._drawMaps = function(map, mapIndex, mapsManager)
    {
    	var name = makeLinkButton$1(map.Title),
            img_url = map.Name === mapsManager._previewMapName ? 'img/collapse-arrow-se.png' : 'img/collapse-arrow-right.gif',
    		load = makeImageButton$1(img_url, img_url),
    		remove = makeImageButton$1("img/recycle.png", "img/recycle_a.png");

    	_title$1(name, _gtxt("Загрузить"));
    	_title$1(load, _gtxt("Показать"));
    	_title$1(remove, _gtxt("Удалить"));
    	
        name.className = name.className + ' maps-manager-mapname';
    	
    	name.onclick = function()
    	{
    		window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + map.Name);
    	};
        
        nsGmx$1.ContextMenuController.bindMenuToElem(name, 'MapListItem', function(){return true;},
        {
            name: map.Name
    	});
    	
    	load.onclick = function()
    	{
    		$(mapsManager._mapPreview).empty();
    		
    		var loading = _div$1([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]);
    		
            if (!mapsManager._mapPreview) {
                mapsManager._mapPreview = _div$1(null, [['css','marginTop','5px'],['css','borderTop','1px solid #216B9C'],['css','overflowY','auto']]);
                $(mapsManager._canvas).append(mapsManager._mapPreview);
                $(mapsManager._dialogDiv).dialog('option', 'height', 550);
                $(mapsManager._dialogDiv).dialog('option', 'minHeight', 550);
                mapsManager._resize();
                
            }
    		_(mapsManager._mapPreview, [loading]);
            

    		// раз уж мы список получили с сервера, то и карты из этого списка точно нужно загружать с него же...
    		mapsManager._loadMapJSON(window.serverBase, map.Name, mapsManager._mapPreview); 

            $(mapsManager._mapsTable.getDataProvider()).change();
    	};
    	
    	remove.onclick = function()
    	{
    		if (map.Name == defaultMapID)
    		{
    			showErrorMessage(_gtxt("$$phrase$$_14"), true);
    			
    			return;
    		}
    		
    		if (map.Name == globalMapName)
    		{
    			showErrorMessage(_gtxt("$$phrase$$_15"), true);
    			
    			return;
    		}
    		
    		if (confirm(_gtxt("Вы действительно хотите удалить эту карту?")))
    		{
    			var loading = loading = _div$1([_img(null, [['attr','src','img/progress.gif']]), _t(_gtxt('удаление...'))], [['css','marginLeft','5px']]);
    		
    			$(remove.parentNode.parentNode).replaceWith(_tr([_td([loading], [['attr','colSpan', 5]])]));
    			
    			sendCrossDomainJSONRequest$1(serverBase + "Map/Delete.ashx?WrapStyle=func&MapID=" + map.MapID, function(response){mapsManager._deleteMapHandler(response, map.MapID);});
    		}
    	};
    	
    	var date = new Date(map.LastModificationDateTime*1000);
    	var modificationDateString = $.datepicker.formatDate('dd.mm.yy', date); // + " " + date.getHours() + ":" + date.getMinutes() + ":" + date.getSeconds();
    	
    	var tr = _tr([
    		_td([load], [['css','textAlign','center']]), 
    		_td([name]), 
    		_td([_t(map.Owner)], [['css','textAlign','center'],['dir','className','invisible maps-manager-owner'], ['dir','title',map.Owner]]), 
    		_td([_t(modificationDateString)], [['css','textAlign','center'],['dir','className','invisible']]), 
    		_td([remove], [['css','textAlign','center']])
    	]);
    	
    	for (var i = 0; i < tr.childNodes.length; i++)
    		tr.childNodes[i].style.width = this._fields[i].width;
    	
    	attachEffects$1(tr, 'hover');
        
        if (mapsManager._activeIndex === mapIndex) {
            $(tr).addClass('maps-manager-active');
        }
    	
    	return tr;
    };

    nsGmx$1.MapsManagerControl.prototype._deleteMapHandler = function(response, id)
    {
    	if (!parseResponse(response))
    		return;
    	
        var mapsTable = this._mapsTable;
        
    	if (response.Result == 'deleted')
    	{
            mapsTable.start = 0;
    		mapsTable.reportStart = mapsTable.start * mapsTable.limit;
            mapsTable.getDataProvider().filterOriginalItems(function(elem)
    		{
    			return elem.MapID != id;
    		});
    	}
    	else
    		showErrorMessage(_gtxt("Ошибка!"), true, _gtxt("Слоя нет в базе"));
    };

    nsGmx$1.MapsManagerControl.prototype._loadMapJSON = function(host, name, parent)
    {
    	//loadMapJSON(host, name, function(layers)
        this._previewMapName = name;
        
        var hostName = L.gmxUtil.normalizeHostname(host),
            apiKey = window.mapsSite ? window.apiKey : null; //передаём apiKey только если не локальная версия ГеоМиксера
        
        L.gmx.gmxMapManager.getMap(hostName, apiKey, name, window.gmxSkipTiles).then(function(mapInfo) {
            var previewLayersTree = new layersTree({showVisibilityCheckbox: true, allowActive: false, allowDblClick: false}),
                ul = previewLayersTree.drawTree(mapInfo, 2);

            $(ul).treeview();

            //раскрываем группы по клику
            $(ul).click(function(event) {
                if ($(event.target).hasClass('groupLayer')) {
                    var clickDiv = $(event.target.parentNode.parentNode.parentNode).children("div.hitarea");
                    clickDiv.length && $(clickDiv[0]).trigger('click');
                }
            });
    		
    		$(parent).empty();
            
            var hint = $('<div class="mapslist-hint">' + _gtxt('maplist.hint') + '</div>');

    		_(parent, [hint[0], ul]);
    		
    		_queryMapLayers.addDraggable(parent);
    	});
    };

    nsGmx$1.ContextMenuController.addContextMenuElem({
        title: function() { return "Открыть в новом окне"; },
        clickCallback: function(context)
        {
            window.open(window.location.href.split(/\?|#/)[0] + "?" + context.name, '_blank');
        }
    }, 'MapListItem');

    })(nsGmx$1.Utils._);

    (function($){

    _translationsHash.addtext("rus", {
                            "pluginsEditor.selectedTitle" : "Плагины карты",
                            "pluginsEditor.availableTitle" : "Доступные плагины",
                            "pluginsEditor.add" : "Добавить плагин",
                            "pluginsEditor.paramsTitle" : "Параметры плагина"
                         });

    _translationsHash.addtext("eng", {
                            "pluginsEditor.selectedTitle" : "Map plugins",
                            "pluginsEditor.availableTitle" : "Available plugins",
                            "pluginsEditor.add" : "Add plugin",
                            "pluginsEditor.paramsTitle" : "Parameter of plugin"
                         });


    var MapPlugins = function()
    {
        var _plugins = [];
        var _params = {};

        //вместо массива из одного элемента передаём сам элемент
        var normalizeParams = function(params) {
            var res = {};
            for (var p in params) {
                res[p] = params[p].length === 1 ? params[p][0] : params[p];
            }

            return res;
        };

        this.addPlugin = function(pluginName, pluginParams, onlyParams)
        {
            _params[pluginName] = pluginParams || _params[pluginName] || {};

            if (!onlyParams && _plugins.indexOf(pluginName) === -1) {
                _plugins.push(pluginName);
            }

            $(this).change();

            return true;
        };

        this.each = function(callback) {
            for (var p = 0; p < _plugins.length; p++) {
                callback(_plugins[p], _params[_plugins[p]] || {});
            }
        };

        this.remove = function(pluginName) {
            var nameIndex = _plugins.indexOf(pluginName);
            if (nameIndex !== -1) {
                _plugins.splice(nameIndex, 1);
                $(this).change();
            }
        };

        this.isExist = function(pluginName)
        {
            return _plugins.indexOf(pluginName) !== -1;
        };

        this.getPluginParams = function(pluginName) {
            return _params[pluginName];
        };

        this.setPluginParams = function(pluginName, pluginParams) {
            _params[pluginName] = pluginParams;
            $(this).change();
        };

        //обновляем используемость и параметры плагинов
        this.updateGeomixerPlugins = function() {
            for (var p = 0; p < _plugins.length; p++) {
                var plugin = nsGmx$1.pluginsManager.getPluginByName(_plugins[p]),
                    lazyLoad = plugin && plugin.lazyLoad;

                nsGmx$1.pluginsManager.setUsePlugin(_plugins[p], !lazyLoad);
            }

            for (var p in _params) {
                nsGmx$1.pluginsManager.updateParams(p, normalizeParams(_params[p]));
            }
        };

        this.load = function(data, version) {
            if (version === 1) {
                _plugins = data;
                _params = {};
            } else if (version === 2) {
                _plugins = [];
                _params = {};
                for (var p = 0; p < data.length; p++) {
                    _plugins.push(data[p].name);
                    _params[data[p].name] = data[p].params;
                }
            } else if (version === 3) {
                _plugins = data.plugins;

                //поддержка ошибки, которая прокралась в базу...
                if ($.isArray(data.params) && data.params.length === 0) {
                    _params = {};
                } else {
                    _params = data.params;
                }
            }
        };

        this.save = function(version) {
            if (version === 1) {
                return _plugins;
            } else if (version === 2) {
                var res = [];
                _plugins.forEach(function(name) {
                    res.push({name: name, params: _params[name]});
                });
                return res;
            } else if (version === 3) {
                return {
                    plugins: _plugins,
                    params: _params
                }
            }
        };
    };

    var GeomixerPluginsWidget = function(container, mapPlugins)
    {
        var template = Handlebars.compile('<div class="pluginsEditor-allPlugins-container">' +
            '<div class="pluginEditor-widgetHeader">{{i "pluginsEditor.availableTitle"}}</div>' +
            '<div class="pluginEditor-treePlaceholder"></div>' +
            '<div class="pluginEditor-controls">' +
                '<input class="inputStyle inputFullWidth pluginEditor-pluginInput"><br>' +
                '<button class="pluginEditor-addButton">{{i "pluginsEditor.add"}}</button>' +
            '</div>' +
        '</div>');

        var lang = window.nsGmx.Translations.getLanguage();

        var DEFAULT_GROUP_NAME = {
            eng: 'Main',
            rus: 'Основные'
        };

        var _allPluginGroups = {},
            configGroups = window.gmxPluginGroups || [],
            groupByPluginName = [],
            groupOrder = {};

        configGroups.forEach(function(group, index) {
            groupOrder[group[lang]] = index;
            group.plugins.forEach(function(plugin) {
                groupByPluginName[plugin] = group[lang];
            });
        });

        nsGmx$1.pluginsManager.forEachPlugin(function(plugin)
        {
            if ( plugin.pluginName && plugin.mapPlugin && (plugin.isPublic || nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN)) )
            {
                var groupName = groupByPluginName[plugin.pluginName] || DEFAULT_GROUP_NAME[lang];
                _allPluginGroups[groupName] = _allPluginGroups[groupName] || {groupName: groupName, plugins: []};
                _allPluginGroups[groupName].plugins.push({name: plugin.pluginName, isPublic: plugin.isPublic});
                //_allPlugins.push({name: plugin.pluginName, isPublic: plugin.isPublic});
            }
        });

        //по алфавиту
        for (var g in _allPluginGroups) {
            _allPluginGroups[g].plugins.sort(function(a, b) {
                return a.name > b.name ? 1 : -1;
            });
        }

        var isListActive = false;
        var update = function()
        {
            $(container).empty();

            var filteredGroups = [];
            for (var g in _allPluginGroups) {
                var plugins = _allPluginGroups[g].plugins.filter(function(plugin) {return !mapPlugins.isExist(plugin.name);});
                //если в группе нет плагинов, не показываем её
                plugins.length && filteredGroups.push({
                    groupName: _allPluginGroups[g].groupName,
                    plugins: plugins
                });
            }
            //сохраняем порядок, как в конфиге, default group - первой
            filteredGroups.sort(function(a, b) {
                return groupOrder[a.groupName] - groupOrder[b.groupName];
            });

            var pluginGroupTemplate = Handlebars.compile('<ul class="pluginEditor-pluginsTree ui-helper-noselect">{{#groups}}' +
                '<li>' +
                    '<div class="pluginEditor-groupTitle">{{groupName}}</div>' +
                    '<ul>{{#plugins}}' +
                        '<li class="pluginEditor-pluginItem ui-helper-noselect" data-plugin-name="{{name}}">{{name}}</li>' +
                    '{{/plugins}}</ul>' +
                '</li>' +
                '{{/groups}}</ul>');

            var pluginsTree = $(pluginGroupTemplate({groups: filteredGroups}));

            pluginsTree.find('.pluginEditor-pluginItem').click(function(e) {
                isListActive = true;
                var pluginName = $(this).data('pluginName');

                if (e.ctrlKey) {
                    $(this).toggleClass('pluginEditor-activePluginItem');
                } else {
                    pluginsTree.find('.pluginEditor-pluginItem').removeClass('pluginEditor-activePluginItem');
                    $(this).addClass('pluginEditor-activePluginItem');
                }
            });

            pluginsTree.find('.pluginEditor-groupTitle').click(function() {
                $(this).siblings('.hitarea').click();
            });

            var ui = $(template());

            ui.find('.pluginEditor-treePlaceholder').append(pluginsTree);

            ui.find('.pluginEditor-pluginInput').bind('focus', function() {
                isListActive = false;
            });

            ui.find('.pluginEditor-addButton').click(function() {
                var selected = [];

                if (isListActive) {
                    pluginsTree.find('.pluginEditor-activePluginItem').each(function(i, elem) {
                        selected.push($(elem).data('pluginName'));
                    });
                } else {
                    var pluginInput = ui.find('.pluginEditor-pluginInput');
                    if (nsGmx$1.pluginsManager.getPluginByName(pluginInput.val())) {
                        selected.push(pluginInput.val());
                    } else {
                        inputError(pluginInput[0]);
                    }
                }

                for (var sp = 0; sp < selected.length; sp++)
                    mapPlugins.addPlugin( selected[sp] );
            });

            ui.appendTo(container);

            pluginsTree.treeview(/*{collapsed: true}*/);
        };

        $(mapPlugins).change(update);
        update();
    };

    var paramsWidgets = {};

    var MapPluginParamsWidget = function(mapPlugins, pluginName) {

        if (paramsWidgets[pluginName]) {
            return;
        }
        var FakeTagMetaInfo = function()
        {
            this.isTag = function(tag) { return true; };
            this.getTagType = function(tag) { return 'String'; };
            this.getTagDescription = function(tag) { return ''; };
            this.getTagArray = function() { return []; };
            this.getTagArrayExt = function() { return []; };
        };
        var fakeTagMetaInfo = new FakeTagMetaInfo();

        var pluginParams =  mapPlugins.getPluginParams(pluginName);
        var tagInitInfo = {};

        for (var tagName in pluginParams) {
            tagInitInfo[tagName] = {Value: pluginParams[tagName]};
        }

        var layerTags = new nsGmx$1.LayerTagsWithInfo(fakeTagMetaInfo, tagInitInfo);

        var container = $('<div/>');

        var pluginValues = new nsGmx$1.LayerTagSearchControl(layerTags, container);

        var updateParams = function() {
            var newParams = {};
            layerTags.eachValid(function(tagid, tag, value) {
                newParams[tag] = newParams[tag] || [];
                newParams[tag].push(value);
            });

            mapPlugins.setPluginParams(pluginName, newParams);
        };

        var dialogDiv = showDialog(
                _gtxt('pluginsEditor.paramsTitle') + " " + pluginName,
                container[0],
                {
                    width: 320,
                    height: 200,
                    closeFunc: function() {
                        updateParams();
                        delete paramsWidgets[pluginName];
                    }
                }
            );

        paramsWidgets[pluginName] = {
            update: updateParams,
            closeDialog: function() {
                $(dialogDiv).dialog('close');
            }
        };

    };

    var MapPluginsWidget = Backbone.View.extend({
        template: Handlebars.compile(
            '<div class="pluginEditor-widgetHeader">{{i "pluginsEditor.selectedTitle"}}</div>' +
            '<div class="pluginEditor-currentMapPlugins">' +
                '{{#plugins}}' +
                    '<div class="pluginEditor-widgetElem">' +
                        '{{#unless isCommon}}' +
                            '<span class="pluginEditor-remove gmx-icon-close" data-plugin-name="{{name}}"></span>' +
                        '{{/unless}}' +
                        '<span class="pluginEditor-edit gmx-icon-edit" data-plugin-name="{{name}}"></span>' +
                        '<span class="pluginEditor-title {{#if isCommon}} pluginEditor-commonPlugin{{/if}}">{{name}}</span>' +
                    '</div>' +
                '{{/plugins}}' +
            '</div>'
        ),

        events: {
            'click .gmx-icon-close': function(event) {
                var pluginName = $(event.target).data('pluginName');
                this._mapPlugins.remove(pluginName);
            },

            'click .gmx-icon-edit': function(event) {
                var pluginName = $(event.target).data('pluginName');
                new MapPluginParamsWidget(this._mapPlugins, pluginName);
            }
        },

        initialize: function(options) {
            this._mapPlugins = options.mapPlugins;
            $(this._mapPlugins).change(this.render.bind(this));
            this.render();
        },

        render: function() {
            var mapPlugins = this._mapPlugins,
                pluginsToShow = [];

            nsGmx$1.pluginsManager.forEachPlugin(function(plugin) {
                if ( plugin.pluginName && !plugin.mapPlugin && !mapPlugins.isExist(plugin.pluginName) ) {
                    pluginsToShow.push({
                        name: plugin.pluginName,
                        isCommon: true
                    });
                }
            });

            mapPlugins.each(function(name) {
                pluginsToShow.push({
                    name: name,
                    isCommon: false
                });
            });

            pluginsToShow.sort(function(a, b) {
                return a.isCommon != b.isCommon ? Number(b.isCommon) - Number(a.isCommon) : (a.name > b.name ? 1 : -1);
            });

            this.$el.empty().append(this.template({plugins: pluginsToShow}));
        }
    });

    var createPluginsEditor = function(container, mapPlugins)
    {
        var widgetContainer = $('<div/>', {'class': 'pluginEditor-widgetContainer'});
        var allPluginsContainer = $('<div/>', {'class': 'pluginEditor-allContainer'});
        var mapPluginsWidget = new MapPluginsWidget({
            el: widgetContainer,
            mapPlugins: mapPlugins
        });
        var allPluginsWidget = new GeomixerPluginsWidget(allPluginsContainer, mapPlugins);

        $(container)
            .append($('<table/>', {'class': 'pluginEditor-table'}).append($('<tr/>')
                .append($('<td/>', {'class': 'pluginEditor-allTD'}).append(allPluginsContainer))
                .append($('<td/>', {'class': 'pluginEditor-widgetTD'}).append(widgetContainer))
            ));

        return {
            update: function() {
                for (var name in paramsWidgets) {
                    paramsWidgets[name].update();
                }
            },
            closeParamsDialogs: function() {
                for (var name in paramsWidgets) {
                    paramsWidgets[name].closeDialog();
                }
            }
        };
    };

    gmxCore.addModule('PluginsEditor', {
        createPluginsEditor: createPluginsEditor,
        MapPlugins: MapPlugins
    });

    nsGmx$1.createPluginsEditor = createPluginsEditor;
    _mapHelper.mapPlugins = new MapPlugins();

    //Cтарая версия информации о плагинах карты. Поддерживается для обратной совместимости (например, загрузка доп. карт)
    //Формат: {String[]} массив имён плагинов
    nsGmx$1.userObjectsManager.addDataCollector('mapPlugins', {
        load: function(data)
        {
            if (data) {
                _mapHelper.mapPlugins.load(data, 1);
                _mapHelper.mapPlugins.updateGeomixerPlugins();
            }
        },
        collect: function() {
            return _mapHelper.mapPlugins.save(1);
        }
    });

    //Вторая версия информации о плагинах карты.
    //Формат: [{name: pluginName1, params: {param: value, ...}}, ...]
    nsGmx$1.userObjectsManager.addDataCollector('mapPlugins_v2', {
        load: function(data)
        {
            if (data) {
                _mapHelper.mapPlugins.load(data, 2);
                _mapHelper.mapPlugins.updateGeomixerPlugins();
            }
        },
        collect: function()
        {
            return _mapHelper.mapPlugins.save(2);
        }
    });

    //Третья версия информации о плагинах карты.
    //Формат: {plugins: [name1, ....], params: {name1: {param1: value1, ...}, ...}}
    nsGmx$1.userObjectsManager.addDataCollector('mapPlugins_v3', {
        load: function(data)
        {
            if (data) {
                _mapHelper.mapPlugins.load(data, 3);
                _mapHelper.mapPlugins.updateGeomixerPlugins();
            }
        },
        collect: function()
        {
            return _mapHelper.mapPlugins.save(3);
        }
    });

    })(jQuery);

    !(function(_) {

        var mapLayers = {
            mapLayers: {}
        };

        window.mapLayers = mapLayers;

        var AbstractTree = function() {};

        AbstractTree.prototype.makeSwapChild = function() {
            var div = _div$1(null, [
                ['attr', 'swap', true],
                ['dir', 'className', 'swap'],
                ['css', 'fontSize', '0px']
            ]);

            return div;
        };

        AbstractTree.prototype.getChildsUl = function(node) {
            var ul = $(node).children("ul");

            if (ul.length > 0)
                return ul[0];
            else
                return false;
        };

        AbstractTree.prototype.toggle = function(box) {
            box.onclick = function() {
                $(this.parentNode)
                    .find(">.hitarea")
                    .swapClass('collapsable-hitarea', 'expandable-hitarea')
                    .swapClass('lastCollapsable-hitarea', 'lastExpandable-hitarea')
                    .end()
                    .swapClass('collapsable', 'expandable')
                    .swapClass('lastCollapsable', 'lastExpandable');

                if ($(this.parentNode).hasClass('expandable') || $(this.parentNode).hasClass('lastExpandable'))
                    hide(_abstractTree.getChildsUl(this.parentNode));
                else
                    show(_abstractTree.getChildsUl(this.parentNode));
            };
        };
        AbstractTree.prototype.addNode = function(node, newNodeCanvas) {
            var childsUl = _abstractTree.getChildsUl(node);

            if (childsUl)
                childsUl.insertBefore(newNodeCanvas, childsUl.firstChild);
            else {
                // если первый потомок
                var newSubTree = _ul$1([newNodeCanvas]);
                //_(node, [newSubTree, this.makeSwapChild()]);
                node.insertBefore(newSubTree, node.lastChild);

                newSubTree.loaded = true;

                var div = _div$1(null, [
                    ['dir', 'className', 'hitarea']
                ]);

                if ($(node).hasClass("last")) {
                    $(div).addClass('lastCollapsable-hitarea collapsable-hitarea');
                    $(node).addClass('lastCollapsable');
                } else {
                    $(div).addClass('collapsable-hitarea');
                    $(node).addClass('collapsable');
                }

                this.toggle(div);

                node.insertBefore(div, node.firstChild);

                _layersTree.addExpandedEvents(node);

                if ($(newNodeCanvas).hasClass('collapsable')) {
                    $(newNodeCanvas).addClass('lastCollapsable');
                    $(newNodeCanvas).children('div.hitarea').addClass('lastCollapsable-hitarea');
                }
                if ($(newNodeCanvas).hasClass('expandable')) {
                    $(newNodeCanvas).addClass('lastExpandable');
                    $(newNodeCanvas).children('div.hitarea').addClass('lastExpandable-hitarea');
                }
                if (!$(newNodeCanvas).hasClass('lastCollapsable') && !$(newNodeCanvas).hasClass('lastExpandable'))
                    $(newNodeCanvas).addClass('last');
            }

            $(_abstractTree.getChildsUl(node)).children(":not(li:last)").each(function() {
                $(this).removeClass('last').replaceClass('lastCollapsable', 'collapsable').replaceClass('lastExpandable', 'expandable');
                $(this).children('div.lastCollapsable-hitarea').replaceClass('lastCollapsable-hitarea', 'collapsable-hitarea');
                $(this).children('div.lastExpandable-hitarea').replaceClass('lastExpandable-hitarea', 'expandable-hitarea');
            });
        };
        AbstractTree.prototype.delNode = function(node, parentTree, parent) {
            if (parentTree.childNodes.length == 0) {
                // потомков не осталось, удалим контейнеры
                parentTree.removeNode(true);
                parent.firstChild.removeNode(true);

                // изменим дерево родителя
                $(parent).removeClass("collapsable");
                $(parent).replaceClass("lastCollapsable", "last");
            } else {
                // изменим дерево родителя
                if ($(parentTree).children("li:last").hasClass("collapsable")) {
                    $(parentTree).children("li:last").addClass("lastCollapsable");

                    $(parentTree).children("li:last").each(function() {
                        $(this.firstChild).addClass("lastCollapsable-hitarea");
                    });
                } else
                    $(parentTree).children("li:last").addClass("last");
            }
        };

        AbstractTree.prototype.swapNode = function(node, newNodeCanvas) {
            $(node).after(newNodeCanvas);

            $(node.parentNode).children(":not(li:last)").each(function() {
                $(this).removeClass('last').replaceClass('lastCollapsable', 'collapsable').replaceClass('lastExpandable', 'expandable');
                $(this).children('div.lastCollapsable-hitarea').replaceClass('lastCollapsable-hitarea', 'collapsable-hitarea');
                $(this).children('div.lastExpandable-hitarea').replaceClass('lastExpandable-hitarea', 'expandable-hitarea');
            });

            // изменим дерево родителя
            if ($(node.parentNode).children("li:last").hasClass("collapsable")) {
                $(node.parentNode).children("li:last").addClass("lastCollapsable");

                $(node.parentNode).children("li:last").each(function() {
                    $(this.firstChild).addClass("lastCollapsable-hitarea");
                });
            } else if ($(node.parentNode).children("li:last").hasClass("expandable")) {
                $(node.parentNode).children("li:last").addClass("lastExpandable");

                $(node.parentNode).children("li:last").each(function() {
                    $(this.firstChild).addClass("lastExpandable-hitarea");
                });
            } else
                $(node.parentNode).children("li:last").addClass("last");
        };

        var _abstractTree = new AbstractTree();
        window._abstractTree = _abstractTree;

        //renderParams:
        //  * showVisibilityCheckbox {Bool} - показывать или нет checkbox видимости
        //  * allowActive {Bool} - возможен ли в дереве активный элемент
        //  * allowDblClick {Bool} - переходить ли по двойному клику к видимому экстенту слоя/группы
        //  * showStyle {Bool} - показывать ли иконку стилей
        //  * visibilityFunc {function(layerProps, isVisible)} - ф-ция, которая будет выполнена при изменении видимости слоя.
        //    По умолчанию устанавливает видимость соответствующего слоя в API
        //
        //события:
        //  * layerVisibilityChange - при изменении видимости слоя (параметр - элемент дерева с изменившимся слоем)
        //  * addTreeElem - добавили новый элемент дерева (параметр - новый элемент)
        //  * activeNodeChange - изменили активную ноду дерева (парамер - div активной ноды)
        //  * styleVisibilityChange - при изменении видимости стиля слоя
        var layersTree = function(renderParams) {
            this._renderParams = $.extend({
                showVisibilityCheckbox: true,
                allowActive: true,
                allowDblClick: true,
                showStyle: true,
                visibilityFunc: function(props, isVisible) {
                    if (props.name in nsGmx$1.gmxMap.layersByID) {
                        nsGmx$1.leafletMap[isVisible ? 'addLayer' : 'removeLayer'](nsGmx$1.gmxMap.layersByID[props.name]);
                    }
                }
            }, renderParams);

            // тип узла
            this.type = null;

            // содержимое узла
            this.content = null;

            this.condition = { visible: {}, expanded: {} };

            this.mapStyles = {};

            this.groupLoadingFuncs = [];

            this._treeCanvas = null; //контейнер отрисованного дерева слоёв

            this._layerViewHooks = [];
        };

        layersTree.prototype.addLayerViewHook = function(hook) {
            hook && this._layerViewHooks.push(hook);
        };

        layersTree.prototype._applyLayerViewHooks = function(div, layerProps) {
            this._layerViewHooks.forEach(function(hook) {
                hook(div, layerProps);
            });
        };

        // layerManagerFlag == 0 для дерева слева
        // layerManagerFlag == 1 для списка слоев
        // layerManagerFlag == 2 для списка карт

        layersTree.prototype.drawTree = function(tree, layerManagerFlag) {
            var permalinkParams = this.LayersTreePermalinkParams;

            if (permalinkParams) {
                var tempTree = new nsGmx$1.LayersTree(tree);

                tempTree.forEachNode(function(elem) {
                    var props = elem.content.properties,
                        id = elem.type == 'group' ? props.GroupID : props.LayerID;

                    if (id in permalinkParams) {
                        props.permalinkParams = permalinkParams[id];
                    }
                });

                tree = tempTree.getRawTree();
            }

            this._treeCanvas = _ul$1([this.getChildsList(tree, false, layerManagerFlag, true)], [
                ['dir', 'className', 'filetree']
            ]);
            this.treeModel = new nsGmx$1.LayersTree(tree);
            this._mapTree = tree; //Устарело: используйте this.treeModel для доступа к исходному дереву

            this.treeModel.forEachLayer(function(layerContent, isVisible) {
                layerContent.properties.initVisible = layerContent.properties.visible;
            });

            var _this = this;
            $(this.treeModel).on('nodeVisibilityChange', function(event, elem) {
                var props = elem.content.properties;

                _this.updateVisibilityUI(elem);
                props.changedByViewer = true;

                if (elem.type === 'layer') {
                    _this._renderParams.visibilityFunc(props, props.visible);
                    $(_this).triggerHandler('layerVisibilityChange', [elem]);
                }
            });

            nsGmx$1.leafletMap.on('layeradd layerremove', function(event) {
                if (event.layer.getGmxProperties) {
                    var name = event.layer.getGmxProperties().name;

                    //добавился именно слой из основной карты, а не просто с таким же ID
                    if (event.layer === nsGmx$1.gmxMap.layersByID[name]) {
                        var searchRes = _this.treeModel.findElem('name', name);
                        if (searchRes && (!layerManagerFlag || layerManagerFlag == 0)) {
                            _this.treeModel.setNodeVisibility(searchRes.elem, nsGmx$1.leafletMap.hasLayer(event.layer));
                        }
                    }
                }
            });

            return this._treeCanvas;
        };

        layersTree.prototype.getChildsList = function(elem, parentParams, layerManagerFlag, parentVisibility) {
            // добавляем новый узел
            var li = _li$1();

            _(li, [this.drawNode(elem, parentParams, layerManagerFlag, parentVisibility)]);

            if (elem.content && elem.content.children && elem.content.children.length > 0) {
                var childsUl = _ul$1();

                // initExpand - временное свойство, сохраняющее начальное состояние развёрнутости группы.
                // В expanded будет храниться только текущее состояние (не сохраняется)
                if (typeof elem.content.properties.initExpand == 'undefined')
                    elem.content.properties.initExpand = elem.content.properties.expanded;

                if (!elem.content.properties.expanded) {
                    childsUl.style.display = 'none';
                    childsUl.className = 'hiddenTree';

                    if (!layerManagerFlag) {
                        childsUl.loaded = false;

                        this.addLoadingFunc(childsUl, elem, parentParams, layerManagerFlag);
                    } else {
                        childsUl.loaded = true;

                        var childs = [];

                        for (var i = 0; i < elem.content.children.length; i++)
                            childs.push(this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, true));

                        _(childsUl, childs);
                    }
                } else {
                    childsUl.loaded = true;

                    var childs = [];

                    for (var i = 0; i < elem.content.children.length; i++)
                        childs.push(this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, parentVisibility && elem.content.properties.visible));

                    _(childsUl, childs);
                }

                _(li, [childsUl, _abstractTree.makeSwapChild()]);
            } else if (elem.children) {
                if (elem.children.length > 0) {
                    var childs = [];

                    for (var i = 0; i < elem.children.length; i++)
                        childs.push(this.getChildsList(elem.children[i], elem.properties, layerManagerFlag, true));

                    var childsUl = _ul$1(childs);

                    childsUl.loaded = true;

                    _(li, [childsUl]);
                }

                _(li, [_div$1()]);

                li.root = true;
            } else
                _(li, [_abstractTree.makeSwapChild()]);

            // видимость слоя в дереве
            if (!nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN) &&
                elem.type && elem.type == 'layer' &&
                typeof invisibleLayers != 'undefined' && invisibleLayers[elem.content.properties.name])
                li.style.display = 'none';

            return li;
        };

        layersTree.prototype.addLoadingFunc = function(parentCanvas, elem, parentParams, layerManagerFlag) {
            var func = function() {
                    $(parentCanvas.parentNode.firstChild).bind('click', function() {
                        if (!parentCanvas.loaded) {
                            parentCanvas.loaded = true;

                            var childs = [],
                                grId = $(parentCanvas.parentNode).children("div[GroupID]");

                            for (var i = 0; i < elem.content.children.length; i++) {
                                childs.push(_this.getChildsList(elem.content.children[i], elem.content.properties, layerManagerFlag, _this.getLayerVisibility($(grId).find('input[type="checkbox"]')[0] || $(grId).find('input[type="radio"]')[0])));
                            }

                            _(parentCanvas, childs);

                            if (_queryMapLayers.currentMapRights() == "edit") {
                                _queryMapLayers.addDraggable(parentCanvas);

                                if (!layerManagerFlag) {
                                    _queryMapLayers.addDroppable(parentCanvas);

                                    _queryMapLayers.addSwappable(parentCanvas);
                                }
                            }

                            $(parentCanvas).treeview();

                            _layersTree.addExpandedEvents(parentCanvas);

                            _this.runLoadingFuncs();

                            _queryMapLayers.applyState(_this.condition, _this.mapStyles, $(parentCanvas.parentNode).children("div[GroupID]")[0]);
                        }
                    });
                },
                _this = this;

            this.groupLoadingFuncs.push(func);
        };

        layersTree.prototype.runLoadingFuncs = function() {
            for (var i = 0; i < this.groupLoadingFuncs.length; i++)
                this.groupLoadingFuncs[i]();

            this.groupLoadingFuncs = [];
        };

        layersTree.prototype.addExpandedEvents = function(parent) {
            var _this = this;
            $(parent).find("div.hitarea").each(function() {
                if (!this.clickFunc) {
                    this.clickFunc = true;

                    var divClick = this;

                    if (divClick.parentNode.parentNode.parentNode.getAttribute("multiStyle"))
                        return;

                    $(divClick).bind('click', function() {
                        var div = $(divClick.parentNode).children("div[MapID],div[GroupID],div[LayerID],div[MultiLayerID]")[0],
                            treeElem = _this.findTreeElem(div);

                        if (!treeElem.parents.length)
                            return;

                        var flag = $(divClick).hasClass("expandable-hitarea");
                        treeElem.elem.content.properties.expanded = !flag;
                    });
                }
            });
        };

        layersTree.prototype.drawNode = function(elem, parentParams, layerManagerFlag, parentVisibility) {
            var div;

            if (elem.type == "layer") {
                // var elemProperties = !layerManagerFlag ? nsGmx.gmxMap.layersByID[elem.content.properties.name].getGmxProperties(): elem.content.properties;

                var elemProperties;
                if (nsGmx$1.gmxMap.layersByID[elem.content.properties.name]) {
                    elemProperties = !layerManagerFlag ? nsGmx$1.gmxMap.layersByID[elem.content.properties.name].getGmxProperties() : elem.content.properties;
                } else {
                    elemProperties = elem.content.properties;
                }

                var childs = this.drawLayer(elemProperties, parentParams, layerManagerFlag, parentVisibility);

                if (typeof elem.content.properties.LayerID != 'undefined')
                    div = _div$1(childs, [
                        ['attr', 'LayerID', elem.content.properties.LayerID]
                    ]);
                else if (typeof elem.content.properties.MultiLayerID != 'undefined')
                    div = _div$1(childs, [
                        ['attr', 'MultiLayerID', elem.content.properties.MultiLayerID]
                    ]);
                else
                    div = _div$1(childs, [
                        ['attr', 'LayerID', elem.content.properties.name]
                    ]);

                div.gmxProperties = elem;
                div.gmxProperties.content.properties = elemProperties;

                this._applyLayerViewHooks(div, elemProperties);
            } else {
                if (elem.properties && elem.properties.MapID)
                    div = _div$1(this.drawHeaderGroupLayer(elem.properties, parentParams, layerManagerFlag), [
                        ['attr', 'MapID', elem.properties.MapID]
                    ]);
                else
                    div = _div$1(this.drawGroupLayer(elem.content.properties, parentParams, layerManagerFlag, parentVisibility), [
                        ['attr', 'GroupID', elem.content.properties.GroupID]
                    ]);

                div.gmxProperties = elem;
            }

            div.oncontextmenu = function(e) {
                return false;
            };

            return div;
        };

        layersTree.prototype.setActive = function(span) {
            $(this._treeCanvas).find(".active").removeClass("active");

            if (span) {
                $(span.parentNode).addClass("active");
                $(this).triggerHandler("activeNodeChange", [span.parentNode.parentNode]);
            } else {
                $(this).triggerHandler("activeNodeChange", [null]);
            }
        };

        layersTree.prototype.getActive = function() {
            var activeDiv = $(this._treeCanvas).find(".active");
            return activeDiv[0] ? activeDiv[0].parentNode : null;
        };

        layersTree.prototype.getMinLayerZoom = function(layer) {
            if (!layer.getStyles) {
                return 1;
            }

            var minLayerZoom = 20,
                styles = layer.getStyles();

            for (var i = 0; i < styles.length; i++) {
                minLayerZoom = Math.min(minLayerZoom, styles[i].MinZoom);
            }

            return minLayerZoom;
        };

        layersTree.prototype.layerZoomToExtent = function(bounds, minZoom) {
            if (!bounds) return;

            var lmap = nsGmx$1.leafletMap;
    		// var z = lmap.getBoundsZoom(bounds);

            // if (minZoom !== 20) {
                // z = Math.max(z, minZoom);
            // }

            // z = Math.min(lmap.getMaxZoom(), Math.max(lmap.getMinZoom(), z));
    		var currentZoom = lmap.getZoom();
    		var doubleClickZoom = lmap.getBoundsZoom(bounds);
    		var z = Math.min(Math.max(15, currentZoom), doubleClickZoom);

            //анимация приводит к проблемам из-за бага https://github.com/Leaflet/Leaflet/issues/3249
            //а указать явно zoom в fitBounds нельзя
            //TODO: enable animation!
            lmap.fitBounds(bounds, { animation: false, maxZoom: z });

            //если вызывать setZoom всегда, карта начнёт глючить (бага Leaflet?)
            // if (z !== lmap.getZoom()) {
            //     lmap.setZoom(z);
            // }
        };

        layersTree.prototype.drawLayer = function(elem, parentParams, layerManagerFlag, parentVisibility) {
            var box,
                _this = this;

            if (this._renderParams.showVisibilityCheckbox) {
                box = _checkbox$1(elem.visible, parentParams.list ? 'radio' : 'checkbox', parentParams.GroupID || parentParams.MapID);

                box.className = 'box layers-visibility-checkbox';

                box.setAttribute('box', 'layer');

                box.onclick = function() {
                    _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
                };
            }

            var span = _span$1([_t(elem.title)], [
                ['dir', 'className', 'layer'],
                ['attr', 'dragg', true]
            ]);

            var timer = null,
                clickFunc = function() {
                    var treeNode = _this.findTreeElem(span.parentNode.parentNode).elem;
                    $(treeNode).triggerHandler('click', [treeNode]);

                    if (_this._renderParams.allowActive)
                        _this.setActive(span);

                    if (_this._renderParams.showVisibilityCheckbox) {
                        _this.treeModel.setNodeVisibility(treeNode, true);
                    }
                },
                dbclickFunc = function() {
                    var treeNode = _this.findTreeElem(span.parentNode.parentNode).elem;
                    var layer = nsGmx$1.gmxMap.layersByID[elem.name];
                    $(treeNode).triggerHandler('dblclick', [treeNode]);
                    if (treeNode.content.geometry && layer && layer.getBounds) {
                        var minLayerZoom = _this.getMinLayerZoom(layer);
                        _this.layerZoomToExtent(layer.getBounds(), minLayerZoom);
                    }
                };

            span.onclick = function() {
                if (timer)
                    clearTimeout(timer);

                timer = setTimeout(clickFunc, 200);
            };

            if (this._renderParams.allowDblClick) {
                span.ondblclick = function() {
                    if (timer)
                        clearTimeout(timer);

                    timer = null;

                    clickFunc();
                    dbclickFunc();
                };
            }

            disableSelection(span);

            var spanParent = _div$1([span], [
                    ['attr', 'titleDiv', true],
                    ['css', 'display', 'inline'],
                    ['css', 'position', 'relative'],
                    ['css', 'borderBottom', 'none'],
                    ['css', 'paddingRight', '3px']
                ]),
                spanDescr = _span$1(null, [
                    ['dir', 'className', 'layerDescription']
                ]);

            spanDescr.innerHTML = elem.description ? elem.description : '';

            if (layerManagerFlag == 1) {
    	    var imgIconSrc = (elem.type == "Vector") ? 'img/vector.png' : (typeof elem.MultiLayerID != 'undefined' ? 'img/multi.png' : 'img/rastr.png');
    	    if (elem.type == "Alias") imgIconSrc = 'img/shortcut.png';
                return [_img(null, [
                    ['attr', 'src', imgIconSrc],
                    ['css', 'marginLeft', '3px']
                ]), spanParent, spanDescr];
            }

            if (this._renderParams.showVisibilityCheckbox && !elem.visible) {
                $(spanParent).addClass("invisible");
            }

            nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'Layer', function() { return true; }, {
                layerManagerFlag: layerManagerFlag,
                elem: elem,
                tree: this
            });

            var borderDescr = _span$1();

            var count = 0;
            var metaProps = {};
            if (elem.MetaProperties) {
                for (let key in elem.MetaProperties) {
                    var tagtype = elem.MetaProperties[key].Type;
                    metaProps[key] = nsGmx$1.Utils.convertFromServer(tagtype, elem.MetaProperties[key].Value);
                    count++;
                }
            }

            if (count || elem.Legend) {
                _(borderDescr, [_t('i')], [
                    ['dir', 'className', 'layerInfoButton']
                ]);
                borderDescr.onclick = function() {
                    nsGmx$1.Controls.showLayerInfo({ properties: elem }, { properties: metaProps });
                };
            }

            if (elem.type == "Vector") {
                var styles;

                if (window.newStyles) {
                    if (elem.styles && !elem.gmxStyles) {
                        elem.gmxStyles = L.gmx.StyleManager.decodeOldStyles(elem);
                    }
                    styles = elem.gmxStyles.styles;
                } else {
                    styles = elem.styles;
                }

                var icon = _mapHelper.createStylesEditorIcon(styles, elem.GeometryType ? elem.GeometryType.toLowerCase() : 'polygon', { addTitle: !layerManagerFlag }),
                    multiStyleParent = _div$1(null, [
                        ['attr', 'multiStyle', true]
                    ]),
                    timelineIcon,
                    iconSpan = _span$1([icon]);

                if (styles.length === 1 && elem.name in nsGmx$1.gmxMap.layersByID) {
                    var layer = nsGmx$1.gmxMap.layersByID[elem.name];
                    layer.on('stylechange', function() {
                        if (layer.getStyles().length === 1) {
                            var style = L.gmxUtil.toServerStyle(layer.getStyles()[0].RenderStyle);
                            var newIcon = _mapHelper.createStylesEditorIcon(
                                [{ MinZoom: 1, MaxZoom: 21, RenderStyle: style }],
                                elem.GeometryType ? elem.GeometryType.toLowerCase() : 'polygon', { addTitle: !layerManagerFlag }
                            );
                            $(iconSpan).empty().append(newIcon);
                        }
                    });
                }

                $(iconSpan).attr('styleType', $(icon).attr('styleType'));

                _mapHelper.createMultiStyle(elem, this, multiStyleParent, true, layerManagerFlag);

                if (!layerManagerFlag) {
                    if (!parentVisibility || !elem.visible)
                        $(multiStyleParent).addClass("invisible");

                    iconSpan.onclick = function() {
                        if (_queryMapLayers.currentMapRights() == "edit") {
                            nsGmx$1.createStylesDialog(elem, _this);
                        }
                    };

                    if (elem.name in nsGmx$1.gmxMap.layersByID) {
                        var layer = nsGmx$1.gmxMap.layersByID[elem.name];

                        if (layer.getGmxProperties) {
                            var props = layer.getGmxProperties(),
                                layerName = props.name;

                            if (props.Temporal && (props.IsRasterCatalog || (props.Quicklook && props.Quicklook !== 'null'))) {
                                timelineIcon = this.CreateTimelineIcon(elem);
    						}
                        }
                    }
                }

                var resElems = [spanParent, spanDescr, borderDescr];

                if (this._renderParams.showStyle) {
                    resElems.push(multiStyleParent);
                    resElems.unshift(iconSpan);
                }
                this._renderParams.showVisibilityCheckbox && resElems.unshift(box);

                if (timelineIcon) {
                    resElems.unshift(timelineIcon);
                }
                return resElems;
            } else {
                if (this._renderParams.showVisibilityCheckbox)
                    return [box, spanParent, spanDescr, borderDescr];
                else
                    return [spanParent, spanDescr, borderDescr];
            }
        };

        layersTree.prototype.CreateTimelineIcon = function(elem) {
    		var conf = {
    			disabledSrc: 'img/timeline-icon-disabled.svg',
    			enabledSrc: 'img/timeline-icon-enabled.svg',
    			addTitle: window._gtxt('Добавить в таймлайн'),
    			removeTitle: window._gtxt('Удалить из таймлайна')
    		},
    		layerID = elem.name,
    		icon = nsGmx$1.Utils._img(null, [
    			['attr', 'src', conf.disabledSrc],
    			['dir','className', 'gmx-timeline-icon disabled'],
    			['dir','title', conf.addTitle]
    		]),
    		toggleIcon = function(flag) {
    			if (flag) {
    				icon.src = conf.enabledSrc;
    				icon.title = conf.addTitle;
    				icon.classList.remove('disabled');
    			} else {
    				icon.src = conf.disabledSrc;
    				icon.title = conf.removeTitle;
    				icon.classList.add('disabled');
    			}
    		};

    		// TODO: требуется замена jQuery	+ не эффективно устанавливается множество хэндлеров
    		$(this).on('layerTimelineRemove', function(e, data) {
    			if (data.layerID === layerID) {
    				toggleIcon(false);
    			}
    		});

    		$(this).on('layerTimelineAdd', function(e, data) {
    			if (data.layerID === layerID) {
    				toggleIcon(true);
    			}
    		});

            L.DomEvent
                .on(icon, 'click', function() {
    				var disabled = icon.classList.contains('disabled'),
    					tlc = nsGmx$1.timeLineControl,
    					layer = nsGmx$1.gmxMap.layersByID[layerID];
    				if (disabled) {
    					if (!tlc._map) { nsGmx$1.leafletMap.addControl(tlc); }
    					tlc.addLayer(layer);
    				} else {
    					tlc.removeLayer(layer);
    				}
    			}, this);
    		return icon;
    	};

        layersTree.prototype.drawGroupLayer = function(elem, parentParams, layerManagerFlag, parentVisibility) {
            var box,
                _this = this;

            if (this._renderParams.showVisibilityCheckbox) {
                box = _checkbox$1(elem.visible, parentParams.list ? 'radio' : 'checkbox', parentParams.GroupID || parentParams.MapID);

                box.className = 'box layers-visibility-checkbox';

                box.setAttribute('box', 'group');

                box.onclick = function() {
                    _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
                };

                if (typeof elem.ShowCheckbox !== 'undefined' && !elem.ShowCheckbox) {
                    box.isDummyCheckbox = true;
                    box.style.display = 'none';
                }
            }

            var span = _span$1([_t(elem.title)], [
                ['dir', 'className', 'groupLayer'],
                ['attr', 'dragg', true]
            ]);

            var timer = null,
                clickFunc = function() {
                    if (_this._renderParams.allowActive)
                        _this.setActive(span);

                    if (_this._renderParams.showVisibilityCheckbox) {
                        var div = span.parentNode.parentNode;

                        if (div.gmxProperties.content.properties.ShowCheckbox) {
                            _this.treeModel.setNodeVisibility(_this.findTreeElem(div).elem, true);
                        }

                        var clickDiv = $(div.parentNode).children("div.hitarea");
                        if (clickDiv.length)
                            $(clickDiv[0]).trigger("click");
                    }
                },
                dbclickFunc = function() {
                    var childsUl = _abstractTree.getChildsUl(span.parentNode.parentNode.parentNode);

                    if (childsUl) {
                        var bounds = new L.LatLngBounds(),
                            minLayerZoom = 20;

                        _mapHelper.findChilds(_this.findTreeElem(span.parentNode.parentNode).elem, function(child) {
                            if (child.type == 'layer' && (child.content.properties.LayerID || child.content.properties.MultiLayerID) && child.content.geometry) {
                                var layer = nsGmx$1.gmxMap.layersByID[child.content.properties.name];
                                bounds.extend(layer.getBounds());

                                minLayerZoom = Math.min(minLayerZoom, _this.getMinLayerZoom(layer));
                            }
                        });

                        _this.layerZoomToExtent(bounds, minLayerZoom);
                    }
                };

            span.onclick = function() {
                if (timer)
                    clearTimeout(timer);

                timer = setTimeout(clickFunc, 200);
            };

            if (this._renderParams.allowDblClick) {
                span.ondblclick = function() {
                    if (timer)
                        clearTimeout(timer);

                    timer = null;

                    clickFunc();
                    dbclickFunc();
                };
            }

            disableSelection(span);

            var spanParent = _div$1([span], [
                ['attr', 'titleDiv', true],
                ['css', 'display', 'inline'],
                ['css', 'position', 'relative'],
                ['css', 'borderBottom', 'none'],
                ['css', 'paddingRight', '3px']
            ]);

            if (this._renderParams.showVisibilityCheckbox && (!parentVisibility || !elem.visible)) {
                $(spanParent).addClass("invisible");
            }

            if (!layerManagerFlag) {

                nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'Group', function() {
                        return _queryMapLayers.currentMapRights() == "edit";
                    },
                    function() {
                        return {
                            div: spanParent.parentNode,
                            tree: _this
                        }
                    });
            }

            if (this._renderParams.showVisibilityCheckbox)
                return [box, spanParent];
            else
                return [spanParent];
        };
        layersTree.prototype.drawHeaderGroupLayer = function(elem, parentParams, layerManagerFlag) {
            var span = _span$1([_t(elem.title)], [
                    ['dir', 'className', 'groupLayer']
                ]),
                spanParent = _div$1([span], [
                    ['css', 'display', 'inline'],
                    ['css', 'position', 'relative'],
                    ['css', 'borderBottom', 'none'],
                    ['css', 'paddingRight', '3px']
                ]),
                _this = this;

            if (this._renderParams.allowActive) {
                span.onclick = function() {
                    _this.setActive(this);
                };
            }

            if (!layerManagerFlag) {
                nsGmx$1.ContextMenuController.bindMenuToElem(spanParent, 'Map', function() {
                        return _queryMapLayers.currentMapRights() == "edit";
                    },
                    function() {
                        return {
                            div: spanParent.parentNode,
                            tree: _this
                        }
                    }
                );
            }

            return [spanParent];
        };

        layersTree.prototype.removeGroup = function(div) {
            var template = Handlebars.compile('<div class="removeGroup-container">' +
                '{{#if anyChildren}}' +
                '<label><input type="checkbox" checked class="removeGroup-layers">{{i "Включая вложенные слои"}}</label><br>' +
                '{{/if}}' +
                '<button class="removeGroup-remove">{{i "Удалить"}}</button>' +
                '</div>');
            var groupNode = _layersTree.treeModel.findElemByGmxProperties(div.gmxProperties).elem;

            var ui = $(template({ anyChildren: groupNode.content.children.length > 0 })),
                pos = nsGmx$1.Utils.getDialogPos(div, true, 90),
                _this = this;

            ui.find('.removeGroup-remove').click(function() {
                var parentTree = div.parentNode.parentNode,
                    childsUl = _abstractTree.getChildsUl(div.parentNode);

                if (ui.find('.removeGroup-layers').prop('checked')) {
                    _layersTree.treeModel.forEachLayer(function(layerContent) {
                        _queryMapLayers.removeLayer(layerContent.properties.name);
                    }, groupNode);
                } else {
                    //TODO: не работает, когда группа не раскрыта или раскрыта не полностью
                    var divDestination = $(parentTree.parentNode).children("div[MapID],div[GroupID]")[0];

                    if (childsUl) {
                        // переносим все слои наверх
                        $(childsUl).find("div[LayerID],div[MultiLayerID]").each(function() {
                            var spanSource = $(this).find("span.layer")[0];

                            _this.moveHandler(spanSource, divDestination);
                        });
                    }
                }

                _this.removeTreeElem(div);

                div.parentNode.removeNode(true);

                _abstractTree.delNode(null, parentTree, parentTree.parentNode);

                $(dialogDiv).dialog('destroy');
                dialogDiv.removeNode(true);

                _mapHelper.updateUnloadEvent(true);

                _this.updateZIndexes();
            });

            var title = _gtxt("Удаление группы [value0]", div.gmxProperties.content.properties.title);
            var dialogDiv = showDialog(title, ui[0], 250, 100, pos.left, pos.top);
        };

        //по элементу дерева слоёв ищет соответствующий элемент в DOM представлении
        layersTree.prototype.findUITreeElem = function(elem) {
            var props = elem.content.properties,
                searchStr;

            if (props.LayerID)
                searchStr = "div[LayerID='" + props.LayerID + "']";
            else if (props.MultiLayerID)
                searchStr = "div[MultiLayerID='" + props.MultiLayerID + "']";
            else if (props.GroupID)
                searchStr = "div[GroupID='" + props.GroupID + "']";
            else
                searchStr = "div[LayerID='" + props.name + "']";

            return $(this._treeCanvas).find(searchStr)[0];
        };

        layersTree.prototype.getLayerVisibility = function(box) {
            if (!box.checked)
                return false;

            var el = box.parentNode.parentNode.parentNode;

            while (!el.root) {
                var group = $(el).children("[GroupID]"),
    				chB = $(group).find('input[type="checkbox"]')[0] || $(group).find('input[type="radio"]')[0];

                if (group.length > 0) {
                    if (!chB.checked)

                        return false;
                }

                el = el.parentNode;
            }

            return true;
        };

        //Устанавливает галочку в checkbox и нужный стиль DOM ноде дерева в зависимости от видимости
        //ничего не трогает вне ноды и в самом дереве
        layersTree.prototype.updateVisibilityUI = function(elem) {
            var div = this.findUITreeElem(elem);
            if (div) {
                var isVisible = elem.content.properties.visible;
                $(div).children("[titleDiv], [multiStyle]").toggleClass("invisible", !isVisible);
                var checkbox = $(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0];
                checkbox.checked = isVisible;
            }
        };

        layersTree.prototype.dummyNode = function(node) {
            var text = node.innerHTML;

            if (text.length > 40) {
                text = text.substring(0, 37) + '...';
            }

            return div = _div$1([_t(text)], [
                ['dir', 'className', 'dragableDummy']
            ]);
        };

        //проходится по всем слоям дерева и устанавливает им z-индексы в соответствии с их порядком в дереве
        layersTree.prototype.updateZIndexes = function() {
            var curZIndex = 0;

            this.treeModel.forEachLayer(function(layerContent, isVisible, nodeDepth) {
                var layer = nsGmx$1.gmxMap.layersByID[layerContent.properties.name];

                var zIndex = curZIndex++;
                layer.setZIndex && layer.setZIndex(zIndex);
            });
        };

        layersTree.prototype.moveHandler = function(spanSource, divDestination) {
            var node = divDestination.parentNode,
                divSource = spanSource.parentNode.parentNode.parentNode,
                parentTree = divSource.parentNode,
                parentElem = this.findTreeElem($(divSource).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0]).parents[0];

            this.removeTreeElem(spanSource.parentNode.parentNode);
            this.addTreeElem(divDestination, 0, spanSource.parentNode.parentNode.gmxProperties);

            // добавим новый узел
            var childsUl = _abstractTree.getChildsUl(node);

            if (childsUl) {
                _abstractTree.addNode(node, divSource);

                this.updateListType(divSource);

                if (!childsUl.loaded)
                    divSource.removeNode(true);
            } else {
                _abstractTree.addNode(node, divSource);

                this.updateListType(divSource);
            }

            parentElem && parentElem.content && this.treeModel.updateNodeVisibility(parentElem);

            // удалим старый узел
            _abstractTree.delNode(node, parentTree, parentTree.parentNode);

            _mapHelper.updateUnloadEvent(true);

            this.updateZIndexes();
        };

        layersTree.prototype.swapHandler = function(spanSource, divDestination) {
            var node = divDestination.parentNode,
                divSource = spanSource.parentNode.parentNode.parentNode,
                parentTree = divSource.parentNode,
                parentElem = this.findTreeElem($(divSource).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0]).parents[0];

            if (node == divSource)
                return;

            this.removeTreeElem(spanSource.parentNode.parentNode);

            var divElem = $(divDestination.parentNode).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0],
                divParent = $(divDestination.parentNode.parentNode.parentNode).children("div[MapID],div[GroupID]")[0],
                index = this.findTreeElem(divElem).index;

            this.addTreeElem(divParent, index + 1, spanSource.parentNode.parentNode.gmxProperties);

            _abstractTree.swapNode(node, divSource);

            this.updateListType(divSource);

            parentElem && parentElem.content && this.treeModel.updateNodeVisibility(parentElem);

            // удалим старый узел
            _abstractTree.delNode(node, parentTree, parentTree.parentNode);

            _mapHelper.updateUnloadEvent(true);

            this.updateZIndexes();
        };

        layersTree.prototype.copyHandler = function(gmxProperties, divDestination, swapFlag, addToMap) {
            var _this = this;
            var isFromList = typeof gmxProperties.content.geometry === 'undefined';
            var layerProperties = (gmxProperties.type !== 'layer' || !isFromList) ? gmxProperties : false,
                copyFunc = function() {
                    if (addToMap) {
                        if (!_this.addLayersToMap(layerProperties))
                            return;
                    } else {
                        if (_this.treeModel.findElemByGmxProperties(gmxProperties)) {
                            if (layerProperties.type === 'layer')
                                showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", layerProperties.content.properties.title), true);
                            else
                                showErrorMessage(_gtxt("Группа '[value0]' уже есть в карте", layerProperties.content.properties.title), true);

                            return;
                        }
                    }

                    var node = divDestination.parentNode,
                        parentProperties = swapFlag ? $(divDestination.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0].gmxProperties : divDestination.gmxProperties,
                        li;

                    if (swapFlag) {
                        var parentDiv = $(divDestination.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0];

                        li = _this.getChildsList(layerProperties, parentProperties, false, parentDiv.getAttribute('MapID') ? true : _this.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0] ? $(parentDiv).find('input[type="checkbox"]')[0] : parentDiv.firstChild));
                    } else
                        li = _this.getChildsList(layerProperties, parentProperties, false, _this.getLayerVisibility($(divDestination).find('input[type="checkbox"]')[0] ? $(divDestination).find('input[type="checkbox"]')[0] : divDestination.firstChild));

                    if (layerProperties.type == 'group') {
                        // добавляем группу
                        if (_abstractTree.getChildsUl(li)) {
                            var div = _div$1(null, [
                                ['dir', 'className', 'hitarea']
                            ]);

                            if (layerProperties.content.properties.expanded) {
                                $(div).addClass('collapsable-hitarea');
                                $(li).addClass('collapsable');
                            } else {
                                $(div).addClass('expandable-hitarea');
                                $(li).addClass('expandable');
                            }

                            _abstractTree.toggle(div);

                            li.insertBefore(div, li.firstChild);

                            $(li).treeview();

                            // если копируем из карты
                            if (isFromList)
                                _layersTree.runLoadingFuncs();
                        }

                        _queryMapLayers.addDraggable(li);

                        _queryMapLayers.addDroppable(li);
                    } else {
                        _queryMapLayers.addDraggable(li);

                        if (layerProperties.type == 'layer' && layerProperties.content.properties.styles.length > 1)
                            $(li).treeview();
                    }

                    _queryMapLayers.addSwappable(li);

                    if (swapFlag) {
                        var divElem = $(divDestination.parentNode).children("div[GroupID],div[LayerID],div[MultiLayerID]")[0],
                            divParent = $(divDestination.parentNode.parentNode.parentNode).children("div[MapID],div[GroupID]")[0],
                            index = _this.findTreeElem(divElem).index;

                        _this.addTreeElem(divParent, index + 1, layerProperties);

                        _abstractTree.swapNode(node, li);

                        _this.updateListType(li, true);
                    } else {
                        _this.addTreeElem(divDestination, 0, layerProperties);

                        var childsUl = _abstractTree.getChildsUl(node);

                        _abstractTree.addNode(node, li);
                        _this.updateListType(li, true);

                        if (childsUl && !childsUl.loaded) {
                            li.removeNode(true);
                        }
                    }

                    _mapHelper.updateUnloadEvent(true);

                    _this.updateZIndexes();
                },
                _this = this;

            if (!layerProperties) {
                if (gmxProperties.content.properties.LayerID) {
                    sendCrossDomainJSONRequest$1(serverBase + "Layer/GetLayerJson.ashx?WrapStyle=func&LayerName=" + gmxProperties.content.properties.name + "&srs=" + (nsGmx$1.leafletMap.options.srs || "3395"), function(response) {
                        if (!parseResponse(response))
                            return;

                        layerProperties = { type: 'layer', content: response.Result };

                        if (layerProperties.content.properties.type == 'Vector')
                            layerProperties.content.properties.styles = [{ MinZoom: 1, MaxZoom: 21, RenderStyle: layerProperties.content.properties.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[layerProperties.content.properties.GeometryType] : _mapHelper.defaultStyles[layerProperties.content.properties.GeometryType] }];
                        else if (layerProperties.content.properties.type != 'Vector' && !layerProperties.content.properties.MultiLayerID)
                            layerProperties.content.properties.styles = [{ MinZoom: layerProperties.content.properties.MinZoom, MaxZoom: 21 }];

                        layerProperties.content.properties.mapName = _this.treeModel.getMapProperties().name;
                        layerProperties.content.properties.hostName = _this.treeModel.getMapProperties().hostName;
                        layerProperties.content.properties.visible = true;

                        copyFunc();
                    });
                } else {
                    sendCrossDomainJSONRequest$1(serverBase + "MultiLayer/GetMultiLayerJson.ashx?WrapStyle=func&MultiLayerID=" + gmxProperties.content.properties.MultiLayerID, function(response) {
                        if (!parseResponse(response))
                            return;

                        layerProperties = { type: 'layer', content: response.Result };

                        layerProperties.content.properties.styles = [{ MinZoom: layerProperties.content.properties.MinZoom, MaxZoom: 20 }];

                        layerProperties.content.properties.mapName = _this.treeModel.getMapProperties().name;
                        layerProperties.content.properties.hostName = _this.treeModel.getMapProperties().hostName;
                        layerProperties.content.properties.visible = true;

                        copyFunc();
                    });
                }
            } else
                copyFunc();
        };

        //не работает для мультислоёв
        layersTree.prototype.addLayerToTree = function(layerName) {
            var gmxProperties = {
                type: 'layer',
                content: {
                    properties: {
                        LayerID: layerName,
                        name: layerName
                    }
                }
            };

            var targetDiv = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0];

            this.copyHandler(gmxProperties, targetDiv, false, true);
        };

        layersTree.prototype.checkGroupForDuplicates = function(elements) {
            var alreadyOnMap = false;
            for (var i = 0; i < elements.length; i++) {
                var elem = elements[i],
                    layer = elem.content,
                    name = layer.properties.name;

                if (nsGmx$1.gmxMap.layersByID[name]) {
                    alreadyOnMap = nsGmx$1.gmxMap.layersByID[name].getGmxProperties().title;
                    break;
                }
            }
            return alreadyOnMap;
        };

        //геометрия слоёв должна быть в координатах меркатора
        layersTree.prototype.addLayersToMap = function(elem) {
            var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;

            var layerOrder = nsGmx$1.gmxMap.rawTree.properties.LayerOrder,
                currentZoom = nsGmx$1.leafletMap.getZoom();

            if (typeof elem.content.properties.GroupID != 'undefined') {
    			var alreadyOnMap = this.checkGroupForDuplicates(elem.content.children);
    			if (alreadyOnMap) {
    				showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", alreadyOnMap), true);
                    return false;
    			} else {
    				for (var i = 0; i < elem.content.children.length; i++) {
    				var res = this.addLayersToMap(elem.content.children[i]);

        				if (!res)
        					return false;
        			}
        		}
            } else {
                var layer = elem.content,
                    name = layer.properties.name;

                // hack to avoid API defaults by initFromDescription;
                var propsHostName = window.serverBase.replace(/https?:\/\//, '');
                propsHostName = propsHostName.replace(/\//g, '');

                layer.properties.hostName = propsHostName;

                if (!nsGmx$1.gmxMap.layersByID[name]) {
                    var visibility = typeof layer.properties.visible != 'undefined' ? layer.properties.visible : false,
                        rcMinZoom = layer.properties.RCMinZoomForRasters,
                        layerOnMap = L.gmx.createLayer(layer, {
                            layerID: name,
                            hostName: propsHostName,
                            zIndexOffset: null,
                            srs: nsGmx$1.leafletMap.options.srs || '',
                            skipTiles: nsGmx$1.leafletMap.options.skipTiles || '',
                            isGeneralized: window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true
                        });

                    updateZIndex(layerOnMap);
                    nsGmx$1.gmxMap.addLayer(layerOnMap);

                    visibility && nsGmx$1.leafletMap.addLayer(layerOnMap);

                    layerOnMap.getGmxProperties().changedByViewer = true;

                    nsGmx$1.leafletMap.on('zoomend', function(e) {
                        currentZoom = nsGmx$1.leafletMap.getZoom();

                        for (var l = 0; l < nsGmx$1.gmxMap.layers.length; l++) {
                            var layer = nsGmx$1.gmxMap.layers[l];

                            updateZIndex(layer);
                        }
                    });
                } else {
                    showErrorMessage(_gtxt("Слой '[value0]' уже есть в карте", nsGmx$1.gmxMap.layersByID[name].getGmxProperties().title), true);
                    return false;
                }
            }

            function updateZIndex(layer) {
                var props = layer.getGmxProperties();

                switch (layerOrder) {
                    case 'VectorOnTop':
                        if (props.type === 'Vector') {
                            if (props.IsRasterCatalog) {
                                var rcMinZoom = props.RCMinZoomForRasters;
                                layer.setZIndexOffset(currentZoom < rcMinZoom ? DEFAULT_VECTOR_LAYER_ZINDEXOFFSET : 0);
                            } else {
                                layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                            }
                        }
                        break;
                }
            }

            return true;
        };

        layersTree.prototype.getParentParams = function(li) {
            //при визуализации дерева в него добавляются новые элементы. Используем хак, чтобы понять, было отрисовано дерево или нет
            var parentParams = li.parentNode.parentNode.childNodes[1].tagName == "DIV" ? li.parentNode.parentNode.childNodes[1].gmxProperties : li.parentNode.parentNode.childNodes[0].gmxProperties,
                listFlag;

            if (parentParams.content)
                listFlag = parentParams.content.properties;
            else
                listFlag = parentParams.properties;

            return listFlag;
        };

        layersTree.prototype.updateListType = function(li, skipVisible) {
            //при визуализации дерева в него добавляются новые элементы. Используем хак, чтобы понять, было отрисовано дерево или нет
            var parentParams = li.parentNode.parentNode.childNodes[1].tagName == "DIV" ? li.parentNode.parentNode.childNodes[1].gmxProperties : li.parentNode.parentNode.childNodes[0].gmxProperties,
                listFlag;

            if (parentParams.content)
                listFlag = parentParams.content.properties.list;
            else
                listFlag = parentParams.properties.list;

            var div = $(li).children("div[MapID],div[GroupID],div[LayerID],div[MultiLayerID]")[0],
                box = $(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0],
                newBox = _checkbox$1(
                    box.checked,
                    listFlag ? 'radio' : 'checkbox',
                    parentParams.content ? parentParams.content.properties.GroupID : parentParams.properties.MapID
                ),
                _this = this;

            newBox.className = 'box layers-visibility-checkbox';

            if (box.getAttribute('box') == 'group')
                newBox.setAttribute('box', 'group');

            $(box).replaceWith(newBox);

            newBox.onclick = function() {
                _this.treeModel.setNodeVisibility(_this.findTreeElem(this.parentNode).elem, this.checked);
            };

            if (box.isDummyCheckbox) {
                newBox.isDummyCheckbox = true;
                newBox.style.display = 'none';
            }

            if (!skipVisible) {
                var parentDiv = $(newBox.parentNode.parentNode.parentNode.parentNode).children("div[GroupID]")[0];
                parentDiv && this.treeModel.updateNodeVisibility(this.findTreeElem(parentDiv).elem, this.findTreeElem(newBox.parentNode).elem);
            }

            return newBox;
        };

        layersTree.prototype.removeTreeElem = function(div) {
            var elem = this.findTreeElem(div);

            if (typeof elem.parents[0].children != 'undefined')
                elem.parents[0].children.splice(elem.index, 1);
            else
                elem.parents[0].content.children.splice(elem.index, 1);
        };

        layersTree.prototype.addTreeElem = function(div, index, elemProperties) {
            var elem = this.findTreeElem(div);

            if (typeof elem.elem.children != 'undefined')
                elem.elem.children.splice(index, 0, elemProperties);
            else
                elem.elem.content.children.splice(index, 0, elemProperties);

            $(this.treeModel.getRawTree()).triggerHandler('addTreeElem', [elemProperties]);
        };

        layersTree.prototype.findTreeElem = function(div) {
            if (div.getAttribute("MapID"))
                return { elem: this.treeModel.getRawTree(), parents: [], index: false };
            else if (div.getAttribute("GroupID"))
                return this.treeModel.findElem("GroupID", div.getAttribute("GroupID"));
            else if (div.getAttribute("LayerID"))
                return this.treeModel.findElem("name", div.getAttribute("LayerID"));
            else if (div.getAttribute("MultiLayerID"))
                return this.treeModel.findElem("name", div.getAttribute("MultiLayerID"));
        };

        //Дерево основной карты
        var _layersTree = new layersTree({ showVisibilityCheckbox: true, allowActive: true, allowDblClick: true });

        window.layersTree = layersTree;
        window._layersTree = _layersTree;

        //Виджет в левой панели для отображения основного дерева
        var queryMapLayers = function() {
            this.buildedTree = null;
            this.builded = false;

            this.buttonsCanvas = _div$1();

            this.loadDeferred = $.Deferred();
        };

        queryMapLayers.prototype = new leftMenu$1();

        queryMapLayers.prototype.addLayers = function(data, condition, mapStyles, LayersTreePermalinkParams) {
            if (condition)
                _layersTree.condition = condition;

            if (mapStyles)
                _layersTree.mapStyles = mapStyles;

            if (LayersTreePermalinkParams)
                _layersTree.LayersTreePermalinkParams = LayersTreePermalinkParams;

            this.buildedTree = _layersTree.drawTree(data);
        };

        queryMapLayers.prototype.applyState = function(condition, mapLayersParam, div) {
            if (!objLength$1(condition.visible) && !objLength$1(condition.expanded) && !objLength$1(mapLayersParam))
                return;

            var parentElem = typeof div == 'undefined' ? _layersTree.treeModel.getRawTree() : _layersTree.findTreeElem(div).elem,
                visFlag = typeof div == 'undefined' ? true : _layersTree.getLayerVisibility($(div).find('input[type="checkbox"]')[0] || $(div).find('input[type="radio"]')[0]),
                _this = this;

            _mapHelper.findTreeElems(parentElem, function(elem, visibleFlag) {
                var props = elem.content.properties;
                if (elem.type == 'group') {
                    var groupId = props.GroupID;

                    if (typeof condition.visible[groupId] != 'undefined' && props.visible != condition.visible[groupId]) {
                        props.visible = condition.visible[groupId];

                        var group = $(_this.buildedTree).find("div[GroupID='" + groupId + "']");

                        if (group.length) {
                            var it = $(group).find('input[type="checkbox"]')[0] || $(group).find('input[type="radio"]')[0];
                            if (it) it.checked = condition.visible[groupId];
    					}
                    }

                    if (typeof condition.expanded[groupId] != 'undefined' && props.expanded != condition.expanded[groupId]) {
                        props.expanded = condition.expanded[groupId];

                        var group = $(_this.buildedTree).find("div[GroupID='" + groupId + "']");

                        if (group.length) {
                            var clickDiv = $(group[0].parentNode).children("div.hitarea");

                            if (clickDiv.length)
                                $(clickDiv[0]).trigger("click");
                        }
                    }
                } else {
                    var name = props.name;
                    if (typeof condition.visible[name] != 'undefined') {
                        _layersTree.treeModel.setNodeVisibility(elem, condition.visible[name]);
                    } else {
                        _layersTree.treeModel.setNodeVisibility(elem, props.initVisible);
                    }

                    if (props.type == "Vector" && typeof mapLayersParam != 'undefined' && typeof mapLayersParam[name] != 'undefined' &&
                        !_this.equalStyles(props.styles, mapLayersParam[name])) {
                        // что-то менялось в стилях
                        var newStyles = mapLayersParam[name],
                            div = $(_this.buildedTree).find("div[LayerID='" + props.LayerID + "']")[0];

                        props.styles = newStyles;

                        _mapHelper.updateMapStyles(newStyles, name);
                        props.changedByViewer = true;

                        div && _mapHelper.updateTreeStyles(newStyles, div, _layersTree, true);
                    }
                }
            }, visFlag);
        };

        queryMapLayers.prototype.equalStyles = function(style1, style2) {
            if (style1.length != style2.length)
                return false;

            for (var i = 0; i < style1.length; i++)
                if (!equals(style1[i], style2[i]))
                    return false;

            return true;
        };

        queryMapLayers.prototype.getContainerBefore = function() {
            if (!this.builded) return;

            return $('.layers-before', this.workCanvas).show();
        };

        queryMapLayers.prototype.getContainerAfter = function() {
            if (!this.builded) return;

            return $('.layers-after', this.workCanvas).show();
        };

        queryMapLayers.prototype.load = function(data) {
            if (this.buildedTree && !this.builded) {
                var _this = this;

                this.treeCanvas = _div$1(null, [
                    ['dir', 'className', 'layers-tree']
                ]);

                //Для обратной совместимости - есть много мапплетов карт, которые пытаются интегрироваться после первого table
                //TODO: изнечтожить все такие мапплеты
                _(this.workCanvas, [_table()]);

                _(this.workCanvas, [
                    _div$1([
                        //_table([_tbody([_tr([_td([_span([_t(_gtxt("Шкала прозрачности"))],[['css','marginLeft','7px'],['css','color','#153069'],['css','fontSize','12px']])]), _td([this.rasterLayersSlider(_queryMapLayers.treeCanvas)])])])])
                    ], [
                        ['dir', 'className', 'layers-before'],
                        ['css', 'display', 'none']
                    ])
                ]);

                _(this.workCanvas, [this.treeCanvas]);

                _(this.treeCanvas, [this.buildedTree]);

                _(this.workCanvas, [
                    _div$1([
                        //_table([_tbody([_tr([_td([_span([_t(_gtxt("Шкала прозрачности"))],[['css','marginLeft','7px'],['css','color','#153069'],['css','fontSize','12px']])]), _td([this.rasterLayersSlider(_queryMapLayers.treeCanvas)])])])])
                    ], [
                        ['dir', 'className', 'layers-after'],
                        ['css', 'display', 'none']
                    ])
                ]);

                $(this.buildedTree).treeview();

                _layersTree.runLoadingFuncs();

                _layersTree.addExpandedEvents(this.buildedTree);

                //при клике на любом пустом месте дерева слоёв снимаем выделение
                $(this.treeCanvas).click(function(event) {
                    var t = $(event.target);
                    //все элементы, на которых можно кликнуть без снятия выделения
                    if (t.hasClass('hitarea') || t.hasClass('groupLayer') || t.attr('styletype') || t.parents('div[layerid],div[MultiLayerID]').length) {
                        return;
                    }
                    _layersTree.setActive(null);
                });

                $(this.treeCanvas).droppable({
                    accept: "span[dragg]",
                    drop: function(ev, ui) {
                        queryMapLayers._droppableHandler.bind($(_this.buildedTree).find('[mapid]')[0], ev, ui)();
                    }
                });

                this.applyState(_layersTree.condition, _layersTree.mapStyles);

                this.builded = true;

                $(this).triggerHandler('load');
                this.loadDeferred.resolve();
            }
        };

        queryMapLayers.prototype.applyOpacityToRasterLayers = function(opacity, parent) {

            var active = $(parent).find(".active");

            // слой
            if (active[0] && (active[0].parentNode.getAttribute("LayerID") || active[0].parentNode.getAttribute("MultiLayerID"))) {
                var props = active[0].parentNode.gmxProperties.content.properties,
                    layer = nsGmx$1.gmxMap.layersByID[props.name];

                layer.setRasterOpacity && layer.setRasterOpacity(opacity / 100);

                return;
            }

            if (active.length) {
                // группа или карта
                var treeElem = _layersTree.findTreeElem(active[0].parentNode);

                _mapHelper.findChilds(treeElem.elem, function(child) {
                    var props = child.content.properties;
                    var layer = nsGmx$1.gmxMap.layersByID[props.name];
                    layer.setRasterOpacity && layer.setRasterOpacity(opacity / 100);
                }, true);
            } else {
                // все растровые слои
                var layers = nsGmx$1.gmxMap.layers;
                for (var i = 0; i < layers.length; i++) {
                    layers[i].setRasterOpacity && layers[i].setRasterOpacity(opacity / 100);
                }
            }
        };

        queryMapLayers.prototype.rasterLayersSlider = function(parent) {
            var slider = nsGmx$1.Controls.createSlider(100,
                    function(event, ui) {
                        _queryMapLayers.applyOpacityToRasterLayers(ui.value, parent);
                    }),
                elem = _div$1([slider], [
                    ['css', 'width', '120px']
                ]);

            slider.style.margin = '10px';
            slider.style.backgroundColor = '#F4F4F4';

            _title(slider, _gtxt("Прозрачность выбранного слоя/группы/карты"));

            return _div$1([elem], [
                ['css', 'padding', '5px 0px 0px 15px']
            ]);
        };

        queryMapLayers.prototype.currentMapRights = function() {
            var mapProperties = _layersTree.treeModel && _layersTree.treeModel.getMapProperties();
            return mapProperties ? mapProperties.Access : "none";
        };

        queryMapLayers.prototype.layerRights = function(name) {
            var layer = nsGmx$1.gmxMap.layersByID[name];
            return layer ? layer.getGmxProperties().Access : null;
        };

        queryMapLayers.prototype.addUserActions = function() {
            if (this.currentMapRights() == "edit") {
                this.addDraggable(this.treeCanvas);

                this.addDroppable(this.treeCanvas);

                this.addSwappable(this.treeCanvas);
            }
        };

        queryMapLayers.prototype.removeUserActions = function() {
            //	removeChilds(this.buttonsCanvas);

            this.removeDraggable(this.treeCanvas);

            this.removeDroppable(this.treeCanvas);

            this.removeSwappable(this.treeCanvas);
        };

        queryMapLayers.prototype.addDraggable = function(parent) {
            $(parent).find("span[dragg]").draggable({
                helper: function(ev) {
                    return _layersTree.dummyNode(ev.target)
                },
                cursorAt: { left: 5, top: 10 },
                appendTo: document.body
            });
        };
        queryMapLayers.prototype.removeDraggable = function(parent) {
            $(parent).find("span[dragg]").draggable('destroy');
        };

        queryMapLayers._droppableHandler = function(ev, ui) {
            $('body').css("cursor", '');

            // удалим элемент, отображающий копирование
            ui.helper[0].removeNode(true);

            // уберем заведомо ложные варианты - сам в себя, копирование условий
            if (this == ui.draggable[0].parentNode.parentNode) return;

            var circle = false,
                layerManager = false;

            $(this).parents().each(function() {
                if ($(this).prev().length > 0 && $(this).prev()[0] == ui.draggable[0].parentNode.parentNode)
                    circle = true;
            });

            if (circle) return;

            var isFromExternalMaps = false;
            $(ui.draggable[0].parentNode.parentNode).parents().each(function() {
                if (this == $('#layersList')[0] || this == $('#mapsList')[0] || this == $('#externalMapsCanvas')[0])
                    layerManager = true;

                if (this == $('#externalMapsCanvas')[0])
                    isFromExternalMaps = true;
            });

            if (!layerManager)
                _layersTree.moveHandler(ui.draggable[0], this);
            else
                _layersTree.copyHandler(ui.draggable[0].parentNode.parentNode.gmxProperties, this, false, !isFromExternalMaps);
        };

        queryMapLayers.prototype.addDroppable = function(parent) {
            $(parent).find("div[GroupID],div[MapID]").droppable({
                accept: "span[dragg]",
                hoverClass: 'droppableHover',
                greedy: true,
                drop: queryMapLayers._droppableHandler
            });

            $(parent).find("div[LayerID],div[MultiLayerID]").droppable({
                accept: "span[dragg]",
                greedy: true,
                drop: function(ev, ui) {
                    var swapElem = $(this).next();
                    swapElem.removeClass('swap-droppableHover');
                    queryMapLayers._swapHandler.call(swapElem[0], ev, ui);
                },
                over: function(ev, ui) {
                    $(this).next().addClass('swap-droppableHover');
                },
                out: function(ev, ui) {
                    $(this).next().removeClass('swap-droppableHover');
                }
            });
        };
        queryMapLayers.prototype.removeDroppable = function(parent) {
            $(parent).find("div[GroupID],div[MapID]").droppable('destroy');
        };

        //статическая ф-ция
        queryMapLayers._swapHandler = function(ev, ui) {
            $('body').css("cursor", '');

            // удалим элемент, отображающий копирование
            ui.helper[0].removeNode(true);

            //проверим, не идёт ли копирование группы внутрь самой себя
            var circle = false;

            $(this).parents().each(function() {
                if ($(this).prev().length > 0 && $(this).prev()[0] == ui.draggable[0].parentNode.parentNode)
                    circle = true;
            });

            if (circle) return;

            var layerManager = false;

            var isFromExternalMaps = false;
            $(ui.draggable[0].parentNode.parentNode).parents().each(function() {
                if (this == $('#layersList')[0] || this == $('#mapsList')[0] || this == $('#externalMapsCanvas')[0])
                    layerManager = true;

                if (this == $('#externalMapsCanvas')[0])
                    isFromExternalMaps = true;
            });

            var gmxProperties = ui.draggable[0].parentNode.parentNode.gmxProperties;

            if (!layerManager)
                _layersTree.swapHandler(ui.draggable[0], this);
            else
                _layersTree.copyHandler(gmxProperties, this, true, !isFromExternalMaps);
        };

        queryMapLayers.prototype.addSwappable = function(parent) {
            $(parent).find("div[swap]").droppable({ accept: "span[dragg]", hoverClass: 'swap-droppableHover', greedy: true, drop: queryMapLayers._swapHandler });
        };
        queryMapLayers.prototype.removeSwappable = function(parent) {
            $(parent).find("div[swap]").droppable('destroy');
        };

        queryMapLayers.prototype.asyncCreateLayer = function(promise, title) {
            var _this = this;

            var taskDiv = _div$1(),
                active = $(_this.buildedTree).find(".active")[0],
                parentDiv;

            if (active && (active.parentNode.getAttribute('MapID') || active.parentNode.getAttribute('GroupID')))
                parentDiv = active.parentNode.parentNode;
            else
                parentDiv = _this.buildedTree.firstChild;

            _abstractTree.addNode(parentDiv, _li$1([taskDiv, _div$1(null, [
                ['css', 'height', '5px'],
                ['css', 'fontSize', '0px']
            ])]));

            promise.fail(function(taskInfo) {
                var parentTree = taskDiv.parentNode.parentNode;
                taskDiv.parentNode.removeNode(true);
                _abstractTree.delNode(null, parentTree, parentTree.parentNode);
            }).done(function(taskInfo) {
                if (!$.isArray(taskInfo.Result)) {
                    taskInfo.Result = [taskInfo.Result];
                }

                var parentDiv = $(taskDiv.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0],
                    parentProperties = parentDiv.gmxProperties;

                var parentTree = taskDiv.parentNode.parentNode;
                taskDiv.parentNode.removeNode(true);
                _abstractTree.delNode(null, parentTree, parentTree.parentNode);

                for (var l = 0; l < taskInfo.Result.length; l++) {
                    var newLayer = taskInfo.Result[l];
                    var newProps = newLayer.properties;

                    var mapProperties = _layersTree.treeModel.getMapProperties();
                    newProps.mapName = mapProperties.name;
                    newProps.hostName = mapProperties.hostName;
                    newProps.visible = true;

                    if (!newProps.styles) {
                        if (newProps.type == 'Vector')
                            newProps.styles = [{ MinZoom: 1, MaxZoom: 21, RenderStyle: newProps.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[newProps.GeometryType] : _mapHelper.defaultStyles[newProps.GeometryType] }];
                        else if (newProps.type != 'Vector' && !newProps.MultiLayerID)
                            newProps.styles = [{ MinZoom: newProps.MinZoom, MaxZoom: 21 }];
                    }

                    var convertedCoords = newLayer.geometry ? L.gmxUtil.convertGeometry(newLayer.geometry, true) : null;

                    _layersTree.addLayersToMap({ content: { properties: newProps, geometry: newLayer.geometry } });

                    var li = _layersTree.getChildsList({
                            type: 'layer',
                            content: { properties: newProps, geometry: convertedCoords }
                        },
                        parentProperties,
                        false,
                        parentDiv.getAttribute('MapID') ? true : _layersTree.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0])
                    );

                    _abstractTree.addNode(parentDiv.parentNode, li);

                    var divElem = $(li).children("div[LayerID]")[0],
                        divParent = $(li.parentNode.parentNode).children("div[MapID],div[GroupID]")[0];

                    _layersTree.addTreeElem(divParent, 0, { type: 'layer', content: { properties: newProps, geometry: convertedCoords } });

                    _queryMapLayers.addSwappable(li);

                    _queryMapLayers.addDraggable(li);

                    _layersTree.updateListType(li);
                }

                _mapHelper.updateUnloadEvent(true);
                _layersTree.updateZIndexes();
            }).progress(function(taskInfo) {
                $(taskDiv).empty();
                _(taskDiv, [_span$1([_t(title + ':')], [
                    ['css', 'color', '#153069'],
                    ['css', 'margin', '0px 3px']
                ]), _t(taskInfo.Status)]);
            });
        };

        queryMapLayers.prototype.asyncUpdateLayer = function(promise, properties, recreateLayer) {
            var layerDiv = $(_queryMapLayers.buildedTree).find("[LayerID='" + properties.LayerID + "']")[0],
                _this = this;

            promise
                .done(function(taskInfo) {
                    if (recreateLayer) {
                        var newLayerProperties = taskInfo.Result.properties;

                        var mapProperties = _layersTree.treeModel.getMapProperties();
                        newLayerProperties.mapName = mapProperties.name;
                        newLayerProperties.hostName = mapProperties.hostName;
                        newLayerProperties.visible = layerDiv.gmxProperties.content.properties.visible;

                        newLayerProperties.styles = layerDiv.gmxProperties.content.properties.styles;

                        //var convertedCoords = from_merc_geometry(taskInfo.Result.geometry);
                        var origGeometry = taskInfo.Result.geometry,
                            convertedGeometry = origGeometry ? L.gmxUtil.geometryToGeoJSON(origGeometry, true) : null;

                        _this.removeLayer(newLayerProperties.name);

                        _layersTree.addLayersToMap({ content: { properties: newLayerProperties, geometry: origGeometry } });

                        var parentProperties = $(_queryMapLayers.buildedTree.firstChild).children("div[MapID]")[0].gmxProperties,
                            li = _layersTree.getChildsList({ type: 'layer', content: { properties: newLayerProperties, geometry: convertedGeometry } }, parentProperties, false, _layersTree.getLayerVisibility($(layerDiv).find('input[type="checkbox"]')[0] || $(layerDiv).find('input[type="radio"]')[0]));

                        $(li).find('[multiStyle]').treeview();

                        $(layerDiv.parentNode).replaceWith(li);

                        _layersTree.findTreeElem($(li).children("div[LayerID]")[0]).elem = { type: 'layer', content: { properties: newLayerProperties, geometry: convertedGeometry } };

                        _queryMapLayers.addSwappable(li);

                        _queryMapLayers.addDraggable(li);

                        _layersTree.updateListType(li);
                        _layersTree.updateZIndexes();

                        var checkedLayer = nsGmx$1.gmxMap.layersByID[newLayerProperties.name];
                        if (checkedLayer) {
                            L.gmx.layersVersion.chkVersion(checkedLayer);
                        }                } else {
                        $('#' + taskInfo.TaskID).remove();

                        layerDiv.style.display = '';
                    }
                }).fail(function(taskInfo) {
                    $('#' + taskInfo.TaskID).remove();
                    layerDiv.style.display = '';
                }).progress(function(taskInfo) {
                    var taskDiv;

                    if (!$('#' + taskInfo.TaskID).length) {
                        taskDiv = _div$1(null, [
                            ['attr', 'id', taskInfo.TaskID]
                        ]);

                        layerDiv.style.display = 'none';

                        $(layerDiv).before(taskDiv);
                    } else {
                        taskDiv = $('#' + taskInfo.TaskID)[0];

                        $(taskDiv).empty();
                    }

                    _(taskDiv, [_span$1([_t(properties.Title + ':')], [
                        ['css', 'color', '#153069'],
                        ['css', 'margin', '0px 3px']
                    ]), _t(taskInfo.Status)]);
                });
        };

        queryMapLayers.prototype.asyncCopyLayer = function(promise, title) {
            console.log('layer copied');

            var _this = this;

            var taskDiv = _div$1(),
                active = $(_this.buildedTree).find(".active")[0],
                parentDiv;

            if (active && (active.parentNode.getAttribute('MapID') || active.parentNode.getAttribute('GroupID')))
                parentDiv = active.parentNode.parentNode;
            else
                parentDiv = _this.buildedTree.firstChild;

            _abstractTree.addNode(parentDiv, _li$1([taskDiv, _div$1(null, [
                ['css', 'height', '5px'],
                ['css', 'fontSize', '0px']
            ])]));

            promise.fail(function(taskInfo) {
                console.log('failed');
                var parentTree = taskDiv.parentNode.parentNode;
                taskDiv.parentNode.removeNode(true);
                _abstractTree.delNode(null, parentTree, parentTree.parentNode);
            }).done(function(taskInfo) {
                console.log('ok');
                if (!$.isArray(taskInfo.Result)) {
                    taskInfo.Result = [taskInfo.Result];
                }

                var parentDiv = $(taskDiv.parentNode.parentNode.parentNode).children("div[GroupID],div[MapID]")[0],
                    parentProperties = parentDiv.gmxProperties;

                var parentTree = taskDiv.parentNode.parentNode;
                taskDiv.parentNode.removeNode(true);
                _abstractTree.delNode(null, parentTree, parentTree.parentNode);

                for (var l = 0; l < taskInfo.Result.length; l++) {
                    var newLayer = taskInfo.Result[l];
                    var newProps = newLayer.properties;

                    var mapProperties = _layersTree.treeModel.getMapProperties();
                    newProps.mapName = mapProperties.name;
                    newProps.hostName = mapProperties.hostName;
                    newProps.visible = true;

                    if (!newProps.styles) {
                        if (newProps.type == 'Vector')
                            newProps.styles = [{ MinZoom: 1, MaxZoom: 21, RenderStyle: newProps.IsPhotoLayer ? _mapHelper.defaultPhotoIconStyles[newProps.GeometryType] : _mapHelper.defaultStyles[newProps.GeometryType] }];
                        else if (newProps.type != 'Vector' && !newProps.MultiLayerID)
                            newProps.styles = [{ MinZoom: newProps.MinZoom, MaxZoom: 21 }];
                    }

                    var convertedCoords = newLayer.geometry ? L.gmxUtil.convertGeometry(newLayer.geometry, true) : null;

                    _layersTree.addLayersToMap({ content: { properties: newProps, geometry: newLayer.geometry } });

                    var li = _layersTree.getChildsList({
                            type: 'layer',
                            content: { properties: newProps, geometry: convertedCoords }
                        },
                        parentProperties,
                        false,
                        parentDiv.getAttribute('MapID') ? true : _layersTree.getLayerVisibility($(parentDiv).find('input[type="checkbox"]')[0])
                    );

                    _abstractTree.addNode(parentDiv.parentNode, li);

                    var divElem = $(li).children("div[LayerID]")[0],
                        divParent = $(li.parentNode.parentNode).children("div[MapID],div[GroupID]")[0];

                    _layersTree.addTreeElem(divParent, 0, { type: 'layer', content: { properties: newProps, geometry: convertedCoords } });

                    _queryMapLayers.addSwappable(li);

                    _queryMapLayers.addDraggable(li);

                    _layersTree.updateListType(li);
                }

                _mapHelper.updateUnloadEvent(true);
                _layersTree.updateZIndexes();
            }).progress(function(taskInfo) {
                console.log('progress');
                $(taskDiv).empty();
                _(taskDiv, [_span$1([_t(title + ':')], [
                    ['css', 'color', '#153069'],
                    ['css', 'margin', '0px 3px']
                ]), _t(taskInfo.Status)]);
            }).always(function(taskInfo) {
                console.log(taskInfo);
            });
        };

        queryMapLayers.prototype.removeLayer = function(name) {
            var layer = nsGmx$1.gmxMap.layersByID[name];
            if (layer) {
                nsGmx$1.leafletMap.removeLayer(layer);
                nsGmx$1.gmxMap.removeLayer(layer);
            }
        };

        queryMapLayers.prototype.getLayers = function() {
            this.createLayersManager();
        };

        queryMapLayers.prototype.createLayersManager = function() {
            var canvas = _div$1();
            var layerManagerControl = new nsGmx$1.LayerManagerControl(canvas, 'layers');

            var existLayers = [];
            for (var i = 0; i < nsGmx$1.gmxMap.layers.length; i++)
                existLayers.push(nsGmx$1.gmxMap.layers[i].getGmxProperties().name);

            layerManagerControl.disableLayers(existLayers);

            var dialogDiv = showDialog(_gtxt("Список слоев"), canvas, 571, 485, 535, 130, function(size) {
                layerManagerControl.resize(size.height - 55);
            });
        };

        queryMapLayers.prototype.getMaps = function() {
            if (!$('#mapsList').length)
                new nsGmx$1.MapsManagerControl();
        };

        queryMapLayers.prototype.createMapDialog = function(title, buttonName, func, addLink) {
            var uiTemplate = Handlebars.compile(
                '<div class = "createMap-container">' +
                '<input class = "inputStyle inputFullWidth createMap-input">' +
                '<button class = "createMap-button">{{buttonName}}</button>' +
                '</div>');

            var ui = $(uiTemplate({ buttonName: buttonName })),
                input = $('.createMap-input', ui)[0];

            var tryCreateMap = function() {
                input.focus();
                if (input.value != '') {
                    removeDialog(dialogDiv);
                    func(input.value);
                } else {
                    inputError(input);
                }
            };

            $(input, ui).on('keydown', function(e) {
                if (e.keyCode === 13) {
                    tryCreateMap();
                    return false;
                }
            });

            $('.createMap-button', ui).click(tryCreateMap);

            addLink && ui.append(addLink);

            var dialogDiv = showDialog(title, ui[0], 280, 115 + (addLink ? 20 : 0), false, false);
        };

        queryMapLayers.prototype.createMap = function(name) {
            sendCrossDomainJSONRequest$1(serverBase + 'Map/Insert.ashx?WrapStyle=func&Title=' + encodeURIComponent(name), function(response) {
                if (!parseResponse(response))
                    return;

                window.location.replace(window.location.href.split(/\?|#/)[0] + "?" + response.Result);
            });
        };

        (function() {

            var saveMapInternal = function(scriptName, mapTitle, callback) {
                var mapID = String($(_queryMapLayers.buildedTree).find("[MapID]")[0].gmxProperties.properties.MapID),
                    saveTree = {};

                window._mapEditorsHash && _mapEditorsHash[mapID] && _mapEditorsHash[mapID].update();

                //обновим стили слоёв из всех незакрытых диалогов редактирования стилей
                var mStyleEditor = gmxCore.getModule('LayerStylesEditor');
                mStyleEditor && mStyleEditor.updateAllStyles();

                nsGmx$1.userObjectsManager.collect();
                $(_queryMapLayers.buildedTree).find("[MapID]")[0].gmxProperties.properties.UserData = JSON.stringify(nsGmx$1.userObjectsManager.getData());

                $.extend(true, saveTree, _layersTree.treeModel.getRawTree());

                var attributesToSave = ['visible', 'styles', 'AllowSearch', 'TiledQuicklook', 'TiledQuicklookMinZoom', 'name', 'MapStructureID'];

                saveTree.properties.BaseLayers = JSON.stringify(nsGmx$1.leafletMap.gmxBaseLayersManager.getActiveIDs());

                //раскрываем все группы так, как записано в свойствах групп
                _mapHelper.findTreeElems(saveTree, function(child, flag) {
                    var props = child.content.properties;
                    if (child.type === "group") {
                        props.expanded = typeof props.initExpand !== 'undefined' ? props.initExpand : false;
                        delete props.initVisible;
                        delete props.initExpand;
                    } else {
                        var propsToSave = {};
                        for (var i = 0; i < attributesToSave.length; i++) {
                            var attrName = attributesToSave[i];
                            if (attrName in props) {
                                propsToSave[attrName] = props[attrName];
                            }
                        }

                        var styles = props.styles || [];

                        for (var s = 0; s < styles.length; s++) {
                            delete styles[s].HoverStyle;
                        }

                        if (window.newStyles) {
                            var keys = L.gmx.StyleManager.DEFAULT_STYLE_KEYS,
                                stylesHash = {};

                            for (var i = 0; i < keys.length; i++) {
                                stylesHash[keys[i]] = true;
                            }
                            propsToSave.gmxStyles = props.gmxStyles;

                            for (var s = 0; s < propsToSave.gmxStyles.styles.length; s++) {
                                var st = propsToSave.gmxStyles.styles[s];
                                delete st.HoverStyle;
                                for (var key in st.RenderStyle) {
                                    if (!(key in stylesHash)) {
                                        delete st.RenderStyle[key];
                                    }
                                }
                            }
                        }

                        child.content.properties = propsToSave;
                        delete child.content.geometry;
                    }
                }, true);

                var params = {
                    WrapStyle: 'window',
                    MapID: mapID,

                    MapJson: JSON.stringify(saveTree)
                };

                if (mapTitle)
                    params.Title = mapTitle;

                sendCrossDomainPostRequest$1(serverBase + scriptName, params,
                    function(response) {
                        if (!parseResponse(response))
                            return;

                        callback && callback(response.Result);

                        _mapHelper.updateUnloadEvent(false);

                        nsGmx$1.widgets.notifications.stopAction('saveMap', 'success', _gtxt("Сохранено"));
                    }
                );
            };

            queryMapLayers.prototype.saveMap = function() {
                nsGmx$1.widgets.notifications.startAction('saveMap');
                saveMapInternal("Map/SaveMap.ashx", null);
            };

            queryMapLayers.prototype.saveMapAs = function(name) {
                nsGmx$1.widgets.notifications.startAction('saveMap');
                saveMapInternal("Map/SaveAs.ashx", name);
            };

        })();

        var _queryMapLayers = new queryMapLayers();
        window._queryMapLayers = _queryMapLayers;

        mapLayers.mapLayers.load = function() {
            var alreadyLoaded = _queryMapLayers.createWorkCanvas('layers', {
                path: null,
                showCloseButton: false,
                showMinimizeButton: false
            });

            if (!alreadyLoaded)
                _queryMapLayers.load();
        };
        mapLayers.mapLayers.unload = function() {};

    })(nsGmx$1.Utils._);

    nsGmx$1.Templates = nsGmx$1.Templates || {};
    nsGmx$1.Templates.AuthWidget = {};
    nsGmx$1.Templates.AuthWidget["authWidget"] = "{{#if userName}}\n" +
        "    <div class=\"authWidget_authorized\">\n" +
        "        <div class=\"authWidget-userPanel\">\n" +
        "            <div class=\"authWidget-userPanel-iconCell\">\n" +
        "                <div class=\"authWidget-userPanel-userIcon\"></div>\n" +
        "            </div>\n" +
        "            <div class=\"authWidget-userPanel-userMenuCell\"></div>\n" +
        "        </div>\n" +
        "    </div>\n" +
        "{{else}}\n" +
        "\n" +
        "    <div class=\"authWidget_unauthorized\">\n" +
        "        <div class=\"authWidget-userPanel\">\n" +
        "            <div class=\"authWidget-userPanel-iconCell\">\n" +
        "                <div class=\"authWidget-userPanel-userIcon\"></div>\n" +
        "            </div>\n" +
        "            <div class=\"authWidget-loginButton\">\n" +
        "                {{i 'auth.login'}}\n" +
        "            </div>\n" +
        "        </div>\n" +
        "    </div>\n" +
        "{{/if}}\n" +
        "";

    nsGmx$1.AuthWidget = (function() {

        // options.loginDialog
        var AuthWidget = function(options) {
            this._view = $('<div>');
            this._view.addClass('authWidget ui-widget');
            this._authManager = options.authManager;
            this._userInfo = null;

            this._options = $.extend({
                showAccountLink: true,
                accountLink: 'http://my.kosmosnimki.ru/Home/Settings/',
                showMapLink: true,
                changePassword: false
                    /* mapLink */
            }, options);

            this._authManager.getUserInfo().then(function(response) {
                this._render({
                    login: response.Result && response.Result.Login,
                    userName: response.Result && (response.Result.FullName || response.Result.Nickname || response.Result.Login)
                });
                this._userInfo = response.Result;
                $(this).trigger('ready');
            }.bind(this)).fail(function(response) {
                this._render(response);
            }.bind(this));
        };

        AuthWidget.prototype._render = function(vm) {

            this._view.html(Handlebars.compile(nsGmx$1.Templates.AuthWidget.authWidget)(vm));

            if (vm.userName) {
                var dropdownItems = [];

                if (this._options.showAccountLink) {
                    dropdownItems.push({
                        title: nsGmx$1.Translations.getText('auth.myAccount'),
                        link: this._options.accountLink,
                        id: 'AuthWidgetAccountLink',
                        newWindow: true
                    });
                }

                if (this._options.showMapLink) {
                    var defaultMapLink = 'http://maps.kosmosnimki.ru/api/index.html?' + encodeURIComponent('@' + vm.login);
                    dropdownItems.push({
                        title: nsGmx$1.Translations.getText('auth.myMap'),
                        link: this._options.mapLink || defaultMapLink,
                        id: 'AuthWidgetMapLink',
                        newWindow: true
                    });
                }

                if (this._options.changePassword) {
                    dropdownItems.push({
                        title: nsGmx$1.Translations.getText('auth.changePassword'),
                        className: 'authWidget-changePasswordButton'
                    });
                }

                if (this._options.isAdmin) {
                    dropdownItems.push({
                        title: nsGmx$1.Translations.getText('Системные настройки'),
                        link: window.serverBase + 'Administration/Actions.aspx',
                        id: 'AuthWidgetAdminLink',
                        newWindow: true
                    });

                    dropdownItems.push({
                        title: nsGmx$1.Translations.getText('Управление группами'),
                        link: 'javascript:void(0)',
                        className: 'authWidget-usergroupMenuItem'
                    });
                }

                dropdownItems.push({
                    title: nsGmx$1.Translations.getText('auth.logout'),
                    className: 'authWidget-logoutButton'
                });

                var dropdownMenuWidget = new nsGmx$1.DropdownMenuWidget({
                    items: [{
                        title: vm.userName,
                        dropdown: dropdownItems
                    }]
                });

                dropdownMenuWidget.appendTo(this._view.find('.authWidget-userPanel-userMenuCell'));
            }

            this._view.find('.authWidget-usergroupMenuItem').click(function(e) {
                if (this._options.callbacks && 'authWidget-usergroupMenuItem' in this._options.callbacks) {
                    this._options.callbacks['authWidget-usergroupMenuItem']();
                } else {
                    return false;
                }
            }.bind(this));

            this._view.find('.authWidget-changePasswordButton').click(function(e) {
                var native = this._authManager.getNative();
                native.changePasswordDialog();
            }.bind(this));

            this._view.find('.authWidget-loginButton').click(function(e) {
                var $iframeContainer;
                if (this._options.loginDialog) {
                    $iframeContainer = $('<div>').addClass('authWidget-iframeContainer');
                    var dialog = $iframeContainer.dialog({
                        width: 500,
                        height: 450,
                        closeText: nsGmx$1.Translations.getText('auth.closeDialog'),
                        close: function(je, ui) {
                            $(this).dialog('destroy');
                        }
                    });
                    // HACK:
                    $(dialog).parent().find('button.ui-button').addClass('ui-icon').css('outline', 'none');
                }

                this._authManager.login({
                    iframeContainer: $iframeContainer && $iframeContainer[0]
                });
            }.bind(this));

            this._view.find('.authWidget-logoutButton').click(function(e) {
                this._authManager.logout().then(function(response) {
                    this._render(response);
                    this._userInfo = response.Result;
                    $(this).trigger('logout');
                }.bind(this));
            }.bind(this));
        };

        /** Получить информацию о пользователе, которую вернул AuthManager
         * @return {Object}
         */
        AuthWidget.prototype.getUserInfo = function() {
            return this._userInfo;
        };

        AuthWidget.prototype.on = function(eventName, callback) {
            $(this).on(eventName, callback);
        };

        AuthWidget.prototype.appendTo = function(placeholder) {
            placeholder.append(this._view);
        };

        return AuthWidget;
    })();
    nsGmx$1.Translations.addText('rus', {
    	auth: {
    		'login': 'Войти',
    		'logout': 'Выйти',
    		'myAccount': 'Личный кабинет',
            'changePassword': 'Сменить пароль',
    		'myMap': 'Личная карта',
    		'closeDialog': 'Закрыть'
    	}
    });

    nsGmx$1.Translations.addText('eng', {
    	auth: {
    		'login': 'Login',
    		'logout': 'Logout',
    		'myAccount': 'My account',
            'changePassword': 'Change password',
    		'myMap': 'My map',
    		'closeDialog': 'Close'
    	}
    });

    /** Виджет для визуализации информации о текущем статусе пользователя.
    * Показывает кнопки Вход/Выход, имя пользователя. Позволяет отослать логин/пароль на сервер, сменить пароль.
     @memberOf nsGmx
     @class
     @name GeoMixerAuthWidget
    */

    (function($, _)
    {
        var _dialogCanvas = null;

        function changePasswordDialog()
        {
            if ($('#changePasswordCanvas').length)
                return;

            var oldInput = _input$1(null, [['dir','className','inputStyle'],['css','width','160px'],['attr','type','password']]),
                newInput = _input$1(null, [['dir','className','inputStyle'],['css','width','160px'],['attr','type','password']]),
                confirmInput = _input$1(null, [['dir','className','inputStyle'],['css','width','160px'],['attr','type','password']]),
                changeButton = makeButton(_gtxt("Изменить")),
                canvas = _div$1([_div$1([_span$1([_t(_gtxt("Старый пароль"))]), _br$1(), oldInput, _br$1(),
                                    _span$1([_t(_gtxt("Новый пароль"))]), _br$1(), newInput, _br$1(),
                                    _span$1([_t(_gtxt("Подтвердите пароль"))]), _br$1(), confirmInput, _br$1()],[['css','textAlign','center']]),
                               _div$1([changeButton],[['css','textAlign','center'],['css','margin','5px']])],[['attr','id','changePasswordCanvas']]),
                checkPassw = function()
                {
                    if (newInput.value != confirmInput.value)
                    {
                        newInput.value = '';
                        confirmInput.value = '';

                        inputError([newInput, confirmInput], 2000);
                        newInput.focus();

                        return;
                    }

                    nsGmx$1.widgets.notifications.startAction('changePassword');
                    nsGmx$1.AuthManager.changePassword(oldInput.value, newInput.value, function()
                    {
                        jQuery(canvas.parentNode).dialog("destroy");
                        canvas.parentNode.removeNode(true);

                        nsGmx$1.widgets.notifications.stopAction('changePassword', 'success', _gtxt('Пароль изменён'));
                    }, function( message )
                    {
                        message && showErrorMessage(message, true);
                        nsGmx$1.widgets.notifications.stopAction('changePassword', 'failure');
                    });

                    oldInput.value = '';
                    newInput.value = '';
                    confirmInput.value = '';
                };

            showDialog(_gtxt("Изменение пароля"), canvas, 200, 200, false, false);
            canvas.parentNode.style.overflow = 'hidden';

            oldInput.focus();

            changeButton.onclick = function()
            {
                checkPassw();
            };

            $(confirmInput).on('keyup', function(e)
            {
                if (e.keyCode === 13)
                {
                    checkPassw();

                    return false;
                }

                return true;
            });
        }

        var loginDialogTemplate =
            '<div>' +
                '<div class = "loginMainDiv">' +
                    '<form>' +
                        '<div>' +
                            '<span class="loginLabel">{{i "Логин"}}</span><br>' +
                            '<input name="login" class = "inputStyle inputLogin" placeholder = "{{i "адрес электронной почты"}}"><br>' +
                        '</div>' +
                        '<div>' +
                            '<span class="loginLabel">{{i "Пароль"}}</span><br>' +
                            '<input name="password" class = "inputStyle inputPass" type = "password" placeholder = "{{i "пароль"}}"><br>' +
                        '</div>' +
                        '<button class="loginButton">{{i "Вход"}}</button>' +
                    '</form>' +
                '</div>' +
                '{{#isMapsSite}}' +
                '<div class="loginLinks">' +
                    '<span class = "buttonLink registration">{{i "Регистрация"}}</span><br>' +
                    '<span class = "buttonLink passRecovery">{{i "Восстановление пароля"}}</span>' +
                '</div>' +
                '{{/isMapsSite}}' +
            '</div>';

        nsGmx$1.GeoMixerAuthWidget = function( container, authManager, loginCallback, options )
        {
            var _container = container;
            var _authManager = authManager;
            var _this = this;

            _this.changePasswordDialog = changePasswordDialog;

            options = options || {};

            var _createLogin = function()
            {
                var span = makeLinkButton$1(_gtxt('Вход'));

                span.onclick = function()
                {
                    _this.showLoginDialog( loginCallback );
                };
                _(_container, [_div$1([span], [['attr','id','log'],['dir','className','log']])]);
            };

            var _createLogout = function()
            {
                var logoutSpan = makeLinkButton$1(_gtxt('Выход'));

                logoutSpan.onclick = function()
                {
                    _authManager.logout(function()
                    {
                        if (nsGmx$1.GeomixerFramework)
                            _mapHelper.reloadMap();
                        else
                            window.location.replace(window.location.href.split("?")[0] + (defaultMapID == globalMapName ? "" : ("&" + globalMapName)));
                    });
                };

                var userText = _authManager.getLogin();
                if (_authManager.getFullname() !== null && _authManager.getFullname() !== '')
                    userText += ' (' + _authManager.getFullname() + ')';
                var userSpan = _span$1([_t(userText)], [['css','cursor','pointer']]);

                userSpan.onclick = function()
                {
                    if ( _authManager.isAccounts() )
                    {
                        if (window.gmxAuthServer)
                            window.open(  window.gmxAuthServer + "Account/ChangePassword", '_blank');
                    }
                    else
                        changePasswordDialog();
                };

                if ( _authManager.isAccounts() )
                    $(userSpan).css('color', '#5555FF');

                _title$1(userSpan, _gtxt("Изменение пароля"));

                _(_container, [_table([_tr([
                    _td([_div$1([userSpan], [['attr','id','user'],['dir','className','user']])]),
                    _td([_div$1([logoutSpan], [['attr','id','log'],['dir','className','log']])])
                ])])]);
            };

            var _update = function()
            {
                if ( window.gmxViewerUI && window.gmxViewerUI.hideLogin )
                    return;

                $(_container).empty();

                if (_authManager.isLogin())
                {
                    _createLogout();
                }
                else
                {
                    _createLogin();
                }
            };

            $(_authManager).change(_update);
            _update();

            //Показывает диалог с вводом логина/пароля, посылает запрос на сервер.
            this.showLoginDialog = function()
            {
                if (_dialogCanvas) {
                    return;
                }

                var isMapsSite = !!window.mapsSite;
                var dialogHeight = isMapsSite ? 210 : 175;

                var canvas = $(Handlebars.compile(loginDialogTemplate)({isMapsSite: isMapsSite})),
                    loginInput = canvas.find('.inputLogin')[0],
                    passwordInput = canvas.find('.inputPass')[0],
                    loginButton = canvas.find('.loginButton')[0];

                var checkLogin = function(){
                    _authManager.login(loginInput.value, passwordInput.value, function()
                        { //всё хорошо
                            $(jQueryDialog).dialog("destroy");
                            jQueryDialog.removeNode(true);
                            _dialogCanvas = null;
                            loginCallback && loginCallback();
                        }, function(err)
                        { //ошибка
                            if (err.emailWarning)
                            {
                                var errorDiv = $("<div/>", {'class': 'EmailErrorMessage'}).text(err.message);
                                $(loginButton).after(errorDiv);
                                setTimeout(function(){
                                    errorDiv.hide(500, function(){ errorDiv.remove(); });
                                }, 8000);
                            }
                            loginInput.value = '';
                            passwordInput.value = '';
                            inputError([loginInput, passwordInput], 2000);
                            loginInput.focus();
                        }
                    );
                };

                _dialogCanvas = canvas;

                var jQueryDialog = showDialog(_gtxt("Пожалуйста, авторизуйтесь"), canvas[0], 248, dialogHeight, false, false, null, function()
                {
                    _dialogCanvas = null;
                });

                loginInput.focus();

                loginButton.onclick = checkLogin;

                canvas.find('form').submit(function(e) {
                    e.preventDefault();
                });

                canvas.find('.registration').click(options.registrationCallback || function(){
                    window.open(window.gmxAuthServer + 'Account/Registration', '_blank');
                });

                canvas.find('.passRecovery').click(function(){
                    window.open(window.gmxAuthServer + 'Account/Retrive', '_blank');
                });

                $(passwordInput).on('keyup', function(e)
                {
                    if (e.keyCode === 13)
                    {
                        checkLogin();

                        return false;
                    }

                    return true;
                });
            };

            this.getContainer = function()
            {
                return _container;
            };
        };

        // Обратная совместимость. Проверка нужна из-за возможного конфликта с одноимённым классом из общих компонент
        if (!nsGmx$1.AuthWidget) {
            nsGmx$1.AuthWidget = nsGmx$1.GeoMixerAuthWidget;
        }

    })(jQuery, nsGmx$1.Utils._);

    /**
    * @namespace DrawingObjects
    * @description SDK для редактирования объектов на карте
    */
    !(function($, _){

    nsGmx$1.Translations.addText('rus', {
        drawingObjects: {
            editStyleTitle: 'Редактировать стиль',
            removeObject: 'Удалить',
            pointTitle: 'точка',
            lineTitle: 'линия',
            polygonTitle: 'многоугольник',
            rectangleTitle: 'прямоугольник',
            removeAll: 'Очистить',
            downloadShp: 'shp',
            downloadGeoJSON: 'geojson',
            downloadGpx: 'gpx',
            downloadCsv: 'csv',
            downloadNameTitle: 'Введите имя файла для скачивания',
            download: 'Скачать файл',
            downloadRaster: 'Скачать фрагмент растра',
            noRectangleError: 'Выберите область рамкой на карте',
            noRasterError: 'К прямоугольнику не подходит ни одного растрового слоя',

            edit: {
                border: 'Граница',
                color: 'Цвет',
                transparency: 'Прозрачность',
                lineWidth: 'Толщина линии',
                description: 'Описание',
                title: 'Редактирование стиля объекта'
            }
        }
    });

    nsGmx$1.Translations.addText('eng', {
        drawingObjects: {
            editStyleTitle: 'Edit style',
            removeObject: 'Delete',
            pointTitle: 'point',
            lineTitle: 'line',
            polygonTitle: 'polygon',
            rectangleTitle: 'rectangle',
            removeAll: 'Delete',
            downloadShp: 'shp',
            downloadGeoJSON: 'geojson',
            downloadGpx: 'gpx',
            downloadCsv: 'csv',
            downloadNameTitle: 'Enter file name to download',
            download: 'Download file',
            downloadRaster: 'Download fragment of raster',
            noRectangleError: 'Select region using frame',
            noRasterError: 'No one raster layer fit the rectangle',

            edit: {
                border: 'Outline',
                color: 'Color',
                transparency: 'Transparency',
                lineWidth: 'Line thickness',
                description: 'Description',
                title: 'Object style editing'
            }
        }
    });

    var setDrawingFeatureStyle = function(drawingFeature, templateStyle) {
        var color = '#' + L.gmxUtil.dec2hex(templateStyle.outline.color),
            opacity = templateStyle.outline.opacity/100;
        drawingFeature.setOptions({
            lineStyle: {
                color: color,
                opacity: opacity,
                weight: templateStyle.outline.thickness
            },
            pointStyle: {
                color: color,
                opacity: opacity
            }
        });
    };

    var CreateDrawingStylesEditorIcon = function(style, type)
    {
    	var icon = nsGmx$1.Controls.createGeometryIcon(style, type);

    	_title(icon, _gtxt('drawingObjects.editStyleTitle'));

    	return icon;
    };

    var CreateDrawingStylesEditor = function(parentObject, style, elemCanvas)
    {
    	var templateStyle = {};
        var jQueryDialog = null;

    	$.extend(true, templateStyle, style);

    	elemCanvas.onclick = function()
    	{
            if (jQueryDialog) {
                return;
            }
    		var canvas = _div(null,[['css','marginTop','10px']]),
    			outlineParent = _tr(),
    			outlineTitleTds = [],
    			outlineTds = [];

    		outlineTitleTds.push(_td([_t(_gtxt('drawingObjects.edit.border'))],[['css','width','70px']]));

    		var outlineColor = nsGmx$1.Controls.createColorPicker(templateStyle.outline.color,
    			function (colpkr){
    				$(colpkr).fadeIn(500);
    				return false;
    			},
    			function (colpkr){
    				$(colpkr).fadeOut(500);
    				return false;
    			},
    			function (hsb, hex, rgb) {
    				outlineColor.style.backgroundColor = '#' + hex;

    				templateStyle.outline.color = outlineColor.hex = parseInt('0x' + hex);

    				$(elemCanvas).find(".borderIcon")[0].style.borderColor = '#' + hex;

    				setDrawingFeatureStyle(parentObject, templateStyle);
    			});

    		outlineColor.hex = templateStyle.outline.color;

    		_title(outlineColor, _gtxt('drawingObjects.edit.color'));

    		outlineTds.push(_td([outlineColor],[['css','width','40px']]));

    		var divSlider = nsGmx$1.Controls.createSlider(templateStyle.outline.opacity,
    				function(event, ui)
    				{
    					templateStyle.outline.opacity = ui.value;

                        setDrawingFeatureStyle(parentObject, templateStyle);
    				});

    		_title(divSlider, _gtxt('drawingObjects.edit.transparency'));

    		outlineTds.push(_td([divSlider],[['css','width','100px'],['css','padding','4px 5px 3px 5px']]));

    		var outlineThick = nsGmx$1.Controls.createInput((templateStyle.outline && typeof templateStyle.outline.thickness != 'undefined') ? templateStyle.outline.thickness : 2,
    				function()
    				{
    					templateStyle.outline.thickness = Number(this.value);

                        setDrawingFeatureStyle(parentObject, templateStyle);

    					return true;
    				}),
    			closeFunc = function()
    			{
    				var newIcon = CreateDrawingStylesEditorIcon(templateStyle, parentObject.toGeoJSON().geometry.type.toLowerCase());
    				CreateDrawingStylesEditor(parentObject, templateStyle, newIcon);

    				$(elemCanvas).replaceWith(newIcon);

    				$(canvas).find(".colorSelector").each(function()
    				{
    					$('#' + $(this).data("colorpickerId")).remove();
    				});
    			};

    		_title(outlineThick, _gtxt('drawingObjects.edit.lineWidth'));

    		outlineTds.push(_td([outlineThick],[['css','width','30px']]));

    		_(outlineParent, outlineTitleTds.concat(_td([_div([_table([_tbody([_tr(outlineTds)])])],[['attr','fade',true]])])));

    		var text = _input(null, [['attr','value', parentObject.options.title || ""],['dir','className','inputStyle'],['css','width','180px']]);
    		$(text).on('keyup', function(evt)
    		{
                if (evt.keyCode === 13)
                {
                    $(jQueryDialog).dialog('destroy');
                    return;
                }

                parentObject.setOptions({title: this.value});

    			$(parentObject).triggerHandler('onEdit', [parentObject]);

    			return true;
    		});

    		_(canvas, [_table([_tbody([_tr([_td([_t(_gtxt('drawingObjects.edit.description'))], [['css','width','70px']]), _td([text])])])]), _br(), _table([_tbody([outlineParent])])]);

    		var pos = nsGmx$1.Utils.getDialogPos(elemCanvas, false, 80);
    		jQueryDialog = showDialog(_gtxt('drawingObjects.edit.title'), canvas, 280, 130, pos.left, pos.top, false, closeFunc);

            $(jQueryDialog).addClass('drawing-object-leaflet-id-' + parentObject._leaflet_id);
    	};

    	elemCanvas.getStyle = function()
    	{
    		return templateStyle;
    	};
    };

    /** Конструктор
     @class Коллекция нарисованных объектов
     @memberOf DrawingObjects
     @param oInitMap Карта, из которой будут добавляться объекты в коллекцию
    */
    var DrawingObjectCollection = function(oInitMap) {
    	var _objects = []; //{item:, editID: , removeID: }
    	var _this = this;

    	var onEdit = function(drawingObject) {
    		/** Вызывается при изменении объекта в коллекции
    		@name DrawingObjects.DrawingObjectCollection.onEdit
    		@event
    		@param {drawingObject} drawingObject изменённый объект*/
    		$(_this).triggerHandler('onEdit', [drawingObject]);
    	};

    	var onRemove = function(drawingObject) {
    		_this.Remove(drawingObject);
    	};

    	/** Возвращает элемент по номеру
    	@param {int} index № объекта в коллекции*/
    	this.Item = function(index){
    		return _objects[index].item;
    	};

    	/** Возвращает количество элементов в коллекции*/
    	this.Count = function(){
    		return _objects.length;
    	};

    	/** Добавляет объект в коллекцию
    	@param {drawingObject} drawingObject Добавляемый объект*/
    	this.Add = function(drawingObject){

            var editID = drawingObject.on('edit', function() {
                onEdit(drawingObject);
            });

            var removeID = drawingObject.on('remove', function() {
                onRemove(drawingObject);
            });

    		_objects.push({
                item: drawingObject,
                editID: editID,
                removeID: removeID
            });

    		/** Вызывается при добавлении объекта в коллекцию
    		@name DrawingObjects.DrawingObjectCollection.onAdd
    		@event
    		@param {drawingObject} drawingObject добавленный объект*/
    		$(this).triggerHandler('onAdd', [drawingObject]);
    	};

    	/** Удаляет объект из коллекции
    	@param {int} index индекс удаляемого объекта*/
    	this.RemoveAt = function(index){
    		var obj = _objects.splice(index, 1)[0];

    		/** Вызывается при удалении объекта из коллекции
    		@name DrawingObjects.DrawingObjectCollection.onRemove
    		@event
    		@param {int} index индекс удаляённого объекта*/
    		$(this).triggerHandler('onRemove', [index]);
    	};

    	/** Удаляет объект из коллекции
    	@param {drawingObject} drawingObject удаляемый объект*/
    	this.Remove = function(drawingObject){
    		for (var i=0; i<_objects.length; i++){
    			if (_objects[i].item === drawingObject) this.RemoveAt(i);
    		}
    	};

        /** Получить индекс объекта в коллекции. null, если объект не найден
    	@param {drawingObject} drawingObject объект, индекс которого мы хотим найти*/
    	this.getIndex = function(drawingObject){
    		for (var i=0; i<_objects.length; i++){
    			if (_objects[i].item === drawingObject) return i;
    		}

            return null;
    	};
    };

    /** Конструктор
     @class Строка с описанием объекта и ссылкой на него
     @description К строке биндится контекстное меню типа "DrawingObject"
     @memberOf DrawingObjects
     @param {L.Map} oInitMap Карта Leaflet
     @param oInitContainer Объект, в котором находится контрол (div)
     @param drawingObject Объект для добавления на карту
     @param options дополнительные параметры
     @param {bool} [options.allowDelete=true] рисовать ли крестик удаления объекта
     @param {bool} [options.editStyle=true] нужна ли возможность редактировать стили
     @param {function(DrawingObject)} [options.click] ф-ция, которая будет вызвана при клике на объекте.
            По умолчанию - центрирование карты на объекте.
    */
    var DrawingObjectInfoRow = function(oInitMap, oInitContainer, drawingObject, options) {
        var defaultClickFunction = function(obj) {
            var geom = obj.toGeoJSON().geometry;
            var coords = geom.coordinates;
    		if (geom.type == "Point") {
                _map.setView([coords[1], coords[0]], Math.max(14, _map.getZoom()));
            } else {
                _map.fitBounds(drawingObject.getBounds());
            }
        };

        var _options = $.extend({
            allowDelete: true,
            editStyle: true,
            click: defaultClickFunction
        }, options);

    	var _drawingObject = drawingObject;
    	var _this = this;
    	var _map = oInitMap;

    	var _canvas = _div(null, [['dir','className','drawingObjectsItemCanvas']]);
    	var _title = _span(null, [['dir','className','drawingObjectsItemTitle']]);
    	var _text = _span(null, [['dir','className', 'drawingObjectsItemTitle']]);
    	var _summary = _span(null, [['dir','className','summary']]);

        if (_options.click) {
            _canvas.onclick = function(e) {
                if (e.target !== remove && (!_options.editStyle || e.target !== icon)) {
                    _options.click(_drawingObject);
                }
            };
        }

        var lineOptions = _drawingObject.options.lineStyle || L.GmxDrawing.utils.defaultStyles.lineStyle;

    	var icon = null;

        var geom = _drawingObject.toGeoJSON().geometry;
        if (_options.editStyle)
        {
            if (geom.type == "Point")
            {
                icon = _img(null, [['attr','src', (window.gmxJSHost || '') + 'img/flag_min.png'], ['dir', 'className', 'colorIcon']]);
            }
            else
            {
                var regularDrawingStyle = {
                    outline: {
                        color: parseInt('0x' + lineOptions.color.split('#')[1]),
                        thickness: lineOptions.weight,
                        opacity: lineOptions.opacity * 100
                    }
                };

                icon = CreateDrawingStylesEditorIcon(regularDrawingStyle, geom.type.toLowerCase());
                CreateDrawingStylesEditor(_drawingObject, regularDrawingStyle, icon);
            }
        }
        else
            icon = _span(null, [['dir', 'className', geom.type + (L.gmxUtil.isRectangle(geom.coordinates) ? ' RECTANGLE' : '')]]);

    	var remove = _span();

        if (_options.allowDelete)
        {
            remove.setAttribute('title', _gtxt('drawingObjects.removeObject'));
            remove.className = 'gmx-icon-close';
            remove.onclick = function(){
                $(_this).triggerHandler('onRemove', [_drawingObject]);
            };
        }

    	_(_canvas, [_span([icon, _title, _text, _summary], [['dir','className','drawingObjectsItem']]), remove]);

    	_(oInitContainer, [_canvas]);

        this._mouseOverHandler = function() {
            $(_canvas).addClass('drawingObjectsActiveItemCanvas');
        };

        this._mouseOutHandler = function() {
            $(_canvas).removeClass('drawingObjectsActiveItemCanvas');
        };

        _drawingObject.on('mouseover', this._mouseOverHandler);
        _drawingObject.on('mouseout', this._mouseOutHandler);

    	/** Обновляет информацию о геометрии */
    	this.UpdateRow = function(){
            var summary = _drawingObject.getSummary(),
                text = _drawingObject.options.title,
                type = _drawingObject.getType();

    		$(_title).empty();
    		$(_text).empty();
    		$(_summary).empty();

    		if (type === 'Point')
    		{
    			_(_title, [_t(_gtxt('drawingObjects.pointTitle'))]);
    			_(_summary, [_t("(" + summary + ")")]);
    		}
    		else if (type === 'Polyline' || type === 'MultiPolyline')
    		{
    			_(_title, [_t(_gtxt('drawingObjects.lineTitle'))]);
    			_(_summary, [_t("(" + summary + ")")]);
    		}
    		else if (type === 'Polygon' || type === 'MultiPolygon' || type === 'Rectangle')
    		{
    			_(_title, [_t(type === 'Rectangle' ? _gtxt('drawingObjects.rectangleTitle') : _gtxt('drawingObjects.polygonTitle'))]);
    			_(_summary, [_t("(" + summary + ")")]);
    		}

    		_(_text, [_t(text ? text.replace(/<[^<>]*>/g, " ") : "")]);

    		if (text)
    			_title.style.display = 'none';
    		else
    			_title.style.display = '';
    	};

    	/** Удаляет строчку */
    	this.RemoveRow = function(){

    		if (_canvas.parentNode)
                _canvas.parentNode.removeChild(_canvas);

            if (_drawingObject === null) return;

            _drawingObject.off('edit', this.UpdateRow);
            _drawingObject.off('remove', this.RemoveRow);
            _drawingObject.off('mouseover', this._mouseOverHandler);
            _drawingObject.off('mouseout', this._mouseOutHandler);

            _drawingObject = null;
    	};

        /** Удаляет строчку */
        this.getContainer = function() {return _canvas;};

        if (nsGmx$1 && nsGmx$1.ContextMenuController) {
            nsGmx$1.ContextMenuController.bindMenuToElem(_title, 'DrawingObject', function(){return true; }, {obj: _drawingObject} );
        }

        this.getDrawingObject = function(){
            return _drawingObject;
        };

        _drawingObject.on('edit', this.UpdateRow);
        _drawingObject.on('remove', this.RemoveRow);

    	this.UpdateRow();
    };

    /** Конструктор
     @class Контрол для отображения коллекции пользовательских объектов
     @memberOf DrawingObjects
     @param oInitMap Карта
     @param {documentElement} oInitContainer Объект, в котором находится контрол (div)
     @param {DrawingObjects.DrawingObjectCollection} oInitDrawingObjectCollection Коллекция пользовательских объектов
     @param {Object} options Дополнительные параметры.Включает все доп. параметры DrawingObjectInfoRow
     @param {bool} [options.showButtons=true] показывать ли кнопки под списком
     @param {selectedIndex} [options.selectedIndex=null] индекс выбранного элемента
    */
    var DrawingObjectList = function(oInitMap, oInitContainer, oInitDrawingObjectCollection, options){
        var _options = $.extend({showButtons: true, selectedIndex: null}, options);
    	var _this = this;
    	var _rows = [];
    	var _containers = [];
    	var _map = oInitMap;
    	var _collection = oInitDrawingObjectCollection;
    	var _divList = _div(null, [['dir', 'className', 'DrawingObjectList']]);
    	var _divButtons = _div();

    	/** Добавляет объект в "список объектов на карте"
    	@param {drawingObject} drawingObject добавляемый объект */
    	var add = function(drawingObject){
    		var divRow = _div();
    		_(_divList, [divRow]);
    		var row = new DrawingObjectInfoRow(_map, divRow, drawingObject, options);
    		_containers.push(divRow);
    		_rows.push(row);
    		$(row).bind('onRemove', function(){ drawingObject.remove(); } );
    		if (_collection.Count() == 1 && _options.showButtons) show(_divButtons);

            /** В списке мышь переместилась над объект
    		@name DrawingObjects.DrawingObjectList.mouseover
    		@event
    		@param {drawingObject} drawingObject объект, над которым находится мышь*/

            /** В списке мышь переместилась с объекта
    		@name DrawingObjects.DrawingObjectList.mouseout
    		@event
    		@param {drawingObject} drawingObject объект, с которого переместилась мышь*/

            $(divRow).bind({
                mouseover: function() {
                    $(_this).triggerHandler('mouseover', [drawingObject]);
                },
                mouseout: function() {
                    $(_this).triggerHandler('mouseout', [drawingObject]);
                }
            });
    	};

    	var onRemove = function(event, index){
    		if (_collection.Count() == 0) hide$1(_divButtons);
    		var removedDiv = _containers.splice(index, 1)[0];
    		_rows.splice(index, 1);
    		removedDiv.parentNode && removedDiv.parentNode.removeChild(removedDiv);

            if (index === _selectedIndex) {
                _selectedIndex = null;
            } else if (index < _selectedIndex) {
                _selectedIndex--;
            }
    	};

    	$(_collection).bind('onRemove', onRemove);
    	$(_collection).bind('onAdd', function(event, drawingObject){
    		add(drawingObject);
    	});

    	for (var i=0; i<_collection.Count(); i++){ add(_collection.Item(i));}

        /** Очищает список пользовательских объектов*/
    	this.Clear = function(){
    		while (_collection.Count()>0){
    			_collection.Item(0).remove();
    		}

            _selectedIndex = null;
    	};

    	/** Возвращает div, в котором находится кнопка "Очистить" и который не виден при пустой коллекции */
    	this.GetDivButtons = function(){
    		return _divButtons;
    	};

        var delAll = makeLinkButton$1(_gtxt('drawingObjects.removeAll'));
    	delAll.onclick = this.Clear;

    	_(_divButtons, [_div([delAll])]);
    	_( oInitContainer, [_divList, _divButtons]);

    	if (_collection.Count() == 0 || !_options.showButtons) hide$1(_divButtons);

        var _selectedIndex = null;

        /** Устанавливает выбранный элемент списка пользовательских объектов.
            null - нет активного. Неправильные индексы игнорируются. К контейнеру выбранного элемента добавляется класс drawingObjectsSelectedItemCanvas
        */
        this.setSelection = function(selectedIndex) {
            var isValidIndex = !!_rows[selectedIndex] || selectedIndex === null;
            if (selectedIndex === _selectedIndex || !isValidIndex) {
                return _selectedIndex;
            }

            if (_rows[_selectedIndex]) {
                $(_rows[_selectedIndex].getContainer()).removeClass('drawingObjectsSelectedItemCanvas');
            }

            if (_rows[selectedIndex]) {
                $(_rows[selectedIndex].getContainer()).addClass('drawingObjectsSelectedItemCanvas');
            }

            _selectedIndex = selectedIndex;

            return _selectedIndex;
        };

        /** Возвращает индекс выбранного элемента списка пользовательских объектов, null - если нет выбранного*/
        this.getSelection = function() {
            return _selectedIndex;
        };

        this.setSelection(_options.selectedIndex);
    };

    /** Конструктор
     @memberOf DrawingObjects
     @class Встраивает список объектов на карте в геомиксер*/
    var DrawingObjectGeomixer = function() {
    	var _this = this;
    	var oMap = null;
        var gmxMap = null;
    	var oMenu = new leftMenu$1();
    	var oListDiv = _div(null, [['dir', 'className', 'DrawingObjectsLeftMenu']]);
    	var bVisible = false;
        var oCollection = null;

    	/** Вызывается при скрывании меню*/
    	this.Unload = function(){ bVisible = false; };

    	/** Загружает меню*/
    	this.Load = function(){
    		if (oMenu != null){
    			var alreadyLoaded = oMenu.createWorkCanvas("DrawingObjects", this.Unload);
    			if(!alreadyLoaded) _(oMenu.workCanvas, [oListDiv]);
    		}
    		bVisible = true;
    	};

    	var fnAddToCollection = function(ev) {
            var feature = ev.object;
    		if (!nsGmx$1.DrawingObjectCustomControllers || !nsGmx$1.DrawingObjectCustomControllers.isHidden(feature)) {
                oCollection.Add(feature);
            }
    	};

    	var checkDownloadVisibility = function(){
    		var isAnyRectangle = false,
                isNonPolygon = false;

    		for (var i=0; i< oCollection.Count(); i++){
                var feature = oCollection.Item(i);
                var geom = feature.toGeoJSON().geometry;
                isAnyRectangle = isAnyRectangle || L.gmxUtil.isRectangle(geom.coordinates);
                isNonPolygon = isNonPolygon || geom.type !== 'Polygon';
    		}

            $(downloadContainer).toggle(oCollection.Count() > 0);
            $(downloadRaster).toggle(gmxMap.properties.CanDownloadRasters && isAnyRectangle);
            $(downloadGpx).toggle(isNonPolygon);
    	};

        var downloadFormat = null;

    	var downloadShp = makeLinkButton$1(_gtxt('drawingObjects.downloadShp'));
    	downloadShp.onclick = function(){
            downloadFormat = 'Shape';
            downloadNameContainer.toggle();
    	};
        downloadShp.style.margin = '0px 3px';

    	var downloadGeoJSON = makeLinkButton$1(_gtxt('drawingObjects.downloadGeoJSON'));
    	downloadGeoJSON.onclick = function(){
            downloadFormat = 'GeoJSON';
            downloadNameContainer.toggle();
    	};
        downloadGeoJSON.style.margin = '0px 3px';

        var downloadGpx = makeLinkButton$1(_gtxt('drawingObjects.downloadGpx'));
    	downloadGpx.onclick = function(){
            downloadFormat = 'gpx';
            downloadNameContainer.toggle();
    	};
        downloadGpx.style.margin = '0px 3px';

        var downloadCsv = makeLinkButton$1(_gtxt('drawingObjects.downloadCsv'));
    	downloadCsv.onclick = function(){
            downloadFormat = 'csv_wkt';
            downloadNameContainer.toggle();
    	};
        downloadCsv.style.margin = '0px 3px';

        var downloadNameInput = $('<input/>', {title: _gtxt('drawingObjects.downloadNameTitle')}).val('markers').addClass('inputStyle');

        downloadNameInput.keyup(function(e) {
            if (e.keyCode == 13) {
                downloadNameButton.click();
            }
        });

        var downloadNameButton = $('<input/>', {type: 'button'}).val(_gtxt('drawingObjects.download')).addClass('btn').click(function() {
            downloadMarkers(downloadNameInput.val(), downloadFormat);
            downloadNameContainer.hide();
            downloadFormat = null;
        });
        var downloadNameContainer = $('<div/>').append(downloadNameInput, downloadNameButton).hide();

        var downloadRasterOptions = $(
            '<div class="drawingObjectsDownloadRaster">' +
                '<label><input type="radio" name="rasterFormat" checked value="univers">jpeg + georefernce</label>' +
                '<label><input type="radio" name="rasterFormat" value="garmin">kmz (Garmin Custom Maps)</label>' +
                '<button id="downloadRaster" class="btn">' + _gtxt('drawingObjects.download') + '</button>' +
            '</div>'
        ).hide();

        $('#downloadRaster', downloadRasterOptions).click(function() {
            var checkInfo = checkRasterLayer();
            if (checkInfo) {
                var bounds = checkInfo.bounds,
                    layer = checkInfo.layer,
                    format = $('input:checked', downloadRasterOptions).val(),
                    temporalParam = "",
                    props = layer.getGmxProperties();

                if (props.Temporal) {
                    var dateInterval = layer.getDateInterval();
                    if (dateInterval) {
                        var dateBeginStr = nsGmx$1.Utils.convertFromServer('date', dateInterval.beginDate/1000),
                            dateEndStr = nsGmx$1.Utils.convertFromServer('date', dateInterval.endDate/1000);

                        temporalParam = "&StartDate=" + encodeURIComponent(dateBeginStr) + "&EndDate=" + encodeURIComponent(dateEndStr);
                    }
                }

                var truncate9 = function(x) { return ("" + x).substring(0, 9); };

                window.location.href =
                    window.location.protocol + "//" + props.hostName + "/DownloadLayer.ashx" +
                    "?t=" + props.name +
                    "&MinX=" + truncate9(bounds.getWest()) +
                    "&MinY=" + truncate9(bounds.getSouth()) +
                    "&MaxX=" + truncate9(bounds.getEast()) +
                    "&MaxY=" + truncate9(bounds.getNorth()) +
                    "&Format=" + format +
                    temporalParam;
            }
        });

    	var downloadRaster = makeLinkButton$1(_gtxt('drawingObjects.downloadRaster'));
    	downloadRaster.onclick = function(){
            if (downloadRasterOptions.find(':visible').length || checkRasterLayer()) {
                downloadRasterOptions.toggle();
            }
    	};

        var downloadContainer = _div();

    	/** Встраивает список объектов на карте в геомиксер*/
    	this.Init = function(leafletMap, initGmxMap){
    		oMap = leafletMap;
            gmxMap = initGmxMap;
    		oCollection = new DrawingObjectCollection(leafletMap);
            $(oCollection).bind('onAdd', function (){
                if(!bVisible) _this.Load();
            });

            $(oCollection).bind('onRemove', function (){
                oCollection.Count() || oMenu.leftPanelItem.close();
            });

            var lmap = nsGmx$1.leafletMap,
                gmxDrawing = lmap.gmxDrawing,
                features = gmxDrawing.getFeatures();

            features.map(function(ret){
    			fnAddToCollection(ret);
    		});

            lmap.gmxDrawing.on('add', fnAddToCollection);

            $(oCollection).bind('onRemove onAdd', checkDownloadVisibility);

            var oDrawingObjectList = new DrawingObjectList(oMap, oListDiv, oCollection);
            _(downloadContainer, [
                _div([_span([_t(_gtxt('drawingObjects.download'))], [['css', 'fontSize', '12px']]), downloadShp, downloadGeoJSON, downloadGpx, downloadCsv]),
                downloadNameContainer[0],
                _div([downloadRaster]),
                downloadRasterOptions[0]
            ]);
    		_(oDrawingObjectList.GetDivButtons(), [downloadContainer]);

    		checkDownloadVisibility();
    	};

    	/** Скачивает shp файл*/
    	var downloadMarkers = function(fileName, format) {
            var geoms = [];

    		for (var i = 0; i < oCollection.Count(); i++) {
                geoms.push(oCollection.Item(i).toGeoJSON());
            }

            nsGmx$1.Utils.downloadGeometry(geoms, {
                fileName: fileName,
                format: format
            });
    	};

    	/** Скачивает растровые слои*/
    	var checkRasterLayer = function(){
    		var obj = false;

    		for (var i = 0; i < oCollection.Count(); i++){
    			var elem = oCollection.Item(i);

    			if (elem.getType() == 'Rectangle') {
    				obj = elem;
                }
    		}

    		if (!obj)
    		{
    			showErrorMessage(_gtxt('drawingObjects.noRectangleError'), true);
    			return;
    		}

    		var bounds = obj.getBounds(),
                center = bounds.getCenter(),
    			layer = false;

    		var testPolygon = function(polygon, latlng){
    			var testRing = function(ring, x, y)
    			{
    				var isInside = false;
    				for (var j = 0; j < ring.length - 1; j++)
    				{
    					var x1 = ring[j][0],
    						y1 = ring[j][1],
    						x2 = ring[j + 1][0],
    						y2 = ring[j + 1][1];

    					if (((y1 >= y) != (y2 >= y)) && ((x1 + (x2 - x1)*(y - y1)/(y2 - y1)) > x))
    						isInside = !isInside;
    				}

    				return isInside;
    			};

    			for (var j = 0; j < polygon.length; j++)
    				if (testRing(polygon[j], latlng.lng, latlng.lat) != (j == 0))
    					return false;

    			return true;
    		};

            for (var iLayerN = 0; iLayerN < gmxMap.layers.length; iLayerN++) {
                var l = gmxMap.layers[iLayerN],
                    props = l.getGmxProperties(),
                    layerBounds = l.getBounds && l.getBounds(),
                    isProperType = props.type == "Raster" || props.IsRasterCatalog;

                if (isProperType && oMap.hasLayer(l) && layerBounds && layerBounds.isValid() && layerBounds.contains(center)) {
                    var geom = l.getGeometry(),
                        coords = geom.coordinates,
                        bIsPolygonBad = false;

                    if (geom.type === "Polygon" && !testPolygon(coords, center)) {
                        bIsPolygonBad = true;
                    } else if (geom.type == "MultiPolygon") {
                        bIsPolygonBad = true;
                        for (var k = 0; k < coords.length; k++)
                            if (testPolygon(coords[k], center)){
                                bIsPolygonBad = false;
                                break;
                            }
                    }

                    if (!bIsPolygonBad && l && (!layer || (props.MaxZoom > layer.getGmxProperties().MaxZoom))) {
                        layer = l;
                    }
                }
            }
            if (!layer) {
                showErrorMessage(_gtxt('drawingObjects.noRasterError'), true);
                return;
            }

            return {bounds: bounds, layer: layer};
    	};
    };

    var publicInterface = {
    	DrawingObjectCollection: DrawingObjectCollection,
    	DrawingObjectInfoRow: DrawingObjectInfoRow,
    	DrawingObjectList: DrawingObjectList,
    	DrawingObjectGeomixer: DrawingObjectGeomixer
    };

    gmxCore$1.addModule("DrawingObjects", publicInterface);

    })(jQuery, nsGmx$1.Utils._);

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var EventTarget = function () {
        function EventTarget() {
            classCallCheck(this, EventTarget);

            this.listeners = {};
        }

        createClass(EventTarget, [{
            key: 'addEventListener',
            value: function addEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    this.listeners[type] = [];
                }
                this.listeners[type].push(callback);
            }
        }, {
            key: 'on',
            value: function on(type, callback) {
                this.addEventListener(type, callback);
                return this;
            }
        }, {
            key: 'removeEventListener',
            value: function removeEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[type];
                for (var i = 0, l = stack.length; i < l; i++) {
                    if (stack[i] === callback) {
                        stack.splice(i, 1);
                        return this.removeEventListener(type, callback);
                    }
                }
            }
        }, {
            key: 'off',
            value: function off(type, callback) {
                this.removeEventListener(type, callback);
                return this;
            }
        }, {
            key: 'dispatchEvent',
            value: function dispatchEvent(event) {
                if (!(event.type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[event.type];
                Object.defineProperty(event, 'target', {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: this
                });
                for (var i = 0, l = stack.length; i < l; i++) {
                    stack[i].call(this, event);
                }
            }
        }]);
        return EventTarget;
    }();

    var scanexEventTarget_cjs = EventTarget;

    var scanexObjectExtensions_cjs = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', { value: true });

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };

    var copy = function copy(source) {
        switch (typeof source === 'undefined' ? 'undefined' : _typeof(source)) {
            case 'number':
            case 'string':
            case 'function':
            default:
                return source;
            case 'object':
                if (source === null) {
                    return null;
                } else if (Array.isArray(source)) {
                    return source.map(function (item) {
                        return copy(item);
                    });
                } else if (source instanceof Date) {
                    return source;
                } else {
                    return Object.keys(source).reduce(function (a, k) {
                        a[k] = copy(source[k]);
                        return a;
                    }, {});
                }
        }
    };

    var extend = function extend(target, source) {
        if (target === source) {
            return target;
        } else {
            return Object.keys(source).reduce(function (a, k) {
                var value = source[k];
                if (_typeof(a[k]) === 'object' && k in a) {
                    a[k] = extend(a[k], value);
                } else {
                    a[k] = copy(value);
                }
                return a;
            }, copy(target));
        }
    };

    exports.copy = copy;
    exports.extend = extend;
    //# sourceMappingURL=scanex-object-extensions.cjs.js.map
    });

    unwrapExports(scanexObjectExtensions_cjs);
    var scanexObjectExtensions_cjs_1 = scanexObjectExtensions_cjs.copy;
    var scanexObjectExtensions_cjs_2 = scanexObjectExtensions_cjs.extend;

    class IconSidebarWidget extends scanexEventTarget_cjs {
        constructor(container, options) {
            super();
            this._options = options;
            this._options.position = this._options.position || 'left';
            this._collapsedWidth = this._options.collapsedWidth || 40;
            this._extendedWidth = this._options.extendedWidth || 400;

            this._container = container;
            this._container.classList.add('iconSidebarControl');
            this._container.innerHTML = `<ul class="iconSidebarControl-tabs"></ul><div class="iconSidebarControl-content"></div>`;
            this._container.classList.add (this._options.position.indexOf ('left') !== -1 ? 'iconSidebarControl-left' : 'iconSidebarControl-right');
            this._tabsContainer = this._container.querySelector ('.iconSidebarControl-tabs');
            this._panesContainer = this._container.querySelector ('.iconSidebarControl-content');

            this._onTabClick = this._onTabClick.bind(this);

            this._panes = {};
        }

        setPane (id, paneOptions) {
            paneOptions = paneOptions || {};
            let defaultPaneOptions = { position: 0, enabled: true };
            let activeTabId = this._activeTabId;

            this._panes[id] = scanexObjectExtensions_cjs_2(scanexObjectExtensions_cjs_2 (scanexObjectExtensions_cjs_2({}, defaultPaneOptions), this._panes[id] || {}), paneOptions);
            if (!this._panes[id].enabled && this._activeTabId === id) {
                this.close();
            }
            
            this._renderTabs({ activeTabId });
            return this._ensurePane(id);
        }
        enable  (id, enabled) {
            let pane = this._panes[id];
            if (pane) {
                pane.enabled = enabled;
            }
        }
        enabled (id) {
            let pane = this._panes[id];
            if (pane) {
                return pane.enabled;
            }
            else {
                return false;
            }
        }
        open (paneId) {
            if (this._isAnimating) {
                return;
            }

            const pane = this._panes[paneId];
            if (!pane || !pane.enabled) {
                return;
            }

            this._activeTabId = paneId;

            this._setTabActive(paneId, true);
            this._setActiveClass(paneId);

            if (this._isOpened) {

    			let event = document.createEvent('Event');
    			event.initEvent('opened', false, false);
    			event.detail =  {id: this._activeTabId};
    			this.dispatchEvent(event);

                return;
            }

            this._isAnimating = true;
    		this._container.classList.add('iconSidebarControl_opened');
    		this._container.classList.add('iconSidebarControl_expanded');

            this._isOpened = true;

    		let event = document.createEvent('Event');
    		event.initEvent('opening', false, false);
    		this.dispatchEvent(event);

            setTimeout(() => {

    			let ev = document.createEvent('Event');
    			ev.initEvent('opened', false, false);
    			ev.detail =  {id: this._activeTabId};
    			this.dispatchEvent(ev);
                this._isAnimating = false;

            }, 250);
        }

        _setTabActive (paneId, flag) {
            let tabs = this._tabsContainer.querySelectorAll('.iconSidebarControl-tab');
            for (let i = 0; i < tabs.length; ++i) {
                let id = tabs[i].getAttribute('data-tab-id');
                let tab = tabs[i].querySelector('.tab-icon');
                if (id === paneId) {
                    if (flag) {
    					tab.classList.add ('tab-icon-active');

                    }
                    else {
    					tab.classList.remove ('tab-icon-active');
                    }

                } else {
    				tab.classList.remove ('tab-icon-active');
                }
            }
        }

        close () {
            if (this._isAnimating) {
                return;
            }
            this._setTabActive(this._activeTabId, false);
    		this._container.classList.remove ('iconSidebarControl_opened');
            this._isAnimating = true;
            this._isOpened = false;

    		let event = document.createEvent('Event');
    		event.initEvent('closing', false, false);
    		this.dispatchEvent(event);

            setTimeout(() => {
                this._container.classList.remove ('iconSidebarControl_expanded');

    			let ev = document.createEvent('Event');
    			ev.detail = { id: this._activeTabId };
    			ev.initEvent('closed', false, false);
    			this.dispatchEvent(ev);

                this._isAnimating = false;
                this._setActiveClass('');
                this._activeTabId = null;

            }, 250);
        }

        getWidth () {
            if (this._isOpened) {
                return this._extendedWidth;
            } else {
                return this._collapsedWidth;
            }
        }

        getActiveTabId () {
            return this._activeTabId;
        }

        isOpened () {
            return this._isOpened;
        }

        _ensurePane (id) {
            for (let i = 0; i < this._panesContainer.childNodes.length; ++i) {
                let node = this._panesContainer.childNodes[i];
                if (node.getAttribute('data-pane-id') === id) {
                    return node;
                }
            }
    		let paneEl = document.createElement ('div');
    		paneEl.classList.add ('iconSidebarControl-pane');
            paneEl.setAttribute('data-pane-id', id);
            this._panesContainer.appendChild(paneEl);
            return paneEl;
        }

        _setActiveClass (activeId) {
            for (let i = 0; i < this._panesContainer.children.length; i++) {
                let id = this._panesContainer.children[i].getAttribute('data-pane-id');
                let pane = this._panesContainer.querySelector('[data-pane-id=' + id + ']');
                if (id === activeId) {
    				pane.classList.add ('iconSidebarControl-pane-active');
                } else {
    				pane.classList.remove ('iconSidebarControl-pane-active');
                }
            }
        }

        _onTabClick (e) {
            let tabId = e.currentTarget.getAttribute('data-tab-id');
            let pane = this._panes[tabId];
            if (!pane || !pane.enabled) {
                return;
            }
            if (!this._isOpened || this._activeTabId !== tabId) {
                this._renderTabs({ activeTabId: tabId });
                this.open(tabId);
            } else {
                this._renderTabs({});
                this.close();
            }
        }

        _renderTabs (options) {
            const getFlag = (tabId, activeTabId, hoveredTabId, enabled)  => {
                if (!enabled) {
                    return 'disabled';
                } else if (hoveredTabId && tabId === hoveredTabId) {
                    return 'hover';
                } else if (activeTabId && tabId === activeTabId) {
                    return 'active';
                } else {
                    return 'default';
                }
            };

            let activeTabId = options.activeTabId;
            let hoveredTabId = options.hoveredTabId;
            this._tabsContainer.innerHTML = '';
            Object.keys(this._panes)
    		.map(id => scanexObjectExtensions_cjs_2({ id }, this._panes[id]))
    		.sort((a, b) => a.position - b.position)
    		.forEach(options => {
                const { id, createTab, enabled } = options;
                if (!createTab) {
                    return;
                }
                let tabContainerEl = document.createElement ('li');
                tabContainerEl.classList.add ('iconSidebarControl-tab');
                tabContainerEl.setAttribute('data-tab-id', id);
                let tabEl = createTab(getFlag(id, activeTabId, hoveredTabId, enabled));
    			tabContainerEl.addEventListener ('click', this._onTabClick);
                tabContainerEl.appendChild(tabEl);
                this._tabsContainer.appendChild(tabContainerEl);
            });
        }
    }

    /*
    == malihu jquery custom scrollbar plugin == 
    Version: 3.0.2 
    Plugin URI: http://manos.malihu.gr/jquery-custom-content-scroller 
    Author: malihu
    Author URI: http://manos.malihu.gr
    License: MIT License (MIT)
    */
    (function($, window, document, undefined$1) {

        /* 
        ----------------------------------------
        PLUGIN NAMESPACE, PREFIX, DEFAULT SELECTOR(S) 
        ----------------------------------------
        */

        var pluginNS = "mCustomScrollbar",
            pluginPfx = "mCS",
            defaultSelector = ".mCustomScrollbar",





            /* 
            ----------------------------------------
            DEFAULT OPTIONS 
            ----------------------------------------
            */

            defaults = {
                /* 
                set element/content width programmatically 
                values: boolean, pixels, percentage 
                */
                setWidth: false,
                /* 
                set element/content height programmatically 
                values: boolean, pixels, percentage 
                */
                setHeight: false,
                /*
                set the initial css top property of content  
                values: string (e.g. "-100px", "10%" etc.)
                */
                setTop: 0,
                /*
                set the initial css left property of content  
                values: string (e.g. "-100px", "10%" etc.)
                */
                setLeft: 0,
                /* 
                scrollbar axis (vertical and/or horizontal scrollbars) 
                values (string): "y", "x", "yx"
                */
                axis: "y",
                /*
                position of scrollbar relative to content  
                values (string): "inside", "outside" ("outside" requires elements with position:relative)
                */
                scrollbarPosition: "inside",
                /*
                scrolling inertia
                values: integer (milliseconds)
                */
                scrollInertia: 950,
                /* 
                auto-adjust scrollbar dragger length
                values: boolean
                */
                autoDraggerLength: true,
                /*
                auto-hide scrollbar when idle 
                values: boolean
                */
                autoHideScrollbar: false,
                /*
                auto-expands scrollbar on mouse-over and dragging
                */
                autoExpandScrollbar: false,
                /*
                always show scrollbar, even when there's nothing to scroll 
                values: integer (0=disable, 1=always show dragger rail, 2=always show dragger rail, dragger and buttons), boolean
                */
                alwaysShowScrollbar: 0,
                /*
                scrolling always snaps to a multiple of this number in pixels
                values: integer
                */
                snapAmount: null,
                /*
                when snapping, snap with this number in pixels as an offset 
                values: integer
                */
                snapOffset: 0,
                /* 
                mouse-wheel scrolling
                */
                mouseWheel: {
                    /* 
                    enable mouse-wheel scrolling
                    values: boolean
                    */
                    enable: true,
                    /* 
                    scrolling amount in pixels
                    values: "auto", integer 
                    */
                    scrollAmount: "auto",
                    /* 
                    mouse-wheel scrolling axis 
                    the default scrolling direction when both vertical and horizontal scrollbars are present 
                    values (string): "y", "x" 
                    */
                    axis: "y",
                    /* 
                    prevent the default behaviour which automatically scrolls the parent element(s) 
                    when end of scrolling is reached 
                    values: boolean
                    */
                    preventDefault: false,
                    /*
                    the reported mouse-wheel delta value. The number of lines (translated to pixels) one wheel notch scrolls.  
                    values: "auto", integer 
                    "auto" uses the default OS/browser value 
                    */
                    deltaFactor: "auto",
                    /*
                    normalize mouse-wheel delta to -1 or 1 (disables mouse-wheel acceleration) 
                    values: boolean
                    */
                    normalizeDelta: false,
                    /*
                    invert mouse-wheel scrolling direction 
                    values: boolean
                    */
                    invert: false,
                    /*
                    the tags that disable mouse-wheel when cursor is over them
                    */
                    disableOver: ["select", "option", "keygen", "datalist", "textarea"]
                },
                /* 
                scrollbar buttons
                */
                scrollButtons: {
                    /*
                    enable scrollbar buttons
                    values: boolean
                    */
                    enable: false,
                    /*
                    scrollbar buttons scrolling type 
                    values (string): "stepless", "stepped"
                    */
                    scrollType: "stepless",
                    /*
                    scrolling amount in pixels
                    values: "auto", integer 
                    */
                    scrollAmount: "auto"
                },
                /* 
                keyboard scrolling
                */
                keyboard: {
                    /*
                    enable scrolling via keyboard
                    values: boolean
                    */
                    enable: true,
                    /*
                    keyboard scrolling type 
                    values (string): "stepless", "stepped"
                    */
                    scrollType: "stepless",
                    /*
                    scrolling amount in pixels
                    values: "auto", integer 
                    */
                    scrollAmount: "auto"
                },
                /*
                enable content touch-swipe scrolling 
                values: boolean, integer, string (number)
                integer values define the axis-specific minimum amount required for scrolling momentum
                */
                contentTouchScroll: 25,
                /*
                advanced option parameters
                */
                advanced: {
                    /*
                    auto-expand content horizontally (for "x" or "yx" axis) 
                    values: boolean
                    */
                    autoExpandHorizontalScroll: false,
                    /*
                    auto-scroll to elements with focus
                    */
                    autoScrollOnFocus: "input,textarea,select,datalist,keygen,a[tabindex],area,object,[contenteditable='true']",
                    /*
                    auto-update scrollbars on content, element or viewport resize 
                    should be true for fluid layouts/elements, adding/removing content dynamically, hiding/showing elements, content with images etc. 
                    values: boolean
                    */
                    updateOnContentResize: true,
                    /*
                    auto-update scrollbars each time each image inside the element is fully loaded 
                    values: boolean
                    */
                    updateOnImageLoad: true,
                    /*
                    auto-update scrollbars based on the amount and size changes of specific selectors 
                    useful when you need to update the scrollbar(s) automatically, each time a type of element is added, removed or changes its size 
                    values: boolean, string (e.g. "ul li" will auto-update scrollbars each time list-items inside the element are changed) 
                    a value of true (boolean) will auto-update scrollbars each time any element is changed
                    */
                    updateOnSelectorChange: false
                },
                /* 
                scrollbar theme 
                values: string 
                ready-to-use themes: "light", "dark", "light-2", "dark-2", "light-3", "dark-3", "light-thick", "dark-thick", "light-thin", "dark-thin", 
                "rounded", "rounded-dark", "rounded-dots", "rounded-dots-dark", "3d", "3d-dark", "3d-thick", "3d-thick-dark", "minimal", "minimal-dark", 
                "inset", "inset-dark", "inset-2", "inset-2-dark", "inset-3", "inset-3-dark"
                */
                theme: "light",
                /*
                user defined callback functions
                */
                callbacks: {
                    /*
                    function to call when a scroll event starts 
                    values (function): function(){}
                    */
                    onScrollStart: false,
                    /*
                    function to call when a scroll event is complete 
                    values (function): function(){}
                    */
                    onScroll: false,
                    /*
                    function to call when a scroll event is complete and content is scrolled all the way to the end (bottom/right)
                    values (function): function(){}
                    */
                    onTotalScroll: false,
                    /*
                    function to call when a scroll event is complete and content is scrolled back to the beginning (top/left)
                    values (function): function(){}
                    */
                    onTotalScrollBack: false,
                    /*
                    function to call when a scroll event is running 
                    values (function): function(){}
                    */
                    whileScrolling: false,
                    /*
                    onTotalScroll offset value
                    values: integer (pixels)
                    */
                    onTotalScrollOffset: 0,
                    /*
                    onTotalScrollBack offset value
                    values: integer (pixels)
                    */
                    onTotalScrollBackOffset: 0,
                    /*
                    callback offsets will trigger even if content is already scrolled to the end or beginning
                    values: boolean
                    */
                    alwaysTriggerOffsets: true
                },
                /*
                add scrollbar(s) on all elements matching the current selector, now and in the future 
                values: boolean, string 
                string values: "on" (enable), "once" (disable after first invocation), "off" (disable)
                */
                live: false,
                /*
                the matching set of elements (instead of the current selector) to add scrollbar(s), now and in the future
                values: string (selector)
                */
                liveSelector: null
            },





            /* 
            ----------------------------------------
            VARS, CONSTANTS 
            ----------------------------------------
            */

            totalInstances = 0,
            /* plugin instances amount */
            liveTimers = {},
            /* live option timers */
            /* live option timers removal */
            removeLiveTimers = function(selector) {
                if (liveTimers[selector]) {
                    clearTimeout(liveTimers[selector]);
                    functions._delete.call(null, liveTimers[selector]);
                }
            },
            oldIE = (window.attachEvent && !window.addEventListener) ? 1 : 0,
            /* detect IE < 9 */
            touchActive = false,
            /* global touch state (for touch and pointer events) */





            /* 
            ----------------------------------------
            METHODS 
            ----------------------------------------
            */

            methods = {

                /* 
                plugin initialization method 
                creates the scrollbar(s), plugin data object and options
                ----------------------------------------
                */

                init: function(options) {

                    var options = $.extend(true, {}, defaults, options),
                        selector = functions._selector.call(this); /* validate selector */

                    /* 
                    if live option is enabled, monitor for elements matching the current selector and 
                    apply scrollbar(s) when found (now and in the future) 
                    */
                    if (options.live) {
                        var liveSelector = options.liveSelector || this.selector || defaultSelector,
                            /* live selector(s) */
                            $liveSelector = $(liveSelector); /* live selector(s) as jquery object */
                        if (options.live === "off") {
                            /* 
                            disable live if requested 
                            usage: $(selector).mCustomScrollbar({live:"off"}); 
                            */
                            removeLiveTimers(liveSelector);
                            return;
                        }
                        liveTimers[liveSelector] = setTimeout(function() {
                            /* call mCustomScrollbar fn on live selector(s) every half-second */
                            $liveSelector.mCustomScrollbar(options);
                            if (options.live === "once" && $liveSelector.length) {
                                /* disable live after first invocation */
                                removeLiveTimers(liveSelector);
                            }
                        }, 500);
                    } else {
                        removeLiveTimers(liveSelector);
                    }

                    /* options backward compatibility (for versions < 3.0.0) and normalization */
                    options.setWidth = (options.set_width) ? options.set_width : options.setWidth;
                    options.setHeight = (options.set_height) ? options.set_height : options.setHeight;
                    options.axis = (options.horizontalScroll) ? "x" : functions._findAxis.call(null, options.axis);
                    options.scrollInertia = options.scrollInertia < 17 ? 17 : options.scrollInertia;
                    if (typeof options.mouseWheel !== "object" && options.mouseWheel == true) { /* old school mouseWheel option (non-object) */
                        options.mouseWheel = { enable: true, scrollAmount: "auto", axis: "y", preventDefault: false, deltaFactor: "auto", normalizeDelta: false, invert: false };
                    }
                    options.mouseWheel.scrollAmount = !options.mouseWheelPixels ? options.mouseWheel.scrollAmount : options.mouseWheelPixels;
                    options.mouseWheel.normalizeDelta = !options.advanced.normalizeMouseWheelDelta ? options.mouseWheel.normalizeDelta : options.advanced.normalizeMouseWheelDelta;
                    options.scrollButtons.scrollType = functions._findScrollButtonsType.call(null, options.scrollButtons.scrollType);

                    functions._theme.call(null, options); /* theme-specific options */

                    /* plugin constructor */
                    return $(selector).each(function() {

                        var $this = $(this);

                        if (!$this.data(pluginPfx)) { /* prevent multiple instantiations */

                            /* store options and create objects in jquery data */
                            $this.data(pluginPfx, {
                                idx: ++totalInstances,
                                /* instance index */
                                opt: options,
                                /* options */
                                scrollRatio: { y: null, x: null },
                                /* scrollbar to content ratio */
                                overflowed: null,
                                /* overflowed axis */
                                bindEvents: false,
                                /* object to check if events are bound */
                                tweenRunning: false,
                                /* object to check if tween is running */
                                sequential: {},
                                /* sequential scrolling object */
                                langDir: $this.css("direction"),
                                /* detect/store direction (ltr or rtl) */
                                cbOffsets: null,
                                /* object to check whether callback offsets always trigger */
                                /* 
                                object to check how scrolling events where last triggered 
                                "internal" (default - triggered by this script), "external" (triggered by other scripts, e.g. via scrollTo method) 
                                usage: object.data("mCS").trigger
                                */
                                trigger: null
                            });

                            /* HTML data attributes */
                            var o = $this.data(pluginPfx).opt,
                                htmlDataAxis = $this.data("mcs-axis"),
                                htmlDataSbPos = $this.data("mcs-scrollbar-position"),
                                htmlDataTheme = $this.data("mcs-theme");
                            if (htmlDataAxis) { o.axis = htmlDataAxis; } /* usage example: data-mcs-axis="y" */
                            if (htmlDataSbPos) { o.scrollbarPosition = htmlDataSbPos; } /* usage example: data-mcs-scrollbar-position="outside" */
                            if (htmlDataTheme) { /* usage example: data-mcs-theme="minimal" */
                                o.theme = htmlDataTheme;
                                functions._theme.call(null, o); /* theme-specific options */
                            }

                            functions._pluginMarkup.call(this); /* add plugin markup */

                            methods.update.call(null, $this); /* call the update method */

                        }

                    });

                },
                /* ---------------------------------------- */



                /* 
                plugin update method 
                updates content and scrollbar(s) values, events and status 
                ----------------------------------------
                usage: $(selector).mCustomScrollbar("update");
                */

                update: function(el) {

                    var selector = el || functions._selector.call(this); /* validate selector */

                    return $(selector).each(function() {

                        var $this = $(this);

                        if ($this.data(pluginPfx)) { /* check if plugin has initialized */

                            var d = $this.data(pluginPfx),
                                o = d.opt,
                                mCSB_container = $("#mCSB_" + d.idx + "_container"),
                                mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")];

                            if (!mCSB_container.length) { return; }

                            if (d.tweenRunning) { functions._stop.call(null, $this); } /* stop any running tweens while updating */

                            /* if element was disabled or destroyed, remove class(es) */
                            if ($this.hasClass("mCS_disabled")) { $this.removeClass("mCS_disabled"); }
                            if ($this.hasClass("mCS_destroyed")) { $this.removeClass("mCS_destroyed"); }

                            functions._maxHeight.call(this); /* detect/set css max-height value */

                            functions._expandContentHorizontally.call(this); /* expand content horizontally */

                            if (o.axis !== "y" && !o.advanced.autoExpandHorizontalScroll) {
                                mCSB_container.css("width", functions._contentWidth(mCSB_container.children()));
                            }

                            d.overflowed = functions._overflowed.call(this); /* determine if scrolling is required */

                            functions._scrollbarVisibility.call(this); /* show/hide scrollbar(s) */

                            /* auto-adjust scrollbar dragger length analogous to content */
                            if (o.autoDraggerLength) { functions._setDraggerLength.call(this); }

                            functions._scrollRatio.call(this); /* calculate and store scrollbar to content ratio */

                            functions._bindEvents.call(this); /* bind scrollbar events */

                            /* reset scrolling position and/or events */
                            var to = [Math.abs(mCSB_container[0].offsetTop), Math.abs(mCSB_container[0].offsetLeft)];
                            if (o.axis !== "x") { /* y/yx axis */
                                if (!d.overflowed[0]) { /* y scrolling is not required */
                                    functions._resetContentPosition.call(this); /* reset content position */
                                    if (o.axis === "y") {
                                        functions._unbindEvents.call(this);
                                    } else if (o.axis === "yx" && d.overflowed[1]) {
                                        functions._scrollTo.call(this, $this, to[1].toString(), { dir: "x", dur: 0, overwrite: "none" });
                                    }
                                } else if (mCSB_dragger[0].height() > mCSB_dragger[0].parent().height()) {
                                    functions._resetContentPosition.call(this); /* reset content position */
                                } else { /* y scrolling is required */
                                    functions._scrollTo.call(this, $this, to[0].toString(), { dir: "y", dur: 0, overwrite: "none" });
                                }
                            }
                            if (o.axis !== "y") { /* x/yx axis */
                                if (!d.overflowed[1]) { /* x scrolling is not required */
                                    functions._resetContentPosition.call(this); /* reset content position */
                                    if (o.axis === "x") {
                                        functions._unbindEvents.call(this);
                                    } else if (o.axis === "yx" && d.overflowed[0]) {
                                        functions._scrollTo.call(this, $this, to[0].toString(), { dir: "y", dur: 0, overwrite: "none" });
                                    }
                                } else if (mCSB_dragger[1].width() > mCSB_dragger[1].parent().width()) {
                                    functions._resetContentPosition.call(this); /* reset content position */
                                } else { /* x scrolling is required */
                                    functions._scrollTo.call(this, $this, to[1].toString(), { dir: "x", dur: 0, overwrite: "none" });
                                }
                            }

                            functions._autoUpdate.call(this); /* initialize automatic updating (for dynamic content, fluid layouts etc.) */

                        }

                    });

                },
                /* ---------------------------------------- */



                /* 
                plugin scrollTo method 
                triggers a scrolling event to a specific value
                ----------------------------------------
                usage: $(selector).mCustomScrollbar("scrollTo",value,options);
                */

                scrollTo: function(val, options) {

                    /* prevent silly things like $(selector).mCustomScrollbar("scrollTo",undefined); */
                    if (typeof val == "undefined" || val == null) { return; }

                    var selector = functions._selector.call(this); /* validate selector */

                    return $(selector).each(function() {

                        var $this = $(this);

                        if ($this.data(pluginPfx)) { /* check if plugin has initialized */

                            var d = $this.data(pluginPfx),
                                o = d.opt,
                                /* method default options */
                                methodDefaults = {
                                    trigger: "external",
                                    /* method is by default triggered externally (e.g. from other scripts) */
                                    scrollInertia: o.scrollInertia,
                                    /* scrolling inertia (animation duration) */
                                    scrollEasing: "mcsEaseInOut",
                                    /* animation easing */
                                    moveDragger: false,
                                    /* move dragger instead of content */
                                    callbacks: true,
                                    /* enable/disable callbacks */
                                    onStart: true,
                                    onUpdate: true,
                                    onComplete: true
                                },
                                methodOptions = $.extend(true, {}, methodDefaults, options),
                                to = functions._arr.call(this, val),
                                dur = methodOptions.scrollInertia < 17 ? 17 : methodOptions.scrollInertia;

                            /* translate yx values to actual scroll-to positions */
                            to[0] = functions._to.call(this, to[0], "y");
                            to[1] = functions._to.call(this, to[1], "x");

                            /* 
                            check if scroll-to value moves the dragger instead of content. 
                            Only pixel values apply on dragger (e.g. 100, "100px", "-=100" etc.) 
                            */
                            if (methodOptions.moveDragger) {
                                to[0] *= d.scrollRatio.y;
                                to[1] *= d.scrollRatio.x;
                            }

                            methodOptions.dur = dur;

                            setTimeout(function() {
                                /* do the scrolling */
                                if (to[0] !== null && typeof to[0] !== "undefined" && o.axis !== "x" && d.overflowed[0]) { /* scroll y */
                                    methodOptions.dir = "y";
                                    methodOptions.overwrite = "all";
                                    functions._scrollTo.call(this, $this, to[0].toString(), methodOptions);
                                }
                                if (to[1] !== null && typeof to[1] !== "undefined" && o.axis !== "y" && d.overflowed[1]) { /* scroll x */
                                    methodOptions.dir = "x";
                                    methodOptions.overwrite = "none";
                                    functions._scrollTo.call(this, $this, to[1].toString(), methodOptions);
                                }
                            }, 60);

                        }

                    });

                },
                /* ---------------------------------------- */



                /*
                plugin stop method 
                stops scrolling animation
                ----------------------------------------
                usage: $(selector).mCustomScrollbar("stop");
                */
                stop: function() {

                    var selector = functions._selector.call(this); /* validate selector */

                    return $(selector).each(function() {

                        var $this = $(this);

                        if ($this.data(pluginPfx)) { /* check if plugin has initialized */

                            functions._stop.call(null, $this);

                        }

                    });

                },
                /* ---------------------------------------- */



                /*
                plugin disable method 
                temporarily disables the scrollbar(s) 
                ----------------------------------------
                usage: $(selector).mCustomScrollbar("disable",reset); 
                reset (boolean): resets content position to 0 
                */
                disable: function(r) {

                    var selector = functions._selector.call(this); /* validate selector */

                    return $(selector).each(function() {

                        var $this = $(this);

                        if ($this.data(pluginPfx)) { /* check if plugin has initialized */

                            var d = $this.data(pluginPfx),
                                o = d.opt;

                            functions._autoUpdate.call(this, "remove"); /* remove automatic updating */

                            functions._unbindEvents.call(this); /* unbind events */

                            if (r) { functions._resetContentPosition.call(this); } /* reset content position */

                            functions._scrollbarVisibility.call(this, true); /* show/hide scrollbar(s) */

                            $this.addClass("mCS_disabled"); /* add disable class */

                        }

                    });

                },
                /* ---------------------------------------- */



                /*
                plugin destroy method 
                completely removes the scrollbar(s) and returns the element to its original state
                ----------------------------------------
                usage: $(selector).mCustomScrollbar("destroy"); 
                */
                destroy: function() {

                        var selector = functions._selector.call(this); /* validate selector */

                        return $(selector).each(function() {

                            var $this = $(this);

                            if ($this.data(pluginPfx)) { /* check if plugin has initialized */

                                var d = $this.data(pluginPfx),
                                    o = d.opt,
                                    mCustomScrollBox = $("#mCSB_" + d.idx),
                                    mCSB_container = $("#mCSB_" + d.idx + "_container"),
                                    scrollbar = $(".mCSB_" + d.idx + "_scrollbar");

                                if (o.live) { removeLiveTimers(selector); } /* remove live timer */

                                functions._autoUpdate.call(this, "remove"); /* remove automatic updating */

                                functions._unbindEvents.call(this); /* unbind events */

                                functions._resetContentPosition.call(this); /* reset content position */

                                $this.removeData(pluginPfx); /* remove plugin data object */

                                functions._delete.call(null, this.mcs); /* delete callbacks object */

                                /* remove plugin markup */
                                scrollbar.remove(); /* remove scrollbar(s) first (those can be either inside or outside plugin's inner wrapper) */
                                mCustomScrollBox.replaceWith(mCSB_container.contents()); /* replace plugin's inner wrapper with the original content */
                                /* remove plugin classes from the element and add destroy class */
                                $this.removeClass(pluginNS + " _" + pluginPfx + "_" + d.idx + " mCS-autoHide mCS-dir-rtl mCS_no_scrollbar mCS_disabled").addClass("mCS_destroyed");

                            }

                        });

                    }
                    /* ---------------------------------------- */

            },





            /* 
            ----------------------------------------
            FUNCTIONS
            ----------------------------------------
            */

            functions = {

                /* validates selector (if selector is invalid or undefined uses the default one) */
                _selector: function() {
                    return (typeof $(this) !== "object" || $(this).length < 1) ? defaultSelector : this;
                },
                /* -------------------- */

                /* changes options according to theme */
                _theme: function(obj) {
                    var fixedSizeScrollbarThemes = ["rounded", "rounded-dark", "rounded-dots", "rounded-dots-dark"],
                        nonExpandedScrollbarThemes = ["rounded-dots", "rounded-dots-dark", "3d", "3d-dark", "3d-thick", "3d-thick-dark", "inset", "inset-dark", "inset-2", "inset-2-dark", "inset-3", "inset-3-dark"],
                        disabledScrollButtonsThemes = ["minimal", "minimal-dark"],
                        enabledAutoHideScrollbarThemes = ["minimal", "minimal-dark"],
                        scrollbarPositionOutsideThemes = ["minimal", "minimal-dark"];
                    obj.autoDraggerLength = $.inArray(obj.theme, fixedSizeScrollbarThemes) > -1 ? false : obj.autoDraggerLength;
                    obj.autoExpandScrollbar = $.inArray(obj.theme, nonExpandedScrollbarThemes) > -1 ? false : obj.autoExpandScrollbar;
                    obj.scrollButtons.enable = $.inArray(obj.theme, disabledScrollButtonsThemes) > -1 ? false : obj.scrollButtons.enable;
                    obj.autoHideScrollbar = $.inArray(obj.theme, enabledAutoHideScrollbarThemes) > -1 ? true : obj.autoHideScrollbar;
                    obj.scrollbarPosition = $.inArray(obj.theme, scrollbarPositionOutsideThemes) > -1 ? "outside" : obj.scrollbarPosition;
                },
                /* -------------------- */


                /* normalizes axis option to valid values: "y", "x", "yx" */
                _findAxis: function(val) {
                    return (val === "yx" || val === "xy" || val === "auto") ? "yx" : (val === "x" || val === "horizontal") ? "x" : "y";
                },
                /* -------------------- */


                /* normalizes scrollButtons.scrollType option to valid values: "stepless", "stepped" */
                _findScrollButtonsType: function(val) {
                    return (val === "stepped" || val === "pixels" || val === "step" || val === "click") ? "stepped" : "stepless";
                },
                /* -------------------- */


                /* generates plugin markup */
                _pluginMarkup: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        expandClass = o.autoExpandScrollbar ? " mCSB_scrollTools_onDrag_expand" : "",
                        scrollbar = ["<div id='mCSB_" + d.idx + "_scrollbar_vertical' class='mCSB_scrollTools mCSB_" + d.idx + "_scrollbar mCS-" + o.theme + " mCSB_scrollTools_vertical" + expandClass + "'><div class='mCSB_draggerContainer'><div id='mCSB_" + d.idx + "_dragger_vertical' class='mCSB_dragger' style='position:absolute;' oncontextmenu='return false;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>", "<div id='mCSB_" + d.idx + "_scrollbar_horizontal' class='mCSB_scrollTools mCSB_" + d.idx + "_scrollbar mCS-" + o.theme + " mCSB_scrollTools_horizontal" + expandClass + "'><div class='mCSB_draggerContainer'><div id='mCSB_" + d.idx + "_dragger_horizontal' class='mCSB_dragger' style='position:absolute;' oncontextmenu='return false;'><div class='mCSB_dragger_bar' /></div><div class='mCSB_draggerRail' /></div></div>"],
                        wrapperClass = o.axis === "yx" ? "mCSB_vertical_horizontal" : o.axis === "x" ? "mCSB_horizontal" : "mCSB_vertical",
                        scrollbars = o.axis === "yx" ? scrollbar[0] + scrollbar[1] : o.axis === "x" ? scrollbar[1] : scrollbar[0],
                        contentWrapper = o.axis === "yx" ? "<div id='mCSB_" + d.idx + "_container_wrapper' class='mCSB_container_wrapper' />" : "",
                        autoHideClass = o.autoHideScrollbar ? " mCS-autoHide" : "",
                        scrollbarDirClass = (o.axis !== "x" && d.langDir === "rtl") ? " mCS-dir-rtl" : "";
                    if (o.setWidth) { $this.css("width", o.setWidth); } /* set element width */
                    if (o.setHeight) { $this.css("height", o.setHeight); } /* set element height */
                    o.setLeft = (o.axis !== "y" && d.langDir === "rtl") ? "989999px" : o.setLeft; /* adjust left position for rtl direction */
                    $this.addClass(pluginNS + " _" + pluginPfx + "_" + d.idx + autoHideClass + scrollbarDirClass).wrapInner("<div id='mCSB_" + d.idx + "' class='mCustomScrollBox mCS-" + o.theme + " " + wrapperClass + "'><div id='mCSB_" + d.idx + "_container' class='mCSB_container' style='position:relative; top:" + o.setTop + "; left:" + o.setLeft + ";' dir=" + d.langDir + " /></div>");
                    var mCustomScrollBox = $("#mCSB_" + d.idx),
                        mCSB_container = $("#mCSB_" + d.idx + "_container");
                    if (o.axis !== "y" && !o.advanced.autoExpandHorizontalScroll) {
                        mCSB_container.css("width", functions._contentWidth(mCSB_container.children()));
                    }
                    if (o.scrollbarPosition === "outside") {
                        if ($this.css("position") === "static") { /* requires elements with non-static position */
                            $this.css("position", "relative");
                        }
                        $this.css("overflow", "visible");
                        mCustomScrollBox.addClass("mCSB_outside").after(scrollbars);
                    } else {
                        mCustomScrollBox.addClass("mCSB_inside").append(scrollbars);
                        mCSB_container.wrap(contentWrapper);
                    }
                    functions._scrollButtons.call(this); /* add scrollbar buttons */
                    /* minimum dragger length */
                    var mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")];
                    mCSB_dragger[0].css("min-height", mCSB_dragger[0].height());
                    mCSB_dragger[1].css("min-width", mCSB_dragger[1].width());
                },
                /* -------------------- */


                /* calculates content width */
                _contentWidth: function(el) {
                    return Math.max.apply(Math, el.map(function() { return $(this).outerWidth(true); }).get());
                },
                /* -------------------- */


                /* expands content horizontally */
                _expandContentHorizontally: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        mCSB_container = $("#mCSB_" + d.idx + "_container");
                    if (o.advanced.autoExpandHorizontalScroll && o.axis !== "y") {
                        /* 
                        wrap content with an infinite width div and set its position to absolute and width to auto. 
                        Setting width to auto before calculating the actual width is important! 
                        We must let the browser set the width as browser zoom values are impossible to calculate.
                        */
                        mCSB_container.css({ "position": "absolute", "width": "auto" })
                            .wrap("<div class='mCSB_h_wrapper' style='position:relative; left:0; width:999999px;' />")
                            .css({ /* set actual width, original position and un-wrap */
                                /* 
                                get the exact width (with decimals) and then round-up. 
                                Using jquery outerWidth() will round the width value which will mess up with inner elements that have non-integer width
                                */
                                "width": (Math.ceil(mCSB_container[0].getBoundingClientRect().right + 0.4) - Math.floor(mCSB_container[0].getBoundingClientRect().left)),
                                "position": "relative"
                            }).unwrap();
                    }
                },
                /* -------------------- */


                /* adds scrollbar buttons */
                _scrollButtons: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        mCSB_scrollTools = $(".mCSB_" + d.idx + "_scrollbar:first"),
                        btnHTML = [
                            "<a href='#' class='mCSB_buttonUp' oncontextmenu='return false;' />", "<a href='#' class='mCSB_buttonDown' oncontextmenu='return false;' />",
                            "<a href='#' class='mCSB_buttonLeft' oncontextmenu='return false;' />", "<a href='#' class='mCSB_buttonRight' oncontextmenu='return false;' />"
                        ],
                        btn = [(o.axis === "x" ? btnHTML[2] : btnHTML[0]), (o.axis === "x" ? btnHTML[3] : btnHTML[1]), btnHTML[2], btnHTML[3]];
                    if (o.scrollButtons.enable) {
                        mCSB_scrollTools.prepend(btn[0]).append(btn[1]).next(".mCSB_scrollTools").prepend(btn[2]).append(btn[3]);
                    }
                },
                /* -------------------- */


                /* detects/sets css max-height value */
                _maxHeight: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        mCustomScrollBox = $("#mCSB_" + d.idx),
                        mh = $this.css("max-height"),
                        pct = mh.indexOf("%") !== -1,
                        bs = $this.css("box-sizing");
                    if (mh !== "none") {
                        var val = pct ? $this.parent().height() * parseInt(mh) / 100 : parseInt(mh);
                        /* if element's css box-sizing is "border-box", subtract any paddings and/or borders from max-height value */
                        if (bs === "border-box") { val -= (($this.innerHeight() - $this.height()) + ($this.outerHeight() - $this.innerHeight())); }
                        mCustomScrollBox.css("max-height", Math.round(val));
                    }
                },
                /* -------------------- */


                /* auto-adjusts scrollbar dragger length */
                _setDraggerLength: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        mCustomScrollBox = $("#mCSB_" + d.idx),
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")],
                        ratio = [mCustomScrollBox.height() / mCSB_container.outerHeight(false), mCustomScrollBox.width() / mCSB_container.outerWidth(false)],
                        l = [
                            parseInt(mCSB_dragger[0].css("min-height")), Math.round(ratio[0] * mCSB_dragger[0].parent().height()),
                            parseInt(mCSB_dragger[1].css("min-width")), Math.round(ratio[1] * mCSB_dragger[1].parent().width())
                        ],
                        h = oldIE && (l[1] < l[0]) ? l[0] : l[1],
                        w = oldIE && (l[3] < l[2]) ? l[2] : l[3];
                    mCSB_dragger[0].css({
                        "height": h,
                        "max-height": (mCSB_dragger[0].parent().height() - 10)
                    }).find(".mCSB_dragger_bar").css({ "line-height": l[0] + "px" });
                    mCSB_dragger[1].css({
                        "width": w,
                        "max-width": (mCSB_dragger[1].parent().width() - 10)
                    });
                },
                /* -------------------- */


                /* calculates scrollbar to content ratio */
                _scrollRatio: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        mCustomScrollBox = $("#mCSB_" + d.idx),
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")],
                        scrollAmount = [mCSB_container.outerHeight(false) - mCustomScrollBox.height(), mCSB_container.outerWidth(false) - mCustomScrollBox.width()],
                        ratio = [
                            scrollAmount[0] / (mCSB_dragger[0].parent().height() - mCSB_dragger[0].height()),
                            scrollAmount[1] / (mCSB_dragger[1].parent().width() - mCSB_dragger[1].width())
                        ];
                    d.scrollRatio = { y: ratio[0], x: ratio[1] };
                },
                /* -------------------- */


                /* toggles scrolling classes */
                _onDragClasses: function(el, action, xpnd) {
                    var expandClass = xpnd ? "mCSB_dragger_onDrag_expanded" : "",
                        classes = ["mCSB_dragger_onDrag", "mCSB_scrollTools_onDrag"],
                        scrollbar = el.closest(".mCSB_scrollTools");
                    if (action === "active") {
                        el.toggleClass(classes[0] + " " + expandClass);
                        scrollbar.toggleClass(classes[1]);
                        el[0]._draggable = el[0]._draggable ? 0 : 1;
                    } else {
                        if (!el[0]._draggable) {
                            if (action === "hide") {
                                el.removeClass(classes[0]);
                                scrollbar.removeClass(classes[1]);
                            } else {
                                el.addClass(classes[0]);
                                scrollbar.addClass(classes[1]);
                            }
                        }
                    }
                },
                /* -------------------- */


                /* checks if content overflows its container to determine if scrolling is required */
                _overflowed: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        mCustomScrollBox = $("#mCSB_" + d.idx),
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        contentHeight = d.overflowed == null ? mCSB_container.height() : mCSB_container.outerHeight(false),
                        contentWidth = d.overflowed == null ? mCSB_container.width() : mCSB_container.outerWidth(false);
                    return [contentHeight > mCustomScrollBox.height(), contentWidth > mCustomScrollBox.width()];
                },
                /* -------------------- */


                /* resets content position to 0 */
                _resetContentPosition: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        mCustomScrollBox = $("#mCSB_" + d.idx),
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")];
                    functions._stop($this); /* stop any current scrolling before resetting */
                    if ((o.axis !== "x" && !d.overflowed[0]) || (o.axis === "y" && d.overflowed[0])) { mCSB_dragger[0].add(mCSB_container).css("top", 0); } /* reset y */
                    if ((o.axis !== "y" && !d.overflowed[1]) || (o.axis === "x" && d.overflowed[1])) { /* reset x */
                        var cx = dx = 0;
                        if (d.langDir === "rtl") { /* adjust left position for rtl direction */
                            cx = mCustomScrollBox.width() - mCSB_container.outerWidth(false);
                            dx = Math.abs(cx / d.scrollRatio.x);
                        }
                        mCSB_container.css("left", cx);
                        mCSB_dragger[1].css("left", dx);
                    }
                },
                /* -------------------- */


                /* binds scrollbar events */
                _bindEvents: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt;
                    if (!d.bindEvents) { /* check if events are already bound */
                        functions._draggable.call(this);
                        if (o.contentTouchScroll) { functions._contentDraggable.call(this); }
                        if (o.mouseWheel.enable) { /* bind mousewheel fn when plugin is available */
                            function _mwt() {
                                mousewheelTimeout = setTimeout(function() {
                                    if (!$.event.special.mousewheel) {
                                        _mwt();
                                    } else {
                                        clearTimeout(mousewheelTimeout);
                                        functions._mousewheel.call($this[0]);
                                    }
                                }, 1000);
                            }
                            var mousewheelTimeout;
                            _mwt();
                        }
                        functions._draggerRail.call(this);
                        functions._wrapperScroll.call(this);
                        if (o.advanced.autoScrollOnFocus) { functions._focus.call(this); }
                        if (o.scrollButtons.enable) { functions._buttons.call(this); }
                        if (o.keyboard.enable) { functions._keyboard.call(this); }
                        d.bindEvents = true;
                    }
                },
                /* -------------------- */


                /* unbinds scrollbar events */
                _unbindEvents: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        namespace = pluginPfx + "_" + d.idx,
                        sb = ".mCSB_" + d.idx + "_scrollbar",
                        sel = $("#mCSB_" + d.idx + ",#mCSB_" + d.idx + "_container,#mCSB_" + d.idx + "_container_wrapper," + sb + " .mCSB_draggerContainer,#mCSB_" + d.idx + "_dragger_vertical,#mCSB_" + d.idx + "_dragger_horizontal," + sb + ">a"),
                        mCSB_container = $("#mCSB_" + d.idx + "_container");
                    if (d.bindEvents) { /* check if events are bound */
                        /* unbind namespaced events from document/selectors */
                        $(document).unbind("." + namespace);
                        sel.each(function() {
                            $(this).unbind("." + namespace);
                        });
                        /* clear and delete timeouts/objects */
                        clearTimeout($this[0]._focusTimeout);
                        functions._delete.call(null, $this[0]._focusTimeout);
                        clearTimeout(d.sequential.step);
                        functions._delete.call(null, d.sequential.step);
                        clearTimeout(mCSB_container[0].onCompleteTimeout);
                        functions._delete.call(null, mCSB_container[0].onCompleteTimeout);
                        d.bindEvents = false;
                    }
                },
                /* -------------------- */


                /* toggles scrollbar visibility */
                _scrollbarVisibility: function(disabled) {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        contentWrapper = $("#mCSB_" + d.idx + "_container_wrapper"),
                        content = contentWrapper.length ? contentWrapper : $("#mCSB_" + d.idx + "_container"),
                        scrollbar = [$("#mCSB_" + d.idx + "_scrollbar_vertical"), $("#mCSB_" + d.idx + "_scrollbar_horizontal")],
                        mCSB_dragger = [scrollbar[0].find(".mCSB_dragger"), scrollbar[1].find(".mCSB_dragger")];
                    if (o.axis !== "x") {
                        if (d.overflowed[0] && !disabled) {
                            scrollbar[0].add(mCSB_dragger[0]).add(scrollbar[0].children("a")).css("display", "block");
                            content.removeClass("mCS_no_scrollbar_y mCS_y_hidden");
                        } else {
                            if (o.alwaysShowScrollbar) {
                                if (o.alwaysShowScrollbar !== 2) { mCSB_dragger[0].add(scrollbar[0].children("a")).css("display", "none"); }
                                content.removeClass("mCS_y_hidden");
                            } else {
                                scrollbar[0].css("display", "none");
                                content.addClass("mCS_y_hidden");
                            }
                            content.addClass("mCS_no_scrollbar_y");
                        }
                    }
                    if (o.axis !== "y") {
                        if (d.overflowed[1] && !disabled) {
                            scrollbar[1].add(mCSB_dragger[1]).add(scrollbar[1].children("a")).css("display", "block");
                            content.removeClass("mCS_no_scrollbar_x mCS_x_hidden");
                        } else {
                            if (o.alwaysShowScrollbar) {
                                if (o.alwaysShowScrollbar !== 2) { mCSB_dragger[1].add(scrollbar[1].children("a")).css("display", "none"); }
                                content.removeClass("mCS_x_hidden");
                            } else {
                                scrollbar[1].css("display", "none");
                                content.addClass("mCS_x_hidden");
                            }
                            content.addClass("mCS_no_scrollbar_x");
                        }
                    }
                    if (!d.overflowed[0] && !d.overflowed[1]) {
                        $this.addClass("mCS_no_scrollbar");
                    } else {
                        $this.removeClass("mCS_no_scrollbar");
                    }
                },
                /* -------------------- */


                /* returns input coordinates of pointer, touch and mouse events (relative to document) */
                _coordinates: function(e) {
                    var t = e.type;
                    switch (t) {
                        case "pointerdown":
                        case "MSPointerDown":
                        case "pointermove":
                        case "MSPointerMove":
                        case "pointerup":
                        case "MSPointerUp":
                            return [e.originalEvent.pageY, e.originalEvent.pageX];
                            break;
                        case "touchstart":
                        case "touchmove":
                        case "touchend":
                            var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
                            return [touch.pageY, touch.pageX];
                            break;
                        default:
                            return [e.pageY, e.pageX];
                    }
                },
                /* -------------------- */


                /* 
                SCROLLBAR DRAG EVENTS
                scrolls content via scrollbar dragging 
                */
                _draggable: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        namespace = pluginPfx + "_" + d.idx,
                        draggerId = ["mCSB_" + d.idx + "_dragger_vertical", "mCSB_" + d.idx + "_dragger_horizontal"],
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        mCSB_dragger = $("#" + draggerId[0] + ",#" + draggerId[1]),
                        draggable, dragY, dragX;
                    mCSB_dragger.bind("mousedown." + namespace + " touchstart." + namespace + " pointerdown." + namespace + " MSPointerDown." + namespace, function(e) {
                        e.stopImmediatePropagation();
                        e.preventDefault();
                        if (!functions._mouseBtnLeft(e)) { return; } /* left mouse button only */
                        touchActive = true;
                        if (oldIE) { document.onselectstart = function() { return false; }; } /* disable text selection for IE < 9 */
                        _iframe(false); /* enable scrollbar dragging over iframes by disabling their events */
                        functions._stop($this);
                        draggable = $(this);
                        var offset = draggable.offset(),
                            y = functions._coordinates(e)[0] - offset.top,
                            x = functions._coordinates(e)[1] - offset.left,
                            h = draggable.height() + offset.top,
                            w = draggable.width() + offset.left;
                        if (y < h && y > 0 && x < w && x > 0) {
                            dragY = y;
                            dragX = x;
                        }
                        functions._onDragClasses(draggable, "active", o.autoExpandScrollbar);
                    }).bind("touchmove." + namespace, function(e) {
                        e.stopImmediatePropagation();
                        e.preventDefault();
                        var offset = draggable.offset(),
                            y = functions._coordinates(e)[0] - offset.top,
                            x = functions._coordinates(e)[1] - offset.left;
                        _drag(dragY, dragX, y, x);
                    });
                    $(document).bind("mousemove." + namespace + " pointermove." + namespace + " MSPointerMove." + namespace, function(e) {
                        if (draggable) {
                            var offset = draggable.offset(),
                                y = functions._coordinates(e)[0] - offset.top,
                                x = functions._coordinates(e)[1] - offset.left;
                            if (dragY === y) { return; } /* has it really moved? */
                            _drag(dragY, dragX, y, x);
                        }
                    }).add(mCSB_dragger).bind("mouseup." + namespace + " touchend." + namespace + " pointerup." + namespace + " MSPointerUp." + namespace, function(e) {
                        if (draggable) {
                            functions._onDragClasses(draggable, "active", o.autoExpandScrollbar);
                            draggable = null;
                        }
                        touchActive = false;
                        if (oldIE) { document.onselectstart = null; } /* enable text selection for IE < 9 */
                        _iframe(true); /* enable iframes events */
                    });

                    function _iframe(evt) {
                        var el = mCSB_container.find("iframe");
                        if (!el.length) { return; } /* check if content contains iframes */
                        var val = !evt ? "none" : "auto";
                        el.css("pointer-events", val); /* for IE11, iframe's display property should not be "block" */
                    }

                    function _drag(dragY, dragX, y, x) {
                        mCSB_container[0].idleTimer = o.scrollInertia < 233 ? 250 : 0;
                        if (draggable.attr("id") === draggerId[1]) {
                            var dir = "x",
                                to = ((draggable[0].offsetLeft - dragX) + x) * d.scrollRatio.x;
                        } else {
                            var dir = "y",
                                to = ((draggable[0].offsetTop - dragY) + y) * d.scrollRatio.y;
                        }
                        functions._scrollTo($this, to.toString(), { dir: dir, drag: true });
                    }
                },
                /* -------------------- */


                /* 
                TOUCH SWIPE EVENTS
                scrolls content via touch swipe 
                Emulates the native touch-swipe scrolling with momentum found in iOS, Android and WP devices 
                */
                _contentDraggable: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        namespace = pluginPfx + "_" + d.idx,
                        mCustomScrollBox = $("#mCSB_" + d.idx),
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")],
                        dragY, dragX, touchStartY, touchStartX, touchMoveY = [],
                        touchMoveX = [],
                        startTime, runningTime, endTime, distance, speed, amount,
                        durA = 0,
                        durB, overwrite = o.axis === "yx" ? "none" : "all";
                    mCSB_container.bind("touchstart." + namespace + " pointerdown." + namespace + " MSPointerDown." + namespace, function(e) {
                        if (!functions._pointerTouch(e) || touchActive) { return; }
                        var offset = mCSB_container.offset();
                        dragY = functions._coordinates(e)[0] - offset.top;
                        dragX = functions._coordinates(e)[1] - offset.left;
                    }).bind("touchmove." + namespace + " pointermove." + namespace + " MSPointerMove." + namespace, function(e) {
                        if (!functions._pointerTouch(e) || touchActive) { return; }
                        e.stopImmediatePropagation();
                        runningTime = functions._getTime();
                        var offset = mCustomScrollBox.offset(),
                            y = functions._coordinates(e)[0] - offset.top,
                            x = functions._coordinates(e)[1] - offset.left,
                            easing = "mcsLinearOut";
                        touchMoveY.push(y);
                        touchMoveX.push(x);
                        if (d.overflowed[0]) {
                            var limit = mCSB_dragger[0].parent().height() - mCSB_dragger[0].height(),
                                prevent = ((dragY - y) > 0 && (y - dragY) > -(limit * d.scrollRatio.y));
                        }
                        if (d.overflowed[1]) {
                            var limitX = mCSB_dragger[1].parent().width() - mCSB_dragger[1].width(),
                                preventX = ((dragX - x) > 0 && (x - dragX) > -(limitX * d.scrollRatio.x));
                        }
                        if (prevent || preventX) { e.preventDefault(); } /* prevent native document scrolling */
                        amount = o.axis === "yx" ? [(dragY - y), (dragX - x)] : o.axis === "x" ? [null, (dragX - x)] : [(dragY - y), null];
                        mCSB_container[0].idleTimer = 250;
                        if (d.overflowed[0]) { _drag(amount[0], durA, easing, "y", "all", true); }
                        if (d.overflowed[1]) { _drag(amount[1], durA, easing, "x", overwrite, true); }
                    });
                    mCustomScrollBox.bind("touchstart." + namespace + " pointerdown." + namespace + " MSPointerDown." + namespace, function(e) {
                        if (!functions._pointerTouch(e) || touchActive) { return; }
                        e.stopImmediatePropagation();
                        functions._stop($this);
                        startTime = functions._getTime();
                        var offset = mCustomScrollBox.offset();
                        touchStartY = functions._coordinates(e)[0] - offset.top;
                        touchStartX = functions._coordinates(e)[1] - offset.left;
                        touchMoveY = [];
                        touchMoveX = [];
                    }).bind("touchend." + namespace + " pointerup." + namespace + " MSPointerUp." + namespace, function(e) {
                        if (!functions._pointerTouch(e) || touchActive) { return; }
                        e.stopImmediatePropagation();
                        endTime = functions._getTime();
                        var offset = mCustomScrollBox.offset(),
                            y = functions._coordinates(e)[0] - offset.top,
                            x = functions._coordinates(e)[1] - offset.left;
                        if ((endTime - runningTime) > 30) { return; }
                        speed = 1000 / (endTime - startTime);
                        var easing = "mcsEaseOut",
                            slow = speed < 2.5,
                            diff = slow ? [touchMoveY[touchMoveY.length - 2], touchMoveX[touchMoveX.length - 2]] : [0, 0];
                        distance = slow ? [(y - diff[0]), (x - diff[1])] : [y - touchStartY, x - touchStartX];
                        var absDistance = [Math.abs(distance[0]), Math.abs(distance[1])];
                        speed = slow ? [Math.abs(distance[0] / 4), Math.abs(distance[1] / 4)] : [speed, speed];
                        var a = [
                            Math.abs(mCSB_container[0].offsetTop) - (distance[0] * _m((absDistance[0] / speed[0]), speed[0])),
                            Math.abs(mCSB_container[0].offsetLeft) - (distance[1] * _m((absDistance[1] / speed[1]), speed[1]))
                        ];
                        amount = o.axis === "yx" ? [a[0], a[1]] : o.axis === "x" ? [null, a[1]] : [a[0], null];
                        durB = [(absDistance[0] * 4) + o.scrollInertia, (absDistance[1] * 4) + o.scrollInertia];
                        var md = parseInt(o.contentTouchScroll) || 0; /* absolute minimum distance required */
                        amount[0] = absDistance[0] > md ? amount[0] : 0;
                        amount[1] = absDistance[1] > md ? amount[1] : 0;
                        if (d.overflowed[0]) { _drag(amount[0], durB[0], easing, "y", overwrite, false); }
                        if (d.overflowed[1]) { _drag(amount[1], durB[1], easing, "x", overwrite, false); }
                    });

                    function _m(ds, s) {
                        var r = [s * 1.5, s * 2, s / 1.5, s / 2];
                        if (ds > 90) {
                            return s > 4 ? r[0] : r[3];
                        } else if (ds > 60) {
                            return s > 3 ? r[3] : r[2];
                        } else if (ds > 30) {
                            return s > 8 ? r[1] : s > 6 ? r[0] : s > 4 ? s : r[2];
                        } else {
                            return s > 8 ? s : r[3];
                        }
                    }

                    function _drag(amount, dur, easing, dir, overwrite, drag) {
                        if (!amount) { return; }
                        functions._scrollTo($this, amount.toString(), { dur: dur, scrollEasing: easing, dir: dir, overwrite: overwrite, drag: drag });
                    }
                },
                /* -------------------- */


                /* 
                MOUSE WHEEL EVENT
                scrolls content via mouse-wheel 
                via mouse-wheel plugin (https://github.com/brandonaaron/jquery-mousewheel)
                */
                _mousewheel: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        namespace = pluginPfx + "_" + d.idx,
                        mCustomScrollBox = $("#mCSB_" + d.idx),
                        mCSB_dragger = [$("#mCSB_" + d.idx + "_dragger_vertical"), $("#mCSB_" + d.idx + "_dragger_horizontal")];
                    mCustomScrollBox.bind("mousewheel." + namespace, function(e, delta) {
                        functions._stop($this);
                        if (functions._disableMousewheel($this, e.target)) { return; } /* disables mouse-wheel when hovering specific elements */
                        var deltaFactor = o.mouseWheel.deltaFactor !== "auto" ? parseInt(o.mouseWheel.deltaFactor) : (oldIE && e.deltaFactor < 100) ? 100 : e.deltaFactor < 40 ? 40 : e.deltaFactor || 100;
                        if (o.axis === "x" || o.mouseWheel.axis === "x") {
                            var dir = "x",
                                px = [Math.round(deltaFactor * d.scrollRatio.x), parseInt(o.mouseWheel.scrollAmount)],
                                amount = o.mouseWheel.scrollAmount !== "auto" ? px[1] : px[0] >= mCustomScrollBox.width() ? mCustomScrollBox.width() * 0.9 : px[0],
                                contentPos = Math.abs($("#mCSB_" + d.idx + "_container")[0].offsetLeft),
                                draggerPos = mCSB_dragger[1][0].offsetLeft,
                                limit = mCSB_dragger[1].parent().width() - mCSB_dragger[1].width(),
                                dlt = e.deltaX || e.deltaY || delta;
                        } else {
                            var dir = "y",
                                px = [Math.round(deltaFactor * d.scrollRatio.y), parseInt(o.mouseWheel.scrollAmount)],
                                amount = o.mouseWheel.scrollAmount !== "auto" ? px[1] : px[0] >= mCustomScrollBox.height() ? mCustomScrollBox.height() * 0.9 : px[0],
                                contentPos = Math.abs($("#mCSB_" + d.idx + "_container")[0].offsetTop),
                                draggerPos = mCSB_dragger[0][0].offsetTop,
                                limit = mCSB_dragger[0].parent().height() - mCSB_dragger[0].height(),
                                dlt = e.deltaY || delta;
                        }
                        if ((dir === "y" && !d.overflowed[0]) || (dir === "x" && !d.overflowed[1])) { return; }
                        if (o.mouseWheel.invert) { dlt = -dlt; }
                        if (o.mouseWheel.normalizeDelta) { dlt = dlt < 0 ? -1 : 1; }
                        if ((dlt > 0 && draggerPos !== 0) || (dlt < 0 && draggerPos !== limit) || o.mouseWheel.preventDefault) {
                            e.stopImmediatePropagation();
                            e.preventDefault();
                        }
                        functions._scrollTo($this, (contentPos - (dlt * amount)).toString(), { dir: dir });
                    });
                },
                /* -------------------- */


                /* disables mouse-wheel when hovering specific elements like select, datalist etc. */
                _disableMousewheel: function(el, target) {
                    var tag = target.nodeName.toLowerCase(),
                        tags = el.data(pluginPfx).opt.mouseWheel.disableOver,
                        /* elements that require focus */
                        focusTags = ["select", "textarea"];
                    return $.inArray(tag, tags) > -1 && !($.inArray(tag, focusTags) > -1 && !$(target).is(":focus"));
                },
                /* -------------------- */


                /* 
                DRAGGER RAIL CLICK EVENT
                scrolls content via dragger rail 
                */
                _draggerRail: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        namespace = pluginPfx + "_" + d.idx,
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        wrapper = mCSB_container.parent(),
                        mCSB_draggerContainer = $(".mCSB_" + d.idx + "_scrollbar .mCSB_draggerContainer");
                    mCSB_draggerContainer.bind("touchstart." + namespace + " pointerdown." + namespace + " MSPointerDown." + namespace, function(e) {
                        touchActive = true;
                    }).bind("touchend." + namespace + " pointerup." + namespace + " MSPointerUp." + namespace, function(e) {
                        touchActive = false;
                    }).bind("click." + namespace, function(e) {
                        if ($(e.target).hasClass("mCSB_draggerContainer") || $(e.target).hasClass("mCSB_draggerRail")) {
                            functions._stop($this);
                            var el = $(this),
                                mCSB_dragger = el.find(".mCSB_dragger");
                            if (el.parent(".mCSB_scrollTools_horizontal").length > 0) {
                                if (!d.overflowed[1]) { return; }
                                var dir = "x",
                                    clickDir = e.pageX > mCSB_dragger.offset().left ? -1 : 1,
                                    to = Math.abs(mCSB_container[0].offsetLeft) - (clickDir * (wrapper.width() * 0.9));
                            } else {
                                if (!d.overflowed[0]) { return; }
                                var dir = "y",
                                    clickDir = e.pageY > mCSB_dragger.offset().top ? -1 : 1,
                                    to = Math.abs(mCSB_container[0].offsetTop) - (clickDir * (wrapper.height() * 0.9));
                            }
                            functions._scrollTo($this, to.toString(), { dir: dir, scrollEasing: "mcsEaseInOut" });
                        }
                    });
                },
                /* -------------------- */


                /* 
                FOCUS EVENT
                scrolls content via element focus (e.g. clicking an input, pressing TAB key etc.)
                */
                _focus: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        namespace = pluginPfx + "_" + d.idx,
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        wrapper = mCSB_container.parent();
                    mCSB_container.bind("focusin." + namespace, function(e) {
                        var el = $(document.activeElement),
                            nested = mCSB_container.find(".mCustomScrollBox").length,
                            dur = 0;
                        if (!el.is(o.advanced.autoScrollOnFocus)) { return; }
                        functions._stop($this);
                        clearTimeout($this[0]._focusTimeout);
                        $this[0]._focusTimer = nested ? (dur + 17) * nested : 0;
                        $this[0]._focusTimeout = setTimeout(function() {
                            var to = [el.offset().top - mCSB_container.offset().top, el.offset().left - mCSB_container.offset().left],
                                contentPos = [mCSB_container[0].offsetTop, mCSB_container[0].offsetLeft],
                                isVisible = [
                                    (contentPos[0] + to[0] >= 0 && contentPos[0] + to[0] < wrapper.height() - el.outerHeight(false)),
                                    (contentPos[1] + to[1] >= 0 && contentPos[0] + to[1] < wrapper.width() - el.outerWidth(false))
                                ],
                                overwrite = (o.axis === "yx" && !isVisible[0] && !isVisible[1]) ? "none" : "all";
                            if (o.axis !== "x" && !isVisible[0]) {
                                functions._scrollTo($this, to[0].toString(), { dir: "y", scrollEasing: "mcsEaseInOut", overwrite: overwrite, dur: dur });
                            }
                            if (o.axis !== "y" && !isVisible[1]) {
                                functions._scrollTo($this, to[1].toString(), { dir: "x", scrollEasing: "mcsEaseInOut", overwrite: overwrite, dur: dur });
                            }
                        }, $this[0]._focusTimer);
                    });
                },
                /* -------------------- */


                /* sets content wrapper scrollTop/scrollLeft always to 0 */
                _wrapperScroll: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        namespace = pluginPfx + "_" + d.idx,
                        wrapper = $("#mCSB_" + d.idx + "_container").parent();
                    wrapper.bind("scroll." + namespace, function(e) {
                        wrapper.scrollTop(0).scrollLeft(0);
                    });
                },
                /* -------------------- */


                /* 
                BUTTONS EVENTS
                scrolls content via up, down, left and right buttons 
                */
                _buttons: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        seq = d.sequential,
                        namespace = pluginPfx + "_" + d.idx,
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        sel = ".mCSB_" + d.idx + "_scrollbar",
                        btn = $(sel + ">a");
                    btn.bind("mousedown." + namespace + " touchstart." + namespace + " pointerdown." + namespace + " MSPointerDown." + namespace + " mouseup." + namespace + " touchend." + namespace + " pointerup." + namespace + " MSPointerUp." + namespace + " mouseout." + namespace + " pointerout." + namespace + " MSPointerOut." + namespace + " click." + namespace, function(e) {
                        e.preventDefault();
                        if (!functions._mouseBtnLeft(e)) { return; } /* left mouse button only */
                        var btnClass = $(this).attr("class");
                        seq.type = o.scrollButtons.scrollType;
                        switch (e.type) {
                            case "mousedown":
                            case "touchstart":
                            case "pointerdown":
                            case "MSPointerDown":
                                if (seq.type === "stepped") { return; }
                                touchActive = true;
                                d.tweenRunning = false;
                                _seq("on", btnClass);
                                break;
                            case "mouseup":
                            case "touchend":
                            case "pointerup":
                            case "MSPointerUp":
                            case "mouseout":
                            case "pointerout":
                            case "MSPointerOut":
                                if (seq.type === "stepped") { return; }
                                touchActive = false;
                                if (seq.dir) { _seq("off", btnClass); }
                                break;
                            case "click":
                                if (seq.type !== "stepped" || d.tweenRunning) { return; }
                                _seq("on", btnClass);
                                break;
                        }

                        function _seq(a, c) {
                            seq.scrollAmount = o.snapAmount || o.scrollButtons.scrollAmount;
                            functions._sequentialScroll.call(this, $this, a, c);
                        }
                    });
                },
                /* -------------------- */


                /* 
                KEYBOARD EVENTS
                scrolls content via keyboard 
                Keys: up arrow, down arrow, left arrow, right arrow, PgUp, PgDn, Home, End
                */
                _keyboard: function() {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        seq = d.sequential,
                        namespace = pluginPfx + "_" + d.idx,
                        mCustomScrollBox = $("#mCSB_" + d.idx),
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        wrapper = mCSB_container.parent(),
                        editables = "input,textarea,select,datalist,keygen,[contenteditable='true']";
                    mCustomScrollBox.bind("blur." + namespace + " keydown." + namespace + " keyup." + namespace, function(e) {
                        switch (e.type) {
                            case "blur":
                                if (d.tweenRunning && seq.dir) { _seq("off", null); }
                                break;
                            case "keydown":
                            case "keyup":
                                var code = e.keyCode ? e.keyCode : e.which,
                                    action = "on";
                                if ((o.axis !== "x" && (code === 38 || code === 40)) || (o.axis !== "y" && (code === 37 || code === 39))) {
                                    /* up (38), down (40), left (37), right (39) arrows */
                                    if (((code === 38 || code === 40) && !d.overflowed[0]) || ((code === 37 || code === 39) && !d.overflowed[1])) { return; }
                                    if (e.type === "keyup") { action = "off"; }
                                    if (!$(document.activeElement).is(editables)) {
                                        e.preventDefault();
                                        e.stopImmediatePropagation();
                                        _seq(action, code);
                                    }
                                } else if (code === 33 || code === 34) {
                                    /* PgUp (33), PgDn (34) */
                                    if (d.overflowed[0] || d.overflowed[1]) {
                                        e.preventDefault();
                                        e.stopImmediatePropagation();
                                    }
                                    if (e.type === "keyup") {
                                        functions._stop($this);
                                        var keyboardDir = code === 34 ? -1 : 1;
                                        if (o.axis === "x" || (o.axis === "yx" && d.overflowed[1] && !d.overflowed[0])) {
                                            var dir = "x",
                                                to = Math.abs(mCSB_container[0].offsetLeft) - (keyboardDir * (wrapper.width() * 0.9));
                                        } else {
                                            var dir = "y",
                                                to = Math.abs(mCSB_container[0].offsetTop) - (keyboardDir * (wrapper.height() * 0.9));
                                        }
                                        functions._scrollTo($this, to.toString(), { dir: dir, scrollEasing: "mcsEaseInOut" });
                                    }
                                } else if (code === 35 || code === 36) {
                                    /* End (35), Home (36) */
                                    if (!$(document.activeElement).is(editables)) {
                                        if (d.overflowed[0] || d.overflowed[1]) {
                                            e.preventDefault();
                                            e.stopImmediatePropagation();
                                        }
                                        if (e.type === "keyup") {
                                            if (o.axis === "x" || (o.axis === "yx" && d.overflowed[1] && !d.overflowed[0])) {
                                                var dir = "x",
                                                    to = code === 35 ? Math.abs(wrapper.width() - mCSB_container.outerWidth(false)) : 0;
                                            } else {
                                                var dir = "y",
                                                    to = code === 35 ? Math.abs(wrapper.height() - mCSB_container.outerHeight(false)) : 0;
                                            }
                                            functions._scrollTo($this, to.toString(), { dir: dir, scrollEasing: "mcsEaseInOut" });
                                        }
                                    }
                                }
                                break;
                        }

                        function _seq(a, c) {
                            seq.type = o.keyboard.scrollType;
                            seq.scrollAmount = o.snapAmount || o.keyboard.scrollAmount;
                            if (seq.type === "stepped" && d.tweenRunning) { return; }
                            functions._sequentialScroll.call(this, $this, a, c);
                        }
                    });
                },
                /* -------------------- */


                /* scrolls content sequentially (used when scrolling via buttons, keyboard arrows etc.) */
                _sequentialScroll: function(el, action, trigger) {
                    var d = el.data(pluginPfx),
                        o = d.opt,
                        seq = d.sequential,
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        once = seq.type === "stepped" ? true : false;
                    switch (action) {
                        case "on":
                            seq.dir = [
                                (trigger === "mCSB_buttonRight" || trigger === "mCSB_buttonLeft" || trigger === 39 || trigger === 37 ? "x" : "y"),
                                (trigger === "mCSB_buttonUp" || trigger === "mCSB_buttonLeft" || trigger === 38 || trigger === 37 ? -1 : 1)
                            ];
                            functions._stop(el);
                            if (functions._isNumeric(trigger) && seq.type === "stepped") { return; }
                            _start(once);
                            break;
                        case "off":
                            _stop();
                            if (once || (d.tweenRunning && seq.dir)) {
                                _start(true);
                            }
                            break;
                    }
                    /* starts sequence */
                    function _start(once) {
                        var c = seq.type !== "stepped",
                            /* continuous scrolling */
                            t = !once ? 1000 / 60 : c ? o.scrollInertia / 1.5 : o.scrollInertia,
                            /* timer */
                            m = !once ? 2.5 : c ? 7.5 : 40,
                            /* multiplier */
                            contentPos = [Math.abs(mCSB_container[0].offsetTop), Math.abs(mCSB_container[0].offsetLeft)],
                            ratio = [d.scrollRatio.y > 10 ? 10 : d.scrollRatio.y, d.scrollRatio.x > 10 ? 10 : d.scrollRatio.x],
                            amount = seq.dir[0] === "x" ? contentPos[1] + (seq.dir[1] * (ratio[1] * m)) : contentPos[0] + (seq.dir[1] * (ratio[0] * m)),
                            px = seq.dir[0] === "x" ? contentPos[1] + (seq.dir[1] * parseInt(seq.scrollAmount)) : contentPos[0] + (seq.dir[1] * parseInt(seq.scrollAmount)),
                            to = seq.scrollAmount !== "auto" ? px : amount,
                            easing = !once ? "mcsLinear" : c ? "mcsLinearOut" : "mcsEaseInOut",
                            onComplete = !once ? false : true;
                        if (once && t < 17) {
                            to = seq.dir[0] === "x" ? contentPos[1] : contentPos[0];
                        }
                        functions._scrollTo(el, to.toString(), { dir: seq.dir[0], scrollEasing: easing, dur: t, onComplete: onComplete });
                        if (once) {
                            seq.dir = false;
                            return;
                        }
                        clearTimeout(seq.step);
                        seq.step = setTimeout(function() {
                            _start();
                        }, t);
                    }
                    /* stops sequence */
                    function _stop() {
                        clearTimeout(seq.step);
                        functions._stop(el);
                    }
                },
                /* -------------------- */


                /* returns a yx array from value */
                _arr: function(val) {
                    var o = $(this).data(pluginPfx).opt,
                        vals = [];
                    if (typeof val === "function") { val = val(); } /* check if the value is a single anonymous function */
                    /* check if value is object or array, its length and create an array with yx values */
                    if (!(val instanceof Array)) { /* object value (e.g. {y:"100",x:"100"}, 100 etc.) */
                        vals[0] = val.y ? val.y : val.x || o.axis === "x" ? null : val;
                        vals[1] = val.x ? val.x : val.y || o.axis === "y" ? null : val;
                    } else { /* array value (e.g. [100,100]) */
                        vals = val.length > 1 ? [val[0], val[1]] : o.axis === "x" ? [null, val[0]] : [val[0], null];
                    }
                    /* check if array values are anonymous functions */
                    if (typeof vals[0] === "function") { vals[0] = vals[0](); }
                    if (typeof vals[1] === "function") { vals[1] = vals[1](); }
                    return vals;
                },
                /* -------------------- */


                /* translates values (e.g. "top", 100, "100px", "#id") to actual scroll-to positions */
                _to: function(val, dir) {
                    if (val == null || typeof val == "undefined") { return; }
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        wrapper = mCSB_container.parent(),
                        t = typeof val;
                    if (!dir) { dir = o.axis === "x" ? "x" : "y"; }
                    var contentLength = dir === "x" ? mCSB_container.outerWidth(false) : mCSB_container.outerHeight(false),
                        contentOffset = dir === "x" ? mCSB_container.offset().left : mCSB_container.offset().top,
                        contentPos = dir === "x" ? mCSB_container[0].offsetLeft : mCSB_container[0].offsetTop,
                        cssProp = dir === "x" ? "left" : "top";
                    switch (t) {
                        case "function":
                            /* this currently is not used. Consider removing it */
                            return val();
                            break;
                        case "object":
                            if (val.nodeType) { /* DOM */
                                var objOffset = dir === "x" ? $(val).offset().left : $(val).offset().top;
                            } else if (val.jquery) { /* jquery object */
                                if (!val.length) { return; }
                                var objOffset = dir === "x" ? val.offset().left : val.offset().top;
                            }
                            return objOffset - contentOffset;
                            break;
                        case "string":
                        case "number":
                            if (functions._isNumeric.call(null, val)) { /* numeric value */
                                return Math.abs(val);
                            } else if (val.indexOf("%") !== -1) { /* percentage value */
                                return Math.abs(contentLength * parseInt(val) / 100);
                            } else if (val.indexOf("-=") !== -1) { /* decrease value */
                                return Math.abs(contentPos - parseInt(val.split("-=")[1]));
                            } else if (val.indexOf("+=") !== -1) { /* inrease value */
                                var p = (contentPos + parseInt(val.split("+=")[1]));
                                return p >= 0 ? 0 : Math.abs(p);
                            } else if (val.indexOf("px") !== -1 && functions._isNumeric.call(null, val.split("px")[0])) { /* pixels string value (e.g. "100px") */
                                return Math.abs(val.split("px")[0]);
                            } else {
                                if (val === "top" || val === "left") { /* special strings */
                                    return 0;
                                } else if (val === "bottom") {
                                    return Math.abs(wrapper.height() - mCSB_container.outerHeight(false));
                                } else if (val === "right") {
                                    return Math.abs(wrapper.width() - mCSB_container.outerWidth(false));
                                } else if (val === "first" || val === "last") {
                                    var obj = mCSB_container.find(":" + val),
                                        objOffset = dir === "x" ? $(obj).offset().left : $(obj).offset().top;
                                    return objOffset - contentOffset;
                                } else {
                                    if ($(val).length) { /* jquery selector */
                                        var objOffset = dir === "x" ? $(val).offset().left : $(val).offset().top;
                                        return objOffset - contentOffset;
                                    } else { /* other values (e.g. "100em") */
                                        mCSB_container.css(cssProp, val);
                                        methods.update.call(null, $this[0]);
                                        return;
                                    }
                                }
                            }
                            break;
                    }
                },
                /* -------------------- */


                /* calls the update method automatically */
                _autoUpdate: function(rem) {
                    var $this = $(this),
                        d = $this.data(pluginPfx),
                        o = d.opt,
                        mCSB_container = $("#mCSB_" + d.idx + "_container");
                    if (rem) {
                        /* 
                        removes autoUpdate timer 
                        usage: functions._autoUpdate.call(this,"remove");
                        */
                        clearTimeout(mCSB_container[0].autoUpdate);
                        functions._delete.call(null, mCSB_container[0].autoUpdate);
                        return;
                    }
                    var wrapper = mCSB_container.parent(),
                        scrollbar = [$("#mCSB_" + d.idx + "_scrollbar_vertical"), $("#mCSB_" + d.idx + "_scrollbar_horizontal")],
                        scrollbarSize = function() {
                            return [
                                scrollbar[0].is(":visible") ? scrollbar[0].outerHeight(true) : 0, /* returns y-scrollbar height */
                                scrollbar[1].is(":visible") ? scrollbar[1].outerWidth(true) : 0 /* returns x-scrollbar width */
                            ]
                        },
                        oldSelSize = sizesSum(),
                        newSelSize,
                        os = [mCSB_container.outerHeight(false), mCSB_container.outerWidth(false), wrapper.height(), wrapper.width(), scrollbarSize()[0], scrollbarSize()[1]],
                        ns,
                        oldImgsLen = imgSum(),
                        newImgsLen;
                    upd();

                    function upd() {
                        clearTimeout(mCSB_container[0].autoUpdate);
                        mCSB_container[0].autoUpdate = setTimeout(function() {
                            /* update on specific selector(s) length and size change */
                            if (o.advanced.updateOnSelectorChange) {
                                newSelSize = sizesSum();
                                if (newSelSize !== oldSelSize) {
                                    doUpd();
                                    oldSelSize = newSelSize;
                                    return;
                                }
                            }
                            /* update on main element and scrollbar size changes */
                            if (o.advanced.updateOnContentResize) {
                                ns = [mCSB_container.outerHeight(false), mCSB_container.outerWidth(false), wrapper.height(), wrapper.width(), scrollbarSize()[0], scrollbarSize()[1]];
                                if (ns[0] !== os[0] || ns[1] !== os[1] || ns[2] !== os[2] || ns[3] !== os[3] || ns[4] !== os[4] || ns[5] !== os[5]) {
                                    doUpd();
                                    os = ns;
                                }
                            }
                            /* update on image load */
                            if (o.advanced.updateOnImageLoad) {
                                newImgsLen = imgSum();
                                if (newImgsLen !== oldImgsLen) {
                                    mCSB_container.find("img").each(function() {
                                        imgLoader(this.src);
                                    });
                                    oldImgsLen = newImgsLen;
                                }
                            }
                            if (o.advanced.updateOnSelectorChange || o.advanced.updateOnContentResize || o.advanced.updateOnImageLoad) { upd(); }
                        }, 60);
                    }
                    /* returns images amount */
                    function imgSum() {
                        var total = 0;
                        if (o.advanced.updateOnImageLoad) { total = mCSB_container.find("img").length; }
                        return total;
                    }
                    /* a tiny image loader */
                    function imgLoader(src) {
                        var img = new Image();

                        function createDelegate(contextObject, delegateMethod) {
                            return function() { return delegateMethod.apply(contextObject, arguments); }
                        }

                        function imgOnLoad() {
                            this.onload = null;
                            doUpd();
                        }
                        img.onload = createDelegate(img, imgOnLoad);
                        img.src = src;
                    }
                    /* returns the total height and width sum of all elements matching the selector */
                    function sizesSum() {
                        if (o.advanced.updateOnSelectorChange === true) { o.advanced.updateOnSelectorChange = "*"; }
                        var total = 0,
                            sel = mCSB_container.find(o.advanced.updateOnSelectorChange);
                        if (o.advanced.updateOnSelectorChange && sel.length > 0) { sel.each(function() { total += $(this).height() + $(this).width(); }); }
                        return total;
                    }
                    /* calls the update method */
                    function doUpd() {
                        clearTimeout(mCSB_container[0].autoUpdate);
                        methods.update.call(null, $this[0]);
                    }
                },
                /* -------------------- */


                /* snaps scrolling to a multiple of a pixels number */
                _snapAmount: function(to, amount, offset) {
                    return (Math.round(to / amount) * amount - offset);
                },
                /* -------------------- */


                /* stops content and scrollbar animations */
                _stop: function(el) {
                    var d = el.data(pluginPfx),
                        sel = $("#mCSB_" + d.idx + "_container,#mCSB_" + d.idx + "_container_wrapper,#mCSB_" + d.idx + "_dragger_vertical,#mCSB_" + d.idx + "_dragger_horizontal");
                    sel.each(function() {
                        functions._stopTween.call(this);
                    });
                },
                /* -------------------- */


                /* 
                ANIMATES CONTENT 
                This is where the actual scrolling happens
                */
                _scrollTo: function(el, to, options) {
                    var d = el.data(pluginPfx),
                        o = d.opt,
                        defaults = {
                            trigger: "internal",
                            dir: "y",
                            scrollEasing: "mcsEaseOut",
                            drag: false,
                            dur: o.scrollInertia,
                            overwrite: "all",
                            callbacks: true,
                            onStart: true,
                            onUpdate: true,
                            onComplete: true
                        },
                        options = $.extend(defaults, options),
                        dur = [options.dur, (options.drag ? 0 : options.dur)],
                        mCustomScrollBox = $("#mCSB_" + d.idx),
                        mCSB_container = $("#mCSB_" + d.idx + "_container"),
                        totalScrollOffsets = o.callbacks.onTotalScrollOffset ? functions._arr.call(el, o.callbacks.onTotalScrollOffset) : [0, 0],
                        totalScrollBackOffsets = o.callbacks.onTotalScrollBackOffset ? functions._arr.call(el, o.callbacks.onTotalScrollBackOffset) : [0, 0];
                    d.trigger = options.trigger;
                    if (o.snapAmount) { to = functions._snapAmount(to, o.snapAmount, o.snapOffset); } /* scrolling snapping */
                    switch (options.dir) {
                        case "x":
                            var mCSB_dragger = $("#mCSB_" + d.idx + "_dragger_horizontal"),
                                property = "left",
                                contentPos = mCSB_container[0].offsetLeft,
                                limit = [
                                    mCustomScrollBox.width() - mCSB_container.outerWidth(false),
                                    mCSB_dragger.parent().width() - mCSB_dragger.width()
                                ],
                                scrollTo = [to, (to / d.scrollRatio.x)],
                                tso = totalScrollOffsets[1],
                                tsbo = totalScrollBackOffsets[1],
                                totalScrollOffset = tso > 0 ? tso / d.scrollRatio.x : 0,
                                totalScrollBackOffset = tsbo > 0 ? tsbo / d.scrollRatio.x : 0;
                            break;
                        case "y":
                            var mCSB_dragger = $("#mCSB_" + d.idx + "_dragger_vertical"),
                                property = "top",
                                contentPos = mCSB_container[0].offsetTop,
                                limit = [
                                    mCustomScrollBox.height() - mCSB_container.outerHeight(false),
                                    mCSB_dragger.parent().height() - mCSB_dragger.height()
                                ],
                                scrollTo = [to, (to / d.scrollRatio.y)],
                                tso = totalScrollOffsets[0],
                                tsbo = totalScrollBackOffsets[0],
                                totalScrollOffset = tso > 0 ? tso / d.scrollRatio.y : 0,
                                totalScrollBackOffset = tsbo > 0 ? tsbo / d.scrollRatio.y : 0;
                            break;
                    }
                    if (scrollTo[1] < 0) {
                        scrollTo = [0, 0];
                    } else if (scrollTo[1] >= limit[1]) {
                        scrollTo = [limit[0], limit[1]];
                    } else {
                        scrollTo[0] = -scrollTo[0];
                    }
                    clearTimeout(mCSB_container[0].onCompleteTimeout);
                    if (!d.tweenRunning && ((contentPos === 0 && scrollTo[0] >= 0) || (contentPos === limit[0] && scrollTo[0] <= limit[0]))) { return; }
                    functions._tweenTo.call(null, mCSB_dragger[0], property, Math.round(scrollTo[1]), dur[1], options.scrollEasing);
                    functions._tweenTo.call(null, mCSB_container[0], property, Math.round(scrollTo[0]), dur[0], options.scrollEasing, options.overwrite, {
                        onStart: function() {
                            if (options.callbacks && options.onStart && !d.tweenRunning) {
                                /* callbacks: onScrollStart */
                                if (_cb("onScrollStart")) {
                                    _mcs();
                                    o.callbacks.onScrollStart.call(el[0]);
                                }
                                d.tweenRunning = true;
                                functions._onDragClasses(mCSB_dragger);
                                d.cbOffsets = _cbOffsets();
                            }
                        },
                        onUpdate: function() {
                            if (options.callbacks && options.onUpdate) {
                                /* callbacks: whileScrolling */
                                if (_cb("whileScrolling")) {
                                    _mcs();
                                    o.callbacks.whileScrolling.call(el[0]);
                                }
                            }
                        },
                        onComplete: function() {
                            if (options.callbacks && options.onComplete) {
                                if (o.axis === "yx") { clearTimeout(mCSB_container[0].onCompleteTimeout); }
                                var t = mCSB_container[0].idleTimer || 0;
                                mCSB_container[0].onCompleteTimeout = setTimeout(function() {
                                    /* callbacks: onScroll, onTotalScroll, onTotalScrollBack */
                                    if (_cb("onScroll")) {
                                        _mcs();
                                        o.callbacks.onScroll.call(el[0]);
                                    }
                                    if (_cb("onTotalScroll") && scrollTo[1] >= limit[1] - totalScrollOffset && d.cbOffsets[0]) {
                                        _mcs();
                                        o.callbacks.onTotalScroll.call(el[0]);
                                    }
                                    if (_cb("onTotalScrollBack") && scrollTo[1] <= totalScrollBackOffset && d.cbOffsets[1]) {
                                        _mcs();
                                        o.callbacks.onTotalScrollBack.call(el[0]);
                                    }
                                    d.tweenRunning = false;
                                    mCSB_container[0].idleTimer = 0;
                                    functions._onDragClasses(mCSB_dragger, "hide");
                                }, t);
                            }
                        }
                    });
                    /* checks if callback function exists */
                    function _cb(cb) {
                        return d && o.callbacks[cb] && typeof o.callbacks[cb] === "function";
                    }
                    /* checks whether callback offsets always trigger */
                    function _cbOffsets() {
                        return [o.callbacks.alwaysTriggerOffsets || contentPos >= limit[0] + tso, o.callbacks.alwaysTriggerOffsets || contentPos <= -tsbo];
                    }
                    /* 
                    populates object with useful values for the user 
                    values: 
                    	content: this.mcs.content
                    	content top position: this.mcs.top 
                    	content left position: this.mcs.left 
                    	dragger top position: this.mcs.draggerTop 
                    	dragger left position: this.mcs.draggerLeft 
                    	scrolling y percentage: this.mcs.topPct 
                    	scrolling x percentage: this.mcs.leftPct 
                    	scrolling direction: this.mcs.direction
                    */
                    function _mcs() {
                        var cp = [mCSB_container[0].offsetTop, mCSB_container[0].offsetLeft],
                            /* content position */
                            dp = [mCSB_dragger[0].offsetTop, mCSB_dragger[0].offsetLeft],
                            /* dragger position */
                            cl = [mCSB_container.outerHeight(false), mCSB_container.outerWidth(false)],
                            /* content length */
                            pl = [mCustomScrollBox.height(), mCustomScrollBox.width()]; /* content parent length */
                        el[0].mcs = {
                            content: mCSB_container,
                            /* original content wrapper as jquery object */
                            top: cp[0],
                            left: cp[1],
                            draggerTop: dp[0],
                            draggerLeft: dp[1],
                            topPct: Math.round((100 * Math.abs(cp[0])) / (Math.abs(cl[0]) - pl[0])),
                            leftPct: Math.round((100 * Math.abs(cp[1])) / (Math.abs(cl[1]) - pl[1])),
                            direction: options.dir
                        };
                        /* 
                        this refers to the original element containing the scrollbar(s)
                        usage: this.mcs.top, this.mcs.leftPct etc. 
                        */
                    }
                },
                /* -------------------- */


                /* 
                CUSTOM JAVASCRIPT ANIMATION TWEEN 
                Lighter and faster than jquery animate() and css transitions 
                Animates top/left properties and includes easings 
                */
                _tweenTo: function(el, prop, to, duration, easing, overwrite, callbacks) {
                    var callbacks = callbacks || {},
                        onStart = callbacks.onStart || function() {},
                        onUpdate = callbacks.onUpdate || function() {},
                        onComplete = callbacks.onComplete || function() {},
                        startTime = functions._getTime(),
                        _delay, progress = 0,
                        from = el.offsetTop,
                        elStyle = el.style;
                    if (prop === "left") { from = el.offsetLeft; }
                    var diff = to - from;
                    el._mcsstop = 0;
                    if (overwrite !== "none") { _cancelTween(); }
                    _startTween();

                    function _step() {
                        if (el._mcsstop) { return; }
                        if (!progress) { onStart.call(); }
                        progress = functions._getTime() - startTime;
                        _tween();
                        if (progress >= el._mcstime) {
                            el._mcstime = (progress > el._mcstime) ? progress + _delay - (progress - el._mcstime) : progress + _delay - 1;
                            if (el._mcstime < progress + 1) { el._mcstime = progress + 1; }
                        }
                        if (el._mcstime < duration) { el._mcsid = _request(_step); } else { onComplete.call(); }
                    }

                    function _tween() {
                        if (duration > 0) {
                            el._mcscurrVal = _ease(el._mcstime, from, diff, duration, easing);
                            elStyle[prop] = Math.round(el._mcscurrVal) + "px";
                        } else {
                            elStyle[prop] = to + "px";
                        }
                        onUpdate.call();
                    }

                    function _startTween() {
                        _delay = 1000 / 60;
                        el._mcstime = progress + _delay;
                        _request = (!window.requestAnimationFrame) ? function(f) { _tween(); return setTimeout(f, 0.01); } : window.requestAnimationFrame;
                        el._mcsid = _request(_step);
                    }

                    function _cancelTween() {
                        if (el._mcsid == null) { return; }
                        if (!window.requestAnimationFrame) {
                            clearTimeout(el._mcsid);
                        } else { window.cancelAnimationFrame(el._mcsid); }
                        el._mcsid = null;
                    }

                    function _ease(t, b, c, d, type) {
                        switch (type) {
                            case "linear":
                            case "mcsLinear":
                                return c * t / d + b;
                                break;
                            case "mcsLinearOut":
                                t /= d;
                                t--;
                                return c * Math.sqrt(1 - t * t) + b;
                                break;
                            case "easeInOutSmooth":
                                t /= d / 2;
                                if (t < 1) return c / 2 * t * t + b;
                                t--;
                                return -c / 2 * (t * (t - 2) - 1) + b;
                                break;
                            case "easeInOutStrong":
                                t /= d / 2;
                                if (t < 1) return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
                                t--;
                                return c / 2 * (-Math.pow(2, -10 * t) + 2) + b;
                                break;
                            case "easeInOut":
                            case "mcsEaseInOut":
                                t /= d / 2;
                                if (t < 1) return c / 2 * t * t * t + b;
                                t -= 2;
                                return c / 2 * (t * t * t + 2) + b;
                                break;
                            case "easeOutSmooth":
                                t /= d;
                                t--;
                                return -c * (t * t * t * t - 1) + b;
                                break;
                            case "easeOutStrong":
                                return c * (-Math.pow(2, -10 * t / d) + 1) + b;
                                break;
                            case "easeOut":
                            case "mcsEaseOut":
                            default:
                                var ts = (t /= d) * t,
                                    tc = ts * t;
                                return b + c * (0.499999999999997 * tc * ts + -2.5 * ts * ts + 5.5 * tc + -6.5 * ts + 4 * t);
                        }
                    }
                },
                /* -------------------- */


                /* returns current time */
                _getTime: function() {
                    if (window.performance && window.performance.now) {
                        return window.performance.now();
                    } else {
                        if (window.performance && window.performance.webkitNow) {
                            return window.performance.webkitNow();
                        } else {
                            if (Date.now) { return Date.now(); } else { return new Date().getTime(); }
                        }
                    }
                },
                /* -------------------- */


                /* stops a tween */
                _stopTween: function() {
                    var el = this;
                    if (el._mcsid == null) { return; }
                    if (!window.requestAnimationFrame) {
                        clearTimeout(el._mcsid);
                    } else { window.cancelAnimationFrame(el._mcsid); }
                    el._mcsid = null;
                    el._mcsstop = 1;
                },
                /* -------------------- */


                /* deletes a property (avoiding the exception thrown by IE) */
                _delete: function(p) {
                    // try { delete p; } catch (e) { p = null; }
                    p = null;
                },
                /* -------------------- */


                /* detects left mouse button */
                _mouseBtnLeft: function(e) {
                    return !(e.which && e.which !== 1);
                },
                /* -------------------- */


                /* detects if pointer type event is touch */
                _pointerTouch: function(e) {
                    var t = e.originalEvent.pointerType;
                    return !(t && t !== "touch" && t !== 2);
                },
                /* -------------------- */


                /* checks if value is numeric */
                _isNumeric: function(val) {
                        return !isNaN(parseFloat(val)) && isFinite(val);
                    }
                    /* -------------------- */

            };





        /* 
        ----------------------------------------
        PLUGIN SETUP 
        ----------------------------------------
        */

        /* plugin dependencies */
        var _dlp = ("https:" == document.location.protocol) ? "https:" : "http:"; /* dependency location protocol */
        /* load jquery-mousewheel plugin (via CDN) if it's not present (works when mCustomScrollbar fn is called on window load) */
        $.event.special.mousewheel || $("head").append(decodeURI("%3Cscript src=" + _dlp + "//cdnjs.cloudflare.com/ajax/libs/jquery-mousewheel/3.1.11/jquery.mousewheel.min.js%3E%3C/script%3E"));

        /* plugin constructor functions */
        $.fn[pluginNS] = function(method) { /* usage: $(selector).mCustomScrollbar(); */
            if (methods[method]) {
                return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
            } else if (typeof method === "object" || !method) {
                return methods.init.apply(this, arguments);
            } else {
                $.error("Method " + method + " does not exist");
            }
        };
        $[pluginNS] = function(method) { /* usage: $.mCustomScrollbar(); */
            if (methods[method]) {
                return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
            } else if (typeof method === "object" || !method) {
                return methods.init.apply(this, arguments);
            } else {
                $.error("Method " + method + " does not exist");
            }
        };

        /* 
        allow setting plugin default options. 
        usage: $.mCustomScrollbar.defaults.scrollInertia=500; 
        to apply any changed default options on default selectors (below), use inside document ready fn 
        e.g.: $(document).ready(function(){ $.mCustomScrollbar.defaults.scrollInertia=500; });
        */
        $[pluginNS].defaults = defaults;

        /* 
        add window object (window.mCustomScrollbar) 
        usage: if(window.mCustomScrollbar){console.log("custom scrollbar plugin loaded");}
        */
        window[pluginNS] = true;

        $(window).load(function() {
            $(defaultSelector)[pluginNS](); /* add scrollbars automatically on default selector */
        });

    })(jQuery, window, document);

    /** Узел дерева слоёв
     * @typedef nsGmx.LayersTree~Node
     * @property {String} type тип узла (`layer` или `group`)
     * @property {Object} content содержимое узла
     * @property {Object} [content.properties] свойства узла
     * @property {Object} [content.children] потомки узла
    */

    /** Результат поиска узла в дереве слоёв
     * @typedef nsGmx.LayersTree~SearchResult
     * @property {nsGmx.LayersTree~Node} elem Найденный элемент
     * @property {nsGmx.LayersTree~Node[]} parents Массив родителей. Самый последний элемент массива - сама карта
     * @property {Number} index Индекс найденного элемента в своей группе
    */

    /** Visitor при обходе слоёв дерева
     * @callback nsGmx.LayersTree~LayerVisitor
     * @param {Object} layerContent Содержимое узла слоя
     * @param {Boolean} isVisible Видимость слоя с учётом видимости всех родителей
     * @param {Number} nodeDepth Глубина слоя в дереве (начинается с 0)
    */

    /** Visitor при обходе узлов дерева слоёв
     * @callback nsGmx.LayersTree~NodeVisitor
     * @param {nsGmx.LayersTree~Node} node Свойства узла
     * @param {Boolean} isVisible Видимость узла с учётом видимости всех родителей
     * @param {Number} nodeDepth Глубина узла в дереве (начинается с 0)
    */

    /** Класс для работы с деревом слоёв
     * @class
     * @param {Object} tree Дерево слоёв в формате сервера
    */
    nsGmx$1.LayersTree = function( tree )
    {
        /** Изменилась видимость узла дерева. Если изменения касаются нескольких узлов, событие будет 
            генерироваться для каждого узла по отдельности. Кроме того, это же событие генерируется 
            на отдельных узлах дерева.
         * @event nsGmx.LayersTree#nodeVisibilityChange
         * @param {nsGmx.LayersTree~Node} node Узел, видимость которой изменилась
         */
        var _tree = tree;
        var _this = this;
        
        var _findElem = function(elem, propName, propValue, parents)
        {
            var childs = typeof elem.children != 'undefined' ? elem.children : elem.content.children;
            
            for (var i = 0; i < childs.length; i++)
            {
                var props = childs[i].content.properties;
                if (propName in props && props[propName] === propValue) {
                    return {elem:childs[i], parents: [elem].concat(parents || []), index: i};
                }
                
                if (typeof childs[i].content.children != 'undefined')
                {
                    var res = _findElem(childs[i], propName, propValue, [elem].concat(parents || []));
                    
                    if (res)
                        return res;
                }
            }
        };
        
        /** Получить исходное дерево слоёв
        */
        this.getRawTree = function() 
        {
            return _tree;
        };
        
        /** Получить свойства карты
        */
        this.getMapProperties = function() 
        {
            return _tree.properties;
        };
        
        /** Поиск узла дерева по значению одного из атрибутов. Ищет как папки, так и слои. Возвращает первый найденный результат
         * @param {String} propName Имя атрибута
         * @param {String} propValue Значение атрибута
         * @return {nsGmx.LayersTree~SearchResult} Результат поиска. undefined если ничего не найденно
        */
        this.findElem = function(propName, propValue)
        {
            return _findElem(_tree, propName, propValue);
        };
        
        this.findElemByGmxProperties = function(gmxProperties)
        {
            if (gmxProperties.type == 'group') //группа
                return this.findElem("GroupID", gmxProperties.content.properties.GroupID);
            else
                return this.findElem("name", gmxProperties.content.properties.name);
        };
        
        /** Итерирование по всем слоям группы дерева
         * @param {nsGmx.LayersTree~LayerVisitor} callback Будет вызвана для каждого слоя внутри группы. Первый аргумент - свойства слоя, второй - видимость слоя
         * @param {nsGmx.LayersTree~Node} [groupNode] Группа, внутри которой проводить поиск. Если не указана, будет проводиться поиск по всему дереву.
         */
        this.forEachLayer = function(callback, groupNode)
        {
            this.forEachNode(function(node, isVisible, nodeDepth) {
                if (node.type === 'layer') {
                    callback(node.content, isVisible, nodeDepth);
                }
            }, groupNode);
        };
        
        /** Итерирование по всем под-узлам узла дерева
         * @param {nsGmx.LayersTree~NodeVisitor} callback Будет вызвана для каждого узла внутри группы. Первый аргумент - узел, второй - видимость узла
         * @param {nsGmx.LayersTree~Node} [groupNode] Группа, внутри которой проводить поиск. Если не указана, будет проводиться поиск по всему дереву.
         */
        this.forEachNode = function(callback, groupNode)
        {
            var forEachNodeRec = function(o, isVisible, nodeDepth)
            {
                isVisible = isVisible && !!o.content.properties.visible;
                
                callback(o, isVisible, nodeDepth);
                
                if (o.type === 'group') {
                    var a = o.content.children;
                    for (var k = a.length - 1; k >= 0; k--)
                        forEachNodeRec(a[k], isVisible, nodeDepth + 1);
                }
            };
            
            var layers = groupNode ? groupNode.content : _tree;
            
            for (var k = layers.children.length - 1; k >= 0; k--) {
                forEachNodeRec(layers.children[k], true, 0);
            }
        };
        
        /** Клонирование дерева с возможностью его модификации
         * @param {function(node):nsGmx.LayersTree~Node|null} filterFunc - ф-ция, которая может модифицировать узлы дерева. 
                    Вызывается при клонировании очередного узла. Изменения данных можно делать in-place.
                    Для групп вызывается после обработки всех потомков. Если возвращает null, то узел удаляется
         */
        this.cloneRawTree = function(filterFunc) {
            filterFunc = filterFunc || function(node) {return node;};
            var forEachLayerRec = function(o)
            {
                if (o.type == "layer") {
                    return filterFunc($.extend(true, {}, o));
                }
                else if (o.type == "group") {
                    var a = o.content.children;
                    var newChildren = [];
                    for (var k = 0; k < a.length; k++) {
                        var newNode = forEachLayerRec(a[k]);
                        newNode && newChildren.push(newNode);
                    }
                    return filterFunc({
                        type: 'group', 
                        content: {
                            children: newChildren,
                            properties: $.extend(true, {}, o.content.properties)
                        }
                    })
                }
            };
            
            var newFirstLevelGroups = [];
            for (var k = 0; k < _tree.children.length; k++) {
                var newNode = forEachLayerRec(_tree.children[k]);
                newNode && newFirstLevelGroups.push(newNode);
            }
            
            return {
                properties: $.extend(true, {}, _tree.properties),
                children: newFirstLevelGroups
            }
        };
        
        //Методы управления видимостью слоёв в дереве
        
        //проходится по всему поддереву elem и устанавливает видимость isVisible всем узлам включая elem (учитывая ограничения на radio buttons)
        var setSubtreeVisibility = function(elem, isVisible) {
            var props = elem.content.properties;
            if (props.visible != isVisible) {
                props.visible = isVisible;
                $(_this).triggerHandler('nodeVisibilityChange', [elem]);
                $(elem).triggerHandler('nodeVisibilityChange', [elem]);
                
                if (elem.content.children) {
                    for (var c = 0; c < elem.content.children.length; c++) {
                        var vis = isVisible && (!props.list || c == 0); //когда делаем видимой группу-список, виден только первый элемент группы
                        setSubtreeVisibility(elem.content.children[c], vis);
                    }
                }
            }
        };    
        
        /** Устанавливает видимость узла дерева и всех родительских элементов данного узла в зависимости от видимости его прямых потомков. Узел должен быть группой.
         * При этом разруливаются конфликты с несколькими видимыми узлами в radio-группах.
         * @param {nsGmx.LayersTree~Node} node Узел дерева, видимость которого нужно обновить
         * @param {nsGmx.LayersTree~Node} triggerSubnode один их прямых потомков node, состояние которого должно остаться неизменным (важно для разруливания конфликтов в radio-групп)
         * @param {nsGmx.LayersTree~Node[]} [parents] массив всех родителей, опционально
         */
        this.updateNodeVisibility = function(elem, triggerSubnode, parents) {
            var props = elem.content.properties,
                isList = props.list,
                children = elem.content.children,
                triggerNodeVisible = triggerSubnode ? triggerSubnode.content.properties.visible : false,
                visibleNode = triggerNodeVisible ? triggerSubnode : null;
            
            var isVisible = false;
            for (var c = 0; c < children.length; c++) {
                var child = children[c];
                var childVisible = child.content.properties.visible;
                isVisible = isVisible || childVisible;
                
                if (childVisible && !visibleNode) {
                    visibleNode = child;
                }
                
                if (isList && childVisible && child !== visibleNode) {
                    setSubtreeVisibility(child, false);
                }
            }
            
            if (isVisible !== props.visible) {
                props.visible = isVisible;
                
                $(this).triggerHandler('nodeVisibilityChange', [elem]);
                $(elem).triggerHandler('nodeVisibilityChange', [elem]);
                
                if (!parents) {
                    parents = this.findElemByGmxProperties(elem).parents;
                    parents.pop(); //последний элемент - карта; нас не интересует
                }
                var parent = parents.shift();
                parent && this.updateNodeVisibility(parent, elem, parents);
            }
        };
        
        /** Задать видимость узла дерева. Будут сделаны все нужные изменения видимости как выше, 
         * так и ниже по дереву относительно этого узла.
         * @param {nsGmx.LayersTree~Node} node Узел дерева, которому мы хотим задать видимость
         * @param {Boolean} isVisible Видимость узла (true - виден)
         */
        this.setNodeVisibility = function(node, isVisible) {
            if (node.content.properties.visible != isVisible) {
                //устанавливаем видимость поддерева, которое начинается с этого элемента
                setSubtreeVisibility(node, isVisible);
                
                //идём вверх по дереву до корня и меняем видимость родителей
                var parentElem = _this.findElemByGmxProperties(node).parents[0];
                parentElem && parentElem.content && this.updateNodeVisibility(parentElem, node);
            }
        };
    };

    $('#flash').droppable({
        drop: function(event, ui) {
            var obj = ui.draggable[0].gmxDrawingObject;

            if (obj) {
                var text = Functions.GetFullName(obj.TypeName, obj.ObjName);
                nsGmx$1.leafletMap.gmxDrawing.addGeoJSON({
                    type: 'Feature',
                    geometry: L.gmxUtil.geometryToGeoJSON(obj.Geometry)
                }, {text: text});
            }
        }
    });

    window._translationsHash.addtext("rus", {
        "Текущее местоположение отображается только для России и Украины": "Текущее местоположение отображается только для России и Украины",
        "Следующие [value0] страниц": "Следующие [value0] страниц",
        "Следующие [value0] страницы": "Следующие [value0] страницы",
        "Следующая страница": "Следующая страница",
        "Следующая [value0] страница": "Следующая [value0] страница",
        "Предыдущие [value0] страниц" : "Предыдущие [value0] страниц",
        "Первая страница" : "Первая страница",
        "Последняя страница" : "Последняя страница"
    });
    window._translationsHash.addtext("eng", {
        "Текущее местоположение отображается только для России и Украины": "Current location is shown only for Russia and Ukraine",
        "Следующие [value0] страниц": "Next [value0] pages",
        "Следующие [value0] страницы": "Next [value0] pages",
        "Следующая страница": "Next page",
        "Следующая [value0] страница": "Next [value0] pages",
        "Предыдущие [value0] страниц" : "Previous [value0] pages",
        "Первая страница" : "First page",
        "Последняя страница" : "Last page"
    });

    var imagesHost = "img";

    /** Вспомогательные функции
     @namespace Functions
     @memberOf Search
    */
    var Functions = {

    	/** Возвращает полное наименование объекта, состоящее из типа и наименования
    	 @static
    	 @param sType Наименование типа объекта
    	 @param sName Наименование объекта
        */
    	GetFullName: function(/** string */sType, /** string */sName){
    		var sFullName = "";

    		if (sType==null || sType == "государство" || sType == "г." || /[a-zA-Z]/.test(sName))
    			sFullName = sName;
    		else if ((sType.indexOf("район") != -1) || (sType.indexOf("область") != -1) || (sType.indexOf("край") != -1))
    			sFullName = sName + " " + sType;
    		else
    			sFullName = sType + " " + sName;

    		return sFullName;
    	},

    	/** Возвращает полный путь к объекту
        * @memberOf Search.Functions
        *
    	* @param oFoundObject найденный объект
    	* @param sObjectsSeparator разделитель между дочерним элементом и родителем в строке пути
    	* @param bParentAfter признак того, что родительский элемент идет после дочернего
    	* @param sObjNameField название свойства, из которого брать наименование
        */
    	GetPath: function(/*object*/ oFoundObject,/* string */ sObjectsSeparator, /* bool */ bParentAfter, /* string */ sObjNameField){
    		if (sObjNameField == null) sObjNameField = "ObjName";
    		if (oFoundObject == null) return "";
    		var oParentObj = oFoundObject.Parent;
    		if (oParentObj != null && (oParentObj.ObjName == "Российская Федерация" || oParentObj.TypeName == "административный округ")) {
    			oParentObj = oParentObj.Parent;
    		}
    		var sObjectName = (oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183) ? oFoundObject[sObjNameField] : this.GetFullName(oFoundObject.TypeName, oFoundObject[sObjNameField]);
    		if (oParentObj != null && oParentObj[sObjNameField] != null && oParentObj[sObjNameField]){
    			if (bParentAfter){
    				return sObjectName + sObjectsSeparator + this.GetPath(oParentObj, sObjectsSeparator,  bParentAfter, sObjNameField);
    			}
    			else{
    				return this.GetPath(oParentObj, sObjectsSeparator,  bParentAfter, sObjNameField) + sObjectsSeparator + sObjectName;
    			}
    		}
    		else{
    			return sObjectName;
    		}
    	},

    	/** Возвращает строку, соединяющую переданные свойства
    	 @static
    	 @param oProps - Свойства
    	 @param sObjectsSeparator Разделитель 2х свойств в строке*/
    	GetPropertiesString: function(/**object[]*/oProps,/**string*/ sPropSeparator, /**object[]*/arrDisplayFields){
    		var sResultString = "";
    		if (oProps != null){
    			for (var sPropName in oProps){
    				if (sResultString != "") sResultString += sPropSeparator;
    				sResultString += sPropName + ": " + oProps[sPropName];
    			}
    		}
    		return sResultString;
    	}
    };


    /** Конструктор
     @class Предоставляет функции, отображающие найденные объекты на карте
     @memberof Search
     @param {L.Map} map карта, на которой будут рисоваться объекты
     @param {string} sInitImagesHost - строка пути к картинкам
     @param {bool} bInitAutoCenter - если true, карта будет центрироваться по 1ому найденному объекту*/
    var ResultRenderer = function(map, sInitImagesHost, bInitAutoCenter){
    	if (map == null)  throw "ResultRenderer.Map is null";

    	var sImagesHost = sInitImagesHost || "http://maps.kosmosnimki.ru/api/img";
    	var bAutoCenter = (bInitAutoCenter == null) || bInitAutoCenter;

        this.arrContainer = [];
    	var counts = [];

    	/** возвращает стили найденных объектов, используется только для точки*/
    	var getSearchIcon = function(iPosition) {
            iPosition = Math.min(iPosition, 9);
            return L.icon({
                iconUrl: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png",
                iconAnchor: [15, 38],
                popupAnchor: [0, -28]
            });

    		// return [
    						// { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + ".png", dx: -14, dy: -38} },
    						// { marker: { image: sImagesHost + "/search/search_" + (iPosition + 1).toString() + "a.png", dx: -14, dy: -38} }
    				// ];
    	};

        var bindHoverPopup = function(layer, content) {
            layer.bindPopup(content);
        };

    	/**Помещает объект на карту
    	@param {MapObject} oContainer контейнер, содержащий в себе объекты текущей группы результатов поиска
    	@param {MapObject} oFoundObject добавляемый объект
    	@param {int} iPosition порядковый номер добавляемого объекта в группе
    	@param {int} iCount общее количество объектов в группе
        @return {Object} Нарисованные на карте объекты: хеш с полями center и boundary */
    	var DrawObject = function(oContainer, oFoundObject, iPosition, iCount){
            var color = Math.round(0x22 + 0x99*iPosition/iCount);
    		var sDescr = "<b>" + Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName) + "</b><br/>" + Functions.GetPath(oFoundObject.Parent, "<br/>", true);
    		if (oFoundObject.properties != null) sDescr += "<br/>" + Functions.GetPropertiesString(oFoundObject.properties, "<br/>");

            sDescr = sDescr.replace(/;/g, "<br/>");
    		var centerMapElem,
                boundaryMapElem;
    		//Рисуем центр объекта
    		if (oFoundObject.Geometry != null && (oFoundObject.Geometry.type).toUpperCase() == 'POINT') {
                centerMapElem = L.marker([oFoundObject.Geometry.coordinates[1], oFoundObject.Geometry.coordinates[0]], {
                    icon: getSearchIcon(iPosition)
                });
                bindHoverPopup(centerMapElem, sDescr);
                oContainer.addLayer(centerMapElem);
    		}
    		else if (oFoundObject.CntrLon != null && oFoundObject.CntrLat != null){
                centerMapElem = L.marker([oFoundObject.CntrLat, oFoundObject.CntrLon], {
                    icon: getSearchIcon(iPosition)
                });

                bindHoverPopup(centerMapElem, sDescr);
                oContainer.addLayer(centerMapElem);
    		}


    		//Рисуем контур объекта
    		if (oFoundObject.Geometry != null && (oFoundObject.Geometry.type).toUpperCase() != 'POINT') {
                boundaryMapElem = L.geoJson(L.gmxUtil.geometryToGeoJSON(oFoundObject.Geometry), {
                    style: function(feature) {
                        return
                    },
                    onEachFeature: function(feature, layer) {
                        layer.setStyle({
                            color: '#' + (0x1000000 + (color << 16) + (color << 8) + color).toString(16).substr(-6),
                            weight: 3,
                            opacity: 0.6,
                            fill: false
                        });

                        bindHoverPopup(layer, sDescr);
                    }
                });

                oContainer.addLayer(boundaryMapElem);
    		}

            return {center: centerMapElem, boundary: boundaryMapElem};
    	};

    	/**Центрует карту по переданному объекту*/
    	var CenterObject = function(oFoundObject){
    		if (!oFoundObject) return;
    		var iZoom = oFoundObject.TypeName == "г." ? 9 : 15;
            if (oFoundObject.Geometry == null) {
    		    if (oFoundObject.MinLon != null && oFoundObject.MaxLon != null && oFoundObject.MinLat != null && oFoundObject.MaxLat != null
                    && oFoundObject.MaxLon - oFoundObject.MinLon < 1e-9 && oFoundObject.MaxLat - oFoundObject.MinLat < 1e-9)
    			    map.setView([oFoundObject.CntrLat, oFoundObject.CntrLon], iZoom);
    		    else
    			    map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
            }
    		else
    		{
               if ((oFoundObject.Geometry.type).toUpperCase() == 'POINT') {
    		        if (oFoundObject.MinLon != oFoundObject.MaxLon && oFoundObject.MinLat != oFoundObject.MaxLat) {
    			        map.fitBounds([[oFoundObject.MinLat, oFoundObject.MinLon], [oFoundObject.MaxLat, oFoundObject.MaxLon]]);
                    } else {
                        var c = oFoundObject.Geometry.coordinates;
    			        map.setView([c[1], c[0]], iZoom);
                    }
    		    }
    		    else {
                    var bounds = L.gmxUtil.getGeometryBounds(oFoundObject.Geometry);
    			    //var oExtent = getBounds(oFoundObject.Geometry.coordinates);
    			    map.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
                }
    		}
    	};

    	/**Центрует карту по переданному объекту
    	@param {MapObject} oFoundObject объект, который нужно поместить в центр
    	@returns {void}*/
    	this.CenterObject = function(oFoundObject){
    		CenterObject(oFoundObject);
    	};

    	/** Рисует объекты на карте.
    	@param {int} iDataSourceN № источника данных (группы результатов поиска)
    	@param {Array} arrFoundObjects Массив объектов для отрисовки. Каждый объект имеет свойства
    	@param {bool} [options.append=false] Добавить к существующим объектам для источника данных, а не удалять их
    	@return {Array} Нарисованные на карте объекты: массив хешей с полями center и boundary
        */
    	this.DrawObjects = function(iDataSourceN, arrFoundObjects, options){
            options = $.extend({append: false}, options);

            if (!options.append && this.arrContainer[iDataSourceN]) {
                map.removeLayer(this.arrContainer[iDataSourceN]);
                delete this.arrContainer[iDataSourceN];
            }

            if (!this.arrContainer[iDataSourceN]) {
                this.arrContainer[iDataSourceN] = L.layerGroup();
                counts[iDataSourceN] = 0;
            }

    		iCount = arrFoundObjects.length;

            var mapObjects = [];

            counts[iDataSourceN] += arrFoundObjects.length;

    		//Отрисовываем задом наперед, чтобы номер 1 был сверху от 10ого
    		for (var i = arrFoundObjects.length - 1; i >= 0; i--){
    			mapObjects.unshift(DrawObject(this.arrContainer[iDataSourceN], arrFoundObjects[i], counts[iDataSourceN] + i - arrFoundObjects.length, counts[iDataSourceN]));
    		}

    		this.arrContainer[iDataSourceN].addTo(map);
    		if (bAutoCenter && iDataSourceN == 0) CenterObject(arrFoundObjects[0]);

            return mapObjects;
    	};
    };

    var ResultList = function(oInitContainer, oRenderer, ImagesHost){
    	/**Объект, в котором находится контрол (div)*/
        // создается в начале searchLogic.showResult
    	var Container = oInitContainer;
    	var _this = this;

    	var sImagesHost = ImagesHost || "http://maps.kosmosnimki.ru/api/img";

    	var arrDisplayedObjects = []; //Объекты, которые отображаются на текущей странице
    	var iLimit = 10; //Максимальное количество результатов на странице
    	var iPagesCount = 7; //Количество прокручиваемых страниц при нажатии на двойные стрелки
    	if (Container == null) throw "ResultList.Container is null";

    	var oResultCanvas;
    	var arrTotalResultSet = [];

    	if(oResultCanvas == null)
    	{
    		oResultCanvas = nsGmx$1.Utils._div(null, [['dir', 'className', 'searchResultCanvas']]);
            Container.appendChild(oResultCanvas);
    	}
    	var oLoading = nsGmx$1.Utils._div([_img(null, [['attr', 'src', sImagesHost + '/progress.gif'], ['dir', 'className', 'searchResultListLoadingImg']]), _t(_gtxt("загрузка..."))], [['dir', 'className', 'searchResultListLoading']]);
    	var fnNotFound = function(){nsGmx$1.Utils._(oResultCanvas, [nsGmx$1.Utils._div([_t(_gtxt("Поиск не дал результатов"))], [['dir', 'className', 'SearchResultListNotFound']])]);};

    	/**Удаляет все найденные объекты из результатов поиска*/
    	var unload = function(){
    		for(i=0; i<arrDisplayedObjects.length; i++){
    			SetDisplayedObjects(i, []);
    		}
    		$(oResultCanvas).empty();
    	};

        /** Переход на предыдущие страницы*/
        var previous = function(iDataSourceN, divChilds, divPages) {
            var button = makeImageButton(sImagesHost + '/prev.png', sImagesHost + '/prev_a.png');

            button.style.marginBottom = '-7px';

            button.onclick = function() {
    			var oDataSource = arrTotalResultSet[iDataSourceN];
                oDataSource.start -= iPagesCount;
                oDataSource.reportStart = oDataSource.start * iLimit;

                drawPagesRow(iDataSourceN, divChilds, divPages);
            };

            _title(button, _gtxt('Предыдущие [value0] страниц', iPagesCount));

            return button;
        };

        /** Переход на первую страницу*/
        var first = function(iDataSourceN, divChilds, divPages) {
            var button = makeImageButton(sImagesHost + '/first.png', sImagesHost + '/first_a.png');

            button.style.marginBottom = '-7px';

            button.onclick = function() {
    			var oDataSource = arrTotalResultSet[iDataSourceN];
                oDataSource.start = 0;
                oDataSource.reportStart = oDataSource.start * iLimit;

                drawPagesRow(iDataSourceN, divChilds, divPages);
            };

            _title(button, _gtxt('Первая страница'));

            return button;
        };

    	/**Добавляет объект в список найденных результатов*/
    	var drawObject = function(oFoundObject, elemDiv, bIsParent)
    	{
    		var	realPath = (oFoundObject.CountryCode != 28000 && oFoundObject.CountryCode != 310000183)  ? oFoundObject.ObjName : Functions.GetFullName(oFoundObject.TypeName, oFoundObject.ObjName);
    		if (oFoundObject.Parent != null) realPath += ",";

    		var searchElemHeader = _span([_t(realPath)], [['dir', 'className', bIsParent?'searchElemParent':'searchElem']]);

    		/** Вызывается при клике на найденный объект в списке результатов поиска
    		@name Search.ResultList.onObjectClick
    		@event
    		@param {object} oFoundObject Найденный объект*/
    		searchElemHeader.onclick = function(){$(_this).triggerHandler('onObjectClick', [oFoundObject]);};

    		nsGmx$1.Utils._(elemDiv, [searchElemHeader]);
    		if (oFoundObject.Parent != null) drawObject(oFoundObject.Parent, elemDiv, true);
    		if (oFoundObject.properties != null) nsGmx$1.Utils._(elemDiv, [document.createTextNode(" " + Functions.GetPropertiesString(oFoundObject.properties, "; "))]);
    	};

    	/** Рисует строки списка*/
    	var drawRows = function(iDataSourceN, divChilds) {
    		var arrObjects = arrDisplayedObjects[iDataSourceN];
    		$(divChilds).empty();
    		var tbody = _tbody();
    		for (var i = 0; i < arrObjects.length; i++) {
    			var elemTR = _tr(null, [['dir', 'className', 'SearchResultRow']]);
    			var elemTD = _td(null, [['dir', 'className', 'SearchResultText']]);
    			nsGmx$1.Utils._(elemTR, [_td([_t((i+1).toString() + ".")], [['dir', 'className','searchElemPosition']]), elemTD]);
    			drawObject(arrObjects[i], elemTD);

    			// загрузка SHP Файла
    			if (window.gmxGeoCodeShpDownload && arrObjects[i].Geometry != null) {
    			    var shpFileLink = _span([_t(".shp")], [['dir', 'className', 'searchElem'], ['attr', 'title', 'скачать SHP-файл'], ['attr', 'number', i]]);

    			    shpFileLink.onclick = function () {
    			        var obj = arrObjects[$(this).attr('number')];
    			        var objsToDownload = [obj];
    			        $(_this).triggerHandler('onDownloadSHP', [obj.ObjCode, objsToDownload]);
    			    };
    			   nsGmx$1.Utils._(elemTD, [_t(" ")]);
    			   nsGmx$1.Utils._(elemTD, [shpFileLink]);
    			}

                elemTD.gmxDrawingObject = arrObjects[i];

                $(elemTD).draggable({
                    scroll: false,
                    appendTo: document.body,
                    helper: 'clone',
                    distance: 10
                });

    			nsGmx$1.Utils._(tbody, [elemTR]);
    		}
    		nsGmx$1.Utils._(divChilds, [_table([tbody])]);

    	};

    	/**Рисует одну из страниц списка
    	@param iDataSourceN - номер источника данных
    	@param divChilds - раздел для элементов списка
    	@param divPages - раздел для номеров страниц списка*/
    	var drawPagesRow = function(iDataSourceN, divChilds, divPages) {
    		var oDataSource = arrTotalResultSet[iDataSourceN];

    		// перерисовывем номера страниц
    		$(divPages).empty();

    		var end = (oDataSource.start + iPagesCount <= oDataSource.allPages) ? oDataSource.start + iPagesCount : oDataSource.allPages;

    		if (oDataSource.start - iPagesCount >= 0)
    			nsGmx$1.Utils._(divPages, [first(iDataSourceN, divChilds, divPages), previous(iDataSourceN, divChilds, divPages)]);

    		// drawPages(end, iDataSourceN, divChilds, divPages);

    		// if (end + 1 <= oDataSource.allPages)
    		// 	nsGmx.Utils._(divPages, [next(iDataSourceN, divChilds, divPages), last(iDataSourceN, divChilds, divPages)]);
            var startFrom = oDataSource.reportStart * iLimit;

    		SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult.slice(startFrom, (startFrom + iLimit)));
    		drawRows(iDataSourceN, divChilds);
    	};

    	/**Рисует таблицу для результатов источника данных
    	@param iDataSourceN - номер источника данных
    	@param divChilds - раздел для элементов списка
    	@param divPages - раздел для номеров страниц списка*/
    	var drawTable = function(iDataSourceN, divChilds, divPages) {
    		var oDataSource = arrTotalResultSet[iDataSourceN];


    		if (oDataSource.SearchResult.length <= iLimit/* && iDataSourceN < oDataSource.SearchResult.length - 1*/) {
    			$(divPages).empty();
    			SetDisplayedObjects(iDataSourceN, oDataSource.SearchResult);
    			drawRows(iDataSourceN, divChilds);
    		}
    		else {
    			oDataSource.allPages = Math.ceil(oDataSource.SearchResult.length / iLimit);
    			drawPagesRow(iDataSourceN, divChilds, divPages);
    		}
    	};

    	/**Обрабатывает событие нажатия на кнопку "Скачать SHP-файл"
    	@param iDataSourceN - номер источника данных*/
    	var downloadMarkers = function(iDataSourceN) {
    		var oDataSource = arrTotalResultSet[iDataSourceN];
    		var canvas = nsGmx$1.Utils._div(),
    			filename = _input(null, [['dir', 'className', 'filename'], ['attr', 'value', oDataSource.name]]);

    		var downloadButton = makeButton(_gtxt("Скачать"));
    		downloadButton.onclick = function() {
    			if (filename.value == '') {
    				inputError(filename, 2000);

    				return;
    			}

    			/** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
    			@name Search.ResultList.onDownloadSHP
    			@event
    			@param {string} filename Имя файла, которой необходимо будет сформировать
    			@param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/
    			$(_this).triggerHandler('onDownloadSHP', [filename.value, oDataSource.SearchResult]);

    			$(canvas.parentNode).dialog("destroy").remove();
    		};

    		nsGmx$1.Utils._(canvas, [nsGmx$1.Utils._div([_t(_gtxt("Введите имя файла для скачивания")), filename], [['dir', 'className', 'DownloadSHPButtonText']]), nsGmx$1.Utils._div([downloadButton], [['dir', 'className', 'DownloadSHPButton']])]);

    		var area = getOffsetRect(Container);
    		showDialog(_gtxt("Скачать shp-файл"), canvas, 291, 120, 30, area.top + 10);
    	};

    	/**Отображает результаты поиска с источника данных
    	@param iDataSourceN - номер источника данных*/
    	var drawSearchResult = function(iDataSourceN, options) {
    		var oDataSource = arrTotalResultSet[iDataSourceN];

    		var arrDataSourceList = oDataSource.SearchResult;
    		var header = oDataSource.name;

    		var divChilds = nsGmx$1.Utils._div(null, [['dir', 'className', 'SearchResultListChildsCanvas']]),
    			divPages = nsGmx$1.Utils._div(),
    			liInner = _li([divChilds, divPages]),
    			li;
    		if (arrTotalResultSet.length == 1){
    			li = nsGmx$1.Utils._ul([liInner]);
    		}
    		else{
    			li = _li([nsGmx$1.Utils._div([_t(header), _span([_t("(" + arrDataSourceList.length + ")")])], [['dir', 'className', 'searchLayerHeader']]), nsGmx$1.Utils._ul([liInner])]);
    		}

    		oDataSource.start = 0;
    		oDataSource.reportStart = options.page || 0;
    		oDataSource.allPages = 0;

    		drawTable(iDataSourceN, divChilds, divPages);

    		if (oDataSource.CanDownloadVectors) {
    			var downloadVector = makeLinkButton(_gtxt("Скачать shp-файл"));

    			downloadVector.onclick = function() {
    				downloadMarkers(iDataSourceN);
    			};

    			liInner.insertBefore(nsGmx$1.Utils._div([downloadVector], [['dir', 'className', 'SearchDownloadShpLink']]), liInner.firstChild);
    		}

    		return li;
    	};

        var fnDisplayedObjectsChanged = function(event, iDataSourceN, arrFoundObjects){
            oRenderer.DrawObjects(iDataSourceN, arrFoundObjects);
            /** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
            @name Search.ResultListMap.onDisplayedObjectsChanged
            @event
            @param {int} iDataSourceN № источника данных(группы результатов поиска)
            @param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
            // $(_this).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
        };

        var fnObjectClick = function(event, oFoundObject){
            oRenderer.CenterObject(oFoundObject);

            /** Вызывается при клике на найденный объект в списке результатов поиска
            @name Search.ResultListMap.onObjectClick
            @event
            @param {object} oFoundObject Найденный объект*/
            // $(oSearchResultDiv).triggerHandler('onObjectClick', [oFoundObject]);
        };

        var fnDownloadSHP = function(event, filename, arrObjectsToDownload){
            /** Вызывается при необходимости осуществить загрузку SHP-файла с результатами поиска
            @name Search.ResultListMap.onDownloadSHP
            @event
            @param {string} filename Имя файла, которой необходимо будет сформировать
            @param {object[]} SearchResult Результаты поиска, которые необходимо сохранить в файл*/
            // $(oSearchResultDiv).triggerHandler('onDownloadSHP', [filename, arrObjectsToDownload]);
        };


        $(_this).bind('onDisplayedObjectsChanged', fnDisplayedObjectsChanged);
        $(_this).bind('onObjectClick', fnObjectClick);
        $(_this).bind('onDownloadSHP', fnDownloadSHP);

    	/**Отображает результаты поиска в списке
    	@param sTotalListName - заголовок итогового результата
    	@param {Array.<Object>} arrTotalList. Массив объектов со следующими свойствами{name:DataSourceName, CanDownloadVectors:CanDownloadVectors, SearchResult:arrDataSourceList[oObjFound,...]}
    	@returns {void}
    	*/
    	this.ShowResult = function(sTotalListName, arrTotalList, options){
    		arrTotalResultSet = arrTotalList;
    	    $(oResultCanvas).empty();
    		arrDisplayedObjects = [];
    		if (!objLength(arrTotalResultSet)) {
    			fnNotFound();
    			return;
    		}
    		else {
    			var foundSomething = false;

    			for (var i = 0; i < arrTotalResultSet.length; i++) {
    				if (arrTotalResultSet[i].SearchResult.length > 0) {
    					foundSomething = true;
    					break;
    				}
    			}
    			if (!foundSomething) {
    				fnNotFound();
    				return;
    			}
    		}

    		var ulSearch = nsGmx$1.Utils._ul();

    		for (var iDataSourceN  = 0; iDataSourceN < arrTotalResultSet.length; iDataSourceN++)
    			nsGmx$1.Utils._(ulSearch, [drawSearchResult(iDataSourceN, options)]);

    		if (arrTotalResultSet.length == 1){
    			nsGmx$1.Utils._(oResultCanvas, [ulSearch]);
    		}
    		else{
    			nsGmx$1.Utils._(oResultCanvas, [_li([nsGmx$1.Utils._div([_t(sTotalListName)], [['dir', 'className', 'SearchTotalHeader']]), ulSearch])]);
    		}

            if (typeof($.fn.treeview) === 'function') {
                $(oResultCanvas).treeview();
            }

    		$(oResultCanvas).find(".SearchResultListChildsCanvas").each(function() {
    			this.parentNode.style.padding = '0px';
    			this.parentNode.style.background = 'none';
    		});
    	};


        /**Создается переключатель страниц
        @param results - набор результатов
        @param onclick - обработчик нажатия переключателя страниц
        @returns {void}*/
        this.CreatePager = function (results, onclick) {

            function makeNavigButton(pager, img, imga, id, title) {
                var b = makeImageButton(sImagesHost + img, sImagesHost + imga);
                b.style.marginBottom = '-7px';
                $(b).attr('id', id);
                nsGmx$1.Utils._title(b, title);
                nsGmx$1.Utils._(pager, [b]);
                return b;
            }

            containerList = Container;
            $('#respager').remove();
            //var pager = nsGmx.Utils._div([_t('всего: ' + results[0].ResultsCount)], [["attr", "id", "respager"]]);
            var pager = nsGmx$1.Utils._div([_t('')], [["attr", "id", "respager"]]);
            nsGmx$1.Utils._(containerList, [pager]);

            var pcount = results[0].SearchResult[0] ? Math.ceil(results[0].SearchResult[0].OneOf / iLimit) : 0;
            if (pcount > 1) {
                var first = makeNavigButton(pager, '/first.png', '/first_a.png', 'firstpage', _gtxt('Первая страница'));
                $(first).bind('click', function () {
                    fnShowPage(0);
                });
                var prev = makeNavigButton(pager, '/prev.png', '/prev_a.png', 'prevpages', _gtxt('Предыдущие [value0] страниц', iPagesCount));
                $(prev).bind('click', function () {
                    fnShowPage(parseInt($('#page1').text()) - iPagesCount - 1);
                });
                $(first).hide();
                $(prev).hide();

                for (var i = 0; i < iPagesCount && i < pcount; ++i) {
                    var pagelink = makeLinkButton(i + 1);
                    $(pagelink).attr('id', 'page' + (i + 1));
                    if (i == 0){
                        $(pagelink).attr('class', 'page');
                        attachEffects(pagelink, '');
                    }
                    $(pagelink).bind('click', onclick);
                    nsGmx$1.Utils._(pager, [pagelink, _t(' ')]);
                }

                var remains = pcount % iPagesCount;
                var nextPages = pcount/iPagesCount<2 ? remains : iPagesCount;
                var nextButTitle = 'Следующие [value0] страниц';
                if (nextPages == 1)
                    nextButTitle = 'Следующая страница';
                if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11)
                    nextButTitle = 'Следующая [value0] страница';
                if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages<10 || nextPages > 20))
                    nextButTitle = 'Следующие [value0] страницы';
                var next = makeNavigButton(pager, '/next.png', '/next_a.png', 'nextpages', _gtxt(nextButTitle, nextPages));
                $(next).bind('click', function () {
                    fnShowPage(parseInt($('#page' + iPagesCount).text()));
                });
                var last = makeNavigButton(pager, '/last.png', '/last_a.png', 'lastpage', _gtxt('Последняя страница'));
                $(last).bind('click', function () {
                    var lastindex = (remains == 0 ? iPagesCount : remains);
                    fnShowPage(pcount - lastindex, $('#page' + lastindex));
                });

                if (iPagesCount >= pcount) {
                    $(next).hide();
                    $(last).hide();
                }
            }

            var fnShowPage = function (n, active) {
                //alert(n + "\n" + pcount);
                for (var i = 0; i < iPagesCount; ++i) {//pcount
                    if (i + n < pcount) {
                        $('#page' + (i + 1)).text(i + n + 1);
                        $('#page' + (i + 1)).show();
                    }
                    else
                        $('#page' + (i + 1)).hide();
                }

                if (n < iPagesCount) {
                    $('#prevpages').hide(); $('#firstpage').hide();
                }
                else {
                    $('#prevpages').show(); $('#firstpage').show();
                }

                if (n + iPagesCount < pcount) {
                    $('#nextpages').show(); $('#lastpage').show();
                    var rest = pcount - n - iPagesCount;
                    var nextPages = rest < iPagesCount ? rest : iPagesCount;
                    var nextButTitle = 'Следующие [value0] страниц';
                    if (nextPages == 1)
                        nextButTitle = 'Следующая страница';
                    if (nextPages % 10 == 1 && nextPages != 1 && nextPages != 11)
                        nextButTitle = 'Следующая [value0] страница';
                    if (1 < nextPages % 10 && nextPages % 10 < 5 && (nextPages < 10 || nextPages > 20))
                        nextButTitle = 'Следующие [value0] страницы';
                    $('#nextpages').attr('title', _gtxt(nextButTitle, nextPages));
                }
                else {
                    $('#nextpages').hide(); $('#lastpage').hide();
                }

                if (active == null) active = $('#prevpages~span')[0];
                $(active).trigger('click');
            };
        };
        /*----------------------------------------------------------*/

    	/**Возвращает список объектов, которые отображаются на текущей странице во всех разделах*/
    	this.GetDisplayedObjects = function(){return arrDisplayedObjects; };
    	var SetDisplayedObjects = function(iDataSourceN, value) {
    		arrDisplayedObjects[iDataSourceN] = value;

    		/** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
    		@name Search.ResultList.onDisplayedObjectsChanged
    		@event
    		@param {int} iDataSourceN № источника данных(группы результатов поиска)
    		@param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
    		$(_this).triggerHandler('onDisplayedObjectsChanged',[iDataSourceN, arrDisplayedObjects[iDataSourceN]]);
    	};

    	/** Показывает режим загрузки
    	@returns {void}*/
    	this.ShowLoading = function(){
    	    $('#respager').remove();
            $(oResultCanvas).empty();
            // Container.appendChild(oResultCanvas);
    		nsGmx$1.Utils._(oResultCanvas, [oLoading]);
    	};

    	/**Показывает сообщение об ошибке
    	@returns {void}*/
    	this.ShowError = function(){
    		$(oResultCanvas).empty();
    		nsGmx$1.Utils._(oResultCanvas, [_t("Произошла ошибка")]);
    	};

    	/**Очищает результаты поиска
    	@returns {void}*/
    	this.Unload = function(){unload();};
    	/** Возвращает контрол, в котором находится данный контрол*/
    	this.getContainer = function(){return Container;};
    };

    nsGmx$1.SearchLogic = function () {};

    nsGmx$1.SearchLogic.prototype = {
        init: function (params) {
            this.oMenu = params.oMenu || new leftMenu();
            this.oRenderer = new ResultRenderer(nsGmx$1.leafletMap, imagesHost, true);
            this.oSearchResultDiv = document.createElement('div');
            this.searchByStringHooks = [];
            this.oSearchResultDiv.className = 'ddfdfdf';
            this.oSearchResultDiv.title = window._gtxt('Изменить параметры поиска');

            var fnBeforeSearch = function(event){
                /** Вызывается перед началом поиска
                @name Search.SearchGeomixer.onBeforeSearch
                @event */
                $(this.oSearchResultDiv).triggerHandler('onBeforeSearch');
                fnLoad();
            };
            var fnAfterSearch = function(event){
                /** Вызывается после окончания поиска
                @name Search.SearchGeomixer.onAfterSearch
                @event */
                $(this.oSearchResultDiv).triggerHandler('onAfterSearch');
            };
            var onDisplayedObjectsChanged = function(event, iDataSourceN, arrFoundObjects){
                /** Вызывается при изменении отображаемого списка найденных объектов(ведь они отображаются не все)
                @name Search.SearchGeomixer.onDisplayedObjectsChanged
                @event
                @param {int} iDataSourceN № источника данных(группы результатов поиска)
                @param {object[]} arrDSDisplayedObjects Результаты поиска, которые необходимо отобразить в текущей группе*/
                $(this.oSearchResultDiv).triggerHandler('onDisplayedObjectsChanged', [iDataSourceN, arrFoundObjects]);
            };
            var onObjectClick = function(event, oFoundObject){
                /** Вызывается при клике на найденный объект в списке результатов поиска
                @name Search.SearchGeomixer.onObjectClick
                @event
                @param {object} oFoundObject Найденный объект*/
                $(this.oSearchResultDiv).triggerHandler('onObjectClick', [oFoundObject]);
            };
            $(this.oSearchResultDiv).bind('onBeforeSearch', fnBeforeSearch);
            $(this.oSearchResultDiv).bind('onAfterSearch', fnAfterSearch);
            $(this.oSearchResultDiv).bind('onDisplayedObjectsChanged', onDisplayedObjectsChanged);
            $(this.oSearchResultDiv).bind('onObjectClick', onObjectClick);

            // coordinates search hook
            this.addSearchByStringHook(function(searchString) {
                var pos = L.gmxUtil.parseCoordinates(searchString);
                if (pos) {
                    nsGmx$1.leafletMap.panTo(pos);

                    // Добавим иконку по умолчанию
                    // L.Icon.Default.imagePath = 'leaflet/images';
                    nsGmx$1.leafletMap.gmxDrawing.add(L.marker(pos, { draggable: true, title: searchString }));

                    // Либо задать свою иконку
                    // map.gmxDrawing.add(L.marker(pos, {
                        // draggable: true, title: searchString,
                        // icon: L.icon({ iconUrl: 'img/flag_blau1.png', iconAnchor: [6, 36] })
                    // }));

                    //map.moveTo(pos[0], pos[1], map.getZ());
                    //map.drawing.addObject({ type: "POINT", coordinates: pos }, { text: searchString });
                    return true;
                }
            });
        },

        fnLoad: function(){
            if (this.oMenu != null){
                var alreadyLoaded = this.oMenu.createWorkCanvas("search", this.fnUnload.bind(this));
                if(!alreadyLoaded) {
                    this.oMenu.workCanvas.appendChild(this.oSearchResultDiv);
                }
                $(this.oSearchResultDiv).empty();
            }
        },

        fnUnload: function () {
            if (this.lstResult) {
                this.lstResult.Unload();
            }
        },

        showResult: function (response) {
            var _this = this;
            var searchString = response.searchString || '';
            if (searchString) {
                for (var h = 0; h < this.searchByStringHooks.length; h++) {
                    if (this.searchByStringHooks[h].hook(searchString)) {
                        return;
                    }
                }
            }
            this.fnLoad();
            this.lstResult = new ResultList(this.oSearchResultDiv, this.oRenderer, imagesHost);
            this.lstResult.ShowLoading();
            this.lstResult.ShowResult(searchString, response, {page: 0});
            this.lstResult.CreatePager(response, function (e) {
                var evt = e || window.event,
                    active = evt.srcElement || evt.target,
                    activePage = parseInt($(this).text()) - 1;

                $('#prevpages~span:visible').attr('class', 'buttonLink');
                for (var i=0; i<$('#prevpages~span:visible').length; ++i) attachEffects($('#prevpages~span:visible')[i], 'buttonLinkHover');
                $(active).attr('class', 'page');
                attachEffects(active, '');

                _this.lstResult.ShowResult(searchString, response, {page: activePage});
            });
        },

        addSearchByStringHook: function (hook, priority) {
            var _this = this;
            this.searchByStringHooks.push({
                hook: hook,
                priority: priority || 0,
                index: _this.searchByStringHooks.length
            });

            this.searchByStringHooks.sort(function(a, b) {
                return b.priority - a.priority || a.index - b.index;
            });
        },

        removeSearchByStringHook: function(hook) {
            for (var h = 0; h < this.searchByStringHooks.length; h++) {
                if (this.searchByStringHooks[h].hook === hook) {
                    this.searchByStringHooks.splice(h, 1);
                    return;
                }
            }
        },

        layersSearch: function (res) {
            if (!nsGmx$1.gmxMap){
                reject(res);
            }

            var promisesArr = [];

            var layersToSearch = [];
            for (var i=0; i< nsGmx$1.gmxMap.layers.length; i++) {
                //свойства мы берём из дерева слоёв, а не из API. Cвойство AllowSearch относится к карте и не поддерживаются API
                var searchRes = window._layersTree.treeModel.findElem('name', nsGmx$1.gmxMap.layers[i].getGmxProperties().name);

                if (searchRes) {
                    var props = searchRes.elem.content.properties;

                    if (props.type == "Vector" && props.AllowSearch) {
                        layersToSearch.push(props);
                    }
                }
            }

            if (layersToSearch.length > 0) {
                layersToSearch.forEach(function(props) {
                    var mapName = nsGmx$1.gmxMap.layersByID[props.name].options.mapID;
                    var url = window.serverBase + "SearchObject/SearchVector.ashx" +
                        "?LayerNames=" + props.name +
                        "&MapName=" + mapName +
                        "&SearchString=" + encodeURIComponent(res.Result.searchString);

                    var promise = new Promise(function(resolve, reject) {
                        var req = new XMLHttpRequest();
                        req.withCredentials = true;
                        req.open('GET', url);

                        req.onload = function() {
                    if (req.status == 200) {
                        var res = handleResponse(req.response, props);

                        res.then(function (res2) {
                            resolve(res2);
                        });
                    } else {
                          reject(Error(req.statusText));
                        }
                      };
                      req.onerror = function() {
                        reject(Error("Network Error"));
                      };

                      req.send();
                    });

                    promisesArr.push(promise);
                });

                return Promise.all(promisesArr);
            } else {
                return new Promise(function(resolve, reject) {
                        resolve(res);
                })
            }

            function handleResponse(searchReq, layerProps) {
                searchReq = typeof searchReq === 'string' ? JSON.parse(searchReq.substring(1, searchReq.length - 1)) : searchReq;
                var arrLayerResult = [];
                var arrResult = [];
                if (searchReq.Status == 'ok') {
                    for (var iServer = 0; iServer < searchReq.Result.length; iServer++)
                    {
                        var limitSearchResults = typeof(LayerSearchLimit)=="number" ? LayerSearchLimit : 100;
                        var req = searchReq.Result[iServer];
                        for (var j = 0; j<limitSearchResults && j < req.SearchResult.length; j++)
                        {
                            var arrDisplayProperties = {};
                            {
                                arrDisplayProperties = req.SearchResult[j].properties;
                            }

                            for (var p in arrDisplayProperties) {
                                var type = layerProps.attrTypes[layerProps.attributes.indexOf(p)];
                                arrDisplayProperties[p] = nsGmx$1.Utils.convertFromServer(type, arrDisplayProperties[p]);
                            }

                            arrLayerResult.push({
                                ObjName: req.SearchResult[j].properties.NAME || req.SearchResult[j].properties.Name || req.SearchResult[j].properties.name || req.SearchResult[j].properties.text || req.SearchResult[j].properties["Название"] || "[объект]",
                                properties: arrDisplayProperties,
                                Geometry: L.gmxUtil.convertGeometry(req.SearchResult[j].geometry, true)
                            });
                        }
                    }
                    if(arrLayerResult.length > 0) arrResult.push({name: layerProps.title, SearchResult: arrLayerResult, CanDownloadVectors: true});
                    return Promise.resolve(arrResult);
                } else {
                    return Promise.reject(searchReq);
                }
            }
        }
    };

    var main = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', { value: true });

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      return Constructor;
    }

    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }

      subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
          value: subClass,
          writable: true,
          configurable: true
        }
      });
      if (superClass) _setPrototypeOf(subClass, superClass);
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    function _possibleConstructorReturn(self, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      }

      return _assertThisInitialized(self);
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function _iterableToArrayLimit(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    var EventTarget = function () {
        function EventTarget() {
            classCallCheck(this, EventTarget);

            this.listeners = {};
        }

        createClass(EventTarget, [{
            key: 'addEventListener',
            value: function addEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    this.listeners[type] = [];
                }
                this.listeners[type].push(callback);
            }
        }, {
            key: 'on',
            value: function on(type, callback) {
                this.addEventListener(type, callback);
                return this;
            }
        }, {
            key: 'removeEventListener',
            value: function removeEventListener(type, callback) {
                if (!(type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[type];
                for (var i = 0, l = stack.length; i < l; i++) {
                    if (stack[i] === callback) {
                        stack.splice(i, 1);
                        return this.removeEventListener(type, callback);
                    }
                }
            }
        }, {
            key: 'off',
            value: function off(type, callback) {
                this.removeEventListener(type, callback);
                return this;
            }
        }, {
            key: 'dispatchEvent',
            value: function dispatchEvent(event) {
                if (!(event.type in this.listeners)) {
                    return;
                }
                var stack = this.listeners[event.type];
                Object.defineProperty(event, 'target', {
                    enumerable: false,
                    configurable: false,
                    writable: false,
                    value: this
                });
                for (var i = 0, l = stack.length; i < l; i++) {
                    stack[i].call(this, event);
                }
            }
        }]);
        return EventTarget;
    }();

    var scanexEventTarget_cjs = EventTarget;

    var ResultView =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(ResultView, _EventTarget);

      function ResultView(_ref) {
        var _this;

        var input = _ref.input,
            _ref$replaceInput = _ref.replaceInput,
            replaceInput = _ref$replaceInput === void 0 ? false : _ref$replaceInput;

        _classCallCheck(this, ResultView);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(ResultView).call(this));
        _this._input = input;
        _this.index = -1;
        _this.count = 0;
        _this._item = null;
        _this._inputText = '';
        _this._replaceInput = replaceInput;
        _this._list = L.DomUtil.create('div');

        _this._list.setAttribute('class', 'leaflet-ext-search-list noselect');

        _this.allowNavigation = true;
        _this._list.style.top = "".concat(_this._input.offsetTop + _this._input.offsetHeight + 2, "px");
        _this._list.style.left = "".concat(_this._input.offsetLeft, "px");
        _this._handleKey = _this._handleKey.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('keydown', _this._handleKey);

        _this._handleInputClick = _this._handleInputClick.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('click', _this._handleInputClick);

        _this._handleFocus = _this._handleFocus.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('focus', _this._handleFocus);

        _this._list.addEventListener('keydown', _this._handleKey);

        _this._handleWheel = _this._handleWheel.bind(_assertThisInitialized(_this));

        _this._list.addEventListener('wheel', _this._handleWheel);

        L.DomEvent.disableClickPropagation(_this._list).disableScrollPropagation(_this._list); // this._list.addEventListener('mousewheel', this._handleWheel.bind(this));
        // this._list.addEventListener('MozMousePixelScroll', this._handleWheel.bind(this));       

        _this._input.parentElement.appendChild(_this._list);

        _this._handleChange = _this._handleChange.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('input', _this._handleChange);

        return _this;
      }

      _createClass(ResultView, [{
        key: "_handleInputClick",
        value: function _handleInputClick(e) {
          e.stopPropagation();
        }
      }, {
        key: "_handleFocus",
        value: function _handleFocus(e) {
          if (this.index >= 0) {
            var el = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

            L.DomUtil.removeClass(el, 'leaflet-ext-search-list-selected');
          }

          this.index = -1;
          this._item = null;
        }
      }, {
        key: "_handleChange",
        value: function _handleChange(e) {
          this._inputText = this._input.value;
        }
      }, {
        key: "_handleWheel",
        value: function _handleWheel(e) {
          e.stopPropagation();
        }
      }, {
        key: "_handleKey",
        value: function _handleKey(e) {
          if (this.listVisible()) {
            switch (e.keyCode) {
              // ArroLeft / ArrowRight
              case 37:
              case 39:
                e.stopPropagation();
                break;
              // ArrowDown

              case 40:
                e.preventDefault();
                e.stopPropagation();

                if (this.allowNavigation) {
                  if (this.index < 0) {
                    this.index = 0;
                  } else if (0 <= this.index && this.index < this.count - 1) {
                    var _el = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                    L.DomUtil.removeClass(_el, 'leaflet-ext-search-list-selected');
                    ++this.index;
                  } else {
                    var _el2 = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                    L.DomUtil.removeClass(_el2, 'leaflet-ext-search-list-selected');
                    this.index = this.count - 1;
                  }

                  var el = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                  L.DomUtil.addClass(el, 'leaflet-ext-search-list-selected');
                  this.selectItem(this.index);
                  el.focus();
                }

                break;
              // ArrowUp

              case 38:
                e.preventDefault();
                e.stopPropagation();

                if (this.allowNavigation) {
                  if (this.index > 0) {
                    var _el3 = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));

                    L.DomUtil.removeClass(_el3, 'leaflet-ext-search-list-selected');
                    --this.index;
                    _el3 = this._list.querySelector("[tabindex=\"".concat(this.index, "\"]"));
                    L.DomUtil.addClass(_el3, 'leaflet-ext-search-list-selected');
                    this.selectItem(this.index);

                    _el3.focus();
                  } else if (this.index === 0) {
                    this._input.focus();

                    this._input.value = this._inputText;
                  }
                }

                break;
              // Enter

              case 13:
                if (this.index < 0 && this._input.value) {
                  var text = this._input.value;

                  this._input.focus();

                  this._input.setSelectionRange(text.length, text.length);

                  this.hide();
                  var event = document.createEvent('Event');
                  event.initEvent('suggestions:confirm', false, false);
                  event.detail = text;
                  this.dispatchEvent(event);
                } else {
                  this.complete(this.index);
                }

                break;
              // Escape

              case 27:
                if (this.index < 0) {
                  this.hide();
                }

                this._input.focus();

                this._input.value = this._inputText;
                break;

              default:
                break;
            }
          } else {
            if (e.keyCode === 13 && this._input.value) {
              var _text = this._input.value;

              this._input.setSelectionRange(_text.length, _text.length);

              var _event = document.createEvent('Event');

              _event.initEvent('suggestions:confirm', false, false);

              _event.detail = _text;
              this.dispatchEvent(_event);
            } else if (e.keyCode === 27) {
              this._input.value = '';
              this.index = -1;

              this._input.focus();
            }
          }
        }
      }, {
        key: "listVisible",
        value: function listVisible() {
          return this.count > 0 && this._list.style.display !== 'none';
        }
      }, {
        key: "selectItem",
        value: function selectItem(i) {
          this._item = this._items[i];
          var text = this._item.name;

          if (this._replaceInput) {
            this._input.value = text;

            this._input.setSelectionRange(text.length, text.length);
          }
        }
      }, {
        key: "_handleClick",
        value: function _handleClick(i, e) {
          e.preventDefault();
          this.complete(i);
        }
      }, {
        key: "complete",
        value: function complete(i) {
          var item = i >= 0 ? this._items[i] : this._item ? this._item : null;

          if (item) {
            this._item = item;
            this.index = -1;
            var text = item.name;

            if (this._replaceInput) {
              this._input.value = text;

              this._input.setSelectionRange(text.length, text.length);
            }

            this._input.focus();

            this.hide();
            var event = document.createEvent('Event');
            event.initEvent('suggestions:select', false, false);
            event.detail = item;
            this.dispatchEvent(event);
          }
        }
      }, {
        key: "show",
        value: function show(items, highlight) {
          if (items.length) {
            this._item = null;
            this.index = -1;
            this._items = items;
            var html = '<ul>' + this._items.filter(function (x) {
              return x.name && x.name.length;
            }).map(function (x, i) {
              var name = "<span class=\"leaflet-ext-search-list-item-normal\">".concat(x.name, "</span>");

              if (highlight && highlight.length) {
                var start = x.name.toLowerCase().indexOf(highlight.toLowerCase());

                if (start != -1) {
                  var head = x.name.substr(0, start);

                  if (head.length) {
                    head = "<span class=\"leaflet-ext-search-list-item-normal\">".concat(head, "</span>");
                  }

                  var tail = x.name.substr(start + highlight.length);

                  if (tail.length) {
                    tail = "<span class=\"leaflet-ext-search-list-item-normal\">".concat(tail, "</span>");
                  }

                  name = "".concat(head, "<span class=\"leaflet-ext-search-list-item-highlight\">").concat(highlight, "</span>").concat(tail);
                }
              }

              return "<li tabindex=".concat(i, ">").concat(name, "</li>");
            }, []).join('') + '</ul>';
            this._list.innerHTML = html;

            var elements = this._list.querySelectorAll('li');

            for (var i = 0; i < elements.length; ++i) {
              elements[i].addEventListener('click', this._handleClick.bind(this, i));
            }

            this.count = elements.length;
            this._list.style.display = 'block';
          }
        }
      }, {
        key: "hide",
        value: function hide() {
          this._list.style.display = 'none';
        }
      }]);

      return ResultView;
    }(scanexEventTarget_cjs);

    function chain(tasks, state) {
      return tasks.reduce(function (prev, next) {
        return prev.then(next);
      }, new Promise(function (resolve, reject) {
        return resolve(state);
      }));
    }

    var SearchWidget =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(SearchWidget, _EventTarget);

      function SearchWidget(container, _ref) {
        var _this;

        var placeHolder = _ref.placeHolder,
            providers = _ref.providers,
            _ref$suggestionTimeou = _ref.suggestionTimeout,
            suggestionTimeout = _ref$suggestionTimeou === void 0 ? 1000 : _ref$suggestionTimeou,
            _ref$suggestionLimit = _ref.suggestionLimit,
            suggestionLimit = _ref$suggestionLimit === void 0 ? 10 : _ref$suggestionLimit,
            _ref$fuzzySearchLimit = _ref.fuzzySearchLimit,
            fuzzySearchLimit = _ref$fuzzySearchLimit === void 0 ? 1000 : _ref$fuzzySearchLimit,
            _ref$retrieveManyOnEn = _ref.retrieveManyOnEnter,
            retrieveManyOnEnter = _ref$retrieveManyOnEn === void 0 ? false : _ref$retrieveManyOnEn,
            _ref$replaceInputOnEn = _ref.replaceInputOnEnter,
            replaceInputOnEnter = _ref$replaceInputOnEn === void 0 ? false : _ref$replaceInputOnEn;

        _classCallCheck(this, SearchWidget);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(SearchWidget).call(this));
        _this._container = container;
        _this._allowSuggestion = true;
        _this._providers = providers;
        _this._suggestionTimeout = suggestionTimeout;
        _this._suggestionLimit = suggestionLimit;
        _this._fuzzySearchLimit = fuzzySearchLimit;
        _this._retrieveManyOnEnter = retrieveManyOnEnter;
        _this._replaceInputOnEnter = replaceInputOnEnter;

        _this._container.classList.add('leaflet-ext-search');

        _this._container.innerHTML = "<input type=\"text\" value=\"\" placeholder=\"".concat(placeHolder, "\" /><span class=\"leaflet-ext-search-button\"></span>");
        _this._input = _this._container.querySelector('input');
        _this._handleChange = _this._handleChange.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('input', _this._handleChange);

        _this._handleMouseMove = _this._handleMouseMove.bind(_assertThisInitialized(_this));

        _this._input.addEventListener('mousemove', _this._handleMouseMove);

        _this._input.addEventListener('dragstart', _this._handleMouseMove);

        _this._input.addEventListener('drag', _this._handleMouseMove);

        _this._handleSearch = _this._handleSearch.bind(_assertThisInitialized(_this));
        _this._button = _this._container.querySelector('.leaflet-ext-search-button');

        _this._button.addEventListener('click', _this._handleSearch);

        _this.results = new ResultView({
          input: _this._input,
          replaceInput: _this._replaceInputOnEnter
        });
        _this._search = _this._search.bind(_assertThisInitialized(_this));
        _this._selectItem = _this._selectItem.bind(_assertThisInitialized(_this));

        _this.results.addEventListener('suggestions:confirm', function (e) {
          var event = document.createEvent('Event');
          event.initEvent('suggestions:confirm', false, false);
          event.detail = e.detail;

          _this.dispatchEvent(event);

          _this._search(e);
        });

        _this.results.addEventListener('suggestions:select', _this._selectItem); // map.on ('click', this.results.hide.bind(this.results));
        // map.on ('dragstart', this.results.hide.bind(this.results));


        return _this;
      }

      _createClass(SearchWidget, [{
        key: "_suggest",
        value: function _suggest(text) {
          var _this2 = this;

          this.results.allowNavigation = false;

          var tasks = this._providers.filter(function (provider) {
            return provider.showSuggestion;
          }).map(function (provider) {
            return function (state) {
              return new Promise(function (resolve) {
                if (state.completed) {
                  resolve(state);
                } else {
                  provider.find(text, _this2._suggestionLimit, false, false).then(function (response) {
                    state.completed = response.length > 0;
                    state.response = state.response.concat(response);
                    resolve(state);
                  })["catch"](function (e) {
                    return console.log(e);
                  });
                }
              });
            };
          });

          chain(tasks, {
            completed: false,
            response: []
          }).then(function (state) {
            _this2.results.show(state.response, text.trim());

            _this2.results.allowNavigation = true;
          });
        }
      }, {
        key: "_handleChange",
        value: function _handleChange(e) {
          var _this3 = this;

          if (this._input.value.length) {
            if (this._allowSuggestion) {
              this._allowSuggestion = false;
              this._timer = setTimeout(function () {
                clearTimeout(_this3._timer);
                _this3._allowSuggestion = true;
                var text = _this3._input.value;

                _this3._suggest(text);
              }, this._suggestionTimeout);
            }
          } else {
            this.results.hide();
          }
        }
      }, {
        key: "_handleMouseMove",
        value: function _handleMouseMove(e) {
          e.stopPropagation();
          e.preventDefault();
        }
      }, {
        key: "_search",
        value: function _search(e) {
          var _this4 = this;

          var text = e.detail;

          var tasks = this._providers.filter(function (provider) {
            return provider.showOnEnter;
          }).map(function (provider) {
            return function (state) {
              return new Promise(function (resolve) {
                if (state.completed) {
                  resolve(state);
                } else {
                  provider.find(text, _this4._retrieveManyOnEnter ? _this4._fuzzySearchLimit : 1, true, true).then(function (response) {
                    state.completed = response.length > 0;
                    state.response = state.response.concat(response);
                    resolve(state);
                  })["catch"](function (e) {
                    console.log(e);
                    resolve(state);
                  });
                }
              });
            };
          });

          chain(tasks, {
            completed: false,
            response: []
          }).then(function (state) {// if(state.response.length > 0 && !this._retrieveManyOnEnter){
            //     let item = state.response[0];
            //     item.provider
            //     .fetch(item.properties)
            //     .then(response => {});                    
            // }
          });
          this.results && this.results.hide();
        }
      }, {
        key: "_selectItem",
        value: function _selectItem(e) {
          var item = e.detail;
          return item.provider.fetch(item.properties);
        }
      }, {
        key: "_handleSearch",
        value: function _handleSearch(e) {
          e.stopPropagation();

          this._search({
            detail: this._input.value
          });
        }
      }, {
        key: "setText",
        value: function setText(text) {
          this._input.value = text;
        }
      }, {
        key: "setPlaceHolder",
        value: function setPlaceHolder(value) {
          this._input.placeholder = value;
        }
      }]);

      return SearchWidget;
    }(scanexEventTarget_cjs);

    var SearchControl = L.Control.extend({
      includes: L.Evented ? L.Evented.prototype : L.Mixin.Events,
      initialize: function initialize(options) {
        L.setOptions(this, options);
        this._allowSuggestion = true;
        this.options.suggestionTimeout = this.options.suggestionTimeout || 1000;
        this.options.suggestionLimit = this.options.suggestionLimit || 10;
      },
      onAdd: function onAdd(map) {
        this._container = L.DomUtil.create('div', 'leaflet-ext-search');
        this._widget = new SearchWidget(this._container, this.options);
        map.on('click', this._widget.results.hide.bind(this._widget.results));
        map.on('dragstart', this._widget.results.hide.bind(this._widget.results));
        return this._container;
      },
      addTo: function addTo(map) {
        L.Control.prototype.addTo.call(this, map);

        if (this.options.addBefore) {
          this.addBefore(this.options.addBefore);
        }

        return this;
      },
      addBefore: function addBefore(id) {
        var parentNode = this._parent && this._parent._container;

        if (!parentNode) {
          parentNode = this._map && this._map._controlCorners[this.getPosition()];
        }

        if (!parentNode) {
          this.options.addBefore = id;
        } else {
          for (var i = 0, len = parentNode.childNodes.length; i < len; i++) {
            var it = parentNode.childNodes[i];

            if (id === it._id) {
              parentNode.insertBefore(this._container, it);
              break;
            }
          }
        }

        return this;
      },
      setText: function setText(text) {
        this._widget.setText(text);
      },
      setPlaceHolder: function setPlaceHolder(value) {
        this._widget.setPlaceHolder(value);
      }
    });

    var OsmDataProvider =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(OsmDataProvider, _EventTarget);

      function OsmDataProvider(_ref) {
        var _this;

        var serverBase = _ref.serverBase;

        _classCallCheck(this, OsmDataProvider);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(OsmDataProvider).call(this));
        _this._serverBase = serverBase;
        _this.showSuggestion = true;
        _this.showOnSelect = true;
        _this.showOnEnter = true;
        _this.find = _this.find.bind(_assertThisInitialized(_this));
        _this.fetch = _this.fetch.bind(_assertThisInitialized(_this));
        _this._convertGeometry = _this._convertGeometry.bind(_assertThisInitialized(_this));
        _this._key = window.KOSMOSNIMKI_SESSION_KEY == null || window.KOSMOSNIMKI_SESSION_KEY == 'INVALID' ? '' : "&key=".concat(window.KOSMOSNIMKI_SESSION_KEY);
        return _this;
      }

      _createClass(OsmDataProvider, [{
        key: "_convertGeometry",
        value: function _convertGeometry(geometry) {
          switch (geometry.type.toUpperCase()) {
            case 'POINT':
              geometry.type = 'Point';
              break;

            case 'POLYGON':
              geometry.type = 'Polygon';
              break;

            case 'MULTIPOLYGON':
              geometry.type = 'MultiPolygon';
              break;

            case 'LINESTRING':
            case 'POLYLINE':
              geometry.type = 'LineString';
              break;

            case 'MULTILINESTRING':
              geometry.type = 'MultiLineString';
              break;

            default:
              throw 'Unknown WKT type';
          }

          return geometry;
        }
      }, {
        key: "fetch",
        value: function (_fetch) {
          function fetch(_x) {
            return _fetch.apply(this, arguments);
          }

          fetch.toString = function () {
            return _fetch.toString();
          };

          return fetch;
        }(function (obj) {
          var _this2 = this;

          var query = "WrapStyle=None&RequestType=ID&ID=".concat(obj.ObjCode, "&TypeCode=").concat(obj.TypeCode, "&UseOSM=1");
          var req = new Request("".concat(this._serverBase, "/SearchObject/SearchAddress.ashx?").concat(query).concat(this._key));
          var headers = new Headers();
          headers.append('Content-Type', 'application/json');
          var init = {
            method: 'GET',
            mode: 'cors',
            credentials: 'include',
            cache: 'default'
          };
          return new Promise(function (resolve, reject) {
            fetch(req, init).then(function (response) {
              return response.json();
            }).then(function (json) {
              if (json.Status === 'ok') {
                var rs = json.Result.reduce(function (a, x) {
                  return a.concat(x.SearchResult);
                }, []).map(function (x) {
                  var g = _this2._convertGeometry(x.Geometry);

                  var props = Object.keys(x).filter(function (k) {
                    return k !== 'Geometry';
                  }).reduce(function (a, k) {
                    a[k] = x[k];
                    return a;
                  }, {});
                  return {
                    feature: {
                      type: 'Feature',
                      geometry: g,
                      properties: props
                    },
                    provider: _this2,
                    query: obj
                  };
                });
                var event = document.createEvent('Event');
                event.initEvent('fetch', false, false);
                event.detail = rs;

                _this2.dispatchEvent(event);

                resolve(rs);
              } else {
                reject(json);
              }
            })["catch"](function (response) {
              return reject(response);
            });
          });
        })
      }, {
        key: "find",
        value: function find(value, limit, strong, retrieveGeometry) {
          var _this3 = this;

          return new Promise(function (resolve, reject) {
            if (value || value.trim()) {
              var _strong = Boolean(strong) ? 1 : 0;

              var _withoutGeometry = Boolean(retrieveGeometry) ? 0 : 1;

              var query = "WrapStyle=None&RequestType=SearchObject&IsStrongSearch=".concat(_strong, "&WithoutGeometry=").concat(_withoutGeometry, "&UseOSM=1&Limit=").concat(limit, "&SearchString=").concat(encodeURIComponent(value));
              var req = new Request("".concat(_this3._serverBase, "/SearchObject/SearchAddress.ashx?").concat(query).concat(_this3._key));
              var headers = new Headers();
              headers.append('Content-Type', 'application/json');
              var init = {
                method: 'GET',
                mode: 'cors',
                credentials: 'include',
                cache: 'default'
              };
              fetch(req, init).then(function (response) {
                return response.json();
              }).then(function (json) {
                if (json.Status === 'ok') {
                  var rs = json.Result.reduce(function (a, x) {
                    return a.concat(x.SearchResult);
                  }, []).map(function (x) {
                    if (retrieveGeometry && x.Geometry) {
                      var g = _this3._convertGeometry(x.Geometry);

                      var props = Object.keys(x).filter(function (k) {
                        return k !== 'Geometry';
                      }).reduce(function (a, k) {
                        a[k] = x[k];
                        return a;
                      }, {});
                      return {
                        name: x.ObjNameShort,
                        feature: {
                          type: 'Feature',
                          geometry: g,
                          properties: props
                        },
                        properties: props,
                        provider: _this3,
                        query: value
                      };
                    } else {
                      return {
                        name: x.ObjNameShort,
                        properties: x,
                        provider: _this3,
                        query: value
                      };
                    }
                  });

                  if (strong && retrieveGeometry) {
                    var event = document.createEvent('Event');
                    event.initEvent('fetch', false, false);
                    event.detail = rs;

                    _this3.dispatchEvent(event);
                  }

                  resolve(rs);
                } else {
                  reject(json);
                }
              })["catch"](function (response) {
                return reject(response);
              });
            } else {
              reject('Empty string');
            }
          });
        }
      }]);

      return OsmDataProvider;
    }(scanexEventTarget_cjs);

    var CoordinatesDataProvider =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(CoordinatesDataProvider, _EventTarget);

      function CoordinatesDataProvider() {
        var _this;

        _classCallCheck(this, CoordinatesDataProvider);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(CoordinatesDataProvider).call(this));
        _this.showSuggestion = false;
        _this.showOnSelect = false;
        _this.showOnEnter = true;
        _this.fetch = _this.fetch.bind(_assertThisInitialized(_this));
        _this.find = _this.find.bind(_assertThisInitialized(_this));
        _this.rxF = new RegExp('^\\s*\\-?(\\d+(\\.\\d+)?)(\\s+[N|S])?(,\\s*|\\s+)\\-?(\\d+(\\.\\d+)?)(\\s+[E|W])?');
        _this.rxD = new RegExp("^\\s*(\\d{1,2})[\\s|\\u00b0](\\d{1,2})[\\s|\\u0027](\\d{1,2}\\.\\d+)\\u0022?(\\s+[N|S])?,?\\s+(\\d{1,2})[\\s|\\u00b0](\\d{1,2})[\\s|\\u0027](\\d{1,2}\\.\\d+)\\u0022?(\\s+[E|W])?");
        return _this;
      }

      _createClass(CoordinatesDataProvider, [{
        key: "_parseCoordinates",
        value: function _parseCoordinates(value) {
          var m = this.rxD.exec(value);

          if (Array.isArray(m) && m.length === 9) {
            return this._parseDegrees([m[1], m[2], m[3], m[5], m[6], m[7]].map(function (x) {
              return parseFloat(x);
            }));
          }

          m = this.rxF.exec(value);

          if (Array.isArray(m) && m.length === 8) {
            return {
              type: 'Point',
              coordinates: [parseFloat(m[5]), parseFloat(m[1])]
            };
          }

          return null;
        }
      }, {
        key: "_parseDegrees",
        value: function _parseDegrees(_ref) {
          var _ref2 = _slicedToArray(_ref, 6),
              latDeg = _ref2[0],
              latMin = _ref2[1],
              latSec = _ref2[2],
              lngDeg = _ref2[3],
              lngMin = _ref2[4],
              lngSec = _ref2[5];

          return {
            type: 'Point',
            coordinates: [lngDeg + lngMin / 60 + lngSec / 3600, latDeg + latMin / 60 + latSec / 3600]
          };
        }
      }, {
        key: "fetch",
        value: function fetch(value) {
          return new Promise(function (resolve) {
            return resolve([]);
          });
        }
      }, {
        key: "find",
        value: function find(value, limit, strong, retrieveGeometry) {
          var _this2 = this;

          var g = this._parseCoordinates(value);

          return new Promise(function (resolve) {
            var result = {
              feature: {
                type: 'Feature',
                geometry: g,
                properties: {}
              },
              provider: _this2,
              query: value
            };

            if (g) {
              var event = document.createEvent('Event');
              event.initEvent('fetch', false, false);
              event.detail = result;

              _this2.dispatchEvent(event);
            }

            resolve(g ? [result] : []);
          });
        }
      }]);

      return CoordinatesDataProvider;
    }(scanexEventTarget_cjs);

    var CadastreDataProvider =
    /*#__PURE__*/
    function (_EventTarget) {
      _inherits(CadastreDataProvider, _EventTarget);

      function CadastreDataProvider(_ref) {
        var _this;

        var serverBase = _ref.serverBase,
            tolerance = _ref.tolerance;

        _classCallCheck(this, CadastreDataProvider);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(CadastreDataProvider).call(this));
        _this._serverBase = serverBase;
        _this._tolerance = tolerance;
        _this.showSuggestion = true;
        _this.showOnSelect = false;
        _this.showOnEnter = true;
        _this._cadastreLayers = [{
          id: 1,
          title: 'Участок',
          reg: /^\d\d:\d+:\d+:\d+$/
        }, {
          id: 2,
          title: 'Квартал',
          reg: /^\d\d:\d+:\d+$/
        }, {
          id: 3,
          title: 'Район',
          reg: /^\d\d:\d+$/
        }, {
          id: 4,
          title: 'Округ',
          reg: /^\d\d$/
        }, {
          id: 5,
          title: 'ОКС',
          reg: /^\d\d:\d+:\d+:\d+:\d+$/
        }, {
          id: 10,
          title: 'ЗОУИТ',
          reg: /^\d+\.\d+\.\d+/ // ,
          // {id: 7, title: 'Границы', 	reg: /^\w+$/},
          // {id: 6, title: 'Тер.зоны', 	reg: /^\w+$/},
          // {id: 12, title: 'Лес', 		reg: /^\w+$/},
          // {id: 13, title: 'Красные линии', 		reg: /^\w+$/},
          // {id: 15, title: 'СРЗУ', 	reg: /^\w+$/},
          // {id: 16, title: 'ОЭЗ', 		reg: /^\w+$/},
          // {id: 9, title: 'ГОК', 		reg: /^\w+$/},
          // {id: 10, title: 'ЗОУИТ', 	reg: /^\w+$/}
          // /[^\d\:]/g,
          // /\d\d:\d+$/,
          // /\d\d:\d+:\d+$/,
          // /\d\d:\d+:\d+:\d+$/

        }];
        return _this;
      }

      _createClass(CadastreDataProvider, [{
        key: "getCadastreLayer",
        value: function getCadastreLayer(str, type) {
          str = str.trim();

          for (var i = 0, len = this._cadastreLayers.length; i < len; i++) {
            var it = this._cadastreLayers[i];

            if (it.id === type) {
              return it;
            }

            if (it.reg.exec(str)) {
              return it;
            }
          }

          return this._cadastreLayers[0];
        }
      }, {
        key: "find",
        value: function find(value, limit, strong, retrieveGeometry) {
          var _this2 = this;

          var cadastreLayer = this.getCadastreLayer(value);
          return new Promise(function (resolve) {
            // let req = new Request(`${this._serverBase}/typeahead?limit=${limit}&skip=0&text=${value}&type=${cadastreLayer.id}`);
            var req = new Request("".concat(_this2._serverBase, "/features/").concat(cadastreLayer.id, "?text=").concat(value, "&tolerance=").concat(_this2._tolerance, "&limit=").concat(limit));
            var headers = new Headers();
            headers.append('Content-Type', 'application/json');
            var init = {
              method: 'GET',
              mode: 'cors',
              cache: 'default'
            };
            fetch(req, init).then(function (response) {
              return response.json();
            }).then(function (json) {
              // if(json.status === 200){
              var rs = json.features.map(function (x) {
                return {
                  name: x.attrs.name || x.attrs.cn || x.attrs.id,
                  properties: x,
                  provider: _this2,
                  query: value
                };
              });
              resolve(rs); // }
              // else {
              // resolve(json);
              // }                                       
            });
          });
        }
      }, {
        key: "fetch",
        value: function (_fetch) {
          function fetch(_x) {
            return _fetch.apply(this, arguments);
          }

          fetch.toString = function () {
            return _fetch.toString();
          };

          return fetch;
        }(function (obj) {
          var _this3 = this;

          var text = obj.attrs.name || obj.attrs.cn || obj.attrs.id;
          var cadastreLayer = this.getCadastreLayer(text, obj.type);
          return new Promise(function (resolve) {
            if (cadastreLayer) {
              // let req = new Request(`${this._serverBase}/features/${cadastreLayer.id}?tolerance=${this._tolerance}&limit=1&text=${obj.value}`);
              var req = new Request("".concat(_this3._serverBase, "/features/").concat(cadastreLayer.id, "?tolerance=").concat(_this3._tolerance, "&limit=1&text=").concat(text));
              var headers = new Headers();
              headers.append('Content-Type', 'application/json');
              var init = {
                method: 'GET',
                mode: 'cors',
                cache: 'default'
              };
              fetch(req, init).then(function (response) {
                return response.json();
              }).then(function (json) {
                if (json.status === 200) {
                  var event = document.createEvent('Event');
                  event.initEvent('fetch', false, false);
                  event.detail = json;

                  _this3.dispatchEvent(event);

                  var rs = json.features.map(function (x) {
                    return {
                      name: x.attrs.name || x.attrs.cn || x.attrs.id,
                      properties: x,
                      provider: _this3,
                      query: obj
                    };
                  });
                  resolve(rs);
                } else {
                  resolve(json);
                }
              });
            } else {
              resolve([]);
            }
          });
        })
      }]);

      return CadastreDataProvider;
    }(scanexEventTarget_cjs);

    exports.CadastreDataProvider = CadastreDataProvider;
    exports.CoordinatesDataProvider = CoordinatesDataProvider;
    exports.OsmDataProvider = OsmDataProvider;
    exports.SearchControl = SearchControl;
    exports.SearchWidget = SearchWidget;
    //# sourceMappingURL=main.js.map
    });

    unwrapExports(main);
    var main_1 = main.CadastreDataProvider;
    var main_2 = main.CoordinatesDataProvider;
    var main_3 = main.OsmDataProvider;
    var main_4 = main.SearchControl;
    var main_5 = main.SearchWidget;

    nsGmx$1.OsmDataProvider = main_3;

    nsGmx$1.searchProviders = {};

    nsGmx$1.searchProviders.Osm2DataProvider = function(options){
        nsGmx$1.OsmDataProvider.call(this, options);
    };

    nsGmx$1.searchProviders.Osm2DataProvider.prototype = Object.create(nsGmx$1.OsmDataProvider.prototype);
    nsGmx$1.searchProviders.Osm2DataProvider.prototype.constructor = nsGmx$1.Osm2DataProvider;

    nsGmx$1.searchProviders.Osm2DataProvider.prototype.fetch = function (obj) {
        var _this = this;

        var query = 'WrapStyle=None&RequestType=ID&ID=' + obj.ObjCode + '&TypeCode=' + obj.TypeCode + '&UseOSM=1';
        var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
        var headers = new Headers();
        headers.append('Content-Type', 'application/json');
        var init = {
            method: 'GET',
            mode: 'cors',
            credentials: 'include',
            cache: 'default'
        };

        return new Promise(function (resolve, reject) {
            fetch(req, init).then(function (response) {
                return response.json();
            }).then(function (json) {
                if (json.Status === 'ok') {
                    if (typeof _this._onFetch === 'function') {
                        _this._onFetch(json.Result);
                    }
                    var event = document.createEvent('Event');
                    event.initEvent('fetch', false, false);
                    event.detail = json.Result;
                    _this.dispatchEvent(event);
                    resolve(json.Result);
                } else {
                    reject(json.Result);
                }
            }).catch(function (response) {
                return reject(response);
            });
        });
    };

    nsGmx$1.searchProviders.Osm2DataProvider.prototype.find = function (value, limit, strong, retrieveGeometry) {
        var result;
        var _this2 = this;
        _this2.searchString = value;
        var _strong = Boolean(strong) ? 1 : 0;
        var _withoutGeometry = Boolean(retrieveGeometry) ? 0 : 1;
        var query = 'WrapStyle=None&RequestType=SearchObject&IsStrongSearch=' + _strong + '&WithoutGeometry=' + _withoutGeometry + '&UseOSM=1&Limit=' + limit + '&SearchString=' + encodeURIComponent(value);
        var req = new Request(this._serverBase + '/SearchObject/SearchAddress.ashx?' + query + this._key);
        var headers = new Headers();
        headers.append('Content-Type', 'application/json');
        var init = {
            method: 'GET',
            mode: 'cors',
            credentials: 'include',
            cache: 'default'
        };
        return new Promise(function (resolve, reject) {
            var initPromise;

            if (!window.useInternalSearch) {
                initPromise = fetch(req, init).then(function (response) {
                    return response.json();
                });
            } else {
                initPromise = Promise.resolve({
                    Status: 'ok',
                    Result: []
                });
            }

            initPromise.then(function (json) {
                if (json.Status === 'ok') {
                    json.Result.searchString = _this2.searchString;
                    result = json;
                    return json;
                } else {
                    reject(json.Result);
                }
            }).then(function (json1) {
                return window.searchLogic && window.searchLogic.layersSearch(json1);
            }).then(function (json2) {
                var arr = [];

                for (var i = 0; i < result.Result.length; i++) {
                    arr.push(result.Result[i]);
                }

                for (var i = 0; i < json2.length; i++) {
                    if (json2[i] && json2[i].length) {
                        for (var j = 0; j < json2[i].length; j++) {
                            arr.push(json2[i][j]);
                        }
                    }
                }

                arr.searchString = result.Result.searchString;

                return {
                    Status: result.Status,
                    Result: arr
                }
            }).then(function (json3) {
                if (json3.Status === 'ok') {
                    var rs = json3.Result.reduce(function (a, x) {
                        return a.concat(x.SearchResult);
                    }, []).map(function (x) {
                        if (retrieveGeometry && x.Geometry) {
                            var g = _this2._convertGeometry(x.Geometry);
                            var props = Object.keys(x).filter(function (k) {
                                return k !== 'Geometry';
                            }).reduce(function (a, k) {
                                a[k] = x[k];
                                return a;
                            }, {});
                            return {
                                name: x.ObjNameShort,
                                feature: {
                                    type: 'Feature',
                                    geometry: g,
                                    properties: props
                                },
                                properties: props,
                                provider: _this2,
                                query: value
                            };
                        } else {
                            return {
                                name: x.ObjNameShort,
                                properties: x,
                                provider: _this2,
                                query: value
                            };
                        }
                    });
                    if (strong && retrieveGeometry) {
                        var event = document.createEvent('Event');
                        event.initEvent('fetch', false, false);
                        event.detail = json3.Result;
                        _this2.dispatchEvent(event);
                    }
                    resolve(rs);
                } else {
                    reject(json3);
                }
            });
        });
    };

    _translationsHash.addtext("rus", {
    							"loadShape.inputTitle": "Добавить shp-файл (в zip)",
                                "loadShape.loadDone": "Геометрия успешно загружена",
                                "loadShape.loadFail": "Ошибка загрузки геометрии"
    						 });
    						 
    _translationsHash.addtext("eng", {
    							"loadShape.inputTitle": "Add shp-file (zipped)",
                                "loadShape.loadDone": "Successfully loaded",
                                "loadShape.loadFail": "Error loading file"
    						 });

    var drawingObjects = 
    {
    	loadShp: {}
    };

    var queryLoadShp = function()
    {
    	this.builded = false;
    	
    	this.uploader = null;
    };

    queryLoadShp.prototype = new leftMenu$1();

    //Старый вариант для IE9
    //просто удаляет все контролы и создаёт все их заново...
    queryLoadShp.prototype._regenerateControl = function()
    {
        var _this = this;
        $(this.workCanvas).empty();

        var fileInput = _input(null, [['attr', 'type', 'file'], ['attr', 'name', 'file'], ['attr', 'id', 'upload_shapefile']]);
        fileInput.onchange = function()
        {
            if (this.value != "")
                _this.upload();
        };

        //задаём одновременно и enctype и encoding для корректной работы в IE
        this.postForm = _form([fileInput], [['attr', 'method', 'POST'], ['attr', 'encoding', 'multipart/form-data'], ['attr', 'enctype', 'multipart/form-data'], ['attr', 'id', 'upload_shapefile_form']]);

        this.progress = _img(null,[['attr','src','img/progress.gif'],['css','display','none']]);

        this.inputControl = _div([_span([_t(_gtxt("loadShape.inputTitle") + ":")]), this.postForm]);

        this.workCanvas.appendChild(_div([this.inputControl, this.progress], [['css','padding','10px 0px 5px 20px']]));
    };

    queryLoadShp.prototype.load = function()
    {
        if (!this.builded)
        {
            this._regenerateControl();
            this.builded = true;
        }
    };

    queryLoadShp.prototype._showObjectsOnMap = function(objs){
        if (objs.length == 0)
        {
            showErrorMessage(_gtxt("Загруженный shp-файл пуст"), true);
            return;
        }
        var lmap = nsGmx.leafletMap,
            gmxDrawing = lmap.gmxDrawing,
            latLngBounds = L.latLngBounds([]);
        for (var i = 0; i < objs.length; i++) {
            var it = objs[i],
                geoJSON = L.gmxUtil.geometryToGeoJSON(it.geometry),
                b = gmxDrawing.addGeoJSON(geoJSON, {fill: false, properties: it.properties})[0].getBounds();

            latLngBounds.extend(b);
        }
        if (latLngBounds.isValid()) {
            lmap.fitBounds(latLngBounds);
        }
    };

    //files - массив File или WebForms
    queryLoadShp.prototype.loadAndShowFiles = function(files) {
        nsGmx.widgets.notifications.startAction('uploadShp');
        
        var def = $.when.apply($, [].slice.call(files).map(function(file) {
            return nsGmx.Utils.parseShpFile(file);
        }));
        
        def.then(function() {
            this._showObjectsOnMap(_.flatten([].slice.call(arguments)));
            nsGmx.widgets.notifications.stopAction('uploadShp', 'success', _gtxt('loadShape.loadDone'));
        }.bind(this), function() {
            nsGmx.widgets.notifications.stopAction('uploadShp', 'failure', _gtxt('loadShape.loadFail'));
        });
        
        return def;
    };


    //Загружает файлы из поля "file"
    queryLoadShp.prototype.upload = function()
    {
    	hide(this.inputControl);
    	show(this.progress);

        this.loadAndShowFiles([this.postForm]).always(function() {
            this.inputControl.removeChild(this.postForm);
            this._regenerateControl();
        }.bind(this));
    };

    var _queryLoadShp$1 = new queryLoadShp();


    drawingObjects.loadShp.load = function() {
        if ('File' in window) {
            $('<input type="file" multiple>').change(function(e) {
                _queryLoadShp$1.loadAndShowFiles(e.target.files);
            }).click();
        } else { //IE9
            var alreadyLoaded = _queryLoadShp$1.createWorkCanvas(arguments[0] || "shp");

            if (!alreadyLoaded)
                _queryLoadShp$1.load();
        }
    };

    drawingObjects.loadShp.unload = function()
    {
    };

    const _$3 = nsGmx$1.Utils._;

    var wmsProjections = ['EPSG:3395', 'EPSG:4326', 'EPSG:41001'];	// типы проекций

    var getTextContent = function(node) {
        if (typeof node.textContent != 'undefined')
            return node.textContent;

        var data = '';
        for (var i = 0; i < node.childNodes.length; i++)
            data += node.childNodes[i].data;

        return data;
    };

    var getScale = function(z)
    {
        return Math.pow(2, -z)*156543.033928041;
    };

    /** Формирует URL картинки, который можно использовать для получения WMS слоя для данного положения карты
     * @property {String} url - WMS ссылка.
     * @property {object} props - атрибуты.
     * @property {String} props.srs - тип проекции.
     * @property {String} props.version - версия.
     * @property {String} props.name - Идентификатор слоя.
     * @property {object} props.bbox - ограничение по bounds(в географических координатах).
     * @property {object} requestProperties - атрибуты формата результирующего image.
     * @property {String} requestProperties.format - тип (по умолчанию 'image/jpeg').
     * @property {String} requestProperties.transparent - прозрачность подложки ('TRUE'/'FALSE' по умолчанию 'FALSE').
     * @returns {object} - {url: String, bounds: {Extent}}. bounds в географических координатах.
    */
    var getWMSMapURL = function(url, props, requestProperties)
    {
        var CRSParam = {'1.1.1': 'SRS', '1.3.0': 'CRS'};

        requestProperties = requestProperties || {};

        var lmap = nsGmx$1.leafletMap,
            extend = lmap.getBounds();

        var miny = Math.max(extend.getSouth(), -90);
        var maxy = Math.min(extend.getNorth(), 90);
        var minx = Math.max(extend.getWest(), -180);
        var maxx = Math.min(extend.getEast(), 180);

        if (props.bbox)
        {
            minx = Math.max(props.bbox.minx, minx);
            miny = Math.max(props.bbox.miny, miny);
            maxx = Math.min(props.bbox.maxx, maxx);
            maxy = Math.min(props.bbox.maxy, maxy);

            if (minx >= maxx || miny >= maxy)
                return;
        }

        var mercMin = L.Projection.Mercator.project({lat: miny, lng: minx}),
            mercMax = L.Projection.Mercator.project({lat: maxy, lng: maxx});

        var scale = getScale(lmap.getZoom());
        var w = Math.round((mercMax.x - mercMin.x)/scale);
        var h = Math.round((mercMax.y - mercMin.y)/scale);

        var isMerc = !(props.srs == wmsProjections[1]);

        var st = url;
        var format = requestProperties.format || 'image/jpeg';
        var transparentParam = requestProperties.transparent ? 'TRUE' : 'FALSE';
        var version = props.version || '1.1.1';
        var isV130 = version === '1.3.0';

        //st = st.replace(/Service=WMS[\&]*/i, '');
        //st = st.replace(/\&$/, '');

        st += (st.indexOf('?') == -1 ? '?':'&') + 'request=GetMap&Service=WMS';
        st += "&layers=" + encodeURIComponent(props.name) +
            "&VERSION=" + encodeURIComponent(version) +
            "&" + CRSParam[version] + "=" + encodeURIComponent(props.srs) +
            "&styles=" +
            "&width=" + w +
            "&height=" + h +
            "&bbox=" + (isMerc ? mercMin.x : isV130 ? miny : minx) +
                 "," + (isMerc ? mercMin.y : isV130 ? minx : miny) +
                 "," + (isMerc ? mercMax.x : isV130 ? maxy : maxx) +
                 "," + (isMerc ? mercMax.y : isV130 ? maxx : maxy);

        if (url.indexOf('format=') == -1) st += "&format=" + encodeURIComponent(format);
        if (url.indexOf('transparent=') == -1) st += "&transparent=" + encodeURIComponent(transparentParam);

        return {url: st, bounds: {minX: minx, maxX: maxx, minY: miny, maxY: maxy}};
    };

    /**
     * Возвращает описание WMS-слоёв от XML, которую вернул сервер на запрос GetCapabilities
     * @returns {Array} - массив объектов с описанием слоёв
    */
    var parseWMSCapabilities = function(response)
    {
        var supportedVersions = {'1.1.1': true, '1.3.0': true};
        var SRSTagName = {'1.1.1': 'SRS', '1.3.0': 'CRS'};
        var BBOXTagName = {'1.1.1': 'LatLonBoundingBox', '1.3.0': 'EX_GeographicBoundingBox'};
        var serviceLayers = [],
            strResp = response.replace(/[\t\n\r]/g, ' '),
            strResp = strResp.replace(/\s+/g, ' '),
            xml = parseXML(response),
            mainTag = xml.getElementsByTagName('WMS_Capabilities')[0] || xml.getElementsByTagName('WMT_MS_Capabilities')[0],
            version = mainTag.getAttribute('version'),
            layersXML = xml.getElementsByTagName('Layer');

        if (!(version in supportedVersions)) {
            return [];
        }

        for (var i = 0; i < layersXML.length; i++)
        {
            var layer = {version: version},
                name = layersXML[i].getElementsByTagName('Name'),
                title = layersXML[i].getElementsByTagName('Title'),
                bbox = layersXML[i].getElementsByTagName(BBOXTagName[version]),
                srs = layersXML[i].getElementsByTagName(SRSTagName[version]);

            if (srs.length)
            {
                layer.srs = null;
                var supportedSrs = {};
                for (var si = 0; si < srs.length; si++)
                {
                    var srsName = strip(getTextContent(srs[si]));
                    supportedSrs[srsName] = true;
                }

                //порядок имеет значение!
                for (var p = 0; p < wmsProjections.length; p++) {
                    if (wmsProjections[p] in supportedSrs) {
                        layer.srs = wmsProjections[p];
                        break;
                    }
                }
                if (!layer.srs) continue;
            }
            else {
                layer.srs = wmsProjections[0];
            }

            if (name.length)
                layer.name = getTextContent(name[0]);

            if (bbox.length)
            {
                if (version == '1.1.1') {
                    layer.bbox =
                    {
                        minx: Number(bbox[0].getAttribute('minx')),
                        miny: Number(bbox[0].getAttribute('miny')),
                        maxx: Number(bbox[0].getAttribute('maxx')),
                        maxy: Number(bbox[0].getAttribute('maxy'))
                    };
                } else {
                    layer.bbox =
                    {
                        minx: Number(getTextContent(bbox[0].getElementsByTagName('westBoundLongitude')[0])),
                        miny: Number(getTextContent(bbox[0].getElementsByTagName('southBoundLatitude')[0])),
                        maxx: Number(getTextContent(bbox[0].getElementsByTagName('eastBoundLongitude')[0])),
                        maxy: Number(getTextContent(bbox[0].getElementsByTagName('northBoundLatitude')[0]))
                    };
                }
            }

            if (title.length)
                layer.title = getTextContent(title[0]);

            if (layer.name)
                serviceLayers.push(layer);
        }

        return serviceLayers;
    };

    var loadServerData = window.loadServerData =
    {
    	WFS:{},
    	WMS:{}
    };

    /* Порядок координат в WFS зависит от формата SRS (http://geoserver.org/display/GEOSDOC/2.+WFS+-+Web+Feature+Service)
        * EPSG:xxxx: longitude/latitude (supported in WFS 1.1 requests too)
        * http://www.opengis.net/gml/srs/epsg.xml#xxxx: longitude/latitude (supported in WFS 1.1 requests too)
        * urn:x-ogc:def:crs:EPSG:xxxx: latitude/longitude
    */

    var wfsParser = function()
    {
    	this.gmlns = window.location.protocol + '//www.opengis.net/gml';
    	this.kmlns = window.location.protocol + '//earth.google.com/kml/2.0';

    	this.axisOrder = null;
    };

    wfsParser.prototype.elementsNS = function(node,uri,name)
    {
    	var elements=[];

    	if (node.getElementsByTagNameNS)
    		elements = node.getElementsByTagNameNS(uri,name);
    	else
    	{
    		var allNodes = node.getElementsByTagName("*"),
    			potentialNode,
    			fullName;

    		for (var i = 0, len = allNodes.length; i < len ; ++i)
    		{
    			potentialNode = allNodes[i];
    			fullName = (potentialNode.prefix) ? (potentialNode.prefix + ":" + name) : name;
    			if ((name == "*") || (fullName == potentialNode.nodeName))
    			{
    				if( (uri == "*") || (uri == potentialNode.namespaceURI))
    					elements.push(potentialNode);
    			}
    		}
    	}

    	return elements;
    };

    wfsParser.prototype.getChildValue = function(node, def)
    {
    	var value = def || "";
    	if (node)
    	{
    		for(var child = node.firstChild; child; child = child.nextSibling)
    		{
    			switch (child.nodeType)
    			{
    				case 3:
    				case 4: value += child.nodeValue;
    			}
    		}
    	}

    	return value;
    };

    wfsParser.prototype.parse = function(response, srs)
    {
    	var geometries = [],
    		strResp = response.replace(/[\t\n\r]/g, ' '),
    		strResp = strResp.replace(/\s+/g, ' '),
    		xml = parseXML(strResp),
    		parsedNS = strResp.indexOf('<kml') > -1 ? this.kmlns : this.gmlns;

    	this.axisOrder = srs && srs.indexOf("urn:") == 0 ? 'latlong' : 'longlat';

    	var order = ["Polygon","LineString","Point"];

    	for (var i = 0, len = order.length; i < len; ++i)
    	{
    		var type = order[i],
    			nodeList = this.elementsNS(xml.documentElement,parsedNS,type);

    		for (var j = 0; j < nodeList.length; ++j)
    		{
    			geometry = this['parse' + type].apply(this,[nodeList[j]]);

    			if (geometry)
    				geometries.push(geometry);
    		}
    	}

    	return geometries;
    };

    wfsParser.prototype.parsePoint = function(node)
    {
    	var coordString,
    		coords=[],
    		nodeList = this.elementsNS(node,this.gmlns,"pos");

    	if (nodeList.length > 0)
    	{
    		coordString = strip(nodeList[0].firstChild.nodeValue);
    		coords = coordString.split(" ");
    	}
    	if (coords.length == 0)
    	{
    		nodeList = this.elementsNS(node,this.gmlns,"coordinates");

    		if (nodeList.length > 0)
    		{
    			coordString = strip(nodeList[0].firstChild.nodeValue);
    			coords = coordString.split(",");
    		}
    	}
    	if (coords.length == 0)
    	{
    		nodeList = this.elementsNS(node,this.gmlns,"coord");

    		if (nodeList.length > 0)
    		{
    			var xList = this.elementsNS(nodeList[0],this.gmlns,"X"),
    				yList = this.elementsNS(nodeList[0],this.gmlns,"Y");

    			if (xList.length > 0 && yList.length > 0)
    				coords = [xList[0].firstChild.nodeValue, yList[0].firstChild.nodeValue];
    		}
    	}

    	return {feature:{}, geometry:{type: 'Point', coordinates: this.swapCoordinates([Number(coords[0]), Number(coords[1])])}}
    };

    wfsParser.prototype.parseLineString = function(node)
    {
    	var nodeList,
    		coordString,
    		coords = [],
    		points = [],
    		nodeList = this.elementsNS(node,this.gmlns,"posList");

    	if (nodeList.length > 0)
    	{
    		coordString = strip(this.getChildValue(nodeList[0]));
    		coords = coordString.split(" ");

    		for (var i = 0; i < coords.length / 2; ++i)
    		{
    			j = i * 2;
    			x = coords[j];
    			y = coords[j + 1];

    			points.push(this.swapCoordinates([Number(coords[j]), Number(coords[j + 1])]));
    		}
    	}
    	if (coords.length == 0)
    	{
    		nodeList = this.elementsNS(node,this.gmlns,"coordinates");

    		if (nodeList.length > 0)
    		{
    			coordString = strip(this.getChildValue(nodeList[0]));
    			coordString = coordString.replace(/\s*,\s*/g,",");

    			var pointList = coordString.split(" ");

    			for (var i = 0; i < pointList.length; ++i)
    			{
    				coords = pointList[i].split(",");

    				points.push(this.swapCoordinates([Number(coords[0]), Number(coords[1])]));
    			}
    		}
    	}

    	if (points.length != 0)
    	{
    		return {feature:{}, geometry:{type: 'LineString', coordinates: points}}
    	}
    	else
    		return false

    };

    wfsParser.prototype.parsePolygon = function(node)
    {
    	var nodeList = this.elementsNS(node,this.gmlns,"LinearRing"),
    		components = [];

    	if (nodeList.length > 0)
    	{
    		var ring;

    		for (var i = 0; i < nodeList.length; ++i)
    		{
    			ring = this.parseLineString.apply(this,[nodeList[i],true]);

    			if (ring)
    				components.push(ring.geometry.coordinates);
    		}
    	}

    	return {feature:{}, geometry:{type: 'Polygon', coordinates: components}}
    };

    wfsParser.prototype.swapCoordinates = function(arr)
    {
    	if (this.axisOrder == 'latlong')
    		return [arr[1], arr[0]]
    	else
    		return [arr[0], arr[1]];
    };

    var _wfsParser = new wfsParser();

    var jsonParser = function()
    {
    	this.axisOrder = null;
    };

    jsonParser.prototype.parse = function(response, srs)
    {
    	var resp = JSON.parse(response),
    		geometries = [];

    	this.axisOrder = srs && srs.indexOf("urn:") == 0 ? 'latlong' : 'longlat';

    	for (var i = 0; i < resp.features.length; i++)
    	{
    		if (resp.features[i].geometry.type.toLowerCase().indexOf('point') > -1)
    			this.parsePoint(resp.features[i], geometries);
    		else if (resp.features[i].geometry.type.toLowerCase().indexOf('linestring') > -1)
    			this.parseLineString(resp.features[i], geometries);
    		else if (resp.features[i].geometry.type.toLowerCase().indexOf('polygon') > -1)
    			this.parsePolygon(resp.features[i], geometries);
    	}

    	return geometries;
    };

    jsonParser.prototype.parsePoint = function(feature, geometryArr)
    {
    	if (feature.geometry.type.toLowerCase().indexOf('multi') < 0)
    		geometryArr.push({feature: feature, geometry:{type: 'POINT', coordinates: this.swapCoordinates(feature.geometry.coordinates)}});
    	else
    	{
    		for (var i = 0; i < feature.geometry.coordinates.length; i++)
    			geometryArr.push({feature: feature, geometry:{type: 'POINT', coordinates: this.swapCoordinates(feature.geometry.coordinates[i])}});
    	}
    };
    jsonParser.prototype.parseLineString = function(feature, geometryArr)
    {
    	if (feature.geometry.type.toLowerCase().indexOf('multi') < 0)
    	{
    		var newCoords = [];

    		for (var j = 0; j < feature.geometry.coordinates.length; j++)
    			newCoords.push(this.swapCoordinates(feature.geometry.coordinates[j]));

    		geometryArr.push({feature: feature, geometry:{type: 'LINESTRING', coordinates: newCoords}});
    	}
    	else
    	{
    		for (var i = 0; i < feature.geometry.coordinates.length; i++)
    		{
    			var newCoords = [];

    			for (var j = 0; j < feature.geometry.coordinates[i].length; j++)
    				newCoords.push(this.swapCoordinates(feature.geometry.coordinates[i][j]));

    			geometryArr.push({feature: feature, geometry:{type: 'LINESTRING', coordinates: newCoords}});
    		}
    	}
    };
    jsonParser.prototype.parsePolygon = function(feature, geometryArr)
    {
    	if (feature.geometry.type.toLowerCase().indexOf('multi') < 0)
    	{
    		var newCoords = [];

    		for (var k = 0; k < feature.geometry.coordinates.length; j++)
    		{
    			var newCoords2 = [];

    			for (var j = 0; j < feature.geometry.coordinates[k].length; k++)
    				newCoords2.push(this.swapCoordinates(feature.geometry.coordinates[k][j]));

    			newCoords.push(newCoords2);
    		}

    		geometryArr.push({feature: feature, geometry:{type: 'POLYGON', coordinates: newCoords}});
    	}
    	else
    	{
    		for (var i = 0; i < feature.geometry.coordinates.length; i++)
    		{
    			var newCoords = [];

    			for (var k = 0; k < feature.geometry.coordinates[i].length; k++)
    			{
    				var newCoords2 = [];

    				for (var j = 0; j < feature.geometry.coordinates[i][k].length; j++)
    					newCoords2.push(this.swapCoordinates(feature.geometry.coordinates[i][k][j]));

    				newCoords.push(newCoords2);
    			}

    			geometryArr.push({feature: feature, geometry:{type: 'POLYGON', coordinates: newCoords}});
    		}
    	}
    };
    jsonParser.prototype.swapCoordinates = function(arr)
    {
    	if (this.axisOrder == 'latlong')
    		return [arr[1], arr[0]]
    	else
    		return [arr[0], arr[1]];
    };

    var _jsonParser = new jsonParser();

    var queryServerData = function()
    {
    	this.inputField = null;
    	this.parentCanvas = null;

    	this.wfsFormats = {};

    	this.oldBalloon = false;
    	this.oldBalloonIndex = -1;

    	this.proj = ['EPSG:4326','EPSG:3395','EPSG:41001'];

    	this.customParams = undefined;
    };

    queryServerData.prototype = new leftMenu$1();

    /**
        Загружает виджет для добавления/просмотра WMS/WFS слоёв
     @param protocol
     @param parseFunc
     @param drawFunc
     @param customParamsManager {object}- контролер дополнительных параметров. Имеет методы: <br/>
            - init(targetDiv)->void Добавляет контрол к элементу targetDiv<br/>
            - collect()->Object Возвращает выбранные пользователем объекты<br/>
     @param version {string} Версия протокола, которая будет использоваться
    */
    queryServerData.prototype.load = function(protocol, parseFunc, drawFunc, customParamsManager, version)
    {
    	window.convertCoords = function(coordsStr)
    	{
    		var res = [],
    			coordsPairs = strip(coordsStr).replace(/\s+/,' ').split(' ');

    		if (coordsStr.indexOf(',') == -1)
    		{
    			for (var j = 0; j < Math.floor(coordsPairs.length / 2); j++)
    				res.push([Number(coordsPairs[2 * j + 1]), Number(coordsPairs[2 * j])]);
    		}
    		else
    		{
    			for (var j = 0; j < coordsPairs.length; j++)
    			{
    				var parsedCoords = coordsPairs[j].split(',');

    				res.push([Number(parsedCoords[1]), Number(parsedCoords[0])]);
    			}
    		}

    		return res;
    	};

    	window.parseGML = function(response, format, srs)
    	{
    		if (format == 'gml')
    			return _wfsParser.parse(response, srs);
    		else if (format == 'json')
    			return _jsonParser.parse(response, srs);
    		else
    			return [];
    	};

    	var inputField = _input(null, [['dir','className','inputStyle'],['css','width','200px']]);

    	this.parentCanvas = _div(null, [['dir','className','serverDataCanvas']]);

    	var goButton = makeButton(_gtxt("Загрузить")),
    		_this = this;

    	var doGetCapabilities = function()
    	{
    		if (inputField.value != '')
    		{
    			if ( customParamsManager )
    				_this.customParams = customParamsManager.collect();

    			_this.getCapabilities(protocol, strip(inputField.value), parseFunc, drawFunc);

    			inputField.value = '';
    		}
    		else
    			inputError(inputField);
    	};

    	goButton.onclick = doGetCapabilities;

    	$(inputField).on('keydown', function(e)
    	{
    		if (e.keyCode === 13)
    	  	{
    			doGetCapabilities();
    	  		return false;
    	  	}
    	});

    	var canvas = _div([_div([_span([_t(_gtxt("URL сервера"))])], [['css','marginBottom','3px']]),_table([_tbody([_tr([_td([inputField]),_td([goButton])])])], [['css','marginBottom','5px']])],[['css','margin','3px 0px 0px 10px']]);

    	if (customParamsManager)
    	{
    		var customParamsDiv = _div();
    		$(canvas).append(customParamsDiv);
    		_this.customParams = customParamsManager.init(customParamsDiv);
    	}

    	_$3(this.workCanvas, [canvas, this.parentCanvas]);
    };

    queryServerData.prototype.getCapabilities = function(protocol, url, parseFunc, drawFunc, version)
    {
    	var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px']]),
    		_this = this;

    	if (this.parentCanvas.childNodes.length == 0)
    		_$3(this.parentCanvas, [loading]);
    	else
    		this.parentCanvas.insertBefore(loading, this.parentCanvas.firstChild);

        var capabilitiesUrl =
                url.replace(/REQUEST=GetCapabilities[\&]*/i, '')
                   .replace(new RegExp('SERVICE=' + protocol + '[\&]', 'i'), '')
                   .replace(/\&$/, '');

        capabilitiesUrl += capabilitiesUrl.indexOf('?') !== -1 ? '&' : '?';
        capabilitiesUrl += 'REQUEST=GetCapabilities&SERVICE=' + protocol;

        if (version) {
            capabilitiesUrl += '&VERSION=' + version;
        }

    	sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(capabilitiesUrl), function(response) {
    		if (!parseResponse(response)) return;

    		var servicelayers = parseFunc.call(_this, response.Result);

    		drawFunc.call(_this, servicelayers, url, loading, undefined, _this.customParams);
    	});
    };

    queryServerData.prototype.parseWFSCapabilities = function(response)
    {
    	var serviceLayers = [],
    		strResp = response.replace(/[\t\n\r]/g, ' '),
    		strResp = strResp.replace(/\s+/g, ' '),
    		featuresXML = parseXML(response).getElementsByTagName('FeatureType');

    	for (var i = 0; i < featuresXML.length; i++)
    	{
    		var layer = {},
    			name = featuresXML[i].getElementsByTagName('Name'),
    			title = featuresXML[i].getElementsByTagName('Title'),
    			srs = featuresXML[i].getElementsByTagName('DefaultSRS');

    		if (name.length)
    			layer.name = getTextContent(name[0]);

    		if (title.length)
    			layer.title = getTextContent(title[0]);

    		if (srs.length)
    			layer.srs = getTextContent(srs[0]);

    		if (layer.name)
    			serviceLayers.push(layer);
    	}

    	return serviceLayers;
    };

    queryServerData.prototype.loadGML = function(url, parentTreeCanvas, box, header, format, loadLayerParams, srs)
    {
    	var _this = this;

    	sendCrossDomainJSONRequest(serverBase + "ApiSave.ashx?get=" + encodeURIComponent(url), function(response)
    	{
    		if (!parseResponse(response)) return;
    		var geometries = parseGML(response.Result, format, srs);
    		_this.drawGML(geometries, url, parentTreeCanvas, box, header, loadLayerParams);
    	});
    };

    queryServerData.prototype.saveGML = function(geometries)
    {
    	if (typeof geometries == 'undefined' || geometries == null)
    	{
    		geometries = [];

    		globalFlashMap.drawing.forEachObject(function(ret)
    		{
    			geometries.push(ret.geometry);
    		});
    	}

    	window.promptFunction(_gtxt('Введите имя gml-файла для скачивания:'), 'objects.gml', function(fileName)
    	{
    		globalFlashMap.saveObjects(geometries, nsGmx$1.Utils.translit(fileName));
    	});

    	return false;
    };

    queryServerData.prototype.drawGML = function(geometries, url, parentTreeCanvas, box, header, loadLayerParams)
    {
    	var parent = {
    					'Point': L.gmx.createLayer({properties: {}}).addTo(nsGmx$1.leafletMap),
    					'LineString': L.gmx.createLayer({properties: {}}).addTo(nsGmx$1.leafletMap),
    					'Polygon': L.gmx.createLayer({properties: {}}).addTo(nsGmx$1.leafletMap)
    				},
    		styles = {
    					'Point': typeof loadLayerParams != 'undefined' && loadLayerParams['point'] ? loadLayerParams['point'].RenderStyle : { marker: { size: 2 }, outline: { color: 0x0000ff, thickness: 1 } },
    					'LineString': typeof loadLayerParams != 'undefined' && loadLayerParams['linestring'] ? loadLayerParams['linestring'].RenderStyle : { outline: { color: 0x0000ff, thickness: 2 } },
    					'Polygon': typeof loadLayerParams != 'undefined' && loadLayerParams['polygon'] ? loadLayerParams['polygon'].RenderStyle : { outline: { color: 0x0000ff, thickness: 2, opacity: 100 }, fill: {color: 0xffffff, opacity: 20} }
    				};
    	// parent['POINT'].setStyle(styles['POINT']);
    	// parent['LINESTRING'].setStyle(styles['LINESTRING']);
    	// parent['POLYGON'].setStyle(styles['POLYGON']);

    	var geomsPresent = {},
    		bounds = L.gmxUtil.bounds(),
            items = {'Point': [], 'LineString': [], 'Polygon': []};

    	for (var i = 0; i < geometries.length; i++)
    	{
    		//var elem = parent[geometries[i].geometry.type].addObject(geometries[i].geometry);
            items[geometries[i].geometry.type].push([L.gmxUtil.geoJSONtoGeometry(geometries[i].geometry, true)]);
            //parent[geometries[i].geometry.type].addItems();

    		/*if (objLength(geometries[i].feature) > 0)
    		{
    			(function(i)
    			{
    				elem.setHandler("onClick", function(obj)
    				{
    					var elemCanvas = $(divCanvas).find("[geometryType='" + geometries[i].geometry.type + "']")[0];

    					if (!elemCanvas.graphDataProperties ||
    						!geometries[i].feature.properties)
    						return;

    					var balloonCanvas = _div();

    					if (!_diagram.createBalloon(obj, balloonCanvas))
    						return;

    					if (_diagram.createDateTimeDiagramByAttrs(balloonCanvas, 500, 300, geometries[i].feature.properties, elemCanvas.graphDataProperties))
    						_diagram.oldBalloon.resize();
    				})
    			})(i);
    		}*/

    		geomsPresent[geometries[i].geometry.type] = true;

    		bounds.extendArray(geometries[i].geometry.coordinates[0]);
    	}

        parent['Point'].addData(items['Point']);
        parent['LineString'].addData(items['LineString']);
        parent['Polygon'].addData(items['Polygon']);

    	var divCanvas = _div(),
    		divChilds = _div(),
    		spanHeader = _span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')]),
    		_this = this;

    	var clickFunc = function(flag)
    	{
            var lmap = nsGmx$1.leafletMap,
                method = flag ? 'addLayer' : 'removeLayer';
            lmap[method](parent['Point']);
            lmap[method](parent['LineString']);
            lmap[method](parent['Polygon']);

    		if (flag)
    			show(divChilds);
    		else
    			hide(divChilds);
    	};

    	parentTreeCanvas.loaded = function() // переопределим функцию загрузки слоя на центрирование
    	{
    		if (!box.checked)
    		{
    			clickFunc.call(_this, true);

    			box.checked = true;
    		}

    		//globalFlashMap.zoomToExtent(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
            nsGmx$1.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);
    	};

    	parentTreeCanvas.clear = function()
    	{
            var lmap = nsGmx$1.leafletMap;
    		lmap.removeLayer(parent['Point']);
    		lmap.removeLayer(parent['LineString']);
    		lmap.removeLayer(parent['Polygon']);

    		divCanvas.removeNode(true);
    	};

    	box.onclick = function()
    	{
    		clickFunc.call(_this, this.checked);
    	};

    	$(parentTreeCanvas).empty();

    	if (parentTreeCanvas.childNodes.length == 0)
    		_$3(parentTreeCanvas, [divCanvas]);
    	else
    		parentTreeCanvas.insertBefore(divCanvas, parentTreeCanvas.firstChild);

    	_$3(divCanvas, [divChilds]);

    	// for (var type in geomsPresent)
    	// {
    		// var elemCanvas = _div(null, [['css','padding','2px'],['attr','geometryType', type]]),
    			// //icon = _mapHelper.createStylesEditorIcon([{MinZoom:1,MaxZoom:20,RenderStyle:styles[type]}], type.toLowerCase()),
    			// spanElem = _span(null, [['dir','className','layerfeature']]);

    		// if (type == 'Point')
    			// _(spanElem, [_t(_gtxt('точки'))]);
    		// else if (type == 'LineString')
    			// _(spanElem, [_t(_gtxt('линии'))]);
    		// else if (type == 'Polygon')
    			// _(spanElem, [_t(_gtxt('полигоны'))]);

            // var icon;
    		// (function(type){
    			// icon = _mapHelper.createWFSStylesEditor(parent[type], styles[type], type.toLowerCase(), divCanvas)
    		// })(type);

    		// if (typeof loadLayerParams != 'undefined' && loadLayerParams[type.toLowerCase()])
    		// {
    			// var info = loadLayerParams[type.toLowerCase()];

    			// elemCanvas.graphDataType = info.graphDataType;
    			// elemCanvas.graphDataProperties = info.graphDataProperties;
    		// }
    		// else
    		// {
    			// elemCanvas.graphDataType = "func";
    			// elemCanvas.graphDataProperties = "";
    		// }

    		// _(elemCanvas, [icon, spanElem])
    		// _(divChilds, [elemCanvas]);

    	// }

    	//globalFlashMap.zoomToExtent(bounds.minX, bounds.minY, bounds.maxX, bounds.maxY);
        nsGmx$1.leafletMap.fitBounds([[bounds.min.y, bounds.min.x], [bounds.max.y, bounds.max.x]]);

    	box.checked = true;
    };

    //loadParams - параметры для отдельных слоёв
    //serverParams - параметры сервера, которые были указаны пользователем.
    queryServerData.prototype.drawWMS = function(serviceLayers, url, replaceElem, loadParams, serverParams)
    {
    	var ulCanvas = _ul(null, [['css','paddingBottom','5px'], ['attr','url',url]]),
    		ulChilds = _ul(),
    		remove = makeImageButton('img/closemin.png','img/close_orange.png'),
    		lmap = nsGmx$1.leafletMap;

    	$(replaceElem).replaceWith(ulCanvas);

        $(ulCanvas).data('serverParams', serverParams);

    	remove.onclick = function()
    	{
    		for (var i = 0; i < ulChilds.childNodes.length; i++)
            {
    			ulChilds.childNodes[i].firstChild.lastChild.clear && ulChilds.childNodes[i].firstChild.lastChild.clear();
                lmap.removeLayer(ulChilds.childNodes[i].firstChild.lastChild.gmxObject);
    		}

    		this.parentNode.parentNode.parentNode.removeNode(true);
    	};

    	remove.className = 'remove';
    	remove.style.right = '0px';

    	_$3(ulCanvas, [_li([_div([_span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')],[['dir','className','urlHeader']]), remove],[['css','position','relative']]), ulChilds])]);

    	var clickFunc = function(layer, parent, flag)
    	{
    		if (!flag) {
    			lmap.removeLayer(parent);
            } else {
    			updateFunc(layer, parent);
    			lmap.addLayer(parent);
    		}
    	};

    	var updateFunc = function(layer, parent)
    	{
            var requestParams = {};
    		if (serverParams && serverParams.format)
            {
                requestParams.format = "image/" + serverParams.format;
                requestParams.transparent = serverParams.format === 'png';
            }

            var res = getWMSMapURL(url, layer, requestParams);

            if (res)
            {
                var b = res.bounds;
                parent.clearLayers();
                parent.addLayer(L.imageOverlay(serverBase + "ImgSave.ashx?now=true&get=" + encodeURIComponent(res.url), L.latLngBounds([[b.minY, b.minX], [b.maxY, b.maxX]])));
            }
    	};

    	serviceLayers.forEach(function(layer)
    	{
    		var elemCanvas = _div(null, [['css','padding','2px']]),
    			box = _checkbox(false, 'checkbox'),
    			spanElem = _span([_t(layer.title)], [['css','cursor','pointer'],['dir','className','layerfeature']]),
    			parent = L.layerGroup().addTo(nsGmx$1.leafletMap);

            spanElem.gmxObject = parent;

    		box.className = 'floatLeft';

            spanElem.onclick = function()
            {
                if (!box.checked)
                    box.checked = true;

                clickFunc(layer, parent, true);
            };
            box.onclick = function()
            {
                clickFunc(layer, parent, this.checked);
            };
            box.update = function()
            {
                updateFunc(layer, parent);
            };

    		box.setAttribute('layerName', layer.name);

    		_$3(elemCanvas, [box, spanElem]);
    		_$3(ulChilds, [_li([elemCanvas])]);

    		if (typeof loadParams != 'undefined' && loadParams[layer.name])
    			$(spanElem).trigger("click");
    	});

    	$(ulCanvas).treeview();

    	nsGmx$1.leafletMap.on('moveend', function()
    	{
            var boxes = ulChilds.getElementsByTagName('input');

            for (var i = 0; i < boxes.length; i++)
            {
                if (boxes[i].checked)
                    boxes[i].update();
            }
    	});
    };

    //Добавляет контрол выбора формата запроса к WMS и возвращает его в параметре format (пример: "png", "jpg")
    queryServerData.prototype.customWMSParamsManager = (function()
    {
    	var _targetDiv = null;
    	return {
    		init: function(targetDiv)
    		{
    			var select = nsGmx$1.Utils._select([_option([_t('png')]), _option([_t('jpeg')])], [['dir','className','selectStyle'], ['css', 'width', '60px']]);
    			_targetDiv = targetDiv;
    			_$3(_targetDiv, [_t(_gtxt('Формат изображения') + ': '), select]);
    			_targetDiv.style.marginBottom = '5px';
    		},
    		collect: function() {
    			return { format: $("option:selected", _targetDiv).text() };
    		}
    	}
    })();

    queryServerData.prototype.drawWFS = function(serviceLayers, url, replaceElem, loadParams)
    {
    	var ulCanvas = _ul(null, [['css','paddingBottom','5px'], ['attr','url',url]]),
    		ulChilds = _ul(),
    		divFormat = _div(),
    		remove = makeImageButton('img/closemin.png','img/close_orange.png'),
    		_this = this;

    	$(replaceElem).replaceWith(ulCanvas);

    	remove.onclick = function()
    	{
    		for (var i = 0; i < ulChilds.childNodes.length; i++)
    			ulChilds.childNodes[i].firstChild.lastChild.clear && ulChilds.childNodes[i].firstChild.lastChild.clear();

    		this.parentNode.parentNode.parentNode.removeNode(true);
    	};

    	remove.className = 'remove';
    	remove.style.right = '0px';

    	_$3(ulCanvas, [_li([_div([_span([_t(url.length < 45 ? url : url.substr(0, 45) + '...')],[['dir','className','urlHeader']]), divFormat, remove],[['css','position','relative']]), ulChilds])]);

    	var formatSelect = nsGmx$1.Utils._select([_option([_t("JSON")], [['attr','value','json']]),
    								_option([_t("GML / KML")], [['attr','value','gml']])], [['dir','className','selectStyle'],['css','width','100px']]);

    	_$3(divFormat, [formatSelect]);

    	var clickFunc = function(layer, flag, elemCanvas, box, header, loadLayerParams)
    	{
    		if (flag) {
    			var newFormat = formatSelect.value;

    			// загружаем данные только один раз
    			if (!elemCanvas.loaded || elemCanvas.format != newFormat)
    			{
    				elemCanvas.clear && elemCanvas.clear();

                    var separator = url.indexOf('?') !== -1 ? '&' : '?';

    				var objUrl = url + separator + "request=GetFeature&version=1.0.0&typeName=" + layer.name;

    				if (formatSelect.value == 'json')
    					objUrl += '&outputFormat=json';

    				_this.loadGML(objUrl, elemCanvas, box, header, newFormat, loadLayerParams, layer.srs);

    				elemCanvas.loaded = true;
    				elemCanvas.format = newFormat;

    				var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px']]);

    				_$3(elemCanvas, [loading]);
    			}
    			else
    			{
    				if (typeof elemCanvas.loaded == 'function')
    					elemCanvas.loaded();
    			}
    		}
    	};

    	for (var i = 0; i < serviceLayers.length; i++)
    	{
    		var elemCanvas = _div(null, [['css','padding','2px']]),
    			box = _checkbox(false, 'checkbox'),
    			spanElem = _span([_t(serviceLayers[i].title != '' ? serviceLayers[i].title : serviceLayers[i].name)],[['css','cursor','pointer'],['dir','className','layerfeature']]),
    			elemChilds = _div(null, [['css','marginLeft','20px']]);

    		box.className = 'floatLeft';

    		box.setAttribute('layerName', serviceLayers[i].name);

    		(function(layer, parentTreeCanvas, box, header){
    			spanElem.onclick = function()
    			{
    				if (!box.checked)
    					box.checked = true;

    				clickFunc.call(_this, layer, true, parentTreeCanvas, box, header);
    			};
    			box.onclick = function()
    			{
    				clickFunc.call(_this, layer, this.checked, parentTreeCanvas, box, header);
    			};
    		})(serviceLayers[i], elemChilds, box, spanElem);

    		_$3(elemCanvas, [box, _div([spanElem],[['css','display','inline']]), elemChilds]);
    		_$3(ulChilds, [_li([elemCanvas])]);

    		if (typeof loadParams != 'undefined' && loadParams[serviceLayers[i].name])
    		{
    			if (!box.checked)
    				box.checked = true;

    			formatSelect.value = loadParams[serviceLayers[i].name].format;
    			clickFunc.call(_this, serviceLayers[i], true, elemChilds, box, spanElem, loadParams[serviceLayers[i].name].info);
    		}
    	}

    	$(ulCanvas).treeview();
    };


    var _queryServerDataWFS = new queryServerData(),
    	_queryServerDataWMS = new queryServerData();

    loadServerData.WFS.load = function()
    {
    	var alreadyLoaded = _queryServerDataWFS.createWorkCanvas(arguments[0]);

    	if (!alreadyLoaded)
    		_queryServerDataWFS.load('WFS', _queryServerDataWFS.parseWFSCapabilities, _queryServerDataWFS.drawWFS, null, '1.0.0');
    };
    loadServerData.WFS.unload = function()
    {
    //	removeChilds($$('leftContent'))
    };

    loadServerData.WMS.load = function()
    {
    	var alreadyLoaded = _queryServerDataWMS.createWorkCanvas(arguments[0]);

    	if (!alreadyLoaded)
    		_queryServerDataWMS.load('WMS', parseWMSCapabilities, _queryServerDataWMS.drawWMS, _queryServerDataWMS.customWMSParamsManager);
    };
    loadServerData.WMS.unload = function()
    {
    //	removeChilds($$('leftContent'))
    };

    nsGmx$1.userObjectsManager.addDataCollector('wms', {
        collect: function()
        {
            if (!_queryServerDataWMS.workCanvas)
                return null;

            var value = {};

            $(_queryServerDataWMS.workCanvas.lastChild).children("ul[url]").each(function()
            {
                var url = this.getAttribute('url');
                var serverParams = $(this).data('serverParams');

                value[url] = {params: serverParams, layersVisibility: {}};

                $(this).find("input[type='checkbox']").each(function()
                {
                    if (this.checked)
                    {
                        value[url].layersVisibility[this.getAttribute('layerName')] = true;
                    }
                });
            });

            if (!objLength(value))
                return null;

            return value;
        },

        load: function(data)
        {
            if (!data)
                return;

            $('#left_wms').remove();

            _queryServerDataWMS.builded = false;

            loadServerData.WMS.load('wms');

            for (var url in data)
            {
                (function(loadParams)
                {
                    //поддержка старого формата данных
                    if (!('layersVisibility' in loadParams))
                    {
                        loadParams = {layersVisibility: loadParams};
                    }

                    _queryServerDataWMS.getCapabilities('WMS', url, parseWMSCapabilities, function(serviceLayers, url, replaceElem)
                    {
                        _queryServerDataWMS.drawWMS(serviceLayers, url, replaceElem, loadParams.layersVisibility, loadParams.params);
                    });
                })(data[url]);
            }
        }
    });

    nsGmx$1.userObjectsManager.addDataCollector('wfs', {
        collect: function()
        {
            if (!_queryServerDataWFS.workCanvas)
                return null;

            var value = {};

            $(_queryServerDataWFS.workCanvas.lastChild).children("ul[url]").each(function()
            {
                var url = this.getAttribute('url');

                value[url] = {};

                $(this).find("input[type='checkbox']").each(function()
                {
                    if (this.checked)
                    {
                        var wfsLayerInfo = {};

                        $(this.parentNode.lastChild).find(".colorIcon").each(function()
                        {
                            wfsLayerInfo[this.geometryType] = {RenderStyle: this.getStyle(), graphDataType: this.parentNode.graphDataType, graphDataProperties: this.parentNode.graphDataProperties};
                        });

                        value[url][this.getAttribute('layerName')] = {format: this.parentNode.lastChild.format, info: wfsLayerInfo};
                    }
                });
            });

            if (!objLength(value))
                return null;

            return value;
        },

        load: function(data)
        {
            if (!data)
                return;

            $('#left_wfs').remove();

            _queryServerDataWFS.builded = false;

            loadServerData.WFS.load('wfs');

            for (var url in data)
            {
                (function(loadParams)
                {
                    _queryServerDataWFS.getCapabilities('WFS', url, _queryServerDataWFS.parseWFSCapabilities, function(serviceLayers, url, replaceElem)
                    {
                        _queryServerDataWFS.drawWFS(serviceLayers, url, replaceElem, loadParams);
                    }, '1.0.0');
                })(data[url]);
            }
        }
    });

    /**
        Возвращает массив ссылок в верхнее левое мета-меню в формате HeaderWidget из CommonComponents.
        Считывает информацию из window.gmxViewerUI.headerLinkItems в формате [{icon: iconPath, title: TITLE, href: HREF}, ...] (формат ГеоМиксера)
        Если переменной нет, подставляет значения по умолчению ("Карта пожаров", "Поиск снимков", "Платформа Геомиксер")
        @memberOf nsGmx
    */
    nsGmx$1.addHeaderLinks = function()
    {
        var isHeaderLinks = false;
        if ( typeof window.headerLinks === 'boolean' ) isHeaderLinks = window.headerLinks; //совместимость с предыдущими версиями
        if ( typeof window.gmxViewerUI !== 'undefined' && typeof window.gmxViewerUI.headerLinks !== 'undefined' )
            isHeaderLinks = window.gmxViewerUI.headerLinks;

        if (!isHeaderLinks) {
            return [];
        }

        var items = (window.gmxViewerUI && window.gmxViewerUI.headerLinkItems) ||
            [
                {title: _gtxt("Карта пожаров"), href: _gtxt("http://fires.ru"), newWindow: true},
                {title: _gtxt("Поиск снимков"), href: _gtxt("https://search.kosmosnimki.ru"), newWindow: true},
                {title: _gtxt("Платформа Геомиксер"), newWindow: true, id: 'HeaderLinkGeoMixer'}
            ];

        return $.extend(true, [], items).map(function(item, index, array) {
            item.link = item.href;
            return {
                id: 'headerLinksItem' + index,
                title: item.title,
                func: function(){
                    if (item.link) {
                        window.open(item.link, '_blank');
                    }
                }.bind(item)
            }
        })
    };

    nsGmx$1.TransparencySliderWidget = function(container) {
        var _this = this;
        var ui = $(Handlebars.compile(
    		'<div class="leaflet-gmx-iconSvg leaflet-gmx-iconSvg-transparency svgIcon leaflet-control gmx-transslider-toggle-icon" title="{{i "TransparencySliderWidget.title"}}"><svg role="img" class="svgIcon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency"></use></svg></div>' +
            '<div class = "gmx-transslider-container"></div>' +
            '<div class = "leaflet-gmx-iconSvg leaflet-gmx-iconSvg-transparency-eye svgIcon leaflet-gmx-iconSvg-active leaflet-control gmx-transslider-onoff" title="{{i "TransparencySliderWidget.onOffTitle"}}"><svg role="img" class="svgIcon gmx-transslider-hide"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency-eye"></use></svg><svg role="img" class="svgIcon"><use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#transparency-eye-off"></use></svg></div>'
        )()).appendTo(container);

        var sliderContainer = container.find('.gmx-transslider-container');

        this._isCollapsed = true;

        container.find('.gmx-transslider-toggle-icon').click(function() {
            this._isCollapsed = !this._isCollapsed;
            sliderContainer.toggle(!this._isCollapsed);
            container.find('.gmx-transslider-onoff').toggle(!this._isCollapsed);
            container.find('.gmx-transslider-toggle-icon').toggleClass('leaflet-gmx-iconSvg-active', !this._isCollapsed);
        }.bind(this));

        var isOpaque = true;
        var updateOnOffIcon = function(value) {
            var isOpaqueNew = value === 1.0;
            if (isOpaqueNew !== isOpaque) {
                isOpaque = isOpaqueNew;
                var arr = container.find('.gmx-transslider-onoff')[0].childNodes;
    			if (isOpaque) {
    				L.DomUtil.removeClass(arr[1], 'gmx-transslider-hide');
    				L.DomUtil.addClass(arr[0], 'gmx-transslider-hide');
    			} else {
    				L.DomUtil.removeClass(arr[0], 'gmx-transslider-hide');
    				L.DomUtil.addClass(arr[1], 'gmx-transslider-hide');
    			}
            }
        };

        sliderContainer.slider({
            range: 'min',
            min: 0.0,
            max: 1.0,
            step: 0.01,
            value: 1.0,
            change: function(event, ui) {
                $(_this).triggerHandler(event, ui);
                updateOnOffIcon(ui.value);
            },
            slide: function(event, ui) {
                $(_this).triggerHandler(event, ui);
                updateOnOffIcon(ui.value);
            }
        }).hide();

        // fix map moving in IE
        if (nsGmx$1.leafletMap) {
            var dragging = nsGmx$1.leafletMap.dragging;
            L.DomEvent
                .on(sliderContainer[0], 'mouseover', dragging.disable, dragging)
                .on(sliderContainer[0], 'mouseout', dragging.enable, dragging);
        }

        container.find('.gmx-transslider-onoff').click(function(){
            var curValue = sliderContainer.slider('value');
            sliderContainer.slider('value', curValue !== 1.0 ? 1.0 : 0.0);
        }).hide();

        container.on('mousedown click', function(event) {
            event.stopPropagation();
        });
    };

    nsGmx$1.TransparencySliderWidget.prototype.isCollapsed = function() {
        return this._isCollapsed;
    }
    ;
    nsGmx$1.Translations.addText('rus', { TransparencySliderWidget: {
        title: 'Прозрачность растровых слоёв',
        onOffTitle: 'Показать/скрыть растры'
    }});
                             
    nsGmx$1.Translations.addText("eng", { TransparencySliderWidget: {
        title: 'Raster layers transparency',
        onOffTitle: 'Show/hide rasters'
    }});

    L.Control.GmxLayers2 = L.Control.Layers.extend({
        options: {
            collapsed: true,
            autoZIndex: false,
            id: 'layers'
        },

        initialize: function (baseLayers, overlays, options) {
            L.Control.Layers.prototype.initialize.call(this, baseLayers, overlays, options);
        },
        onAdd: function (map) {
            L.Control.Layers.prototype.onAdd.call(this, map);
            this.init = false;
            this._initLayout();
            this._update();

            this._iconClick = function () {
                if (this._iconContainer) {
                    this.setActive(!this.options.isActive);
                    this._update();
                    if (this.options.stateChange) { this.options.stateChange(this); }
                }
            };
            var stop = L.DomEvent.stopPropagation;
            L.DomEvent
                .on(this._iconContainer, 'mousemove', stop)
                .on(this._iconContainer, 'touchstart', stop)
                .on(this._iconContainer, 'mousedown', stop)
                .on(this._iconContainer, 'dblclick', stop)
                .on(this._iconContainer, 'click', stop)
                .on(this._iconContainer, 'click', this._iconClick, this);

            return this._container;
        },

        _initLayout: function () {
            var controlClassName = 'leaflet-control-layers2',
                prefix = 'leaflet-gmx-iconSvg',
                iconClassName =  prefix + ' ' + prefix + '-overlays svgIcon',
                listClassName = 'leaflet-control-layers',
                container = this._container = L.DomUtil.create('div', controlClassName),
                iconContainer = this._iconContainer = L.DomUtil.create('div', iconClassName),
                listContainer = this._listContainer = L.DomUtil.create('div', listClassName);

            var openingDirection = this.options.direction || 'bottom';

            L.DomUtil.addClass(listContainer, listClassName + '-' + openingDirection);
            if (this.options.title) { this._iconContainer.title = this.options.title; }

    		this._prefix = prefix;

            //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
            container.setAttribute('aria-haspopup', true);

            if (!L.Browser.touch) {
                L.DomEvent
                    .disableClickPropagation(container)
                    .disableScrollPropagation(container);
            } else {
                L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
            }

            var placeHolder = this._placeHolder = L.DomUtil.create('div', 'layers-placeholder');
            placeHolder.innerHTML = this.options.placeHolder;

            var form = this._form = L.DomUtil.create('form', listClassName + '-list');

            if (this.options.collapsed) {

              var useHref = '#' + 'overlays';
              iconContainer.innerHTML = '<svg role="img" class="svgIcon">\
              <use xlink:href="' + useHref + '"></use>\
            </svg>';

                var link = this._layersLink = L.DomUtil.create('a', '', listContainer);
                link.href = '#';
                link.title = 'Layers';

                if (L.Browser.touch) {
                    L.DomEvent
                        .on(iconContainer, 'click', L.DomEvent.stop)
                        .on(iconContainer, 'click', this._expand, this);
                }
                //Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
                L.DomEvent.on(form, 'click', function () {
                    setTimeout(L.bind(this._onInputClick, this), 0);
                }, this);

                this._map.on('click', this._collapse, this);
            } else {
                this._expand();
            }

            this._baseLayersList = L.DomUtil.create('div', listClassName + '-base', form);
            this._separator = L.DomUtil.create('div', listClassName + '-separator', form);
            this._overlaysList = L.DomUtil.create('div', listClassName + '-overlays', form);

            listContainer.appendChild(form);
            listContainer.appendChild(placeHolder);
            container.appendChild(iconContainer);
            container.appendChild(listContainer);
            if (!this.init) { container.style.display = 'none'; }
        },

        _addLayer: function (layer, name, overlay) {
            if (Object.keys(this._layers).length === 0) {
                this.init = true;
            }

            L.Control.Layers.prototype._addLayer.call(this, layer, name, overlay);
        },

        _addItemObject: function (obj) {
            var label = this._addItem(obj);
            if (obj.layer && obj.layer._gmx && obj.layer._gmx.layerID) {
                label.className = '_' + obj.layer._gmx.layerID;
            }
        },

        _addItem: function (obj) {
            if (L.version === '0.7.7') {
                var label = document.createElement('label'),
                input,
                checked = this._map.hasLayer(obj.layer);

                if (obj.overlay) {
                    input = document.createElement('input');
                    input.type = 'checkbox';
                    input.className = 'leaflet-control-layers-selector';
                    input.defaultChecked = checked;
                } else {
                    input = this._createRadioElement('leaflet-base-layers', checked);
                }

                input.layerId = L.stamp(obj.layer);

                L.DomEvent.on(input, 'click', this._onInputClick, this);

                var name = document.createElement('span');
                name.innerHTML = ' ' + obj.name;

                label.appendChild(input);
                label.appendChild(name);

                var container = obj.overlay ? this._overlaysList : this._baseLayersList;
                container.appendChild(label);

                return label;
            } else {
                var label = document.createElement('label'),
                    checked = this._map.hasLayer(obj.layer),
                    input;

                if (obj.overlay) {
                    input = document.createElement('input');
                    input.type = 'checkbox';
                    input.className = 'leaflet-control-layers-selector';
                    input.defaultChecked = checked;
                } else {
                    input = this._createRadioElement('leaflet-base-layers', checked);
                }

                var presentLayer, presentIndex;

                for (var i = 0; i < this._layerControlInputs.length; i++) {
                    var inp = this._layerControlInputs[i];
                    if (inp.layerId === obj.layer._leaflet_id) {
                        presentLayer = inp;
                    }
                }

                presentIndex =  this._layerControlInputs.indexOf(presentLayer);

                if (presentLayer) {
                    this._layerControlInputs = [].concat(
                        this._layerControlInputs.slice(0, presentIndex),
                        input,
                        this._layerControlInputs.slice(presentIndex + 1, this._layerControlInputs.length));
                } else {
                    this._layerControlInputs.push(input);
                }

                input.layerId = L.Util.stamp(obj.layer);

                L.DomEvent.on(input, 'click', this._onInputClick, this);

                var name = document.createElement('span');
                name.innerHTML = ' ' + obj.name;

                // Helps from preventing layer control flicker when checkboxes are disabled
                // https://github.com/Leaflet/Leaflet/issues/2771
                var holder = document.createElement('div');

                label.appendChild(holder);
                holder.appendChild(input);
                holder.appendChild(name);

                var container = obj.overlay ? this._overlaysList : this._baseLayersList;
                container.appendChild(label);

                this._checkDisabledLayers();
                return label;
            }
        },

        _update: function () {
            if (!this._listContainer) {
                return;
            }
            var options = this.options;

            if (this.init) {
                this._container.style.display = '';
                this.setActive(false);
                this.init = false;
            }

            this._baseLayersList.innerHTML = '';
            this._overlaysList.innerHTML = '';

            var baseLayersPresent = false,
                overlaysPresent = false,
                i, obj;

            for (i in this._layers) {
                obj = this._layers[i];
                if (obj.overlay) {
                    this._addItemObject(obj);
                    overlaysPresent = true;
                } else {
                    baseLayersPresent = true;
                }
            }

            this._container.style.display = overlaysPresent ? '' : 'none';

            this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
            this._form.style.display = overlaysPresent || baseLayersPresent ? '' : 'none';
            this._placeHolder.style.display = overlaysPresent || baseLayersPresent ? 'none' : '';


            if (!options.isActive) {
                this._form.style.display = 'none';
                this._placeHolder.style.display = 'none';
            }
        },

        _expand: function () {
            L.DomUtil.addClass(this._listContainer, 'leaflet-control-layers-expanded');
        },

        _collapse: function () {
            this._listContainer.className = this._listContainer.className.replace(' leaflet-control-layers-expanded', '');
            this.setActive(false);
        },

        setActive: function (active, skipEvent) {
            var options = this.options,
                togglable = options.togglable || options.toggle;
            if (togglable) {
                var prev = options.isActive,
                    prefix = this._prefix,
                    className = prefix + '-' + options.id,
                    container = this._iconContainer;

                options.isActive = active;
                if (active) {
                    L.DomUtil.addClass(container, prefix + '-active');
                    L.DomUtil.addClass(container, className + '-active');
                    if (container.children.length) {
                        L.DomUtil.addClass(container, prefix + '-externalImage-active');
                    }
                    if (options.styleActive) { this.setStyle(options.styleActive); }

            		L.DomUtil.addClass(this._listContainer, 'leaflet-control-layers-expanded');
                } else {
                    L.DomUtil.removeClass(container, prefix + '-active');
                    L.DomUtil.removeClass(container, className + '-active');
                    if (container.children.length) {
                        L.DomUtil.removeClass(container, prefix + '-externalImage-active');
                    }
                    if (options.style) { this.setStyle(options.style); }
                    L.DomUtil.removeClass(this._listContainer, 'leaflet-control-layers-expanded');
                }
                // ugly bug in IE
                // IE appends 'extended' class to the parent!
                if (L.DomUtil.hasClass(this._container, 'leaflet-control-layers-expanded')) {
                    L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
                }        }
        },

        addTo: function (map) {
            // L.Control.prototype.addTo.call(this, map);
            L.Control.GmxIcon.prototype.addTo.call(this, map);
            if (this.options.addBefore) {
                this.addBefore(this.options.addBefore);
            }
            return this;
        },

        addBefore: function (id) {
            var parentNode = this._parent && this._parent._container;
            if (!parentNode) {
                parentNode = this._map && this._map._controlCorners[this.getPosition()];
            }
            if (!parentNode) {
                this.options.addBefore = id;
            } else {
                for (var i = 0, len = parentNode.childNodes.length; i < len; i++) {
                    var it = parentNode.childNodes[i];
                    if (id === it._id) {
                        parentNode.insertBefore(this._container, it);
                        break;
                    }
                }
            }
            return this;
        }
    });

    L.Control.gmxLayers2 = L.Control.GmxLayers2;
    L.control.gmxLayers2 = function (baseLayers, overlays, options) {
      return new L.Control.GmxLayers2(baseLayers, overlays, options);
    };

    var gmxMediaDescription = function gmxMediaDescription(descField, descData, storeDescFieldName, mode, mediaLayerName, mediaObjId, mediaLayer, dialogSettings) {
      //Основные переменные
      var editor,
          mediaDescDialog = jQuery('<div class="mediaDesc-Div"><img src="' + pluginPath + 'addit/media_img_load.gif"></img></div>'),
          mediaDescDialogTitle,
          mediaDescTextArea = jQuery('<textarea name="mediaDescInput" id="mediaDescInput"></textarea>'),
          exp1 = /(?:^|[^"'])(\b((https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|]))/gim,
          exp2 = /(?:^|[^"'https?:\/\/])(\b((www.)[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|]))/gim; //descData = descData.replace(exp1, '<a href="$1" target="_blank">$1</a>'); //Проверяем текст на наличие ссылок вида http/ftp и превращаем в URL.
      //descData = descData.replace(exp2, '<a href="http://$1" target="_blank">$1</a>'); //Проверяем текст на наличие ссылок вида www и превращаем в URL.
      //Основные функции диалога
      //Исправление бага с окном добавления ссылок через CKEditor в модальном режиме диалога описания

      $.widget("ui.dialog", $.ui.dialog, {
        //  jQuery UI - v1.10.2 - 2013-12-12
        //  http://bugs.jqueryui.com/ticket/9087#comment:27 - bugfix
        //  http://bugs.jqueryui.com/ticket/4727#comment:23 - bugfix
        //  allowInteraction fix to accommodate windowed editors
        _allowInteraction: function _allowInteraction(event) {
          if (this._super(event)) {
            return true;
          } // address interaction issues with general iframes with the dialog


          if (event.target.ownerDocument != this.document[0]) {
            return true;
          } // address interaction issues with dialog window


          if ($(event.target).closest(".cke_dialog").length) {
            return true;
          } // address interaction issues with iframe based drop downs in IE


          if ($(event.target).closest(".cke").length) {
            return true;
          }
        },
        // jQuery UI - v1.10.2 - 2013-10-28
        //  http://dev.ckeditor.com/ticket/10269 - bugfix
        //  moveToTop fix to accommodate windowed editors
        _moveToTop: function _moveToTop(event, silent) {
          if (!event || !this.options.modal) {
            this._super(event, silent);
          }
        }
      }); //Функция сохранения описание из Режима Чтения (данные записываются сразу в слой)

      var saveDescfromReadMode = function saveDescfromReadMode() {
        var newData = mediaDescTextArea.val();
        var descriptionLength = newData.length;
        var edata = editor.getData();
        newData = edata.replace(/>/gim, '> ');
        newData = newData.replace(exp1, ' <a href="$1" target="_blank">$1</a> ' + ' ');
        newData = newData.replace(exp2, ' <a href="http://$1" target="_blank">$1</a> ' + ' ');

        if (descriptionLength > 5000) {
          var descriptionLengthDIFF = descriptionLength - 5000;
          alert(_gtxt('mediaPlugin2.mediaDescDialogLimit.alert') + descriptionLengthDIFF + _gtxt('mediaPlugin2.mediaDescDialogSymbols.alert'));
        } else {
          _mapHelper.modifyObjectLayer(mediaLayerName, [{
            id: mediaObjId,
            properties: {
              '_mediadescript_': newData
            },
            action: 'update'
          }]).done(function () {
            mediaDescDialog.dialog('close').remove();
            new gmxMediaDescription(null, newData, null, 'read', mediaLayerName, mediaObjId, mediaLayer, dialogSettings); //После сохранения закрываем старое окно и открываем новое с описанием.
          });
        }
      }; //Функция сохранения описание из Режима Чтения (Пользователь решает сохранять данные или нет)


      var saveDescfromEditMode = function saveDescfromEditMode() {
        var newdescData = mediaDescTextArea.val();
        var descriptLength = newdescData.length;
        var eddata = editor.getData();
        newdescData = eddata.replace(/>/gim, '> ');
        newdescData = newdescData.replace(exp1, ' <a href="$1" target="_blank">$1</a> ' + ' ');
        newdescData = newdescData.replace(exp2, ' <a href="http://$1" target="_blank">$1</a> ' + ' ');

        if (descriptLength > 5000) {
          var descriptLengthDIFF = descriptLength - 5000;
          alert(_gtxt('mediaPlugin2.mediaDescDialogLimit.alert') + descriptLengthDIFF + _gtxt('mediaPlugin2.mediaDescDialogSymbols.alert'));
        } else {
          descField.set(storeDescFieldName, newdescData);
          mediaDescDialog.dialog('close').remove();
        }
      }; //Функция переключения в режим "HTML"


      var editortoHTML = function editortoHTML(prevmode) {
        for (var editorHTMLInstance in CKEDITOR.instances) {
          var curHTMLInstance = editorHTMLInstance;
          break;
        }
        $('#' + editor.id + '_top').hide();
        editor.resize('100%', mediaDescDialog.height() - 5, true);
        CKEDITOR.instances[curHTMLInstance].setMode('source');

        if (prevmode == 'fromedit') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'WYSIWYGMode',
              text: _gtxt("mediaPlugin2.descDialogWYSIWYGButton.label"),
              click: function click() {
                editortoWYSIWYG('fromedit');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt('mediaPlugin2.descDialogEditSaveButton.label'),
              click: saveDescfromEditMode
            }]
          });
        } else if (prevmode == 'fromread') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'WYSIWYGMode',
              text: _gtxt("mediaPlugin2.descDialogWYSIWYGButton.label"),
              click: function click() {
                editortoWYSIWYG('fromread');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt("mediaPlugin2.descDialogSaveButton.label"),
              click: saveDescfromReadMode
            }]
          });
        }
      }; //Функция переключения в режим "WYSIWYG"


      var editortoWYSIWYG = function editortoWYSIWYG(prevmode) {
        for (var editorWYSIWYGInstance in CKEDITOR.instances) {
          var curWYSIWYGInstance = editorWYSIWYGInstance;
          break;
        }
        $('#' + editor.id + '_top').show();
        editor.resize('100%', mediaDescDialog.height() - 50, true);
        CKEDITOR.instances[curWYSIWYGInstance].setMode('wysiwyg');

        if (prevmode == 'fromedit') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'htmlMode',
              text: 'HTML',
              click: function click() {
                editortoHTML('fromedit');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt('mediaPlugin2.descDialogEditSaveButton.label'),
              click: saveDescfromEditMode
            }]
          });
        } else if (prevmode == 'fromread') {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'htmlMode',
              text: 'HTML',
              click: function click() {
                editortoHTML('fromread');
              }
            }, {
              id: 'saveDescData',
              text: _gtxt("mediaPlugin2.descDialogSaveButton.label"),
              click: saveDescfromReadMode
            }]
          });
        }
      }; //Функция переключения из режима "Чтение" в режим "Редактирование"


      var changeDescDialogMode = function changeDescDialogMode() {
        mediaDescDialog.dialog('close');
        descEditMode();
        mediaDescDialog.dialog({
          buttons: [{
            id: 'htmlMode',
            text: 'HTML',
            click: function click() {
              editortoHTML('fromread');
            }
          }, {
            id: 'saveDescData',
            text: _gtxt("mediaPlugin2.descDialogSaveButton.label"),
            click: saveDescfromReadMode
          }]
        });
        mediaDescDialog.dialog('open');
      }; //Режим "Чтение"


      var descReadMode = function descReadMode() {
        var isEditableLayer = function isEditableLayer(layer) {
          var layerProps = layer.getGmxProperties();

          var layerRights = _queryMapLayers.layerRights(layerProps.name);

          return layerProps.type === 'Vector' && (layerRights == 'edit' || layerRights == 'editrows');
        };

        $(mediaDescDialog).on('click', '.imgMedia', function (e) {
          var newwindowHref = $(this).find('img').attr('src');

          if (newwindowHref) {
            e.preventDefault();
            window.open(newwindowHref, 'new' + e.screenX);
          }
        });
        mediaDescDialog.dialog({
          title: mediaDescDialogTitle,
          width: 510,
          height: dialogSettings.dialogDescHeight,
          minHeight: dialogSettings.dialogDescHeight,
          maxWidth: 510,
          minWidth: 510,
          modal: false,
          autoOpen: false,
          dialogClass: 'media-DescDialog',
          close: function close() {
            mediaDescDialog.dialog('close').remove();
          }
        });
        mediaDescDialog.html('<div class="media-descDiv">' + descData + '</div>');
        mediaDescDialog.dialog('open');

        if (isEditableLayer(mediaLayer)) {
          mediaDescDialog.dialog({
            buttons: [{
              id: 'changeDescMode',
              text: _gtxt("mediaPlugin2.descDialogEditButton.label"),
              click: changeDescDialogMode
            }]
          });
        }
      }; //Режим "Редактирование"


      var descEditMode = function descEditMode() {
        gmxCore.loadScript(pluginPath + 'ckeditor_4.4.1_custom/ckeditor/ckeditor.js');
        gmxCore.loadScript(pluginPath + 'ckeditor_4.4.1_custom/ckeditor/adapters/jquery.js').done(function () {
          var CKEDITOR_BASEPATH = gmxCore.getModulePath('ckeditor'); //CKEDITOR.config.enterMode = '2';

          mediaDescTextArea.val(descData);
          mediaDescTextArea.ckeditor();
          CKEDITOR.on('instanceReady', function (ev) {
            editor = ev.editor;
            $('#' + editor.id + '_top').show();
            editor.resize('100%', mediaDescDialog.height() - 65, true);
            editor.on('doubleclick', function (evt) {
              var element = evt.data.element;

              if (element.is('img') && !element.data('cke-realelement') && !element.isReadOnly()) {
                var targetSrc = element.getAttribute('src');
                window.open(targetSrc, 'new' + e.screenX);
              }
            });
            $('iframe').contents().click(function (e) {
              if (typeof e.target.href != 'undefined' && e.ctrlKey == true) {
                window.open(e.target.href, 'new' + e.screenX);
              }
            });
          });
          CKEDITOR.on('dialogDefinition', function (ev) {
            var dialogName = ev.data.name;
            var dialogDefinition = ev.data.definition;

            if (dialogName == 'link') {
              var informationTab = dialogDefinition.getContents('target');
              var targetField = informationTab.get('linkTargetType');
              targetField['default'] = '_blank';
            }
          });
          mediaDescDialog.html(mediaDescTextArea);
        });
        mediaDescDialog.dialog({
          //title: mediaDescDialogTitle,
          width: 510,
          height: dialogSettings.dialogDescHeight,
          minHeight: dialogSettings.dialogDescHeight,
          maxWidth: 510,
          minWidth: 510,
          modal: true,
          resize: function resize() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          resizeStop: function resizeStop() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          drag: function drag() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          dragStop: function dragStop() {
            editor.resize('100%', mediaDescDialog.height() - 65, true);
          },
          autoOpen: false,
          buttons: [{
            id: 'htmlMode',
            text: 'HTML',
            click: function click() {
              editortoHTML('fromedit');
            }
          }, {
            id: 'saveDescData',
            text: _gtxt('mediaPlugin2.descDialogEditSaveButton.label'),
            click: saveDescfromEditMode
          }],
          dialogClass: 'media-DescDialog',
          close: function close() {
            mediaDescDialog.dialog('close').remove();
          }
        });
        mediaDescDialog.dialog('open');
      }; //Дополнительные условия


      if (mode == 'read') {
        //mediaDescDialogTitle = _gtxt('mediaPlugin2.mediaDescDialogTitleRead.label');
        descReadMode();
      } else if (mode == 'edit') {
        //mediaDescDialogTitle = _gtxt('mediaPlugin2.mediaDescDialogTitleEdit.label');
        descEditMode();
      } else if (mode == 'baloon') {
        /*mediaDescDialogTitle = _gtxt('mediaPlugin2.mediaDescDialogTitleEdit.label');*/
        descReadMode();
        changeDescDialogMode();
      }
    };

    _translationsHash.addtext("rus", {
      mediaPlugin2: {
        "layerPropertiesTitle": 'Добавить описание',
        "balloonDefaultTitle": 'Медиа Описание',
        "descButton.label": 'Редактировать',
        "descButton.help": 'Редактировать медиа описание',
        "descSpan.label": 'Описание',
        "descSpan.help": 'Медиа описание',
        "descDialogEditButton.label": 'Редактировать',
        "descDialogWYSIWYGButton.label": 'Визуально',
        "descDialogSaveButton.label": 'Сохранить',
        "descDialogEditSaveButton.label": 'Готово',
        "descBalloonButton.label": 'Описание',
        "descInBalloonButton.label": 'Редактировать описание',
        "descDialogTitle.label": 'Просмотр Медиа-Описания',
        "mediaDescDialogTitleEdit.label": 'Редактировать описание',
        "mediaDescDialogTitleRead.label": 'Чтение описания',
        "mediaDescDialogLimit.alert": 'Количество символов в описании больше 5000.\nУкоротите описание на ',
        "mediaDescDialogSymbols.alert": ' символов',
        "mediaDescImgDialogError.alert": 'Не удалось загрузить изображение.\n Проверьте правильность ссылки',
        "WarningText": 'Для хранения описаний требуется добавление нового поля к слою'
      }
    });

    _translationsHash.addtext("eng", {
      mediaPlugin2: {
        "layerPropertiesTitle": 'Add media description',
        "balloonDefaultTitle": 'Media description',
        "descButton.label": 'Edit',
        "descButton.help": 'Edit media description',
        "descSpan.label": 'Description',
        "descSpan.help": 'Media Description',
        "descDialogEditButton.label": 'Edit',
        "descDialogWYSIWYGButton.label": 'WYSIWYG',
        "descDialogSaveButton.label": 'Save',
        "descDialogEditSaveButton.label": 'OK',
        "descBalloonButton.label": 'Description',
        "descInBalloonButton.label": 'Edit Description',
        "descDialogTitle.label": 'Media-Description Viewer',
        "mediaDescDialogTitleEdit.label": 'Edit Description',
        "mediaDescDialogTitleRead.label": 'View Description',
        "mediaDescDialogLimit.alert": 'Description length more then 5000 symbols.\nDelete ',
        "mediaDescDialogSymbols.alert": ' symbols',
        "mediaDescImgDialogError.alert": 'Image load failure.\n Check URL on error',
        "WarningText": 'New attribute will be added to this layer to store descriptions'
      }
    }); //Модифицирует описание слоя, добавляя или удаляя свойства, необходимые для хранения описания объектов.
    //Метатег удаляется и добавляется, а необходимый атриут только добавляется (никогда не удаляется)


    var modifyLayerProperties = function modifyLayerProperties(layerProperties, isAddDescription) {
      var metaProps = layerProperties.get('MetaProperties'),
          tagId = metaProps.getTagIdByName(DESC_METATAG);

      if (isAddDescription) {
        tagId || metaProps.addNewTag(DESC_METATAG, DESC_DEFAULT_FIELD, 'String');
        var columns = layerProperties.get('Columns').slice();

        if (!_.findWhere(columns, {
          Name: DESC_DEFAULT_FIELD
        })) {
          columns.push({
            Name: DESC_DEFAULT_FIELD,
            ColumnSimpleType: 'String'
          });
        }

        layerProperties.set('Columns', columns);
      } else {
        metaProps.deleteTag(tagId);
      }

      layerProperties.set('MetaProperties', metaProps);
    };

    var DESC_METATAG = 'mediaDescField',
        DESC_DEFAULT_FIELD = '_mediadescript_',
        DESC_INLINE_HOOK = 'mediainline';
    var pluginPath = gmxCore.getModulePath('MediaPlugin2');
    var publicInterface = {
      pluginName: 'Media Plugin',
      afterViewer: function afterViewer(mediaDescDialogSettings, map) {
        mediaDescDialogSettings = $.extend({
          dialogDescHeight: 450,
          inBaloonDesc: false
        }, mediaDescDialogSettings);

        gmxCore.loadModule('LayerEditor').done(function () {
          nsGmx.LayerEditor.addInitHook(function (layerEditor, layerProperties, parametres) {
            var metaProps = layerProperties.get('MetaProperties'),
                isMedia = metaProps.getTagByName(DESC_METATAG);

            if (layerProperties.get('Type') !== 'Vector') {
              return;
            }

            var uiTemplate = Handlebars.compile('<label class = "media-props">' + '<input type="checkbox" id="media-props-checkbox" {{#isMedia}}checked{{/isMedia}}>' + '{{i "mediaPlugin2.layerPropertiesTitle"}}' + '</label>');
            $(layerEditor).on('premodify', function () {
              modifyLayerProperties(layerProperties, $('#media-props-checkbox', ui).prop("checked"));
            });
            var ui = $(uiTemplate({
              isMedia: isMedia
            }));
            parametres.additionalUI = parametres.additionalUI || {};
            parametres.additionalUI.advanced = parametres.additionalUI.advanced || [];
            parametres.additionalUI.advanced.push(ui[0]);
          });
        });

        var balloonHook = function balloonHook(layer, props, div, node, hooksCount) {
          //Если есть описание в балуне, отдельной ссылки на описание не нужно
          if (hooksCount[DESC_INLINE_HOOK]) {
            return;
          } // var layer = o.layer,


          var layerProps = layer.getGmxProperties(),
              layerName = layerProps.name,
              metaTag = layerProps.MetaProperties && layerProps.MetaProperties[DESC_METATAG];

          if (!metaTag) {
            $(node).empty().append(props[DESC_DEFAULT_FIELD]);
          } else if (props[metaTag.Value].length) {
            var descBaloonButtonLabel = '<b><a href="">{{i "mediaPlugin2.descBalloonButton.label"}}</a></b>',
                mediaDescDialogMode = 'read';
            var ui = $(Handlebars.compile(descBaloonButtonLabel)()).click(function (e) {
              e.preventDefault();
              var mediaObjectId = props[layerProps.identityField];
              var descripText = props[metaTag.Value];
              new gmxMediaDescription('', descripText, '', mediaDescDialogMode, layerName, mediaObjectId, layer, mediaDescDialogSettings);
            });

            if (node) {
              $(node).empty().append(ui);
            } else {
              $(div).append($('<br/>'), ui);
            }
          }
        };

        var attachBalloonHook = function attachBalloonHook(layer) {
          if (!layer.addPopupHook) {
            //например, виртуальные слои могут не поддерживать popup hooks
            return;
          }

          var props = layer.getGmxProperties();
          var metaTag = props.MetaProperties && props.MetaProperties[DESC_METATAG];
          layer.addPopupHook(metaTag ? metaTag.Value : DESC_DEFAULT_FIELD, function (properties, div, node, hooksCount) {
            balloonHook(layer, properties, div, node, hooksCount);
          }); //добавляем просмотр описания внутри балуна

          layer.addPopupHook(DESC_INLINE_HOOK, function (properties, div, node) {
            var metaTag = props.MetaProperties && props.MetaProperties[DESC_METATAG];

            if (!node || !metaTag) {
              return;
            }

            var html = properties[metaTag.Value];
            $(node).html('<div class="media-inlineDescr media-descDiv">' + html + '</div>');
            $(node).on('click', '.imgMedia', function (e) {
              e.preventDefault();
              var contwindowHref = $(this).find('img').attr('src');
              window.open(contwindowHref, 'new' + e.screenX);
            });
          });
        };

        nsGmx.gmxMap.layers.forEach(attachBalloonHook);

        var paramHook = function paramHook(layerName, id, parametres) {
          var layer = nsGmx.gmxMap.layersByID[layerName],
              props = layer.getGmxProperties(),
              fieldName = props.MetaProperties && props.MetaProperties[DESC_METATAG] && props.MetaProperties[DESC_METATAG].Value; //layer.bringToTopItem(id);

          parametres = parametres || {};
          parametres.fields = parametres.fields || [];

          if (fieldName) {
            var fieldDescription = _.findWhere(parametres.fields, {
              name: fieldName
            });

            if (fieldDescription) {
              fieldDescription.hide = true;
            } else {
              parametres.fields.push({
                name: fieldName,
                hide: true
              });
            }
          }

          parametres.afterPropertiesControl = function (EOCInteraction) {
            var mediaGUI = $('<div class="media-Desc-GUI"><span id="media-Desc-EditLabel" title="' + _gtxt("mediaPlugin2.descSpan.help") + '">' + _gtxt("mediaPlugin2.descSpan.label") + '</span><span id ="mediaDesc-EditButton" class="buttonLink" title="' + _gtxt("mediaPlugin2.descButton.help") + '">' + _gtxt("mediaPlugin2.descButton.label") + '</span></div>');
            $('#mediaDesc-EditButton', mediaGUI).click(function () {
              if (!fieldName) {
                var ui = $(Handlebars.compile('<div>{{i "mediaPlugin2.WarningText"}}</div>')());
                ui.dialog({
                  buttons: [{
                    id: 'warning-ok',
                    text: 'OK',
                    click: function click() {
                      $(this).dialog("close");
                      gmxCore.loadModule('LayerProperties').then(function () {
                        var layerProperties = new nsGmx.LayerProperties();
                        layerProperties.initFromServer(layerName).then(function () {
                          modifyLayerProperties(layerProperties, true);
                          layerProperties.save().then(function () {
                            L.gmx.layersVersion.chkVersion(layer, function () {
                              fieldName = layer.getGmxProperties().MetaProperties[DESC_METATAG].Value;
                              var fields = EOCInteraction.getAll();

                              if (!fields[fieldName]) {
                                EOCInteraction.add({
                                  name: fieldName,
                                  view: {
                                    _value: '',
                                    setValue: function setValue(value) {
                                      this._value = value;
                                    },
                                    getValue: function getValue() {
                                      return this._value;
                                    },
                                    checkValue: function checkValue() {
                                      return true;
                                    }
                                  }
                                });
                              }

                              var getdescData = EOCInteraction.get(fieldName) || '';
                              new gmxMediaDescription(EOCInteraction, getdescData, fieldName, 'edit', null, null, null, mediaDescDialogSettings);
                            });
                          });
                        });
                      });
                    }
                  }, {
                    id: 'warning-cancel',
                    text: 'Cancel',
                    click: function click() {
                      $(this).dialog("close");
                    }
                  }]
                });
              } else {
                var getdescData = EOCInteraction.get(fieldName);
                new gmxMediaDescription(EOCInteraction, getdescData, fieldName, 'edit', null, null, null, mediaDescDialogSettings);
              }
            });
            return mediaGUI[0];
          };

          return parametres;
        };

        nsGmx.EditObjectControl.addParamsHook(paramHook);
      }
    };
    gmxCore.addModule("MediaPlugin2", publicInterface, {// css: 'MediaPlugin2.css'
    });

    const _$4 = nsGmx$1.Utils._;

    //для отслеживания того, что не открыли диалог редактирования одного и того же объекта несколько раз
    var EditObjectControlsManager = {
        _editControls: [],
        _paramsHooks: [],

        find: function(layerName, oid)
        {
            for (var iD = 0; iD < this._editControls.length; iD++)
                if ( layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid )
                    return this._editControls[iD].control;
        },

        add: function(layerName, oid, control)
        {
            for (var iD = 0; iD < this._editControls.length; iD++)
                if ( layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid )
                {
                    this._editControls[iD].control = control;
                    return;
                }
            this._editControls.push({ layer: layerName, oid: oid, control: control });
        },

        remove: function(layerName, oid)
        {
            for (var iD = 0; iD < this._editControls.length; iD++)
                if ( layerName == this._editControls[iD].layer && oid == this._editControls[iD].oid )
                {
                    this._editControls.splice(iD, 1);
                    return;
                }
        },

        addParamsHook: function(paramsHook) {
            this._paramsHooks.push(paramsHook);
        },

        applyParamsHook: function(layerName, objectId, params) {
            for (var h = 0; h < this._paramsHooks.length; h++) {
                params = this._paramsHooks[h](layerName, objectId, params);
            }

            return params;
        }
    };

    var getInputElement = function(type)
    {
        var input = _input(null, [['dir','className','inputStyle edit-obj-input']]);

        if (type == 'date')
        {
            $(input).datepicker({
                changeMonth: true,
                changeYear: true,
                dateFormat: "dd.mm.yy"
            });
        }
        else if ( type == 'datetime' )
        {
            $(input).datetimepicker(
            {
                changeMonth: true,
                changeYear: true,
                dateFormat: "dd.mm.yy",
                timeFormat: "HH:mm:ss",
                showSecond: true,
                timeOnly: false
            });
        }
        else if ( type == "time" )
        {
            $(input).timepicker({
                timeOnly: true,
                timeFormat: "HH:mm:ss",
                showSecond: true
            });
        }

        return input;
    };

    //Коллекция полей с информацией для создания диалога редактирования
    var FieldsCollection = function() {
        var _asArray = [];
        var _asHash = {};

        this.append = function(field) {
            if (field.name && _asHash[field.name]) {
                var origIndex = _asHash[field.name].origIndex;
                $.extend(true, _asHash[field.name], field);
                _asHash[field.name].origIndex = origIndex;
            } else {
                field.origIndex = _asArray.length;
                _asArray.push(field);
                if (field.name) {
                    _asHash[field.name] = field;
                }
            }
        };

        this.get = function(name) {
            return _asHash[name];
        };

        this.each = function(callback) {
            _asArray.forEach(callback);
        };

        this.updateValue = function(name) {
            var field = _asHash[name];
            if (field && field.view) {
                field.value = field.view.getValue();
            }
            return field && field.value;
        };

        //Сначала isRequired, потом identityField, потом в порядке добавления
        this.sort = function() {
            _asArray = _asArray.sort(function(a, b) {
                if (!!a.isRequired !== !!b.isRequired) {
                    return Number(!!b.isRequired) - Number(!!a.isRequired);
                }

                if (!!a.identityField !== !!b.identityField) {
                    return Number(!!b.identityField) - Number(!!a.identityField);
                }

                var userZIndexDelta = (a.index || 0) - (b.index || 0);
                return userZIndexDelta || (a.origIndex - b.origIndex);
            });
        };
    };

    /** Объект, описывающий один атрибут слоя
     * @typedef {Object} nsGmx.EditObjectControl.FieldInfo
     * @property {String} name имя атрибута (обязательно)
     * @property {String|int} [value] значение атрибута в формате сервера
     * @property {bool} [constant=false] можно ли редактировать атрибут
     * @property {bool} [hide=false] совсем не показыавать этот атрибут
     * @property {String} [title=<совпадает с name>] что показывать вместо имени атрибута
     * @property {function(val):bool} [validate] ф-ция для валидации результата. На вход получает введённое пользователем значение
    *      (до преобразования в серверный формат), должна вернуть валидно ли это значение.
     * @property {String} [isRequired=false] является ли значение атрибута обязательным. Обязательные атрибуты показываются выше всех остальных и выделяются жирным шрифтом.
     * @property {Number} [index=0] индекс для сортировки. Влияет на порядок показа полей в диалоге. Больше - выше.
    */

    /** Контрол, который показывает диалог редактирования существующего или добавления нового объекта в слой.
    *
    * @memberOf nsGmx
    * @class
    * @param {String}   layerName ID слоя
    * @param {Number}   objectId ID объекта (null для нового объекта)
    * @param {Object}   [params] Дополнительные параметры контрола
    * @param {gmxAPI.drawingObject} [params.drawingObject] Пользовательский объект для задании геометрии или null, если геометрия не задана
    * @param {function} [params.onGeometrySelection] Внешняя ф-ция для выбора геометрии объекта.
             Сигнатура: function(callback), параметр callback(gmxAPI.drawingObject|geometry) должен быть вызван когда будет выбрана геометрия.
    * @param {HTMLNode} [params.geometryUI] HTML элемент, который нужно использовать вместо стандартных контролов для выбора геометрии (надпись + иконка)
    * @param {nsGmx.EditObjectControl.FieldInfo[]} [params.fields] массив с описанием характеристик атрибутов для редактирования . Должен содержать только атрибуты, которые есть в слое.
    * @param {bool} [params.allowDuplicates=<depends>] Разрешать ли несколько диалогов для редактирования/создания этого объекта.
             По умолчанию для редактирования запрещено, а для создания нового разрешено.
    * @param {HTMLNode | function(nsGmx.EditObjectControl): HTMLNode} [params.afterPropertiesControl] HTML элемент, который нужно поместить после списка атрибутов или ф-ция, которая возвращает этот элемент
    */
    var EditObjectControl = function(layerName, objectId, params)
    {
        /** Объект был изменён/добавлен
         * @event nsGmx.EditObjectControl#modify
         */

        /** Генерируется перед изменением/добавлением объекта. Может быть использован для сохранения в свойствах объекта каких-то внешних данных.
         * @event nsGmx.EditObjectControl#premodify
         */

        /** Закрытие диалога редактирования
         * @event nsGmx.EditObjectControl#close
         */

        if (_queryMapLayers.layerRights(layerName) !== 'edit' && _queryMapLayers.layerRights(layerName) !== 'editrows') {
            showErrorMessage(_gtxt('Недостаточно прав для редактирования объектов слоя'), true);
            return;
        }

        var isNew = objectId == null;
        var _params = $.extend({
                drawingObject: null,
                fields: [],
                validate: {},
                allowDuplicates: isNew,
                afterPropertiesControl: _span()
            }, params);

        _params = EditObjectControlsManager.applyParamsHook(layerName, objectId, _params);

        var _this = this;
        if (!_params.allowDuplicates && EditObjectControlsManager.find(layerName, objectId))
            return EditObjectControlsManager.find(layerName, objectId);

        EditObjectControlsManager.add(layerName, objectId, this);

        var lmap = nsGmx$1.leafletMap,
            layersByID = nsGmx$1.gmxMap.layersByID;
        var layer = layersByID[layerName];
        var geometryInfoContainer = _div(null, [['css','color','#215570'], ['css','fontSize','12px']]);

        var originalGeometry = null;
        var identityField = layer._gmx.properties.identityField;

        var geometryInfoRow = null;

        var drawingObjectLeafletID = null;
        var bindDrawingObject = function(obj)
        {
            geometryInfoRow && geometryInfoRow.RemoveRow();

            if (!obj) return;

            var InfoRow = gmxCore.getModule('DrawingObjects').DrawingObjectInfoRow;
            geometryInfoRow = new InfoRow(
                lmap,
                geometryInfoContainer,
                obj,
                { editStyle: false, allowDelete: false }
            );
            drawingObjectLeafletID = obj._leaflet_id;
        };

        var objStyle = params && params.event ? params.event.gmx.target.currentStyle : null;
        var bindGeometry = function(geom) {
            if (geom) {
                var geojson = new L.GeoJSON(geom),
    				styleParams = objStyle ? {
                        pointStyle: {
                            shape: 'box', color: objStyle.strokeStyle
                        },
                        lineStyle: {
                            color: objStyle.strokeStyle
                        }
                    } : {},
                    arr = lmap.gmxDrawing.addGeoJSON(geojson, styleParams);
                for (var i = 0, len = arr.length; i < len; i++) {
                    bindDrawingObject(arr[i]);
                }
            }
        };
        var fieldsCollection = new FieldsCollection();

        var createDialog = function()
        {
            var createButton = makeLinkButton(isNew ? _gtxt("Создать") : _gtxt("Изменить")),
                removeButton = makeLinkButton(_gtxt("Удалить")),
                isSaving = false;

            var canvas = _div(null, [['dir', 'className', 'edit-obj']]);

            $(canvas).bind('dragover', function() {
                return false;
            });

            $(canvas).bind('drop', function(e) {
                var files = e.originalEvent.dataTransfer.files;
                nsGmx$1.Utils.parseShpFile(files[0]).done(function(objs) {
                    bindGeometry(nsGmx$1.Utils.joinPolygons(nsGmx$1._.pluck(objs, 'geometry')));
                });
                return false;
            });

            removeButton.onclick = function()
            {
                _mapHelper.modifyObjectLayer(layerName, [{action: 'delete', id: objectId}]).done(function()
                {
                    removeDialog(dialogDiv);
                    closeFunc();
                });
            };

            removeButton.style.marginLeft = '10px';

            isNew && $(removeButton).hide();

            createButton.onclick = function()
            {
                if (isSaving) {
                    return;
                }

                $(_this).trigger('premodify');

                var properties = {};
                var anyErrors = false;

                fieldsCollection.each(function(field) {
                    var name = field.name;
                    if (!name) {
                        return;
                    }

                    var isValid = field.view.checkValue();
                    if (isValid) {
                        properties[name] = fieldsCollection.updateValue(name);
                    }
                    anyErrors = anyErrors || !isValid;
                });

                if (anyErrors) return;

                var obj = { properties: properties };

                var selectedGeom = _this.getGeometry();

                // if (!selectedGeom)
                // {
                    // showErrorMessage("Геометрия для объекта не задана", true, "Геометрия для объекта не задана");
                    // return;
                // }

                if (!isNew)
                {
                    obj.id = objectId;

                    var curGeomString = JSON.stringify(selectedGeom);
                    var origGeomString = JSON.stringify(originalGeometry);

                    if (origGeomString !== curGeomString) {
                        obj.geometry = selectedGeom;
                    }
                }
                else
                {
                    obj.geometry = selectedGeom;
                }

                isSaving = true;

                _mapHelper.modifyObjectLayer(layerName, [obj], 'EPSG:4326').done(function()
                {
                    $(_this).trigger('modify');
                    removeDialog(dialogDiv);
                    closeFunc();
                });
            };

            var resizeFunc = function(event, ui)
            {
                if (!isNew && $(canvas).children("[loading]").length)
                    return;

                canvas.firstChild.style.height = canvas.parentNode.offsetHeight - 25 - 10 - 10 + 'px';
            };

            var closeFunc = function()
            {
                // search for opened styles editing dialog
                if (drawingObjectLeafletID) {
                    var styleEditingDialog = $('.drawing-object-leaflet-id-' + drawingObjectLeafletID);
                }

                geometryInfoRow && geometryInfoRow.getDrawingObject() && nsGmx$1.leafletMap.gmxDrawing.remove(geometryInfoRow.getDrawingObject());

                originalGeometry = null;

                if (styleEditingDialog) {
                    removeDialog(styleEditingDialog);
                }

                EditObjectControlsManager.remove(layerName, objectId);

                $(_this).trigger('close');
            };

            var drawAttrList = function(fields)
            {
                var trs = [],
                    firstInput;

                //сначала идёт геометрия
                var geomTitleTmpl = Handlebars.compile('<span>' +
                    '<span class="edit-obj-geomtitle">{{i "Геометрия"}}</span>' +
                    '<span id = "choose-geom" class="gmx-icon-choose"></span>' +
                '</span>');

                var geometryUI = _params.geometryUI || $(geomTitleTmpl())[0];
                $('#choose-geom', geometryUI).click(function() {
                    if (_params.onGeometrySelection) {
                        _params.onGeometrySelection(bindGeometry);
                    } else {
                        nsGmx$1.Controls.chooseDrawingBorderDialog(
                            'editObject',
                            bindDrawingObject,
                            { geomType: layer.getGmxProperties().GeometryType }
                        );
                    }
                });

                trs.push(_tr([_td([geometryUI],[['css','height','20px']]), _td([geometryInfoContainer])]));

                fields.sort();

                //потом все остальные поля
                fields.each(function(field) {
                    var td = _td();
                    if (field.constant)
                    {
                        field.view = field.view || {
                            getUI: function() {
                                var span = _span(null,[['dir', 'className', 'edit-obj-constant-value']]);
                                span.rowName = field.name;
                                span.rowType = field.type;
                                if ('value' in field) {
                                    _$4(span, [_t(nsGmx$1.Utils.convertFromServer(field.type, field.value))]);
                                }
                                return span;
                            },
                            getValue: function() {return field.value},
                            setValue: function() {},
                            checkValue: function() { return true; }
                        };
                    }
                    else
                    {
                        field.view = field.view || {
                            getUI: function() {
                                if (!this._input) {
                                    var input = this._input = getInputElement(field.type);
                                    input.rowName = field.name;
                                    input.rowType = field.type;

                                    firstInput = firstInput || input;

                                    if ('value' in field)
                                        input.value = nsGmx$1.Utils.convertFromServer(field.type, field.value);
                                }
                                return this._input;
                            },
                            getValue: function() {
                                return nsGmx$1.Utils.convertToServer(field.type, this._input.value);
                            },
                            setValue: function(value) {
                                this._input.value = nsGmx$1.Utils.convertFromServer(field.type, value);
                            },
                            checkValue: function() {
                                var validationFunc = field.validate || _params.validate[field.name];
                                var isValid = !validationFunc || validationFunc(this._input.value);
                                if (!isValid) {
                                    inputError(this._input);
                                }
                                return isValid;
                            },
                            _input: null
                        };
                    }

                    _$4(td, [field.view.getUI(_this)]);

                    var fieldHeader = _span([_t(field.title || field.name)],[['css','fontSize','12px']]);
                    if (field.isRequired) {
                        fieldHeader.style.fontWeight = 'bold';
                    }
                    var tr = _tr([_td([fieldHeader]), td], [['css', 'height', '22px']]);

                    field.hide && $(tr).hide();

                    trs.push(tr);
                });

                var afterPropUI = typeof _params.afterPropertiesControl === 'function' ? _params.afterPropertiesControl(_this) : _params.afterPropertiesControl;

                _$4(canvas, [_div([_table([_tbody(trs)], [['dir', 'className', 'obj-edit-proptable']]), afterPropUI],[['dir', 'className', 'obj-edit-canvas'], ['css','overflow','auto']])]);

                _$4(canvas, [_div([createButton, removeButton],[['css','margin','10px 0px'],['css','height','20px']])]);

                firstInput && firstInput.focus();

                resizeFunc();
            };
    var prop = layer._gmx.properties;

            var dialogDiv = showDialog(isNew ? _gtxt("Создать объект слоя [value0]", prop.title) : _gtxt("Редактировать объект слоя [value0]", prop.title), canvas, 520, 300, false, false, resizeFunc, closeFunc);

            if (!isNew)
            {
                var loading = _div([_img(null, [['attr','src','img/progress.gif'],['css','marginRight','10px']]), _t(_gtxt('загрузка...'))], [['css','margin','3px 0px 3px 20px'],['attr','loading',true]]);

                _$4(canvas, [loading]);

                //получаем геометрию объекта
                sendCrossDomainJSONRequest(serverBase + "VectorLayer/Search.ashx?WrapStyle=func&layer=" + layerName + "&page=0&pagesize=1&orderby=" + identityField + "&geometry=true&query=[" + identityField + "]=" + objectId, function(response)
                {
                    if (!parseResponse(response))
                        return;

                    $(canvas).children("[loading]").remove();

                    var columnNames = response.Result.fields;
                    var geometryRow = response.Result.values.length > 0 ? response.Result.values[0] : [];
    				
    				if (geometryRow.length > 0) {
    					
    					var types = response.Result.types;
    					for (var i = 0; i < geometryRow.length; ++i)
    					{
    						if (columnNames[i] === 'geomixergeojson')
    						{
    							var geom = L.gmxUtil.geometryToGeoJSON(geometryRow[i], true);
    							if (geom) {
    								bindGeometry(geom);
    								originalGeometry = $.extend(true, {}, geom);
    							}
    						}
    						else
    						{
    							var field = {
    								value: geometryRow[i],
    								type: types[i],
    								name: columnNames[i],
    								constant: columnNames[i] === identityField,
    								identityField: columnNames[i] === identityField,
    								isRequired: false
    							};

    							fieldsCollection.append(field);
    						}
    					}

    					_params.fields.forEach(fieldsCollection.append);

    					drawAttrList(fieldsCollection);
    				}
                    else {
    					console.log('Geometry row is empty');
    					$(dialogDiv).dialog('close');
    				}

                    _this.initPromise.resolve();
                });
            }
            else
            {
                for (var i = 0; i < prop.attributes.length; ++i)
                {
                    fieldsCollection.append({type: prop.attrTypes[i], name: prop.attributes[i]});
                }

                _params.fields.forEach(fieldsCollection.append);

                if (_params.drawingObject) {
                    bindDrawingObject(_params.drawingObject);
                }

                drawAttrList(fieldsCollection);

                _this.initPromise.resolve();
            }
        };

        /** Promise для отслеживания момента полной инициализации диалога. Только после полной инициализации можно полноценно пользоваться методами get/set
          * @memberOf nsGmx.EditObjectControl.prototype
          * @member {jQuery.Deferred} initPromise
        */
        this.initPromise = $.Deferred();

        /** Получить текущее значение атрибута из контрола
          @memberOf nsGmx.EditObjectControl.prototype
          @param {String} fieldName Имя атрибута
          @method get
        */
        this.get = function(fieldName) {
            return fieldsCollection.updateValue(fieldName);
        };

        this.getAll = function() {
            var res = {};
            fieldsCollection.each(function(field) {
                res[field.name] = fieldsCollection.updateValue(field.name);
            });

            return res;
        };

        /** Задать значение атрибута объекта из контрола
          @memberOf nsGmx.EditObjectControl.prototype
          @method set
          @param {String} fieldName Имя атрибута
          @param {String|Integer} value Значение в клиентском формате, который нужно установить для этого атрибута
        */
        this.set = function(fieldName, value) {
            var field = fieldsCollection.get(fieldName);
            if (field) {
                field.view.setValue(value);
            }
        };

        /** Задать геометрию для редактируемого объекта
          @memberOf nsGmx.EditObjectControl.prototype
          @method setGeometry
          @param {gmxAPI.DrawingObject|geometry} geometry Геометрия в виде drawing объекта или просто описание геометрии
        */
        this.setGeometry = function(geometry) {
            bindGeometry(geometry);
        };

        this.getGeometryObj = function() {
            return geometryInfoRow ? geometryInfoRow.getDrawingObject() : null;
        };

        this.getGeometry = function() {
            if (geometryInfoRow) {
                var geom = geometryInfoRow.getDrawingObject();
                var geojson = geom.toGeoJSON();
                return geojson.geometry;
            } else {
                return null;
            }
        };

        this.getLayer = function() { return layer; };

        this.add = function(field) {
            fieldsCollection.append(field);
        };

        createDialog();
    };

    nsGmx$1.EditObjectControl = EditObjectControl;

    /** Добавить "хук" для модификации параметров при всех вызовах ф-ции {@link nsGmx.EditObjectControl}
        @function
        @param {function(Object): Object} {paramsHook} Ф-ция, которая принимает на вход параметры ф-ции {@link nsGmx.EditObjectControl}
            и возвращает модифицируемые параметры (возможна замена in place)
    */
    nsGmx$1.EditObjectControl.addParamsHook = EditObjectControlsManager.addParamsHook.bind(EditObjectControlsManager);

    //Тут кратко описываются разные внешние классы для системы генерации документации

    /** ГеоМиксер активно использует {@link http://jquery.com/|jQuery}
     * @namespace jQuery
     */

    /** Официальная документация: {@link http://api.jquery.com/category/deferred-object/|jQuery Deferred}
     * @name Deferred
     * @memberOf jQuery
     */


    /** Библиотека для формализации понятия модели и представления: {@link http://backbonejs.org/|Backbone}
     * @namespace Backbone
     */

    /** Официальная документация: {@link http://backbonejs.org/#Model| Backbone Model}
     * @name Model
     * @memberOf Backbone
     */


    /**
        Основное пространство имён ГеоМиксера
        @namespace
    */
    nsGmx$1.widgets = nsGmx$1.widgets || {};



    (function() {

        var gmxJSHost = window.gmxJSHost || '';

        if (!window.mapHostName && window.gmxJSHost) {
            window.mapHostName = /https?:\/\/(.*)\/api\//.exec(window.gmxJSHost)[1];
        }

        var _mapHostName; //откуда грузить API
        var protocol = window.location.protocol;

        if (window.mapHostName) {
            _mapHostName = protocol + '//' + window.mapHostName + '/api/';
        } else {
            var curUri = L.gmxUtil.parseUri(window.location.href);
            _mapHostName = protocol + '//' + curUri.host + curUri.directory;
        }

        var _serverBase = window.serverBase || /(.*)\/[^\/]*\//.exec(_mapHostName)[1] + '/';

        nsGmx$1.initGeoMixer = function() {

            var oSearchLeftMenu = new leftMenu$1();
            window.searchLogic = new nsGmx$1.SearchLogic();

            //для синхронизации меню и тулбара при включении/выключении сетки координат
            nsGmx$1.gridManager = {
                state: false,
                gridControl: null,
                options: null,
                menu: null,

                setState: function(state) {
                    var isActive = state.isActive,
                        options = state.options;

                    if (this.state == isActive) {
                        return;
                    }

                    //lazy instantantion
                    this.gridControl = this.gridControl || new L.GmxGrid();
                    nsGmx$1.leafletMap[isActive ? 'addLayer' : 'removeLayer'](this.gridControl);
                    if (options) {
                        this.restoreOptions(options);
                    }
                    this.state = isActive;
                    nsGmx$1.leafletMap.gmxControlIconManager.get('gridTool').setActive(isActive);
                    _menuUp.checkItem('mapGrid', isActive);
                    _mapHelper.gridView = isActive; //можно удалить?

                    if (this.state) {
                        this.configureGrid();
                    } else {
                        if (this.menu) {
                            this.menu.Unload();
                        }
                    }
                },

                saveOptions: function() {
                    this.options = this.gridControl.options;
                },

                restoreOptions: function(options) {
                    this.gridControl.setUnits(options.units);
                    if (options.customStep) {
                        this.gridControl.setStep(options.customStep.x, options.customStep.y);
                    }
                    this.gridControl.setColor(options.color);
                    this.gridControl.setTitleFormat(options.titleFormat);
                },

                configureGrid: function() {
                    var _this = this;
                    gmxCore$1.loadModule('GridPlugin', 'src/GridPlugin.js').then(function(def) {
                        _this.menu = new def.ConfigureGridMenu(nsGmx$1.gridManager);
                        _this.menu.Load();
                    });
                }
            };

            var createMenuNew = function() {
                //формирует описание элемента меню для включения/выключения плагина
                var getPluginToMenuBinding = function(pluginName, menuItemName, menuTitle) {
                    var plugin = nsGmx$1.pluginsManager.getPluginByName(pluginName);

                    if (!plugin) {
                        return null;
                    }

                    var sel = function() {
                        nsGmx$1.pluginsManager.setUsePlugin(pluginName, true);
                        nsGmx$1.pluginsManager.done(function() {
                            var paramsClone = $.extend(true, {}, plugin.params);
                            plugin.body.afterViewer && plugin.body.afterViewer(paramsClone, nsGmx$1.leafletMap);
                            _mapHelper.mapPlugins.addPlugin(pluginName, plugin.params);
                        });
                    };

                    var unsel = function() {
                        nsGmx$1.pluginsManager.setUsePlugin(pluginName, false);
                        nsGmx$1.pluginsManager.done(function() {
                            _mapHelper.mapPlugins.remove(pluginName);
                            plugin.body.unload && plugin.body.unload();
                        });
                    };

                    return {
                        id: menuItemName,
                        title: menuTitle,
                        onsel: sel,
                        onunsel: unsel,
                        checked: plugin.isUsed()
                    }
                };

                var isMapEditor = _queryMapLayers.currentMapRights() === 'edit',
                    isLogined = nsGmx$1.AuthManager.isLogin();

                _menuUp.submenus = [];

                _menuUp.addItem({
                    id: 'mapsMenu',
                    title: _gtxt('Карта'),
                    childs: [].concat(
                        isLogined ? [{ id: 'mapList', title: _gtxt('Открыть'), func: function() { _queryMapLayers.getMaps(); } }] : [], [{
                                id: 'mapCreate',
                                title: _gtxt('Создать'),
                                func: function() {
                                    _queryMapLayers.createMapDialog(_gtxt('Создать карту'), _gtxt('Создать'), _queryMapLayers.createMap);
                                }
                            },
                            { id: 'mapSave', title: _gtxt('Сохранить'), func: _queryMapLayers.saveMap },
                            {
                                id: 'mapSaveAs',
                                title: _gtxt('Сохранить как'),
                                func: function() {
                                    _queryMapLayers.createMapDialog(_gtxt('Сохранить карту как'), _gtxt('Сохранить'), _queryMapLayers.saveMapAs);
                                },
                                delimiter: true
                            },
                            {
                                id: 'export',
                                title: _gtxt('Экспорт'),
                                func: function() {
                                    mapExportMenu();
                                },
                                disabled: !isLogined
                            },
                            { id: 'shareMenu', title: _gtxt('Поделиться'), func: function() { _mapHelper.showPermalink(); } },
                            // {id: 'codeMap',      title: _gtxt('Код для вставки'),   func: function(){_mapHelper.createAPIMapDialog()}, disabled: true},
                            {
                                id: 'mapTabsNew',
                                title: _gtxt('Добавить закладку'),
                                func: function() {
                                    mapHelp.tabs.load('mapTabs');
                                    _queryTabs.add();
                                }
                            },
                            { id: 'printMap', title: _gtxt('Печать'), func: function() { _mapHelper.print(); }, delimiter: true },
                            {
                                id: 'mapProperties',
                                title: _gtxt('Свойства'),
                                func: function() {
                                    var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
                                    nsGmx$1.createMapEditor(div);
                                },
                                disabled: !isMapEditor
                            },
                            {
                                id: 'createGroup',
                                title: _gtxt('Добавить подгруппу'),
                                func: function() {
                                    var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
                                    nsGmx$1.addSubGroup(div, _layersTree);
                                },
                                disabled: !isMapEditor
                            },
                            {
                                id: 'mapSecurity',
                                title: _gtxt('Права доступа'),
                                func: function() {
                                    var securityDialog = new nsGmx$1.mapSecurity(),
                                        props = _layersTree.treeModel.getMapProperties();
                                    securityDialog.getRights(props.MapID, props.title);
                                },
                                disabled: !isMapEditor
                            }
                        ]
                    )
                });

                _menuUp.addItem({
                    id: 'dataMenu',
                    title: _gtxt('Данные'),
                    childs: [
                        { id: 'layerList', title: _gtxt('Открыть слой'), func: function() { _queryMapLayers.getLayers(); }, disabled: !isMapEditor },
                        {
                            id: 'createLayer',
                            title: _gtxt('Создать слой'),
                            childs: [
                                { id: 'createRasterLayer', title: _gtxt('Растровый'), func: _mapHelper.createNewLayer.bind(_mapHelper, 'Raster'), disabled: !isMapEditor },
                                { id: 'createVectorLayer', title: _gtxt('Векторный'), func: _mapHelper.createNewLayer.bind(_mapHelper, 'Vector'), disabled: !isMapEditor },
                                { id: 'createMultiLayer', title: _gtxt('Мультислой'), func: _mapHelper.createNewLayer.bind(_mapHelper, 'Multi'), disabled: !isMapEditor },
                                { id:'createVirtualLayer', title: 'Виртуальный', func: function() {

                                    gmxCore$1.loadModule('LayerEditor').then(function() {
                                        nsGmx$1.LayerEditor.addInitHook(function(layerEditor, layerProperties, params) {
                                            if (layerProperties.get('Type') !== 'Virtual') {
                                                return;
                                            }

                                            $(layerEditor).on('premodify', function() {
                                                layerProperties.set('ContentID', ui.find('.vlayer-contentid').val());
                                            });

                                            var template = Handlebars.compile('<div type="vlayer-container">' +
                                                '<span class="vlayer-label">Тип слоя</span>' +
                                                '<input class="vlayer-contentid inputStyle" value="{{ContentID}}">' +
                                            '</div>');

                                            var ui = $(template({ContentID: layerProperties.get('ContentID')}));

                                            params.additionalUI = params.additionalUI || {};
                                            params.additionalUI.main = params.additionalUI.advanced || [];
                                            params.additionalUI.main.push(ui);
                                        });

                                        var parent = _div(null, [['attr','id','newVirtualLayer'], ['css', 'height', '100%']]),
                                            properties = {Title:'', Description: '', Date: ''};

                                        var dialogDiv = showDialog('Создать виртуальный слой', parent, 340, 340, false, false);

                                        nsGmx$1.createLayerEditor(false, 'Virtual', parent, properties, {
                                            doneCallback: function() {
                                                removeDialog(dialogDiv);
                                            }
                                        });
                                    });

                                    }, disabled: !isMapEditor
                                }
                            ],
                            disabled: !isMapEditor
                        },
                        {
                            id: 'baseLayers',
                            title: _gtxt('Базовые слои'),
                            func: function() {
                                var div = $(_layersTree._treeCanvas).find('div[MapID]')[0];
                                nsGmx$1.createMapEditor(div, 1);
                            },
                            delimiter: true,
                            disabled: !isMapEditor
                        },
                        { id: 'loadFile', title: _gtxt('Загрузить объекты'), func: drawingObjects.loadShp.load, delimiter: true },
                        { id: 'loadPhotos', title: _gtxt('Загрузить фотографии'), func: function() { PhotoLayerDialog(); }, delimiter: true, disabled: !isMapEditor },
                        { id: 'wms', title: _gtxt('Подключить WMS'), func: loadServerData.WMS.load },
                        { id: 'wfs', title: _gtxt('Подключить WFS'), func: loadServerData.WFS.load }
                    ]
                });

                _menuUp.addItem({
                    id: 'viewMenu',
                    title: _gtxt('Вид'),
                    childs: [
                        { id: 'externalMaps', title: _gtxt('Дополнительные карты'), func: mapHelp.externalMaps.load },
                        { id: 'mapTabs', title: _gtxt('Закладки'), func: mapHelp.tabs.load },
                        { id: 'DrawingObjects', title: _gtxt('Объекты'), func: oDrawingObjectGeomixer.Load }
                        // {id:'searchView',     title: _gtxt('Результаты поиска'),    func: oSearchControl.Load}
                    ]
                });

                _menuUp.addItem({
                    id: 'instrumentsMenu',
                    title: _gtxt('Инструменты'),
                    childs: [{
                            id: 'mapGrid',
                            title: _gtxt('Координатная сетка'),
                            onsel: nsGmx$1.gridManager.setState.bind(nsGmx$1.gridManager, { isActive: true }),
                            onunsel: nsGmx$1.gridManager.setState.bind(nsGmx$1.gridManager, { isActive: false }),
                            checked: _mapHelper.gridView
                        },
                        {
                            id: 'mapIndexGrid',
                            title: _gtxt('Индексная сетка'),
                            func: function() {
                                indexGridMenu();
                            }
                        },
                        {
                            id: 'buffer',
                            title: _gtxt('Создание буферных зон'),
                            func: function() {
                                BufferZonesMenu();
                            },
                            disabled: !isLogined
                        },
                        { id: 'shift', title: _gtxt('Ручная привязка растров'), func: function() {}, disabled: true },
                        { id: 'crowdsourcing', title: _gtxt('Краудсорсинг данных'), func: function() {}, disabled: true },
                        { id: 'geocoding', title: _gtxt('Пакетный геокодинг'), func: function() {}, disabled: true },
                        { id: 'directions', title: _gtxt('Маршруты'), func: function() {}, disabled: true }
                    ]
                });


                function fillPluginsMenu() {
                    var plugins = window.menuPlugins || [];

                    // для локальной версии Геомиксера покажем плагины кадастра и Викимапии
                    if (!window.menuPlugins) {
                        if (nsGmx$1.pluginsManager.getPluginByName('Cadastre')) {
                            plugins.push({ pluginName: 'Cadastre', menuItemName: 'cadastre', menuTitle: 'Кадастр Росреестра' });
                        }
                    }

                    if (plugins.length) {
                        var childs = [];
                        for (var p = 0; p < plugins.length; p++) {
                            childs.push(
                                getPluginToMenuBinding(
                                    plugins[p].pluginName,
                                    plugins[p].menuItemName,
                                    window._gtxt(plugins[p].menuTitle)
                                )
                            );
                        }

                        _menuUp.addItem({ id: 'pluginsMenu', title: _gtxt('Сервисы'), childs: childs });
                    }
                }
                fillPluginsMenu();

                _menuUp.addItem({
                    id: 'helpMenu',
                    title: _gtxt('Справка'),
                    childs: nsGmx$1.gmxMap.properties.MapID !== '31RJS' ? [
                        { id: 'about', title: _gtxt('О проекте'), func: _mapHelper.version },
                    ].concat(window.mapsSite ? [{
                            id: 'usage',
                            title: _gtxt('Руководство пользователя'),
                            func: function() {
                                window.open('http://geomixer.ru/index.php/docs/', '_blank');
                            }
                        },
                        {
                            id: 'api',
                            title: _gtxt('GeoMixer API'),
                            func: function() {
                                window.open('https://geomixer.ru/docs/dev-manual/rest-api/get-started/', '_blank');
                            }
                        },
                        {
                            id: 'pluginsUsage',
                            title: _gtxt('Использование плагинов'),
                            func: function() {
                                window.open('http://geomixer.ru/index.php/docs/manual/plugins', '_blank');
                            }
                        }
                    ] : []) : [{
                            id: 'usage',
                            title: _gtxt('Руководство'),
                            func: function() {
                                window.open(window.location.protocol + '//kosmosnimki.ru/downloads/%D1%86%D1%81%D0%BC%D1%81.pdf', '_blank');
                            }
                        }]
                });
            };

            var createToolbar = function() {
                var lmap = nsGmx$1.leafletMap;

                var SliderControl = L.Control.extend({
                    options: {
                        position: 'topleft'
                    },
                    onAdd: function(map) {
                        var sliderContainer = $('<div class="gmx-slider-control"></div>');
                        this._widget = new nsGmx$1.TransparencySliderWidget(sliderContainer);

                        $(this._widget).on('slide slidechange', function(event, ui) {
                            _queryMapLayers.applyOpacityToRasterLayers(ui.value * 100, _queryMapLayers.buildedTree);
                        });

                        return sliderContainer[0];
                    },
                    onRemove: function() {},
                    isCollapsed: function() { return this._widget.isCollapsed(); }
                });
                var sliderControl = new SliderControl();
                lmap.addControl(sliderControl);

                //пополняем тулбар
                var uploadFileIcon = L.control.gmxIcon({
                    id: 'uploadFile',
                    title: _gtxt('Загрузить объекты')
                }).on('click', drawingObjects.loadShp.load.bind(drawingObjects.loadShp));

                lmap.gmxControlIconManager.get('drawing').addIcon(uploadFileIcon);

                // выпадающие группы иконок наезжают на слайдер прозрачности.
                // Эта ф-ция разруливает этот конфликт, скрывая слайдер в нужный момент
                var resolveToolConflict = function(iconGroup) {
                    iconGroup
                        .on('collapse', function() {
                            $('.gmx-slider-control').removeClass('invisible');
                        }).on('expand', function() {
                            sliderControl.isCollapsed() || $('.gmx-slider-control').addClass('invisible');
                        });
                };

                if (_queryMapLayers.currentMapRights() === 'edit') {

                    var saveMapIcon = L.control.gmxIcon({
                            id: 'saveMap',
                            title: _gtxt('Сохранить карту'),
                            addBefore: 'drawing'
                        })
                        .addTo(lmap)
                        .on('click', _queryMapLayers.saveMap.bind(_queryMapLayers));

                    //группа создания слоёв
                    var createVectorLayerIcon = L.control.gmxIcon({
                        id: 'createVectorLayer',
                        title: _gtxt('Создать векторный слой'),
                        addBefore: 'drawing'
                    }).on('click', function() {
                        _mapHelper.createNewLayer('Vector');
                        createVectorLayerIcon.setActive(true);
                        createRasterLayerIcon.setActive(false);
                    });

                    var createRasterLayerIcon = L.control.gmxIcon({
                        id: 'createRasterLayer',
                        title: _gtxt('Создать растровый слой'),
                        addBefore: 'drawing'
                    }).on('click', function() {
                        _mapHelper.createNewLayer('Raster');
                        createRasterLayerIcon.setActive(true);
                        createVectorLayerIcon.setActive(false);
                    });

                    var createLayerIconGroup = L.control.gmxIconGroup({
                        id: 'createLayer',
                        isSortable: true,
                        //isCollapsible: false,
                        items: [createVectorLayerIcon, createRasterLayerIcon],
                        addBefore: 'drawing'
                    }).addTo(lmap);

                    var bookmarkIcon = L.control.gmxIcon({
                        id: 'bookmark',
                        title: _gtxt('Добавить закладку'),
                        addBefore: 'drawing'
                    }).on('click', function() {
                        mapHelp.tabs.load('mapTabs');
                        _queryTabs.add();
                    }).addTo(lmap);

                    resolveToolConflict(createLayerIconGroup);
                } else {
                    resolveToolConflict(lmap.gmxControlIconManager.get('drawing'));
                }

                var printIcon = L.control.gmxIcon({
                        id: 'gmxprint',
                        title: _gtxt('Печать'),
                        addBefore: 'drawing'
                    })
                    .addTo(lmap)
                    .on('click', _mapHelper.print.bind(_mapHelper));

                var permalinkIcon = L.control.gmxIcon({
                        id: 'permalink',
                        title: _gtxt('Ссылка на карту'),
                        addBefore: 'drawing'
                    })
                    .addTo(lmap)
                    .on('click', _mapHelper.showPermalink.bind(_mapHelper));

                if (window.mapsSite) {
                    var shareIconControl = new nsGmx$1.ShareIconControl({
                        className: 'shareIcon',
                        id: 'share',
                        text: 'Share',
                        style: {
                            width: 'auto'
                        },
                        togglable: true,
                        permalinkManager: {
                            save: function() {
                                return $.when(
                                    _mapHelper.createPermalink(),
                                    nsMapCommon.generateWinniePermalink()
                                )
                            }
                        },
                        permalinkUrlTemplate: '{{href}}?permalink={{permalinkId}}',
                        embeddedUrlTemplate: window.location.protocol + '//winnie.kosmosnimki.ru/2.0/?config={{winnieId}}',
                        winnieUrlTemplate: window.location.protocol + '//winnie.kosmosnimki.ru/2.0/?config={{winnieId}}&edit=1',
                        previewUrlTemplate: 'iframePreview.html?width={{width}}&height={{height}}&permalinkUrl={{{embeddedUrl}}}'
                    });
                    lmap.addControl(shareIconControl);
                }

                var gridIcon = L.control.gmxIcon({
                        id: 'gridTool',
                        title: _gtxt('Координатная сетка'),
                        togglable: true,
                        addBefore: 'drawing'
                    })
                    .addTo(lmap)
                    .on('click', function() {
                        var state = { isActive: gridIcon.options.isActive };
                        nsGmx$1.gridManager.setState(state);
                    });

                _mapHelper.customParamsManager.addProvider({
                    name: 'GridManager',
                    loadState: function(state) {
                        nsGmx$1.gridManager.setState(state);
                    },
                    saveState: function() {
                        return {
                            version: '1.0.0',
                            isActive: gridIcon.options.isActive,
                            options: nsGmx$1.gridManager.options
                        }
                    }
                });

                lmap.addControl(L.control.gmxIcon({
                    id: 'boxzoom-dashed-rounded',
                    toggle: true,
                    addBefore: 'drawing',
                    title: 'Увеличение',
                    onAdd: function(control) {
                        var map = control._map,
                            _onMouseDown = map.boxZoom._onMouseDown;
                        map.boxZoom._onMouseDown = function(e) {
                            _onMouseDown.call(map.boxZoom, {
                                clientX: e.clientX,
                                clientY: e.clientY,
                                which: 1,
                                shiftKey: true
                            });
                        };
                        map.on('boxzoomend', function() {
                            map.dragging.enable();
                            map.boxZoom.removeHooks();
                            control.setActive(false);
                        });
                    },
                    stateChange: function(control) {
                        var map = control._map;
                        if (control.options.isActive) {
                            map.dragging.disable();
                            map.boxZoom.addHooks();
                        } else {
                            map.dragging.enable();
                            map.boxZoom.removeHooks();
                        }
                    }
                }));

                /**
                 * seachParams
                 */

                 var osmProvider = new nsGmx$1.searchProviders.Osm2DataProvider({
                     showOnMap: true,
                     serverBase: '//maps.kosmosnimki.ru',
                     limit: 10
                 });

                 var searchProviders = [];
                 searchProviders.push(osmProvider);

                 osmProvider.addEventListener('fetch', function (e) {
                     window.searchLogic.showResult(e.detail);
                 });

                window.searchControl = new main_4({
                    id: 'searchcontrol',
                    placeHolder: 'Поиск по векторным слоям и адресной базе',
                    position: 'topright',
                    limit: 10,
                    retrieveManyOnEnter: true,
                    providers: searchProviders,
                    style: {
                        editable: false,
                        map: true,
                        pointStyle: {
                            size: 8,
                            weight: 1,
                            opacity: 1,
                            color: '#00008B'
                        },
                        lineStyle: {
                            fill: false,
                            weight: 3,
                            opacity: 1,
                            color: '#008B8B'
                        }
                    }
                });

                window.searchLogic.searchControl = window.searchControl;

                lmap.addControl(window.searchControl);
                lmap.gmxControlsManager.add(window.searchControl);
                // shitty trick
                // 'cause Aryunov doesn't use controls id
                window.searchControl._container._id = 'searchcontrol';

                var searchContainer = window.searchControl._widget._container;
                var stop = L.DomEvent.stopPropagation;

                L.DomEvent
                    .on(searchContainer, 'mousemove', stop)
                    .on(searchContainer, 'touchstart', stop)
                    .on(searchContainer, 'mousedown', stop)
                    .on(searchContainer, 'dblclick', stop)
                    .on(searchContainer, 'contextmenu', stop)
                    .on(searchContainer, 'click', stop);

                var gmxLayers = new L.control.gmxLayers2(null, null, {
                    title: window._gtxt('Панель оверлеев'),
                    collapsed: true,
                    togglable: true,
                    addBefore: 'searchcontrol',
                    direction: '',
                    placeHolder: window._gtxt("оверлеи отсутствуют")

                });

                lmap.addControl(gmxLayers);
                lmap.gmxControlsManager.add(gmxLayers);
            };

            var createDefaultMenu = function() {
                _menuUp.submenus = [];

                _menuUp.addItem({
                    id: 'mapsMenu',
                    title: _gtxt('Карта'),
                    childs: [
                        { id: 'mapCreate', title: _gtxt('Создать'), func: function() { _queryMapLayers.createMapDialog(_gtxt('Создать карту'), _gtxt('Создать'), _queryMapLayers.createMap); } },
                        { id: 'mapList', title: _gtxt('Открыть'), func: function() { _queryMapLayers.getMaps(); } }
                    ]
                });

                _menuUp.addItem({
                    id: 'helpMenu',
                    title: _gtxt('Справка'),
                    childs: [
                        { id: 'usage', title: _gtxt('Использование'), onsel: mapHelp.mapHelp.load, onunsel: mapHelp.mapHelp.unload },
                        { id: 'serviceHelp', title: _gtxt('Сервисы'), onsel: mapHelp.serviceHelp.load, onunsel: mapHelp.serviceHelp.unload },
                        { id: 'about', title: _gtxt('О проекте'), func: _mapHelper.version }
                    ]
                });
            };

            var parseURLParams = function() {
                var q = window.location.search,
                    kvp = (q.length > 1) ? q.substring(1).split('&') : [];

                for (var i = 0; i < kvp.length; i++) {
                    kvp[i] = kvp[i].split('=');
                }

                var params = {},
                    givenMapName = false;

                for (var j = 0; j < kvp.length; j++) {
                    if (kvp[j].length == 1) {
                        if (!givenMapName)
                            givenMapName = decodeURIComponent(kvp[j][0]);
                    } else {
                        params[kvp[j][0]] = kvp[j][1];
                    }
                }

                return { params: params, givenMapName: givenMapName };
            };

            $(function() {

                var virtualLayerManager = new nsGmx$1.VirtualLayerManager();
                L.gmx.addLayerClassLoader(virtualLayerManager.loader);

                $('body').on('keyup', function(event) {
                    if ((event.target === document.body || $(event.target).hasClass('leaflet-container')) && event.keyCode === 79) {
                        _queryMapLayers.getMaps();
                        return false;
                    }
                });

                var languageFromSettings = translationsHash.getLanguageFromCookies() || window.defaultLang;
                window.language = languageFromSettings || 'rus';

                window.shownTitle = window.pageTitle || _gtxt('ScanEx Web Geomixer - просмотр карты');
                document.title = window.shownTitle;

                window.serverBase = _serverBase;

                addParseResponseHook('*', function(response, customErrorDescriptions) {
                    if (response.Warning) {
                        //мы дожидаемся загрузки дерева слоёв, чтобы не добавлять notification widget слишком рано (до инициализации карты в контейнере)
                        _queryMapLayers.loadDeferred.then(function() {
                            nsGmx$1.widgets.notifications.stopAction(null, 'warning', response.Warning, 0);
                        });
                    }
                });

                var customErrorTemplate = Handlebars.compile('<div class="CustomErrorText">{{description}}</div>'),
                    commonErrorTemplate = Handlebars.compile(
                        '<div class="CommonErrorText"><table class="CommonErrorTable">' +
                        '<tr><td>{{message}}</td></tr>' +
                        '<tr class="StacktraceContainer"><td class="StacktraceContainer">{{#if stacktrace}}<textarea class="inputStyle error StacktraceErrorText">{{stacktrace}}</textarea>{{/if}}</td></tr>' +
                        '</table></div>'
                    );

                //при каждой ошибке от сервера будем показывать диалог с ошибкой и стектрейсом.
                addParseResponseHook('error', function(response, customErrorDescriptions) {
                    var errInfo = response.ErrorInfo;

                    if (errInfo.ErrorMessage && !errInfo.ErrorMessage in _mapHelper.customErrorsHash) {
                        if (customErrorDescriptions && errInfo.ExceptionType in customErrorDescriptions) {
                            var canvas = $(customErrorTemplate({
                                description: customErrorDescriptions[errInfo.ExceptionType]
                            }));
                            showDialog(_gtxt('Ошибка!'), canvas[0], 220, 100);
                        } else {
                            var stackTrace = response.ErrorInfo.ExceptionType && response.ErrorInfo.StackTrace;
                            var canvas = $(commonErrorTemplate({
                                message: errInfo.ErrorMessage,
                                stacktrace: stackTrace
                            }));
                            showDialog(_gtxt('Ошибка сервера'), canvas[0], 220, 170, false, false);
                            return false;
                        }
                    }
                });

                _translationsHash.addErrorHandler(function(text) {
                    showErrorMessage$1('Не найдено тектовое описание для "' + text + '"');
                });

                nsGmx$1.pluginsManager = new(gmxCore$1.getModule('PluginsManager').PluginsManager)();

                //будем сохранять в пермалинке все активные плагины
                _mapHelper.customParamsManager.addProvider({
                    name: 'PluginManager',
                    loadState: function(state) {
                        for (var p in state.usage) {
                            var plugin = nsGmx$1.pluginsManager.getPluginByName(p);

                            plugin && plugin.setUsage(state.usage[p] ? 'used' : 'notused');
                        }
                    },
                    saveState: function() {
                        var usage = {};
                        nsGmx$1.pluginsManager.forEachPlugin(function(plugin) {
                            if (plugin.pluginName) {
                                usage[plugin.pluginName] = plugin.isUsed();
                            }
                        });

                        return {
                            version: '1.0.0',
                            usage: usage
                        }
                    }
                });

                //сейчас подгружаются все глобальные плагины + все плагины карт, у которых нет имени в конфиге
                nsGmx$1.pluginsManager.done(function() {
                    nsGmx$1.AuthManager.checkUserInfo(function() {
                        nsGmx$1.pluginsManager.beforeMap();

                        var parsedURL = parseURLParams();

                        parseReferences(parsedURL.params, parsedURL.givenMapName);

                    }, function() {
                        //TODO: обработка ошибок
                    });
                });
            });

            function parseReferences(params, givenMapName) {
                window.documentHref = window.location.href.split('?')[0];

                if (params['permalink']) {
                    eraseCookie$1('TinyReference');
                    createCookie('TinyReference', params['permalink']);

                    if (location.search.indexOf('debug=1') === -1) {
    					window.location.replace(documentHref + (givenMapName ? ('?' + givenMapName) : ''));
    				} else {
    					var tinyRef = readCookie('TinyReference');
    					_mapHelper.restoreTinyReference(tinyRef, function(obj) {
    						if (obj.mapName) {
    							window.globalMapName = obj.mapName;
    						}
    						loadMap(obj);
    					});
    				}
                    return;
                }

                var defaultState = { isFullScreen: params['fullscreen'] == 'true' || params['fullscreen'] == 'false' ? params['fullscreen'] : 'false' };

                if ('x' in params && 'y' in params && 'z' in params &&
                    !isNaN(Number(params.x)) && !isNaN(Number(params.y)) && !isNaN(Number(params.z)))
                    defaultState.position = { x: Number(params.x), y: Number(params.y), z: Number(params.z) };

                if ('mx' in params && 'my' in params &&
                    !isNaN(Number(params.mx)) && !isNaN(Number(params.my)))
                    defaultState.marker = { mx: Number(params.mx), my: Number(params.my), mt: 'mt' in params ? params.mt : false };

                if ('mode' in params)
                    defaultState.mode = params.mode;

                if ('dt' in params) {
                    defaultState.dt = params.dt;
                }

                window.defaultMapID = typeof window.defaultMapID !== 'undefined' ? window.defaultMapID : 'DefaultMap';

                var mapName = window.defaultMapID && !givenMapName ? window.defaultMapID : givenMapName;

                window.globalMapName = mapName;

                if (!window.globalMapName) {
                    // нужно прописать дефолтную карту в конфиге
                    alert(_gtxt('$$phrase$$_1'));

                    return;
                } else {
                    checkUserInfo(defaultState);
                }
            }

            function checkUserInfo(defaultState) {
                var tinyRef = readCookie('TinyReference');

                if (tinyRef) {
                    eraseCookie$1('TinyReference');
                    _mapHelper.restoreTinyReference(tinyRef, function(obj) {
                        if (obj.mapName) {
                            window.globalMapName = obj.mapName;
                        }
                        loadMap(obj);
                    }, function() {
                        loadMap(defaultState); //если пермалинк какой-то не такой, просто открываем дефолтное состояние
                    });

                    var tempPermalink = readCookie('TempPermalink');

                    if (tempPermalink && tempPermalink == tinyRef) {
                        nsGmx$1.Utils.TinyReference.remove(tempPermalink);
                        eraseCookie$1('TempPermalink');
                    }
                } else {
                    loadMap(defaultState);
                }
            }


            window.layersShown = true;

            window.resizeAll = function() {
                if (window.printMode) {
                    return;
                }

                var top = 0,
                    bottom = 0,
                    right = 0,
                    left,
                    headerHeight = $('#header').outerHeight(),
                    mainDiv = $('#flash')[0];

                if (window.exportMode) {
                    left = 0;
                } else {
                    if (window.iconSidebarWidget)  {
                        left = window.iconSidebarWidget.getWidth();
                    } else {
                        left = layersShown ? 400 : 40;
                    }
                }
                mainDiv.style.left = left + 'px';
                mainDiv.style.top = top + 'px';
                mainDiv.style.width = getWindowWidth() - left - right + 'px';
                mainDiv.style.height = getWindowHeight() - top - headerHeight - bottom + 'px';

                nsGmx$1.leafletMap && nsGmx$1.leafletMap.invalidateSize();

                if (layersShown) {
                    $('#leftMenu').show();

                    var mapNameHeight = $('.mainmap-title').outerHeight();

                    var baseHeight = getWindowHeight() - top - bottom - headerHeight;

                    $('#leftMenu')[0].style.height = baseHeight + 'px';

                    var leftContentContainer = $('#leftContent')[0];
                    if (leftContentContainer) {
                        leftContentContainer.style.top = ($('#leftPanelHeader')[0].offsetHeight + mapNameHeight) + 'px';
                        leftContentContainer.style.height = baseHeight -
                            $('#leftPanelHeader')[0].offsetHeight -
                            $('#leftPanelFooter')[0].offsetHeight -
                            mapNameHeight + 'px';
                    }
                } else {
                    $('#leftMenu').hide();
                }
            };

            var editUIInited = false;
            var initEditUI = function() {
                if (editUIInited) {
                    return;
                }

                var isEditableLayer = function(layer) {
                    var props = layer.getGmxProperties(),
                        layerRights = _queryMapLayers.layerRights(props.name);

                    return props.type === 'Vector' &&
                        (layerRights === 'edit' || layerRights === 'editrows');
                };

                var hasEditableLayer = false;
                for (var iL = 0; iL < nsGmx$1.gmxMap.layers.length; iL++)
                    if (isEditableLayer(nsGmx$1.gmxMap.layers[iL])) {
                        hasEditableLayer = true;
                        break;
                    }

                if (!hasEditableLayer) return;

                //добавляем пункт меню к нарисованным объектам
                nsGmx$1.ContextMenuController.addContextMenuElem({
                    title: _gtxt('EditObject.drawingMenuTitle'),
                    isVisible: function(context) {
                        var active = $(_queryMapLayers.treeCanvas).find('.active');

                        //должен быть векторный слой
                        if (!active[0] || !active[0].parentNode.getAttribute('LayerID') ||
                            !active[0].parentNode.gmxProperties.content.properties.type === 'Vector') {
                            return false;
                        }

                        //TODO: проверить тип геометрии

                        var layer = nsGmx$1.gmxMap.layersByID[active[0].parentNode.gmxProperties.content.properties.name];

                        //слой поддерживает редактирование и у нас есть права на это
                        return isEditableLayer(layer);
                    },
                    clickCallback: function(context) {
                        var active = $(_queryMapLayers.treeCanvas).find('.active');
                        var layerName = active[0].parentNode.gmxProperties.content.properties.name;
                        new nsGmx$1.EditObjectControl(layerName, null, { drawingObject: context.obj });
                    }
                }, 'DrawingObject');

                //добавляем пункт меню ко всем слоям
                nsGmx$1.ContextMenuController.addContextMenuElem({
                    title: _gtxt('EditObject.menuTitle'),
                    isVisible: function(context) {
                        var layer = nsGmx$1.gmxMap.layersByID[context.elem.name];
                        return !context.layerManagerFlag && isEditableLayer(layer);
                    },
                    clickCallback: function(context) {
                        new nsGmx$1.EditObjectControl(context.elem.name);
                    }
                }, 'Layer');

                //добавляем тул в тублар карты
                var listeners = {};
                var pluginPath = gmxCore$1.getModulePath('EditObjectPlugin');

                var editIcon = L.control.gmxIcon({
                    id: 'editTool',
                    title: _gtxt('Редактировать'),
                    togglable: true,
                    addBefore: 'gmxprint'
                }).addTo(nsGmx$1.leafletMap);

                editIcon.on('statechange', function() {
                    if (editIcon.options.isActive) {

                        var clickHandler = function(event) {
                            var layer = event.target,
                                props = layer.getGmxProperties(),
                                id = event.gmx.properties[props.identityField];

                            layer.bringToTopItem(id);
                            new nsGmx$1.EditObjectControl(props.name, id, { event: event });
                            return true; // TODO: как oтключить дальнейшую обработку события
                        };

                        for (var iL = 0; iL < nsGmx$1.gmxMap.layers.length; iL++) {
                            var layer = nsGmx$1.gmxMap.layers[iL],
                                props = layer.getGmxProperties();

                            if (layer.disableFlip && layer.disablePopup) {
                                layer.disableFlip();
                                layer.disablePopup();
                            }

                            listeners[props.name] = clickHandler.bind(null); //bind чтобы были разные ф-ции
                            if (layer instanceof L.gmx.VectorLayer) {
    							layer.on('click', listeners[props.name]);
    						}
                        }
                    } else {
                        for (var layerName in listeners) {
                            var pt = listeners[layerName];
                            var layer = nsGmx$1.gmxMap.layersByID[layerName];
                            if (layer && layer instanceof L.gmx.VectorLayer) {
                                layer.off('click', listeners[layerName]);
                                if (layer.getGmxProperties().type !== 'Virtual') {
                                    layer.enableFlip();
                                    layer.enablePopup();
                                }
                            }
                        }
                        listeners = {};
                    }
                });

                editUIInited = true;
            };

            function initAuthWidget() {
                var registrationCallback = function() {
                    gmxCore$1.loadModule('ProfilePlugin').then(function(AccountModule) {
                        AccountModule.showRegistrationForm(function() {
                            window.location.reload();
                        });
                    });
                };

                var nativeAuthWidget = new nsGmx$1.GeoMixerAuthWidget($('<div/>')[0], nsGmx$1.AuthManager, function() {
                    _mapHelper.reloadMap();
                }, { registrationCallback: registrationCallback });

                // прокси между nsGmx.AuthManager редактора и AuthManager'а из общей библиотеки
                var authManagerProxy = {
                    getUserInfo: function() {
                        var def = $.Deferred();
                        nsGmx$1.AuthManager.checkUserInfo(function() {
                            var auth = nsGmx$1.AuthManager;
                            def.resolve({
                                Status: 'ok',
                                Result: {
                                    Login: auth.getLogin(),
                                    Nickname: auth.getNickname(),
                                    FullName: auth.getFullname()
                                }
                            });
                        });
                        return def;
                    },

                    login: function() {
                        nativeAuthWidget.showLoginDialog();
                    },

                    logout: function() {
                        var def = $.Deferred();
                        nsGmx$1.AuthManager.logout(function() {
                            def.resolve({ Status: 'ok', Result: {} });
                            _mapHelper.reloadMap();
                        });
                        return def;
                    },
                    getNative: function() {
                        return nativeAuthWidget;
                    }
                };

                nsGmx$1.widgets.authWidget = new nsGmx$1.AuthWidget({
                    authManager: authManagerProxy,
                    showAccountLink: !!window.mapsSite,
                    accountLink: null,
                    showMapLink: !!window.mapsSite,
                    changePassword: !window.mapsSite,
                    isAdmin: nsGmx$1.AuthManager.isRole(nsGmx$1.ROLE_ADMIN),
                    callbacks: {
                        'authWidget-usergroupMenuItem': showUserList
                    }
                });

                var authPlaceholder = nsGmx$1.widgets.header.getAuthPlaceholder();
                nsGmx$1.widgets.authWidget.appendTo(authPlaceholder);

                authPlaceholder.on('click', '#AuthWidgetAccountLink', function() {
                    gmxCore$1.loadModule('ProfilePlugin').then(function(AccountModule) {
                        AccountModule.showProfile();
                    });
                });

                //ugly hack
                nsGmx$1.widgets.authWidget.showLoginDialog = nativeAuthWidget.showLoginDialog.bind(nativeAuthWidget);
            }


            function loadMap(state) {
                //при переходе на новое API мы изменили место хранения мапплетов карты
                //раньше мапплеты хранились в свойстве onLoad карты
                //теперь - внутри клиентских данных (UserData)

                nsGmx$1.mappletLoader = {
                    _script: '',

                    //UserObjectsManager interface
                    collect: function() {
                        return this._script;
                    },
                    load: function(data) {
                        this._script = data;
                    },

                    //self public interface
                    execute: function() {
                        if (this._script) {
                            var evalStr = '(' + this._script + ')';
                            try {
                                eval(evalStr)();
                            } catch (e) {
                                console.error(e);
                            }
                        }
                    },
                    get: function() {
                        return this._script;
                    },
                    set: function(data) {
                        this._script = data;
                    }
                };
                nsGmx$1.userObjectsManager.addDataCollector('mapplet_v2', nsGmx$1.mappletLoader);

                layersShown = (state.isFullScreen == 'false');

                if (state.language) {
                    window.language = state.language;
                    translationsHash.updateLanguageCookies(window.language);
                }

                window.onresize = resizeAll;
                resizeAll();

                L.Icon.Default.imagePath = (window.gmxJSHost || '') + 'img';
                var iconUrl = L.Icon.Default.imagePath + '/flag_blau1.png';

                if (L.version !== '0.7.7') {
                    L.Icon.Default = L.Icon.Default.extend({
                        _getIconUrl: function (name) {
                            return L.Icon.prototype._getIconUrl.call(this, name);
                        }
                    });
                }

                L.Marker = L.Marker.extend({
                    options: {
                        icon: new L.Icon.Default({
                            iconUrl: iconUrl,
                            iconSize: [36, 41],
                            iconAnchor: [7, 37],
                            popupAnchor: [3, -25],
                            shadowUrl: iconUrl,
                            shadowSize: [0, 0],
                            shadowAnchor: [0, 0],
    						iconRetinaUrl: L.Icon.Default.imagePath + '/marker-icon.png'
                        })
                    }
                });

                L.marker = function (latlng, options) {
                    return new L.Marker(latlng, options);
                };

                var hostName = L.gmxUtil.normalizeHostname(window.serverBase),
                    apiKey = window.mapsSite ? window.apiKey : null; //передаём apiKey только если не локальная версия ГеоМиксера

                //мы явно получаем описание карты, но пока что не начинаем создание слоёв
                //это нужно, чтобы получить список плагинов и загрузить их до того, как начнутся создаваться слои
                var skipTiles = (window.mapOptions ? window.mapOptions.skipTiles : '') || window.gmxSkipTiles || '';
                var srs = window.mapOptions ? window.mapOptions.srs : '';

                if (!srs) { var arr = location.href.match(/[?&][cs]rs=(\d+)/); if (arr) { srs = arr[1]; } }

                var isGeneralized = window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true;

                L.gmx.gmxMapManager.loadMapProperties({
                    srs: srs,
                    serverHost: hostName,
                    apiKey: apiKey,
                    mapName: globalMapName,
                    skipTiles: skipTiles,
                    isGeneralized: isGeneralized
                }).then(function(mapInfo) {
                    var userObjects = state.userObjects || (mapInfo && mapInfo.properties.UserData);
                    userObjects && nsGmx$1.userObjectsManager.setData(JSON.parse(userObjects));

                    //в самом начале загружаем только данные о плагинах карты.
                    //Остальные данные будем загружать чуть позже после частичной инициализации вьюера
                    //О да, формат хранения данных о плагинах часто менялся!
                    //Поддерживаются все предыдущие форматы из-за старых версий клиента и сложности обновления базы данных
                    nsGmx$1.userObjectsManager.load('mapPlugins');
                    nsGmx$1.userObjectsManager.load('mapPlugins_v2');
                    nsGmx$1.userObjectsManager.load('mapPlugins_v3');

                    //вызываем сразу после загрузки списка плагинов ГеоМиксера,
                    //так как в state может содержаться информация о включённых плагинах
                    if (state.customParamsCollection) {
                        _mapHelper.customParamsManager.loadParams(state.customParamsCollection);
                    }

                    //после загрузки списка плагинов карты начали загружаться не глобальные плагины,
                    //у которых имя плагина было прописано в конфиге. Ждём их загрузки.
                    nsGmx$1.pluginsManager.done(function() {
                        nsGmx$1.pluginsManager.preloadMap();
                        L.gmx.loadMap(globalMapName, {
                            srs: srs,
                            skipTiles: skipTiles,
                            hostName: window.serverBase,
                            apiKey: apiKey,
                            setZIndex: true,
                            isGeneralized: isGeneralized
                        }).then(processGmxMap.bind(null, state));
                    });
                }, function(resp) {
                    initHeader();
                    initAuthWidget();

                    _menuUp.defaultHash = 'usage';

                    _menuUp.createMenu = function() {
                        createDefaultMenu();
                        nsGmx$1.pluginsManager.addMenuItems(_menuUp);
                    };

                    _menuUp.go(nsGmx$1.widgets.header.getMenuPlaceholder()[0]);

                    $('#left_usage').hide();

                    _menuUp.checkView();

                    var str = resp && resp.ErrorInfo && resp.ErrorInfo.ErrorMessage ? resp.ErrorInfo.ErrorMessage : 'У вас нет прав на просмотр данной карты';
                    nsGmx$1.widgets.notifications.stopAction(null, 'failure', _gtxt(str) || str, 0);

                    window.onresize = resizeAll;
                    resizeAll();

                    state.originalReference && createCookie('TinyReference', state.originalReference);

                    nsGmx$1.widgets.authWidget.showLoginDialog();
                });
            }

            //создаём подложки в BaseLayerManager по описанию из config.js
            function initDefaultBaseLayers() {

                var lang = L.gmxLocale.getLanguage(),
                    iconPrefix = 'img/baseLayers/',
                    blm = nsGmx$1.leafletMap.gmxBaseLayersManager,
                    zIndexOffset = 2000000,
                    defaultMapID = window.baseMap.defaultMapID,
                    promises = [],
                    defaultHostName;

                if (window.baseMap.defaultHostName) {
                    defaultHostName = window.baseMap.defaultHostName === '/' ? _serverBase : window.baseMap.defaultHostName;
                } else {
                    defaultHostName = 'maps.kosmosnimki.ru';
                }

                if (window.baseMap.baseLayers) {
                    var baseLayers = window.baseMap.baseLayers,
                        bl;

                    // проставляем дефолтным слоям свойства, зависящие от путей, языка, zIndex
                    for (var i = 0; i < baseLayers.length; i++) {
                        bl = baseLayers[i];
                        // у Спутника в конфиге нет иконки и копирайта
                        if (bl.id === 'sputnik') {
                            bl.icon = iconPrefix + 'basemap_sputnik_ru.png';
                            bl.layers[0].attribution = '<a href="http://maps.sputnik.ru">Спутник</a> © ' + (lang === 'rus' ? 'Ростелеком' : 'Rostelecom') + ' | © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>';
                        }
                        // у ОСМ в конфиге нет иконки и урл
                        if (bl.id === 'OSM') {
                            bl.icon = iconPrefix + 'basemap_osm_' + (lang === 'rus' ? 'ru' : 'eng') + '.png',
                                bl.layers[0].urlTemplate = 'http://{s}.tile.osm.kosmosnimki.ru/kosmo' + (lang === 'rus' ? '' : '-en') + '/{z}/{x}/{y}.png';
                        }
                        // у гибрида в конфиге нет урл
                        if (bl.id === 'OSMHybrid') {
                            bl.layers[0].urlTemplate = 'http://{s}.tile.osm.kosmosnimki.ru/kosmohyb' + (lang === 'rus' ? '' : '-en') + '/{z}/{x}/{y}.png';
                            // bl.layers[0].setZIndex(zIndexOffset);
                        }
                        // у спутника нет иконки
                        if (bl.id === 'satellite') {
                            bl.icon = iconPrefix + 'basemap_satellite.png';
                        }
                    }

                    for (var i = 0; i < baseLayers.length; i++) {
                        var bl = baseLayers[i];
                        if (bl.layers && bl.layers.length) {
                            var l = bl.layers;
                            for (var j = 0; j < l.length; j++) {
                                if (l[j].urlTemplate) {
                                    // заменяем в подложках с айди описания слоев на L.tileLayers
                                    l[j] = L.tileLayer(l[j].urlTemplate, l[j]);
                                } else {
                                    var layerID = l[j].layerID,
                                        hostName = l[j].hostName || defaultHostName,
                                        mapID = l[j].mapID || defaultMapID,
                                        skipTiles = (window.mapOptions ? window.mapOptions.skipTiles : '') || window.gmxSkipTiles || '',
                                        srs = window.mapOptions ? window.mapOptions.srs : '',
                                        isGeneralized = window.mapOptions && 'isGeneralized' in window.mapOptions ? window.mapOptions.isGeneralized : true;

                                    if (!srs) { var arr = location.href.match(/[?&][cs]rs=(\d+)/); if (arr) { srs = arr[1]; } }
                                    // resolve promise -> заменяем в подложках с айди описания слоев на gmxLayers
                                    var promise = L.gmx.loadLayer(mapID, layerID, {
                                        hostName: hostName,
                                        srs: srs,
                                        isGeneralized: isGeneralized,
                                        skipTiles: skipTiles
                                    }).then(function(layer) {
                                        var id = layer.getGmxProperties().name;
                                        for (var k = 0; k < baseLayers.length; k++) {
                                            var bl = baseLayers[k];

                                            if (bl.layers && bl.layers.length) {
                                                var l = bl.layers;

                                                for (var m = 0; m < l.length; m++) {
                                                    if (l[m].layerID && l[m].layerID === id) {
                                                        l[m] = layer;
                                                    }
                                                }
                                            }
                                        }
                                    });

                                    promises.push(promise);
                                }
                            }
                        }
                    }
                }
                return L.gmx.Deferred.all.apply(null, promises).then(function() {
                    if (window.baseMap.baseLayers) {
                        var layers = window.baseMap.baseLayers,
                            layersToLoad = {};

                        layers.forEach(function(bl) {
                            layersToLoad[bl.id] = bl;
                        });

                        // добавим в гибрид снимок
                        if (layersToLoad.satellite && layersToLoad.OSMHybrid) {
                            layersToLoad.OSMHybrid.layers[0].setZIndex(zIndexOffset);
                            layersToLoad.OSMHybrid.layers.push(layersToLoad.satellite.layers[0]);
                        }

                        _.each(layersToLoad, function(l, name) {
                            blm.add(name, l);
                        });
                    }
                });
            }

            function showUserList() {
                gmxCore$1.loadModule('UserGroupWidget').then(function(module) {
                    var canvas = $('<div/>');
                    new module.UserGroupListWidget(canvas);
                    canvas.dialog({
                        width: 400,
                        height: 400,
                        title: _gtxt('Управление группами пользователей')
                    });
                });
            }

            // Инициализации шапки. Будем оттягивать с инициализацией до последнего момента, так как при инициализации
            // требуется знать текущий язык, а он становится известен только после загрузки карты
            function initHeader() {

                nsGmx$1.widgets.header = new nsGmx$1.HeaderWidget({
                    logo: (window.gmxViewerUI && window.gmxViewerUI.logoImage) || 'img/geomixer_transpar_small.svg'
                });

                nsGmx$1.widgets.header.appendTo($('.header'));
            }

            function processGmxMap(state, gmxMap) {
                var DEFAULT_VECTOR_LAYER_ZINDEXOFFSET = 2000000;
                var defCenter = [55.7574, 37.5952],
                    mapProps = gmxMap.properties,
                    defZoom = mapProps.DefaultZoom || 5,
                    data = gmxMap.rawTree;

                if (mapProps.DefaultLat && mapProps.DefaultLong) {
                    defCenter = [mapProps.DefaultLat, mapProps.DefaultLong];
                } else {
                    //подсчитаем общий extend всех видимых слоёв
                    var visBounds = L.latLngBounds([]);

                    for (var l = 0; l < gmxMap.layers.length; l++) {
                        var layer = gmxMap.layers[l];

                        if (layer.getGmxProperties().visible && layer.getBounds) {
                            visBounds.extend(layer.getBounds());
                        }
                    }

                    if (visBounds.isValid()) {
                        //вычислям центр и максимальный zoom по bounds (map.fitBounds() использовать не можем, так как ещё нет карты)
                        var proj = L.Projection.Mercator;
                        var mercBounds = L.bounds([proj.project(visBounds.getNorthWest()), proj.project(visBounds.getSouthEast())]);
                        var ws = 2 * proj.project(L.latLng(0, 180)).x,
                            screenSize = [$('#flash').width(), $('#flash').height()];

                        var zoomX = Math.log(ws * screenSize[0] / (mercBounds.max.x - mercBounds.min.x)) / Math.log(2) - 8;
                        var zoomY = Math.log(ws * screenSize[1] / (mercBounds.max.y - mercBounds.min.y)) / Math.log(2) - 8;

                        defZoom = Math.floor(Math.min(zoomX, zoomY, 17));
                        defCenter = proj.unproject(mercBounds.getCenter());
                    }
                }

                //если информации о языке нет ни в куках ни в config.js, то используем данные о языке из карты
                if (!translationsHash.getLanguageFromCookies() && !window.defaultLang && data) {
                    window.language = data.properties.DefaultLanguage;
                }

                initHeader();

                if (!window.gmxViewerUI || !window.gmxViewerUI.hideLanguage) {
                    var langContainer = nsGmx$1.widgets.header.getLanguagePlaceholder();
                    nsGmx$1.widgets.languageWidget = new nsGmx$1.LanguageWidget();
                    nsGmx$1.widgets.languageWidget.appendTo(langContainer);
                }
                var mapOptions = L.extend(window.mapOptions ? window.mapOptions : {}, {
                    contextmenu: true,
                    // если есть пермалинк, центрируем и зумируем карту сразу по его параметрам
                    center: state.position ? [state.position.y, state.position.x] : defCenter,
                    zoom: state.position ? state.position.z : defZoom,
                    // boxZoom: false,
                    zoomControl: false,
                    attributionControl: false,
                    trackResize: true,
                    fadeAnimation: !window.gmxPhantom, // отключение fadeAnimation при запуске тестов
                    zoomAnimation: !window.gmxPhantom, // отключение zoomAnimation при запуске тестов
                    distanceUnit: mapProps.DistanceUnit,
                    squareUnit: mapProps.SquareUnit,
                    minZoom: mapProps.MinZoom || undefined,
                    maxZoom: mapProps.MaxZoom || undefined,
                    maxPopupCount: mapProps.maxPopupContent
                });

                var lmap = new L.Map($('#flash')[0], mapOptions);


                // update layers zIndexes
                var currentZoom = lmap.getZoom(),
                    layerOrder = gmxMap.rawTree.properties.LayerOrder;

                updateZIndexes();

                lmap.on('zoomend', function(e) {
                    currentZoom = lmap.getZoom();
                    updateZIndexes();
                });

                //clip polygons
                if (mapProps.MinViewX && mapProps.MinViewY && mapProps.MaxViewX && mapProps.MaxViewY) {
                    lmap.on('layeradd', function(e) {
                        if (e.layer.addClipPolygon) {
                            _mapHelper.clipLayer(e.layer, mapProps);
                        }
                    });
                }

                // bind clusters to photoLayers
                for (var l = 0; l < gmxMap.layers.length; l++) {
                    var layer = gmxMap.layers[l],
                        props = layer.getGmxProperties();

                    if (props.IsPhotoLayer) {
                        layer.bindClusters({
                            iconCreateFunction: function(cluster) {
                                var photoClusterIcon = L.divIcon({
                                    html: '<img src="' + (window.serverBase ? window.serverBase + _mapHelper.defaultPhotoIconStyles.point.marker.image : _mapHelper.defaultPhotoIconStyles.point.marker.image) + '" class="photo-icon"/><div class="marker-cluster-photo">' + cluster.getChildCount() + '</div>',
                                    className: 'photo-div-icon',
                                    iconSize: [14, 12],
                                    iconAnchor: [0, 0]
                                });
                                return photoClusterIcon;
                            },
                            maxClusterRadius: 40,
                            spiderfyOnMaxZoom: true,
                            spiderfyZoom: 14,
                            spiderfyDistanceMultiplier: 1.2,
                            disableClusteringAtZoom: 19,
                            maxZoom: 19
                        });
                    }
                }
                lmap.contextmenu.insertItem({
                    text: _gtxt('Поставить маркер'),
                    callback: function(event) {
                        lmap.gmxDrawing.addGeoJSON({ type: 'Point', coordinates: [event.latlng.lng, event.latlng.lat] });
                    }
                });

                lmap.contextmenu.insertItem({
                    text: _gtxt('Центрировать'),
                    callback: function(event) {
                        lmap.setView(event.latlng);
                    }
                });

                function updateZIndexes() {
                    for (var l = 0; l < gmxMap.layers.length; l++) {
                        var layer = gmxMap.layers[l],
                            props = layer.getGmxProperties();

                        switch (layerOrder) {
                            case 'VectorOnTop':
                                if (props.type === 'Vector' && layer.setZIndexOffset) {
                                    var minZoom,
                                        rcMinZoom,
                                        quickLookMinZoom,
                                        defaultMinZoom = 6;

                                    if (props.IsRasterCatalog || (props.Quicklook && props.Quicklook !== 'null')) {
                                        rcMinZoom = props.IsRasterCatalog ? props.RCMinZoomForRasters : null;
                                        quickLookMinZoom = (props.Quicklook && nsGmx$1.Utils.isJSON(props.Quicklook)) ? JSON.parse(props.Quicklook).minZoom : null;

                                        if (props.IsRasterCatalog && !props.Quicklook) {
                                            minZoom = nsGmx$1.Utils.checkForNumber(rcMinZoom) ? rcMinZoom : defaultMinZoom;
                                        } else if (!props.IsRasterCatalog && props.Quicklook) {
                                            minZoom = nsGmx$1.Utils.checkForNumber(quickLookMinZoom) ? quickLookMinZoom : defaultMinZoom;
                                        } else if (props.IsRasterCatalog && props.Quicklook) {
                                            rcMinZoom = nsGmx$1.Utils.checkForNumber(rcMinZoom) ? rcMinZoom : defaultMinZoom;
                                            quickLookMinZoom = nsGmx$1.Utils.checkForNumber(quickLookMinZoom) ? quickLookMinZoom : defaultMinZoom;

                                            minZoom = Math.min(rcMinZoom, quickLookMinZoom);
                                        }
                                        layer.setZIndexOffset(currentZoom < rcMinZoom ? DEFAULT_VECTOR_LAYER_ZINDEXOFFSET : 0);
                                    } else {
                                        layer.setZIndexOffset(DEFAULT_VECTOR_LAYER_ZINDEXOFFSET);
                                    }
                                }
                                break;
                        }
                    }
                }

                // Begin: запоминание текущей позиции карты
                function saveMapPosition(key) {
                    window.localStorage.setItem('lastMapPosiotion_' + key, JSON.stringify({ zoom: lmap.getZoom(), center: lmap.getCenter() }));
                }

                function getMapPosition(key) {
                    return JSON.parse(localStorage.getItem('lastMapPosiotion_' + key));
                }
                lmap.on('boxzoomstart', function(ev) { saveMapPosition('z'); });
                L.DomEvent.on(document, 'keydown', function(ev) {
                    var key = ev.key;
                    if (lmap.gmxMouseDown === 1) {
                        var pos = getMapPosition(key);
                        if (pos && (key === 'z' || Number(key) >= 0)) {
                            lmap.setView(pos.center, pos.zoom);
                        }
                    } else if (lmap.gmxMouseDown > 1) {
                        if (Number(key) >= 0) {
                            saveMapPosition(key);
                        }
                    }

                }, lmap);
                // End: запоминание текущей позиции карты

                lmap.gmxControlsManager.init(window.controlsOptions);
                // lmap.addControl(new L.Control.gmxLayers(lmap.gmxBaseLayersManager, {
                //     // position: 'topleft',
                //     collapsed: true,
                //     hideBaseLayers: true
                // }));

                nsGmx$1.leafletMap = lmap;

                var loc = nsGmx$1.leafletMap.gmxControlsManager.get('location');

                loc.setCoordinatesFormat(gmxMap.properties.coordinatesFormat);

                loc.on('coordinatesformatchange', function(ev) {
                    nsGmx$1.leafletMap.options.coordinatesFormat = ev.coordinatesFormat;
                });

                var baseLayerDef = 'baseMap' in window ? initDefaultBaseLayers() : lmap.gmxBaseLayersManager.initDefaults({ hostName: window.mapHostName, apiKey: window.apiKey, srs: lmap.options.srs, skipTiles: lmap.options.skipTiles, isGeneralized: lmap.options.isGeneralized });

                baseLayerDef.then(function() {

                    nsGmx$1.gmxMap = gmxMap;
                    gmxAPI.layersByID = gmxMap.layersByID; // слои по layerID

                    var mapProp = gmxMap.rawTree.properties || {};
                    var baseLayers = mapProp.BaseLayers ? JSON.parse(mapProp.BaseLayers) : [window.language === 'eng' ? 'mapbox' : 'sputnik', 'OSMHybrid', 'satellite'];

                    lmap.gmxBaseLayersManager.setActiveIDs(baseLayers);

                    var baseLayersControl = new L.Control.GmxIconLayers(lmap.gmxBaseLayersManager, { id: 'iconLayers' });                
                    lmap.gmxControlsManager.add(baseLayersControl);

                    lmap.addControl(baseLayersControl);

                    nsGmx$1.widgets.commonCalendar = new nsGmx$1.CommonCalendarWidget();

                    // добавление временных слоев в commonCalendar
                    // добавление происходит безопасно, в клон объекта со списком слоев
                    var initTemporalLayers = function(layers) {
                        layers = layers || nsGmx$1.gmxMap.layers;

                        var attrs = nsGmx$1.widgets.commonCalendar.model.toJSON(),
                            showCalendar = undefined,
                            dateInterval,
                            dateBegin,
                            dateEnd;

                        for (var i = 0; i < layers.length; i++) {
                            var layer = layers[i],
                                props = layer.getGmxProperties(),
                                isVisible = props.visible,
                                isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.setDateInterval);
                            if (isTemporalLayer) {
                                // показываем виджет календаря, если в карте есть хоть один мультивременной слой
                                showCalendar = true;

                                dateInterval = layer.getDateInterval ? layer.getDateInterval() : new nsGmx$1.DateInterval();

                                if (dateInterval.beginDate && dateInterval.endDate) {
                                    dateBegin = dateInterval.beginDate;
                                    dateEnd = dateInterval.endDate;
                                } else {
                                    dateInterval = new nsGmx$1.DateInterval();
                                    dateBegin = dateInterval.get('dateBegin');
                                    dateEnd = dateInterval.get('dateEnd');
                                }

                                if (!(props.name in attrs.unbindedTemporalLayers)) {
                                    nsGmx$1.widgets.commonCalendar.bindLayer(props.name);

                                    layer.setDateInterval(dateBegin, dateEnd);

                                    if (props.LayerID in attrs.dailyFiltersHash) {
                                        nsGmx$1.widgets.commonCalendar.applyDailyFilter([layer]);
                                    }

                                }
                                //подписка на изменение dateInterval
                                if (layer.getDateInterval) {
                                    layer.on('dateIntervalChanged', nsGmx$1.widgets.commonCalendar.onDateIntervalChanged, nsGmx$1.widgets.commonCalendar);
                                }
                            }
                        }

                        nsGmx$1.widgets.commonCalendar.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);

                        if (showCalendar && !attrs.isAppended) {
                            nsGmx$1.widgets.commonCalendar.show();
                        }
                    };

                    // привяжем изменение активной ноды к календарю
                    $(_layersTree).on('activeNodeChange', function(e, p) {
                        var layerID = $(p).attr('layerid'),
                            calendar = nsGmx$1.widgets.commonCalendar.model.get('calendar'),
                            synchronyzed = nsGmx$1.widgets.commonCalendar.model.get('synchronyzed');

                        lmap.fireEvent('layersTree.activeNodeChange', { layerID: layerID });
                    });

                    $(_layersTree).on('layerVisibilityChange', function(event, elem) {
                        var props = elem.content.properties,
                            attrs = nsGmx$1.widgets.commonCalendar.model.toJSON(),
                            visible = props.visible,
                            layerID = props.LayerID,
                            calendar = attrs.calendar,
                            currentLayer = attrs.currentLayer,
                            synchronyzed = attrs.synchronyzed;

                        if (synchronyzed) {
                            return;
                        } else {
                            if (layerID) {
                                var layer = nsGmx$1.gmxMap.layersByID[layerID],
                                    props = layer.getGmxProperties(),
                                    isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval),
                                    visibleTemporalLayers, index;

                                if (isTemporalLayer) {
                                    if (visible) {
                                        if (currentLayer) {
                                            return;
                                        } else {
                                            var dateInterval = layer.getDateInterval();

                                            if (dateInterval.beginDate && dateInterval.endDate) {
                                                nsGmx$1.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, layer);
                                            }
                                        }
                                    } else {
                                        if (currentLayer) {
                                            if (layerID !== currentLayer) {
                                                return;
                                            } else {
                                                visibleTemporalLayers = getLayersListWithTarget(nsGmx$1.gmxMap.layers, layer),
                                                    index = visibleTemporalLayers.indexOf(layer);

                                                if (visibleTemporalLayers.length === 1) {
                                                    nsGmx$1.widgets.commonCalendar.model.set('currentLayer', null);
                                                } else {
                                                    if (index === 0) {
                                                        var targetLayer = visibleTemporalLayers[index + 1],
                                                            targetLayerID = targetLayer.getGmxProperties().LayerID,
                                                            dateInterval = targetLayer.getDateInterval();

                                                        nsGmx$1.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, targetLayer);
                                                        // nsGmx.widgets.commonCalendar.model.set('currentLayer', targetLayerID)
                                                    } else {
                                                        var targetLayer = visibleTemporalLayers[index - 1],
                                                            targetLayerID = targetLayer.getGmxProperties().LayerID,
                                                            dateInterval = targetLayer.getDateInterval();

                                                        nsGmx$1.widgets.commonCalendar.setDateInterval(dateInterval.beginDate, dateInterval.endDate, targetLayer);
                                                        // nsGmx.widgets.commonCalendar.model.set('currentLayer', targetLayerID)
                                                    }
                                                }

                                            }
                                        } else {
                                            return;
                                        }
                                    }
                                }
                            }
                        }
                        nsGmx$1.widgets.commonCalendar.updateVisibleTemporalLayers(nsGmx$1.gmxMap.layers);

                        function getLayersListWithTarget(layers, targetLayer) {
                            var visibleTemporalLayers = [];
                            for (var i = 0; i < layers.length; i++) {
                                var layer = layers[i],
                                    props = layer.getGmxProperties && layer.getGmxProperties(),
                                    isTemporalLayer,
                                    isVisible;

                                if (props) {
                                    isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);
                                    isVisible = props.visible;

                                    if (isTemporalLayer && isVisible || layer === targetLayer) {
                                        visibleTemporalLayers.push(layer);
                                    }
                                }
                            }
                            return visibleTemporalLayers;
                        }
                    });

                    $(_layersTree).on('styleVisibilityChange', function(event, styleVisibilityProps) {
                        var it = nsGmx$1.gmxMap.layersByID[styleVisibilityProps.elem.name],
                            styles = it.getStyles(),
                            st = styles[styleVisibilityProps.styleIndex];

                        var div = $(_queryMapLayers.buildedTree).find("div[LayerID='" + styleVisibilityProps.elem.LayerID + "']")[0],
                            elemProperties = div.gmxProperties.content.properties,
                            treeStyles = window.newStyles ?  elemProperties.gmxStyles.styles : elemProperties.styles,
                            treeSt = treeStyles[styleVisibilityProps.styleIndex];

                        if (typeof treeSt._MinZoom === 'undefined') {
                            treeSt._MinZoom = treeSt.MinZoom;
                        }

                        if (styleVisibilityProps.show) {
                            treeSt.MinZoom = treeSt._MinZoom;
                            st.MinZoom = treeSt._MinZoom;
    						treeSt.disabled = false;
                        } else {
                            treeSt.disabled = true;
                        }
    					st.disabled = treeSt.disabled;

                        it.setStyles(styles);
                    });

                    _mapHelper.customParamsManager.addProvider({
                        name: 'commonCalendar',
                        loadState: function(state) {
                            if (!('version' in state)) {
                                var tmpDateInterval = new nsGmx$1.DateInterval({
                                    dateBegin: new Date(state.dateBegin),
                                    dateEnd: new Date(state.dateEnd)
                                });
                                nsGmx$1.widgets.commonCalendar.getDateInterval().loadState(tmpDateInterval.saveState());
                            } else if (state.version === '1.0.0') {
                                nsGmx$1.widgets.commonCalendar.model.set('synchronyzed', typeof(state.synchronyzed) !== 'undefined' ? state.synchronyzed : true);
                                nsGmx$1.widgets.commonCalendar.model.set('currentLayer', typeof(state.currentLayer) !== 'undefined' ? state.currentLayer : null);
                                nsGmx$1.widgets.commonCalendar.getDateInterval().loadState(state.dateInterval);
                                nsGmx$1.widgets.commonCalendar.model.set('dailyFilter', typeof(state.dailyFilter) !== 'undefined' ? state.dailyFilter : true);
                            } else {
                                throw 'Unknown params version';
                            }
                        },
                        saveState: function() {
                            return {
                                version: '1.0.0',
                                dateInterval: nsGmx$1.widgets.commonCalendar.getDateInterval().saveState(),
                                currentLayer: nsGmx$1.widgets.commonCalendar.model.get('currentLayer'),
                                synchronyzed: nsGmx$1.widgets.commonCalendar.model.get('synchronyzed'),
                                dailyFilter: nsGmx$1.widgets.commonCalendar.model.get('dailyFilter')
                            };
                        }
                    });

                    $('#flash').bind('dragover', function() {
                        return false;
                    });

                    $('#flash').bind('drop', function(e) {
                        if (!e.originalEvent.dataTransfer) {
                            return;
                        }

                        _queryLoadShp.loadAndShowFiles(e.originalEvent.dataTransfer.files);

                        return false;
                    });

                    if (state.dt) {
                        try {
                            var dateLocal = $.datepicker.parseDate('dd.mm.yy', state.dt);
                            var dateBegin = nsGmx$1.CalendarWidget.fromUTC(dateLocal);
                            var dateEnd = new Date(dateBegin.valueOf() + 24 * 3600 * 1000);
                            var dateInterval = nsGmx$1.widgets.commonCalendar.getDateInterval();
                            dateInterval.set({
                                dateBegin: dateBegin,
                                dateEnd: dateEnd
                            });
                        } catch (e) {}
                    }

                    nsGmx$1.pluginsManager.beforeViewer();

                    //для каждого ответа сервера об отсутствии авторизации (Status == 'auth') сообщаем об этом пользователю или предлагаем залогиниться
                    addParseResponseHook('auth', function() {
                        if (nsGmx$1.AuthManager.isLogin()) {
                            showErrorMessage$1(_gtxt('Недостаточно прав для совершения операции'), true);
                        } else {
                            nsGmx$1.widgets.authWidget.showLoginDialog();
                        }

                        return false;
                    });

                    initAuthWidget();

                    //инициализация контролов пользовательских объектов
                    //соответствующий модуль уже загружен
                    var oDrawingObjectsModule = gmxCore$1.getModule('DrawingObjects');
                    window.oDrawingObjectGeomixer = new oDrawingObjectsModule.DrawingObjectGeomixer();
                    window.oDrawingObjectGeomixer.Init(nsGmx$1.leafletMap, nsGmx$1.gmxMap);

                    //для всех слоёв должно выполняться следующее условие: если хотя бы одна групп-предков невидима, то слой тоже невидим.
                    (function fixVisibilityConstrains(o) {
                        o.content.properties.visible = o.content.properties.visible;

                        if (o.type === 'group') {
                            var a = o.content.children;

                            var isAnyVisibleChild = false;

                            for (var k = a.length - 1; k >= 0; k--) {
                                var childrenVisibility = fixVisibilityConstrains(a[k]);
                                isAnyVisibleChild = isAnyVisibleChild || childrenVisibility;
                            }

                            // если внутри группы есть включенные слои, группа тоже включается
                            // если же ни одного включенного слоя нет, то группа выключается
                            o.content.properties.visible = isAnyVisibleChild ? true : false;
                        }
                        return o.content.properties.visible;
                    })({ type: 'group', content: { children: data.children, properties: { visible: true } } });

                    window.oldTree = JSON.parse(JSON.stringify(data));

                    window.defaultLayersVisibility = {};

                    for (var k = 0; k < gmxMap.layers.length; k++) {
                        var props = gmxMap.layers[k].getGmxProperties();
                        window.defaultLayersVisibility[props.name] = props.visible;
                    }

                    //основная карта всегда загружена с того-же сайта, что и серверные скрипты
                    data.properties.hostName = window.serverBase.slice(7).slice(0, -1);

                    //DEPRICATED. Do not use it!
                    _mapHelper.mapProperties = data.properties;

                    //DEPRICATED. Do not use it!
                    _mapHelper.mapTree = data;

                    if (window.copyright && typeof window.copyright === 'string') {
                        lmap.gmxControlsManager.get('copyright').setMapCopyright(window.copyright);
                    }

                    var condition = false,
                        mapStyles = false,
                        LayersTreePermalinkParams = false;

                    if (state.condition) {
                        condition = state.condition;
                    }

                    if (state.mapStyles) {
                        mapStyles = state.mapStyles;
                    }
                    if (state.LayersTreePermalinkParams) {
                        LayersTreePermalinkParams = state.LayersTreePermalinkParams;
                    }

                    /**
                     *
                     * SIDEBAR
                     *
                     */

                    window.iconSidebarWidget = new IconSidebarWidget(document.getElementById('leftMenu'), {
                        collapsedWidth: 40,
                        extendedWidth: 400,
                        position: 'left'
                    });

                    window.iconSidebarWidget.addEventListener('opened', window.resizeAll);
                    window.iconSidebarWidget.addEventListener('closed', window.resizeAll);

                    window.createTabFunction = function(options) {
                        return function(state) {
                            var el = document.createElement("div"),
                                tabEl = document.createElement("div"),
                                href = '#' + options.icon.toLowerCase(),
                                symbol = document.querySelector(href);
    						$(el).addClass("tab-icon");

                            if (symbol) $(symbol).addClass("sidebar-icon");

                            tabEl.innerHTML = '<svg role="img" class="svgIcon">\
                        <use xlink:href="' + href + '" href="' + href + '"></use>\
                        </svg>';

                            el.appendChild(tabEl);

                            options.hint && el.setAttribute("title", options.hint);
                            $(tabEl).addClass(options.icon);
                            if (state === "active") {
                                $(tabEl).addClass(options.active);
                                $(el).addClass("tab-icon-active");
                                if (symbol) $(symbol).addClass("sidebar-active-icon");
                            } else {
                                if (symbol && $(symbol).hasClass("sidebar-active-icon")) {
                                    $(symbol).removeClass("sidebar-active-icon");
                                }
                                $(tabEl).addClass(options.inactive);
                            }
                            return el;
                        };
                    };

                    // init tab
                    window.iconSidebarWidget._activeTabId = "layers-tree";

                    var leftMainContainer = nsGmx$1.layersTreePane = window.iconSidebarWidget.setPane(
                        "layers-tree", {
                            createTab: window.createTabFunction({
                                icon: "s-tree",
                                active: "sidebar-icon-active",
                                inactive: "sidebar-icon-inactive",
                                hint: "Слои"
                            })
                        }
                    );

                     leftMainContainer.innerHTML =
                        '<div class="leftMenu">' +
                            '<div class="mainmap-title">' + data.properties.title + '</div>' +
                            '<div id="leftPanelHeader" class="leftPanelHeader"></div>' +
                            '<div id="leftContent" class="leftContent">' +
                                '<div id="leftContentInner" class="leftContentInner"></div>' +
                            '</div>' +
                            '<div id="leftPanelFooter" class="leftPanelFooter"></div>' +
                        '</div>';

                    window.iconSidebarWidget.open("layers-tree");

                     $('.leftContent').mCustomScrollbar();

                     /**
                      *
                      * SIDEBAR END
                      *
                      */


                    _queryMapLayers.addLayers(data, condition, mapStyles, LayersTreePermalinkParams);

                    // переписать на вкладку с деревом
                    var headerDiv = $('.mainmap-title');

                    // special for steppe Project
                    if (data.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                        $(headerDiv).toggle();
                    }

                    nsGmx$1.ContextMenuController.bindMenuToElem(headerDiv[0], 'Map', function() {
                            return _queryMapLayers.currentMapRights() == 'edit';
                        },
                        function() {
                            return {
                                div: $(_layersTree._treeCanvas).find('div[MapID]')[0],
                                tree: _layersTree
                            }
                        }
                    );

                    // _menuUp.defaultHash = 'layers';
                    mapLayers.mapLayers.load();

                    //создаём тулбар
                    var iconContainer = _div(null, [
                        ['css', 'borderLeft', '1px solid #216b9c']
                    ]);

                    // var searchContainer = nsGmx.widgets.header.getSearchPlaceholder()[0];

                    window.searchLogic.init({
                        oMenu: oSearchLeftMenu
                    });

                    //инициализация контролов поиска (модуль уже загружен)
                    var oSearchModule = gmxCore$1.getModule('search');
                    // window.oSearchControl = new oSearchModule.SearchGeomixer();

                    // if (document.getElementById('searchCanvas')) {
                    // window.oSearchControl.Init({
                    //     Menu: oSearchLeftMenu,
                    //     ContainerInput: searchContainer,
                    //     ServerBase: window.serverBase,
                    //     layersSearchFlag: true,
                    //     Map: lmap,
                    //     gmxMap: gmxMap
                    // });

                    _menuUp.createMenu = function() {
                        createMenuNew();
                    };

                    _menuUp.go(nsGmx$1.widgets.header.getMenuPlaceholder()[0]);

                    var headerLinks = nsGmx$1.addHeaderLinks();

                    if (headerLinks.length) {
                        _menuUp.addItem({ id: 'linksMenu', title: _gtxt('Ссылки'), childs: headerLinks });
                    }

                    // Загружаем все пользовательские данные
                    nsGmx$1.userObjectsManager.load();

                    // выставляет правильные z-indexes слоям-вьюхам
                    _layersTree.updateZIndexes();

                    //выполняем мапплет карты нового формата
                    nsGmx$1.mappletLoader.execute();

                    //динамически добавляем пункты в меню. DEPRICATED.
                    nsGmx$1.pluginsManager.addMenuItems(_menuUp);

                    _mapHelper.gridView = false;

                    var updateLeftPanelVis = function() {
                        // $('.leftCollapser-icon')
                        //     .toggleClass('leftCollapser-right', !layersShown)
                        //     .toggleClass('leftCollapser-left', !!layersShown);
                        resizeAll();
                    };

                    // $('#leftCollapser').click(function() {
                    //     layersShown = !layersShown;
                    //     updateLeftPanelVis();
                    // });
                    updateLeftPanelVis();

                    createToolbar();


                    var controls = lmap.gmxControlsManager.getAll();

                    for (var key in controls) {
                        var ctrl = controls[key],
                            cntr = ctrl.getContainer();
                        cntr.addEventListener('click', function (e) {
                            _menuUp.hideOnClick(e);
                        });
                    }
                    if (state.mode) {
                        lmap.gmxBaseLayersManager.setCurrentID(lmap.gmxBaseLayersManager.getIDByAlias(state.mode) || state.mode);
                    } else if (baseLayers.length && !lmap.gmxBaseLayersManager.getCurrentID()) {
                        lmap.gmxBaseLayersManager.setCurrentID(baseLayers[0]);
                    }

                    if (state.drawings) {
                        lmap.gmxDrawing.loadState(state.drawings);
                    } else if (state.drawnObjects) {
                        state.drawnObjects.forEach(function(objInfo) {
                            //старый формат - число, новый - строка
                            var lineStyle = {};

                            if (objInfo.color) {
                                lineStyle.color = typeof objInfo.color === 'number' ? '#' + L.gmxUtil.dec2hex(objInfo.color) : objInfo.color;
                            }

                            if (objInfo.thickness) { lineStyle.weight = objInfo.thickness; }                        if (objInfo.opacity) { lineStyle.opacity = objInfo.opacity / 100; }
                            var featureOptions = $.extend(true, {}, objInfo.properties, {
                                lineStyle: lineStyle
                            });

                            var drawingFeature = lmap.gmxDrawing.addGeoJSON(L.gmxUtil.geometryToGeoJSON(objInfo.geometry), featureOptions)[0];

                            if (objInfo.isBalloonVisible) {
                                drawingFeature.openPopup();
                            }
                        });
                    } else if (state.marker) {
                        nsGmx$1.leafletMap.gmxDrawing.addGeoJSON({
                            type: 'Feature',
                            geometry: { type: 'Point', coordinates: [state.marker.mx, state.marker.my] },
                            properties: { title: state.marker.mt }
                        });
                    }

                    if (state.openPopups) {
                        for (var l in state.openPopups) {
                            var layer = nsGmx$1.gmxMap.layersByID[l];
                            if (layer && layer.addPopup) {
                                state.openPopups[l].forEach(layer.addPopup.bind(layer));
                            }
                        }
                    }

                    _menuUp.checkView();

                    if (nsGmx$1.AuthManager.isLogin()) {
                        _queryMapLayers.addUserActions();
                    }

                    if (state.dateIntervals) {
                        for (var lid in gmxMap.layersByID) {
                            if (lid in state.dateIntervals) {
                                var l = gmxMap.layersByID[lid],
                                    beginDate = new Date(state.dateIntervals[lid].beginDate),
                                    endDate = new Date(state.dateIntervals[lid].endDate);

                                l.setDateInterval(beginDate, endDate);
                            }
                        }
                    }

                    if (state.filters) {
                        for (var key in state.filters) {
                            var l = nsGmx$1.gmxMap.layersByID[key],
                                filtersArr = state.filters[key];

                            for (var i = 0; i < filtersArr.length; i++) {
                                if ('filterById' in filtersArr[i]) {
                                    var filteredId = filtersArr[i]['filterById'];

                                    l.addLayerFilter(function(it) { return it.id === filteredId });
                                }
                            }
                        }
                    }

                    initEditUI();
                    initTemporalLayers();

                    gmxMap.addLayersToMap(lmap);

                    nsGmx$1.leafletMap.on('layeradd', function(event) {
                        var layer = event.layer;

                        if (layer.getGmxProperties) {
                            var layerProps = layer.getGmxProperties();

                            initEditUI();
                            initTemporalLayers([layer]);

                        }
                    });
                    // if (mapProp.MapID !== 'ATTBP') {
                    nsGmx$1.gmxMap.on('onRemoveLayer', function(event) {
                        var layer = event.layer;
                        if (!layer.getGmxProperties()) {
                            return;
                        }
                        var props = layer.getGmxProperties(),
                            isTemporalLayer = (layer instanceof L.gmx.VectorLayer && props.Temporal) || (props.type === 'Virtual' && layer.getDateInterval);

                        if (isTemporalLayer && !(props.name in nsGmx$1.widgets.commonCalendar._unbindedTemporalLayers)) {
                            nsGmx$1.widgets.commonCalendar.unbindLayer(props.name);
                            nsGmx$1.widgets.commonCalendar.updateTemporalLayers();
                            delete nsGmx$1.widgets.commonCalendar._unbindedTemporalLayers[props.name];
                        }
                    });

                    // special for steppe project
                    if (nsGmx$1.gmxMap.properties.MapID === '0786A7383DF74C3484C55AFC3580412D') {
                        nsGmx$1.widgets.commonCalendar.show();
                    }
                    nsGmx$1.pluginsManager.afterViewer();

                    // обработка специальных параметров плагинов
                    nsGmx$1.pluginsManager.forEachPlugin(function (plugin) {
                        if (plugin.moduleName === "gmxTimeLine" && nsGmx$1.timeLineControl) {
    						var treeLayers = $(window._layersTree);
    						nsGmx$1.timeLineControl
    							.on('layerRemove', function(e) {
    								treeLayers.triggerHandler('layerTimelineRemove', e);
    							})
    							.on('layerAdd', function(e) {
    								treeLayers.triggerHandler('layerTimelineAdd', e);
    							})
    							.saveState().dataSources.forEach(function(it) {
    								treeLayers.triggerHandler('layerTimelineAdd', {type: 'layerAdd', layerID: it.layerID});
    							});
                        }
                    });

                    // экспорт карты

                    if (state.exportMode) {
                        _mapHelper.exportMap(state);
                    }
                });
            }

            function mapExportMenu() {
                gmxCore$1.loadModule('MapExport', 'src/MapExport/MapExport.js').then(function(def) {
                    var menu = new def.MapExportMenu();
                    menu.Load();
                });
            }

            function BufferZonesMenu() {
                gmxCore$1.loadModule('BufferZones', 'src/BufferZones/BufferZones.js').then(function(def) {
                    var menu = new def.BufferZonesMenu();
                    menu.Load();
                });
            }

            function indexGridMenu() {
                gmxCore$1.loadModule('IndexGrid', 'src/IndexGrid/IndexGrid.js').then(function(def) {
                    var menu = new def.IndexGridMenu();
                    menu.Load();
                });
            }

            function PhotoLayerDialog() {
                gmxCore$1.loadModule('PhotoLayer', 'src/PhotoLayer/PhotoLayer.js').then(function(def) {
                    var dialog = new def.PhotoLayer();
                    dialog.Load();
                });
            }

            function promptFunction(title, value) {
                var ui = $(Handlebars.compile(
                    '<div class="gmx-prompt-canvas">' +
                    '<input class="inputStyle gmx-prompt-input" value="{{value}}">' +
                    '</div>')({ value: value }));

                ui.find('input').on('keydown', function(e) {
                    var evt = e || window.event;
                    if (e.which === 13) {
                        var coord = L.gmxUtil.parseCoordinates(this.value);
                        nsGmx$1.leafletMap.panTo(coord);
                        return false;
                    }
                });

                showDialog(title, ui[0], 300, 80, false, false);
            }

            window.prompt = promptFunction;

        };
    })();

    // require ('underscore');

    nsGmx$1.initGeoMixer();

}());
